{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Elven","url":"https://fuyunjinglong.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-03T23:13:04.000Z","updated":"2022-09-11T15:20:18.853Z","comments":true,"path":"categories/index.html","permalink":"https://fuyunjinglong.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-07T23:14:12.000Z","updated":"2022-09-11T15:20:18.853Z","comments":true,"path":"tags/index.html","permalink":"https://fuyunjinglong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"0基础_工程热点","slug":"H_工程热点_0基础","date":"2099-11-05T22:33:16.000Z","updated":"2024-02-28T22:43:15.988Z","comments":true,"path":"2099/11/06/H_工程热点_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/11/06/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"前端工程化工程化本质 DevOps即Development和Operations的组合词，是一组过程、方法与系统的统称。 从DevOps软件开发角度出发，设计-》开发-》联调-》测试-》发布。 工程化解决的问题效率&amp;质量 项目立项-》需求分析-》产品原型-》开发实施-》测试部署-》上线运行 通过各种工具和技术，提高开发效率和质量。 安全内容安全策略=》如ie的activeX策略、 代码管理代码实践=》如前后端分离,项目结构、代码结构、代码检查、CI/CD配置，编译器、版本控制、项目配置、系统环境 性能问题=》压缩、打包、线上线下优化措施 代码复用=》组件化、模块化、服务化 多设备兼容=》pollyfill,shim,auto-prefixer,响应式，如android,ios,手表电视，IOT设备的兼容性、分辨率 跨平台=》React Native、Weex、Flutter、Hybrid、Electron、uniapp,如android,ios,手表电视，IOT设备的兼容性、分辨率 跨端=》web,Node.js,IOT,如移动端，IOT设备等 跨场景=》WebXR，WebRTC，WebSocket，如直播场景j跨语言WebAssembly 重要节点的技术 uglifyjs,jQuery的前后端分离年代-》V8、nodejs的创世纪-》grunt、gulp本地执行的任务流管理器，产生大量包-》npm和Bower-》css的sass和less优化-》webpack、rollup.js编译打包-》eslint和ts规范-》跨段的方案React Native、Weex、Flutter-》微信小程序、支付宝小程序、百度小程序-》WebAssembly-》PWA-》vite-》deno-》docker4.react的优雅UI=fn(state),一个输入对应一个输出，可以事先知道 前端在发力的事情 淘宝直播(webRTC)，webXR(ARVR)、Electron、Flutter,SSR优化、ServiceWorker、 GraphQL 、WebAssembly、Serverless 按照项目的生命周期来分配： 需求评审：技术选型 开发前：统一规范 开发中：模块化、组件化 开发完：测试 编译：构建工具 部署：自动化部署 上线后：性能监控 发现问题：性能优化 项目迭代：重构 项目巨型化：微服务 无服务架构升级：Serverless 工程化内容： 脚手架工具:专用工具(vue-cli,create-react-app,angular-cli,vite),通用工具(Yeoman+generator,Plop) 自动化构建:npm script&amp;script hooks,Grunt，Gulp,FIS 模块化打包：webpack,Rollup,Parcel 标准化规范：Eslint,StyleLint,Prettier 自动化测试：Mocha,Jest,Enzyme,Cypress,Nightmare,Puppeteer 自动化部署：Git Hook，Lint-staged,CI/CD 常用周边生态轮子PC UI Element Plus Ant Design Vue Echarts Quasar Vuetify NativeUI Prime Vue Mobile UI Ionic Vue Vant Varlet 国际化 vue-i18n i18next 其他生态 VueUse：针对vue3 composition api的工具库 lodash.js moment:解析、校验、操作、显示日期和时间 validator.js：表单验证 nuxt3 Animate.css：动画库 mescroll.js：滚动插件 swiper：轮播图 day.js vue-draggable：拖拽 vue-qr：生成二维码 vue-cropper：图片裁剪 vue-lazyload：图片懒加载 clipboard.js：复制粘贴 技术选型 可控性 稳定性 适用性 易用性 可控性 可控，就是指如果这门技术因为 BUG 对项目造成了影响，团队中有人能够解决它，而不是等待官方修复。作为技术团队的负责人，一定要是能够兜底的那个人。如果团队解决不了，你必须能够解决。比如魔改vue,react 稳定性 稳定性，表示一门技术更新迭代比较稳定，不会有特别大的修改，比较靠谱。即使有，也很容易做到向后兼容（迁移简单、成本小）。 有两个很典型的反例，那就是 Angular 和 python。例如 python2 升级到 python3，除了语法、API 不兼容之外，python3 的各个版本之间也有差异，直到现在才逐渐稳定下来。 稳定性判断： 社区是否活跃、配套插件是否丰富。 是否经常维护，可以通过 git commit 查看。 官方文档是否齐全。 更新是稳定、小步的迭代，而不是非常激进的更新。 适用性 适用性，是指需要根据业务场景和团队成员来选择技术。 适用性判断： 业务的生命周期：短期js，长期推荐ts 业务的兼容性：ios,android，iot,不能有死机、白屏、卡顿 团队成员：选择约束性比较强的技术是一个更好的选择，如ts(不会就去学)。要用长远的眼光来为团队考虑，太过自由的技术，往往会造成灾难。 易用性 学习曲线相对平缓，而不是陡峭的 统一规范 代码规范 git规范 项目规范 UI规范 代码规范 代码格式 命名规范 文档注释 出名的js规范： airbnb (101k star 英文版)，airbnb-中文版 standard (24.5k star) 中文版 百度前端编码规范 3.9k star 出名的css规范： styleguide 2.3k star spec 3.9k star git规范 分支管理规范 git commit规范 项目规范 npm管理 pnpm管理 UI规范 统一命名 统一样式 模块化、组件化 高内聚 低耦合 模块化、组件化 Web Components 高内聚 低耦合 高内聚：一个函数尽量只做一件事，如注册模块，只处理注册逻辑 低耦合：两个模块之间的关联程度低，如注册模块调用其他模块，直接引用其他模块即可，不要直接在注册模块中写其他功能 模块化、组件化 模块化：拆分html,css,js，按照功能拆分模块 组件化：按照功能拆分为各个组件 Web Components 目前三大框架在构建工具下可很好实现组件化，但如果自己实现呢？ 组件化是前端未来的发展方向，Web Components 就是浏览器原生支持的组件化标准。使用 Web Components API，浏览器可以在不引入第三方代码的情况下实现组件化。 测试原则：程序简单，不用测试代码；功能越复杂，越需要测试代码(如果修改一个复杂项目，你要对所有功能都点击一遍，但有了测试代码，一条命令执行就行) 单元测试Unit 集成测试Integration 端到端测试E2E 构建工具 webpack rollup vite 自动化部署 Gitea + Jenkins Github Actions 性能监控 事前预警 事后分析 数据上报 sendBeacon XMLHttpRequest image 性能优化 加载时优化 运行时优化 加载时优化 白屏时间 首屏时间 运行时优化 重构定义 《重构2》定义： 所谓重构（refactoring）是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。 重构和性能优化都在不改变程序功能的情况下修改代码 重构：为了让代码变得更加容易理解、易于修改 性能优化：为了让程序运行得更快 重构的原则 事不过三，三则重构。即不能重复写同样的代码，在这种情况下要去重构。 如果一段代码让人很难看懂，那就该考虑重构了。 如果已经理解了代码，但是非常繁琐或者不够好，也可以重构。 过长的函数，需要重构。 一个函数最好对应一个功能，如果一个函数被塞入多个功能，那就要对它进行重构了。（4 和 5 不冲突） 重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。 重构手法 在《重构2》这本书中介绍了上百种方法，其中8种比较常用： 提取重复代码，封装成函数 拆分功能太多的函数 变量/函数改名 替换算法 以函数调用取代内联代码 移动语句 折分嵌套条件表达式 将查询函数和修改函数分离 微服务 小应用，建议还是单独建一个项目开发 大应用，使用微前端可以减少开发维护成本 Serverless定义 无服务架构。是指由第三方云计算供应商以服务的方式为开发者提供所需功能，例如数据库、消息，以及身份验证等。它的核心思想是让开发者专注构建和运行应用，而无需管理服务器。 优点： 自动扩展伸缩、无需自己管理 缺点： 云上访问速度变得比较慢 分类 Faas(Function as a Service) 函数即服务 Baas(Backend as a Service) 后端即服务 Faas 其实是一个云计算平台，用户可以将自己写的函数托管到平台上运行。而 Baas 则是提供一系列的服务给用户运用，用户通过 API 调用。 Faas 定义 一个函数通常用于处理某种业务逻辑，例如一个 abs() 函数，它将返回所传参数的绝对值。我们可以把这个函数托管到 Faas 平台，由平台提供容器并运行这个函数。当执行函数时，只需要提供函数所需的参数，就可以在不部署应用的情况下得到函数的执行结果。 Baas 定义 假设你是一个前端，现在要开发一个网站。前端部分你可以自己完成，但后端部分怎么办呢？这个时候就可以使用 Baas 了。也就是说，你只需编写和维护前端页面。其他的一切，例如数据库、身份验证、对象存储等等都由云服务商提供。你只需要在前端通过 API 调用它们就可以使用所需的服务。 参考 带你入门前端工程化 微前端和低代码1.微前端 (1)微前端是什么？ (1.1)定义 微前端只是管理这种复杂性的一种方法，通过将产品拆分为更小、更简单的应用程序，这些应用程序可以由独立的自治团队一直交付到生产环境。 微前端是一种整合项目框架和组织结构的架构思维和方法，不是一种技术。 缺点： 前端模块包使用npm构建发布使用。 开发和维护成本比较高; 团队协作之间不规范； 特点： 独立部署、增量迁移、团队自治、松耦合代码。 (1.2)解决的问题 大型项目，复杂项目的更新维护。 解决场景： 拆分巨型应用，使应用变得更加可维护; 兼容历史应用，实现增量开发; (1.3)微前端架构方案 主要有3种： 自由组织模式，不借助任何框架，自己开发解决第三方依赖问题; 基座模式，需要容器作为基座，基于Single-spa的乾坤; 去中心模式，webpack5新出的模块联邦特性,实现跨技术栈调用，相同技术栈之间实现更加深度的定制; 1)Systemjs模块化解决方案 此类解决方案使用的不多。使用起来很不友好。 关键配置： //指定构建所需要的库 out:{ libraryTarget:’system’ }, //排除打包react,因为要system externals:[‘react’]2)Single-spa微前端框架实战 (1.1)Single-spa最重要三种类型的微前端应用 single-spa-application:微前端架构中的微应用，可以使用vue,react等。 single-spa root config:创建微前端容器应用。 utility modules：公共模块应用，非渲染组件，用于跨应用共享业务逻辑 (1.3)Single-spa的2.3版本 执行create-single-spa命令。 1)初始化相关的两个函数，registerApplication和start 主入口引入基座，基座引入子应用。 //注册子应用 registerApplication({ name:”@study/navbar”,//这里是@团队/应用名称 app:()=&gt;System.import(“@study/navbar”),//应用原地址 activeWhen:[“/“]//应用路径 }) //子应用另一个写法，精准匹配 registerApplication( “@single-spa/welcome”, ()=&gt;System.import(“https://unpkg.com/single-spa-welcome/dist/single-spa-welcome.js), location=&gt;location.pathname===’/‘ ) //设置基座 start({ uurlRerouteOnly:true }) 3)基于Module Federation的微前端架构 模块联邦的应用，比较少。 2.低代码Low Code (1)简介 (1.1)定义 一个创建应用软件的开发环境，更好维护和易用的可视化IDE。 (1.2)特点 全栈可视化编程-what you see is what you get. 低代码扩展能力：组件、主题、模板、逻辑。 全生命周期管理：开发、构建、测试、部署、运维、运营。 (1.3)难点 参考阿里技术专家汪凤震跨端经验(PC、H5、Hybird、小程序、RN 类)《探索低代码的未来》 一是自身是不是适合可视化 搞清核心诉求，不要什么功能都要。 如果是研发这类工具，如没有相关研发资源的重投(5人以上，周期1年以上)，不建议开发 二是可视化引入的难点 低代码一般是全生命周期，本身就是个挑战; 开发周期长; 除了依赖技术底蕴，更要过硬的产品思维 (2)可视化搭建技术 三部曲 IDE的鼠标拖拽=》生成JSON文件=》渲染页面 (1.1)设计原则 组件可嵌套 所见即所得 低侵入性(比如组件包括渲染和编辑，应该是组件只负责渲染，组件编辑留给系统做，而不是组件内部做，组件不关心编辑属性，否则陷入强耦合逻辑。) 组件渲染(深度优先遍历，逐层向上渲染。具体：组件名称-&gt;加载-&gt;注册-&gt;属性拼装-&gt;创建实例) (3)高级低代码平台搭建 阿里的Sula SPA和MPA1.单页应用SPA 第一次进入页面的时候会请求一个html文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容也变化了。 为什么页面切换快？ 页面每次切换跳转时，并不需要做html文件的请求，这样就节约了很多http发送时延，我们在切换页面的时候速度很快。 缺点：首屏时间慢，SEO差 单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。 2.多页面应用MPA 每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。 为什么多页应用的首屏时间快？ 首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度非常快。 为什么搜索引擎优化效果好（SEO）？ 搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在Html中，所以这种多页应用，seo排名效果好。 比较 单页SPA 多页MPA 定义 页面跳转-&gt;JS渲染 页面跳转-&gt;HTML渲染 构成 一个html和多个html片段 多个html 优点 页面切换慢 首屏时间快，SEO好 缺点 首屏时间慢，SEO差 页面切换慢 数据通信 借助vuex或storage之类 依赖URL、cookie或者localstorage麻烦 CI/CD实践 什么是 CI/CD？ 前言CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。 CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这 3 项构成的关联环节。更为复杂的是，”持续交付”有时也包含了持续部署流程。 CI 持续集成（Continuous Integration） 在互联网敏捷开发的过程中，持续集成通常用来进行日常编译和自动化测试。持续集成主要包含以下步骤： 自动化构建Continuous Build 自动化测试Continuous Test 自动化集成Continuous Intergration CD 持续交付（Continuous Delivery） 持续交付是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。 CD 持续部署（Continuous Deployment） 对于一个成熟的 CI/CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。 Gitlab CI/CDGitlab 是开源的 devops 平台，集成了 Gitlab CI/CD 功能，通过 gitlab runner 完成CICD： 开发者在commit代码或者提交merge request会自动触发CI/CD流程 流程开始后，会主动读取项目根目录下的 .gitlab_ci.yml 文件，获取构建镜像，构建步骤，构建命令等,并运行一个CI pipeline（一个pipeline通常分为三个阶段：build，test，deploy），即会执行一系列任务，如用eslint校验代码规范，单元测试等。 根据.gitlab_ci.yml中配置的stage中的tags，选择对应的gitlab runner，根据配置的image启动容器，并在该容器中执行stage中的构建命令 Gitlab CI/CD 中pipeline（流水线），stage（阶段），job（任务）之间的关系为：pipeline 包含了若干个 stage，stage 包含了多个 job，job 是流水线中最小的单位，这些任务是在 gitlab runner 中运行。 Iaas,Paas,Saassass,paas,laas这都是云服务的一种，是一种租赁的关系，而不是买卖的关系。我只关注使用，不需要维护。一次性收费变为按批次周期性服务。云服务本质就是把大家通用的一些服务，放到云端操作。 aas即as a Service以什么东西作为服务， xass即anything as a Service一切即服务 SaaS即Software as a Service软件即服务，如：salesforce的CRM客户关系管理、google docs。 PaaS即Platform as a Service平台即服务，如：Google的App Engine、微软的windows Server on Azure、AWS Elastic Beanstalk。IaaS读依亚S即Infrastructure as a Service基础设施即服务，如：Amazon S3、微软Azure、Google的Compute Engine 三者合称为SPI模式。 还有其他的服务，DaaS数据即服务，DBaaS数据库即服务，DWaaS数据仓库即服务，FaaS功能即服务，AI PaaS人工智能平台即服务，BaaS后端即服务，NaaS网络即服务。 Polyfill黑话Polyfill或者Polyfiller，是英国Web开发者 Remy Sharp 在咖啡店蹲坑的时候拍脑袋造出来的。当时他想用一个词来形容”用JavaScript来实现一些浏览器不支持的原生API“。 Polyfill的准确意思为：用于实现浏览器并不支持的原生API的代码。 querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持。假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.querySelectorAll，使用方法跟现代浏览器原生API无异。那么这个库就可以称为Polyfill或者Polyfiller。 如何用chatgpt提升前端开发效率问题解答和指导：ChatGPT可以帮助回答与前端开发相关的问题。当你在编写代码的时候，当一时忘记了某个API怎么用，就可以向ChatGPT提问，并获得解答和指导，甚至还会给出一些更加深入且性能更好的应用。这可以帮助更快地解决问题和理解前端开发中的概念。 代码片段和示例：ChatGPT可以帮助你生成常见的前端代码片段和示例。你可以描述你想要实现的功能或解决的问题，然后向ChatGPT请求相关代码片段。这样，您可以更快地获得一些基础代码，从而加快开发速度。 自动生成文档：ChatGPT可以帮助你生成前端代码的文档。你可以描述一个函数、组件或类，并向ChatGPT请求生成相关的文档注释。这可以帮助您更轻松地为你的代码添加文档，提高代码的可读性和可维护性。 问题排查和调试：在开发过程中，您可能会遇到问题或错误。您可以向ChatGPT描述您遇到的问题，或者直接把代码交给它，并请求帮助进行排查和调试。ChatGPT可以提供一些建议和指导，帮助您更快地找到问题的根本原因并解决它们。 学习资源和最新信息：ChatGPT可以为你提供关于前端开发的学习资源和最新信息。你可以向ChatGPT询问关于前端开发的最佳实践、最新的框架或库、前端设计原则等方面的问题。这可以帮助我们不断学习和更新自己的前端开发知识，从而提高效率。","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"0基础_移动端","slug":"I_移动端_0基础","date":"2099-11-04T22:33:16.000Z","updated":"2023-06-13T23:16:57.999Z","comments":true,"path":"2099/11/05/I_移动端_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/11/05/I_%E7%A7%BB%E5%8A%A8%E7%AB%AF_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基本概念屏幕尺寸以 iPhone6 为例，其屏幕尺寸为 4.7英寸，指的是屏幕对角线的长度为 4.7 英寸，1英寸（inch）= 2.54cm。 屏幕分辨率（物理分辨率、设备分辨率）以 iPhone6 为例，其屏幕分辨率为 750 x 1334，指的是屏幕水平有 750 个像素点，垂直有 1334 个像素点。 通常，设计师给的UI设计稿上的“px”指的就是物理像素。 像素密度（Pixels Per Inch）PPI（Pixel Per Inch by diagonal）：表示对角线上每英寸所拥有的像素个数。 以 iPhone6 为例，其屏幕像素密度为 326ppi，指的是每英寸有 326 个像素点。 显示分辨率通常，PC 的显示器分辨率是可以设置的，显示分辨率就是指系统或用户设置的分辨率。用户可以通过修改显示分辨率，修改系统字体大小。通常，显示分辨率小于等于设备分辨率。以我的 MacBook Pro (13-inch, 2020) 为例，其设备分辨率为 2560 x 1600，系统默认分辨率为 1440 x 900，用户也可以自己设置为 1680 x 1050、1280 x 800、1024 x 640 等几个分辨率。系统设置分辨率生效是通过算法进行了转换。当用户设置不同的分辨率时，系统将自动根据显示分辨率和物理分辨率的比值来拟合。例如，如果物理分辨率为2560 x 1600，而用户设置的显示分辨率为 1280 x 800，那么 1 个显示像素点将由 4 个物理像素点显示；如果用户设置的分辨率为 1440 x 900，物理分辨率和显示分辨率的比值并不是整数，那么系统将根据各个像素点的色值和亮度计算拟合显示。 逻辑分辨率逻辑分辨率用屏幕的宽*高来表示（单位：设备独立像素）。 通过 screen.width/height 得到的数值就是整个屏幕（不仅仅是浏览器的区域）的宽度和高度（单位：设备独立像素）。在 PC 中，这个数值就是系统设定的显示分辨率的大小。这个数值不随页面缩放、浏览器窗口大小而改变。对于移动端，这个数值可以在 Chrome 开发者工具中，打开移动端调试，页面顶部显示的就是逻辑分辨率。 以 iPhone6 为例，其逻辑分辨率（设备独立像素数）为 375 × 667。 设备像素比（DPR）这里所谓的缩放因子，并不是对图像本身进行缩放，而是使用更多的物理像素来渲染同一个元素。 如下图所示，同样大小的矩形元素（灰色条），在第一个屏幕上采用 8×1 个物理像素来渲染，而在第二个屏幕上采用 16×2 个物理像素来渲染，在第三个设备上则采用 24×3 个物理像素来渲染。 这样做的目的是为了让这个元素在不同设备上看起来差不多大小。 设备独立像素可以简单认为是计算机坐标系统中的一个点，而物理像素可以简单认为是显示器硬件中的一个点。那么它们之间的关系是怎样的呢？设备像素比就是表示二者之间关系的一个概念。 设备像素比就是指设备物理像素和设备独立像素之间的比值。在 JS 中可以通过 window.devicePixelRatio 获取。可以简单理解为：硬件中一个点的大小和系统中一个点的大小的比值。对于某一个固定的设备，这个值是固定不变的。 以 iPhone6 为例，其设备像素比为 2，指的是用其物理像素和逻辑像素的比值为 2。 当然，也有一些例外。iPhone6/7/8Plus 的实际物理像素是 1080x1920，在开发者工具中我们可以看到：它的设备独立像素是 414x736，设备像素比为 3，设备独立像素和设备像素比的乘积并不等于 1080x1920，而是等于 1242x2208。实际上，手机会自动把 1242x2208 个像素点塞进 1080x1920 个物理像素点来渲染，我们不用关心这个过程，而 1242x2208 被称为屏幕的设计像素。 iPhone 常见的几种规格 视口（Viewport）vw和百分比区别: vw只跟视窗有关，跟父级容器大小无关 百分比，跟父级容器有关 视口的概念通常用于移动端。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。 布局视口（Layout Viewport） 可以通过调用 document.documentElement.clientWidth/clientHeight 来获取布局视口大小。在进行 @media 媒体查询的时候，查询的宽度值也是布局视口的宽度值。 视觉视口（Visual Viewport） 视觉视口指用户通过屏幕真实看到的区域。视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。可以通过调用 window.innerWidth/innerHeight 来获取视觉视口大小。 理想视口（Ideal Viewport） 布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口就诞生了：网站页面在移动端展示的理想大小。如上图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，其实也就是逻辑分辨率的大小。 通过 meta viewport 设置布局视口viewport详解 viewport 有以下字段可配置： width 设置布局视口的宽度，为一个正整数，或字符串”width-device” initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置布局视口的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes” 例如： 123&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot; /&gt;复制代码 以上语句的含义为： width=device-width 表示将布局视口设置成为设备屏幕的宽度（逻辑分辨率宽度）； initial-scale=1 的意思是初始缩放的比例是 1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸；而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和 width=device-width 同样的效果。另外，值得一提的是，我们在进行媒体查询的时候，查询的宽度值其实也是布局视口的宽度值。 maximum-scale=1.0, minimum-scale=1.0, user-scalable=no 的目的是阻止用户缩放；（需要注意的是，在 ios10+以上，尽管开发者设置了 user-scalable=no，Safari 还是允许用户通过手势来缩放，安卓手机各大厂商的内置浏览器也逐渐开放用户缩放，即使使用 meta 标签进行设置） rem、em、px、vh与vw的区别？一、 rem 的特点 rem 的大小是根据 html 根目录下的字体大小进行计算的。 当我们改变根目录下的字体大小的时候，下面字体都改变。 rem 不仅可以设置字体的大小，也可以设置元素宽、高等属性。 rem 是 CSS3 新增的一个相对单位（root em，根em），这个单位与 em 区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。 对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用 rem 设定的字体大小。 二、px 特点 px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。 三、em 特点 em 的值并不是固定的； em 会继承父级元素的字体大小。 em 是相对长度单位。当前对行内文本的字体尺寸未被人为设置，相对于当前对象内文本的字体尺寸。如则相对于浏览器的默认字体尺寸。 任意浏览器的默认字体高都是 16px。 所有未经调整的浏览器一般都符合: 1em = 16px。那么 12px = 0.75em，10px = 0.625em。 为了简化 font-size 的换算，需要在 css 中的 body 选择器中声明 Fontsize = 62.5%，这就使 em 值变为 16px*62.5%=10px, 这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了。 四、vh 与 vw 视口 在桌面端，指的是浏览器的可视区域； 在移动端，它涉及 3个 视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。 视口单位中的 “视口”，桌面端指的是浏览器的可视区域；移动端指的就是 Viewport 中的 Layout Viewport。 vh / vw 与 % 单位 解释 vw 1vw = 视口宽度的 1% vh 1vh = 视口高度的 1% vmin 选取 vw 和 vh 中最小的那个 vmax 选取 vw 和 vh 中最大的那个 比如：浏览器视口尺寸为 370px，那么 1vw = 370px * 1% = 6.5px (浏览器会四舍五入向下取 7) vh / vw 与 % 区别 单位 解释 % 元素的祖先元素 vh / vw 视口的尺寸 不过由于 vw 和 vh 是 css3 才支持的长度单位，所以在不支持 css3 的浏览器中是无效的。 移动端适配解决方案参考 2022 年移动端适配方案指南 — 全网最新最全 响应式设计 - 理解设备像素、设备独立像素和 css 像素 移动前端开发之viewport的深入理解 使用 Flexible 实现手淘 H5 页面的终端适配 VW: 是时候放弃 REM 布局了 lib-flexible postcss-px-to-viewport 网页适配 iPhoneX CSS媒体查询通过 CSS 的 @media 媒体查询设置不同的 style。通过媒体查询，我们可以根据不同屏幕设置不同样式，这样就可以实现不同屏幕的适配。 如果我们选择600px,900px,1200px,1800px作为分割点，可以适配到常见的14个机型。 link 元素中的 CSS 媒体查询，不同屏幕加载不同样式文件： 12&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 500px)&quot; href=&quot;mobile.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; media=&quot;(min-width: 980px)&quot; href=&quot;pc.css&quot; /&gt; CSS 样式表中的媒体查询： 12345678910111213141516171819202122232425262728293031323334353637383940/* pc width &gt; 1024px */ body &#123; background-color: yellow; &#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; &#125;&#125; 使用rem单位rem（font size of the root element）是指相对于根元素的字体大小的单位，如果我们设置 html 的 font-size 为 16px，则如果需要设置元素字体大小为 16px，则写为 1rem。但是其还是必须得借助 @media 属性来为不同大小的设备设置不同的 font-size，相对上一种方案，可以减少重复编写相同属性的代价，简单示例如下所示。 我们也能看到该方案存在以下问题： 不同的尺寸需要写多个 @media； 所有涉及到使用 rem 的地方，全部都需要调用方法 calc() ，这个也挺麻烦的； 1234567891011121314151617181920212223242526@media only screen and (min-width: 375px) &#123; html &#123; font-size : 375px; &#125;&#125;@media only screen and (min-width: 360px) &#123; html &#123; font-size : 360px; &#125;&#125;@media only screen and (min-width: 320px) &#123; html &#123; font-size : 320px; &#125;&#125;//定义方法：calc@function calc($val)&#123; @return $val / 1080;&#125;.logo&#123; width : calc(180rem);&#125; flexible适配(淘宝旧方案)在 rem 方案上进行改进，我们可以使用 js 动态来设置根字体，这种方案的典型代表就是 flexible 适配方案。 使用 rem 模拟 vw 特性适配多种屏幕尺寸 核心代码 123456// set 1rem = viewWidth / 10function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + &#x27;px&#x27;&#125;setRemUnit(); 上面的代码中，将 html 节点的 font-size 设置为页面 clientWidth(布局视口)的 1/10，即 1rem 就等于页面布局视口的 1/10，这就意味着我们后面使用的 rem 都是按照页面比例来计算的。 控制 viewport 的 width 和 scale 值适配高倍屏显示 设置 viewport 的 width 为 device-width，改变浏览器 viewport（布局视口和视觉视口）的默认宽度为理想视口宽度，从而使得用户可以在理想视口内看到完整的布局视口的内容。 等比设置 viewport 的 initial-scale、maximum-scale、minimum-scale 的值，从而实现 1 物理像素=1 css像素，以适配高倍屏的显示效果（就是在这个地方规避了大家熟知的“1px 问题”） 核心代码 1234var metaEL= doc.querySelector(&#x27;meta[name=&quot;viewport&quot;]&#x27;);var dpr = window.devicePixelRatio;var scale = 1 / dprmetaEl.setAttribute(&#x27;content&#x27;, &#x27;width=device-width, initial-scale=&#x27; + scale + &#x27;, maximum-scale=&#x27; + scale + &#x27;, minimum-scale=&#x27; + scale + &#x27;, user-scalable=no&#x27;); flexible 的缺陷 由于其缩放的缘故，video 标签的视频频播放器的样式在不同 dpr 的设备上展示差异很大； 如果你去研究过 lib-flexible 的源码，那你一定知道 lib-flexible 对安卓手机的特殊处理，即：一律按 dpr = 1 处理； 不再兼容 @media 的响应式布局，因为 @media 语法中涉及到的尺寸查询语句，查询的尺寸依据是当前设备的物理像素，和 flexible 的布局理论（即针对不同 dpr 设备等比缩放视口的 scale 值，从而同时改变布局视口和视觉视口大小）相悖，因此响应式布局在“等比缩放视口大小”的情境下是无法正常工作的； 其实 flexible 方案是在 模拟 viewport 功能，只是随着浏览器的发展及兼容性增强，viewport 已经能兼容绝大部分主流浏览器，并且 flexible 方案自身存在的问题，所有其也已几乎退出历史潮流。 引用 lib-flexible 的 github 主页的原话： 由于 viewport 单位得到众多浏览器的兼容，lib-flexible 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 viewport 来替代此方案。 Viewport适配(主流方案)原理：类似近大远小，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的。vw作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。 由于 viewport 单位得到众多浏览器的兼容，所以目前基于 viewport 的移动端适配方案被各大厂团队所采用。 vw 作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。 viewport 相关概念如下： vw：是 viewport’s width 的简写，1vw 等于 window.innerWidth 的 1%； vh：和 vw 类似，是 viewport’s height 的简写，1vh 等于 window.innerHeihgt 的 1%； vmin：vmin 的值是当前 vw 和 vh 中较小的值； vmax：vmax 的值是当前 vw 和 vh 中较大的值； 假设我们拿到的视觉稿宽度为 750px，视觉稿中某个字体大小为 75px，则我们的 css 属性只要如下这么写，不需要额外的去用 js 进行设置，也不需要去缩放屏幕等； 123.logo &#123; font-size: 10vw; // 1vw = 750px * 1% = 7.5px&#125; 实现步骤 设置 meta 标签 px 自动转换为 vw 标注不需要转换的属性 Retina 屏预留坑位 设置 meta 标签 在 html 头部设置 mata 标签如下所示，让当前 viewport 的宽度等于设备的宽度，同时不允许用户手动缩放。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; px 自动转换为 vw 设计师一般给宽度大小为 375px 或 750px 的视觉稿，我们采用 vw 方案的话，需要将对应的元素大小单位 px 转换为 vw 单位，这是一项影响开发效率（需要手动计算将 px 转换为 vw）且不利于后续代码维护（css 代码中一堆 vw 单位，不如 px 看的直观）的事情；好在社区提供了 postcss-px-to-viewport 插件，来将 px 自动转换为 vw。 标注不需要转换的属性 在项目中，如果设计师要求某一场景不做自适配，需为固定的宽高或大小，这时我们就需要利用 postcss-px-to-viewport 插件的 Ignoring 特性，对不需要转换的 css 属性进行标注，示例如下所示： /* px-to-viewport-ignore-next */ —&gt; 下一行不进行转换. /* px-to-viewport-ignore */ —&gt; 当前行不进行转换 Retina 屏预留坑位 考虑 Retina 屏场景，可能对图片的高清程度、1px 等场景有需求，所以我们预留判断 Retina 屏坑位。 相关方案如下：在入口的 html 页面进行 dpr 判断，以及 data-dpr 的设置；然后在项目的 css 文件中就可以根据 data-dpr 的值根据不同的 dpr 写不同的样式类； 常见问题1.行内样式的场景 场景：当你需要写行内样式的代码（style）时，postcss-px-to-viewport 插件 无法进行 px 单位无法转换，需要自己手动计算好 vw； 最佳实践：通过添加、修改、删除 className 的方式进行处理此类场景，不直接操作行内样式，这更符合将 js 和 css 隔离开的更佳实践。 2.1px 的问题 retina 屏下 1px 问题是个常谈的问题，相比较普通屏，retina 屏的 1px 线会显得比较粗，设计美感欠缺；在视觉设计师眼里的 1px 是指设备像素 1px，而如果我们直接写 css 的大小 1px，那在 dpr = 2 时，则等于 2px 设备像素，dpr = 3 时，等于 3px 设备像素。所以对于要求处理 1px 的场景，我们要进行特殊处理。 以下介绍常用的几种方法 transform: scale(0.5) 可以使用 transform: scale(0.5) 进行 X、Y 轴的缩放，如下示例所示 1234css复制代码.class1 &#123; height: 1px; transform: scaleY(0.5);&#125; 优点是编写简单，但是如果实现上下左右四条边框会比较难搞，并且如果有嵌套存在的话，会对包含的元素产生影响，所以结合 :before 和 :after 来使用。 transform: scale(0.5) + :before / :after （推荐） 此种方式能解决例如 标签上下左右边框 1px 的场景，以及有嵌套元素存在的场景，比较通用，示例如下所示 123456789101112css复制代码.calss1 &#123; position: relative; &amp;::after &#123; content:&quot;&quot;; position: absolute; bottom:0px; left:0px; right:0px; border-top:1px solid #666; transform: scaleY(0.5); &#125;&#125; 3.box-shadow 利用 css 对阴影处理来模拟边框，示例如下所示，底部一条线，缺点是存在阴影不好看。 123css复制代码 .class1 &#123; box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5); &#125; 4.其它 还有如下等方式处理 1px 问题，但不推荐，了解即可 viewport: 将页面进行缩小处理； border-image：切个 1px 图片来模拟； background-image：切个 1px 图片来模拟； linear-gradient：通过线性渐变，来实现移动端 1px 的线； svg：基于矢量图形(svg) 在不同设备屏幕特性下具有伸缩性。 图片高清的问题 图片高清的问题： 适用普通屏的图片在 retina 屏中，图片展示就会显得模糊； 适用 retina 屏的图片在普通屏中，图片展示就会缺少色差、没有锐利度，并且浪费带宽； 所以如果对性能、美观要求很高的场景，需要根据 dpr 区分使用对应的图片，我们在文章 viewport 适配方案中针对 retina 屏预留了 dpr 方案，相关 css 写法如下： 12345678910css复制代码[data-dpr=&quot;1&quot;] .hello &#123; background-image: url(image@1x.jpg);[data-dpr=&quot;2&quot;] .hello &#123; background-image: url(image@2x.jpg);&#125; [data-dpr=&quot;3&quot;] .hello &#123; background-image: url(image@3x.jpg);&#125; WebView一句话概括：解析并展示页面的一个容器。 webview是原生系统，用于用于移动端 APP 嵌入(Embed) Web 技术，方式是内置了一款高性能webkit内核浏览器。 Webview 是一个基于webkit引擎，可以解析DOM 元素，展示html页面的控件，它和浏览器展示页面的原理是相同的，所以可以把它当做浏览器看待。（chrome浏览器也是基于webkit引擎开发的，Mozilla浏览器是基于Gecko引擎开发的） 百度的开发人员将app加载过程划分为了四个阶段： 初始化组件：260ms Hybrid初始化：270ms 正文加载与渲染：1400ms 图片加载：600ms 所以重点优化正文加载与渲染，手段有三种： WebView预创建和复用 渲染优化（JS、CSS、图片） 模板优化（拆分、预热、复用） 淘宝的秒开率会场性能优化专项小组联合了客户端基础团队、容器团队、前端团队、数据分析团队、测试团队等多个团队，跨栈协同共同努力，在性能优化方向上也做了不少的优化工作。梳理了全链路性能埋点、定义新的性能口径（从用户点击到可视），使用了预渲染、数据预请求、资源加速下载、离线资源等优化手段，既能全链路的维度来度量，也能拆分到各个子阶段细粒度的数据。 这些性能优化手段，经过了618、双11等大促场景的实践检验。用户打开会场的整体平均耗时缩短了200ms700ms左右，秒开率提升10%14%。优化对中低端机绝对收益更高，已实现在低端机上实现秒开会场。在中低端机和高端机上优化前后的对比效果。 Electron是什么定义 Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。通过Node它提供了通常浏览器所不能提供的能力。 历史 2013年的时候，Atom编辑器问世，作为实现它的底层框架Electron也逐渐被熟知，到2014年时被开源，那时它还是叫Atom Shell。 接下来的几年，Electron在不断的更新迭代，几乎每年都有一个重大的里程碑 2013年4月11日，Electron以Atom Shell为名起步。 2014年5月6日，Atom以及Atom Shell以MIT许可证开源。 2015年4月17日，Atom Shell改名为Electron。 2016年5月11日，1.0版本发布。 2016年5月20日，允许向Mac应用商店提交软件包。 2016年8月2日，支持Windows商店。 在最新的稳定版本V3.x中，Electorn集成了Nodejs v10.2.0和内核为v66.0.3359.181的Chromium 底层实现 Electron 结合了 Chromium、Node.js 和用于调用操作系统本地功能的API。 1）Chromium Chromium 是 Google 为发展 Chrome 浏览器而启动的开源项目，Chromium 相当于 Chrome 的工程版或称实验版，新功能会率先在 Chromium 上实现，待验证后才会应用在Chrome 上，故 Chrome 的功能会相对落后但较稳定。 Chromium为Electron提供强大的UI能力，可以在不考虑兼容性的情况下开发界面。 2）Node.js Node.js是一个让 JavaScript 运行在服务端的开发平台，Node 使用事件驱动，非阻塞I/O 模型而得以轻量和高效。 单单靠Chromium是不能具备直接操作原生GUI能力的，Electron内集成了Nodejs，这让其在开发界面的同时也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用。 3）系统API 为了提供原生系统的GUI支持，Electron内置了原生应用程序接口，对调用一些系统功能，如调用系统通知、打开系统文件夹提供支持。 在开发模式上，Electron在调用系统API和绘制界面上是分离开发的，下面我们来看看Electron关于进程如何划分。 为什么要用Electron 以Windows平台为例，大部分人会首先想到使用QT(C++)，WPF(C#) 等语言去开发应用。不可否认的是，这些已经是非常成熟的开发方案了。但是，我们来看下如下两种场景： 公司要做个全新的APP，但是技术人员构成大部分都是前端开发 公司原本就有在线的web应用，但是想包个壳能在桌面直接打开，同时增加一些与系统交互的功能 对于第一种场景，团队中开发人员对于C++和C#并不熟悉，虽然可以现学，但是整个项目的技术管理和项目管理就会变得不可控。 对于第二种场景，对于应用的业务逻辑要求并不多，只是套一个具有浏览器的运行环境，单独为此配置一个C++、C#开发人员划不来。 对于这两种情况，如果现有的前端开发人员能直接搞定，那就非常完美了。 Electron的诞生提供了这种可能性。它可以帮助前端开发者在不需要学习其他语言和技能的前提下，快速开发跨平台的桌面应用。 传统的桌面应用开发方式，一般是下面两种： 1）原生开发 直接将语言编译成可执行文件，直接调用系统API，完成UI绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如： a. 使用C++ / MFC开发Windows应用；b. 使用Objective-C开发MAC应用。 2）托管平台 一开始就有本地开发和UI开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如： a. 使用C# / .NET Framework(只能开发Windows应用)；b. Java / Swing。 不过，上面两种对前端开发人员太不友好了，基本是前端人员不会涉及的领域，但是在这个”大前端”的时代，前端开发者正在想方设法涉足各个领域，使用WEB技术开发客户端的方式横空出世。 为什么还要搬到PC客户端，这里有3个角度的回答： a. 用户角度： 客户端是一款独立的软件，其综合体验一般都是比网站高的，尤其是涉及到「工具」范畴的应用，此外，特定的用户群体也会有类似的使用习惯；b. 发行方角度： 客户端是另一种产品形式，是一种产品的分发方式和入口，客户端可以实现很多本地应用独有的需求去触达用户，也能提供更加可靠的服务；c. 开发角度： 终于…不用考虑浏览器兼容了，Chromium 也足够开发使用一些先进的 CSS 或 JS 特性，我们现在还没计划引入 webpack 和 babel，因为现在好像够用，克制才是爱，除了写起来爽，对于开发来说，终于跳出了浏览器的沙盒，你可以自己去控制 Electron 中的“浏览器”，莫名的开心。 Electron优势： a. 使用具有强大生态的Web技术进行开发，开发成本低，可扩展性强，更炫酷的UI；**b. 跨平台，一套代码可打包为Windows、Linux、Mac三套软件，且编译快速；** c.可直接在现有Web应用上进行扩展，提供浏览器不具备的能力； 缺点：性能比原生桌面应用要低，最终打包后的应用比原生应用大很多。 Electron开发体验： a. 兼容性：虽然你还在用WEB技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用Electron的版本对应Chrome的版本，一般情况下它已经足够新来让你使用最新的API和语法了，你还可以手动升级Chrome版本。同样的，你也不用考虑不同浏览器带的样式和代码兼容问题。b. NodeJS环境：这可能是很多前端开发者曾经梦想过的功能，在WEB界面中使用Node.js提供的强大API，这意味着你在WEB页面直接可以操作文件，调用系统API，甚至操作数据库。当然，除了完整的 Node API，你还可以使用额外的几十万个npm模块。 c.跨域：你可以直接使用Node提供的request模块进行网络请求，这意味着你无需再被跨域所困扰。 d.强大的扩展性：借助node-ffi，为应用程序提供强大的扩展性（更详细的介绍可以自行百度相关资料了解一下）。 Electron项目和Web项目的区别 Electron核心可以分成2个部分：主进程和渲染进程。 主进程连接着操作系统和渲染进程，可以把她看做页面和计算机沟通的桥梁。渲染进程就是我们所熟悉前端环境了，只是载体改变了，从浏览器变成了window。 传统的Web环境我们是不能对用户的系统就行操作的，而Electron相当于NodeJS环境，我们可以在项目里使用所有的node api（Electron的作者相当机智…）。 简单理解：给Web项目套上一个NodeJS环境的壳，就是Electron技术。 项目结构：相比web项目，桌面项目多了一个进程 项目迁移：如果要迁移项目到Web端，就需要把项目中的Electron提供的API和NodeJS的API完全剥离出来，只能遗留Web的代码，比如 node fs模块，Electron提供ipc 模块，都需要剥离。如果你一开始就打算双端程序，在开始写代码时应该对Web代码和Elecctron的代码进行分离，以便后期的迁移。 Electron的基本使用 新建一个目录，初始化npm 123mkdir hellowordnpm init复制代码 修改package.json文件，增加npm run start命令 12345678910111213141516&#123; &quot;name&quot;: &quot;electron demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, //修改为main.js &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; //增加start命令 &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;electron&quot;: &quot;^3.0.10&quot; &#125;&#125;复制代码 通过npm安装Electron 12npm i electron --save-dev复制代码 在根目录创建main.js和index.html main.js 123456789101112const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)function createWindow () &#123; // 创建浏览器窗口 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 然后加载应用的 index.html。 win.loadFile(&#x27;index.html&#x27;)&#125;app.on(&#x27;ready&#x27;, createWindow)复制代码 index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 到这里，我们所有的准备工作都完成了，接下来就是运行它！ 1npm run start 参考 《跨平台桌面应用开发：基于Electron与NW.js》 Electron官网：https://electronjs.org； Electron Github：https://github.com/electron； Electron开发手册：https://electronjs.org/docs。","categories":[{"name":"I_移动端","slug":"I-移动端","permalink":"https://fuyunjinglong.github.io/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[]},{"title":"0基础_计算机网络","slug":"F_计算机网络_0基础","date":"2099-11-03T22:33:16.000Z","updated":"2024-02-28T22:55:08.951Z","comments":true,"path":"2099/11/04/F_计算机网络_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/11/04/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"参考 小林coding 大纲大黑书有一个共同点就是厚、并且很适合盖泡面。哪有人开始打牌的时候就出王炸的呢 第一阶段：简答书籍入手 《图解HTTP》和《图解TCPIP》，《计算机是怎样运行的》《网络是怎样连接的》(两本书适合小白非科班) 第二阶段：简单视频加深印象 韩立刚讲解谢希仁的计算机网络，斯坦福CS144 计算机网络 第三阶段：抓包实践学习 《Wireshark 网络分析就这么简单》以及《Wireshark网络分析的艺术》 第四阶段：经典书籍 《计算机网络：自顶向下方法》，《TCP/IP详解 卷1：协议》 基础篇网络模型前言 会话层、表示层、应用层：http 传输层：tcp(面向连接，安全可靠有序，重试机制，慢，分段传输),udp(无连接，传输快，丢包，一次传输) 网络层：ip路由寻址，排队等待。ip + mac + 广播的方式 就能让你找到全世界所有的计算机的位置 物理层、数据链路层：物理层是物理连接介质，如光纤、双绞线。数据链路层是二进制数据也就是比特流进行分组。 TCP/IP四层概念模型 OSI七层网络模型 OSI七层网络模型与TCP/IP四层概念模型比较 OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 应用层(Application) 应用层 HTTP、TFTP、FTP、NFS、SMTP 表示层(Presentation) Telnet、Rlogin、SNMP、Gopher 会话层(Session) SMTP、DNS 传输层(Transport) 传输层 TCP、UDP 网络层(Network) 网络层 IP、ICMP、ARP、RARP、AKP、UUCP 数据链路层(Data Link) 数据链路层 FDDI、Ethernet、Arpanet、PDN 物理层(Physical) IEEE802.1A IEEE802.2到IEEE802.11 Socket/TCP/HTTP/WebSocket/RPC是什么？ Socket：只是tcp/ip协议中的一个套接字 TCP：面向连接的、可靠的、基于字节流的传输层协议 Http：超文本传输协议。短连接，无状态协议 WebSocket：长连接，服务端主动推送协议 RPC：远程调用方式，具体协议如grpc、Thrift HTTP篇HTTP是什么？Http是超文本传输协议。 超文本：超越文本范围，如文字、语音、视频等 传输：双向传输 协议：行为约定和规范 HTTP 常见的状态码 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。 一文读懂 HTTP/1、HTTP/2、HTTP/3《现代前端技术解析》笔记 HTTP 超文本传输协议是位于 TCP/IP 体系结构中的应用层协议。 Http1.0,Http1.1,Http2.0,Http3.0优化了什么 Http1.1比Http1.0优化了： 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 Http2.0比Http1.1优化了： 头部压缩 二进制格式 并发传输 服务器主动推送资源 Http3.0比Http2.0优化了： 1234遗留问题：- HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。所以Http3.0底层TCP替换为UDP.- 无队头阻塞 更快的连接建立 连接迁移 一、HTTP/1.0 缺陷： 高延迟 — 队头阻塞(Head-Of-Line Blocking) 无状态特性 — 阻碍交互 明文传输 — 不安全性 不支持服务端推送 队头阻塞 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。 针对队头阻塞： 1.将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。 2.减少请求数量 3.内联一些资源：css、base64 图片等 4.合并小文件减少资源数 无状态特性 无状态是指协议对于连接状态没有记忆能力。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是掉登录态。 不安全性 传输内容没有加密，中途可能被篡改和劫持。 二、SPDY 协议 SPDY 是由 google 推行的改进版本的 HTTP1.1 （那时候还没有 HTTP2） 特点： 多路复用 — 解决队头阻塞 头部压缩 — 解决巨大的 HTTP 头部 请求优先级 — 先获取重要数据 服务端推送 — 填补空缺 提高安全性 多路复用 SPDY 允许在一个连接上无限制并发流。因为请求在一个通道上，TCP 效率更高（参考 TCP 拥塞控制 中的慢启动）。更少的网络连接，发出更密集的包。 头部压缩 使用专门的 HPACK 算法，每次请求和响应只发送差异头部，一般可以达到 50% ~90% 的高压缩率。 请求优先级 虽然无限的并发流解决了队头阻塞的问题，但如果带宽受限，客户端可能会因防止堵塞通道而阻止请求。在网络通道被非关键资源堵塞时，高优先级的请求会被优先处理。 服务端推送 可以让服务端主动把资源文件推送给客户端。当然客户端也有权利选择是否接收。 提高安全性 支持使用 HTTPS 进行加密传输。 三、HTTP/2 HTTP2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接。 特点： 二进制分帧 - HTTP2 性能增强的核心 多路复用 - 解决串行的文件传输和连接数过多 二进制分帧 首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：帧、消息、流。 分帧有什么好处？服务器单位时间接收到的请求数变多，可以提高并发数。最重要的是，为多路复用提供了底层支持。 多路复用 一个域名对应一个连接，一个流代表了一个完整的请求-响应过程。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。 缺点： TCP 以及 TCP+TLS 建立连接的延时 TCP 的队头阻塞并没有彻底解决 多路复用导致服务器压力上升 多路复用容易 Timeout 建连延时 TCP 连接需要和服务器进行三次握手，即消耗完 1.5 个 RTT 之后才能进行数据传输。 TLS 连接有两个版本—— TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致需要 1~2 个 RTT。 RTT（Round-Trip Time）:往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。 队头阻塞没有彻底解决 TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。 RTO：英文全称是 Retransmission TimeOut，即重传超时时间；RTO 是一个动态值，会根据网络的改变而改变。RTO 是根据给定连接的往返时间 RTT 计算出来的。接收方返回的 ack 是希望收到的下一组包的序列号。 多路复用导致服务器压力上升 多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。 多路复用容易 Timeout 大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。 即使是使用 Nginx 这样的负载均衡器，想正确进行节流也可能很棘手。其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。 四、HTTP/3 Google在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的 QUIC 协议。而这个就是 HTTP3。它真正“完美”地解决了“队头阻塞”问题。 特点： 改进的拥塞控制、可靠传输 快速握手 集成了 TLS 1.3 加密 多路复用 连接迁移 改进的拥塞控制、可靠传输 从拥塞算法和可靠传输本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点： 可插拔 — 应用程序层面就能实现不同的拥塞控制算法。 一个应用程序的不同连接也能支持配置不同的拥塞控制。应用程序不需要停机和升级就能实现拥塞控制的变更，可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。 关于应用层的可插拔拥塞控制模拟，可以对 socket 上的流为对象进行实验。 单调递增的 Packet Number — 使用 Packet Number 代替了 TCP 的 seq。 每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 重传策略存在二义性，比如客户端发送了一个请求，一个 RTO 后发起重传，而实际上服务器收到了第一次请求，并且响应已经在路上了，当客户端收到响应后，得出的 RTT 将会比真实 RTT 要小。当 Packet N 唯一之后，就可以计算出正确的 RTT。 不允许 Reneging — 一个 Packet 只要被 Ack，就认为它一定被正确接收。 Reneging 的意思是，接收方有权把已经报给发送端 SACK（Selective Acknowledgment） 里的数据给丢了（如接收窗口不够而丢弃乱序的包）。 QUIC 中的 ACK 包含了与 TCP 中 SACK 等价的信息，但 QUIC 不允许任何（包括被确认接受的）数据包被丢弃。这样不仅可以简化发送端与接收端的实现难度，还可以减少发送端的内存压力。 前向纠错（FEC） 早期的 QUIC 版本存在一个丢包恢复机制，但后来由于增加带宽消耗和效果一般而废弃。FEC 中，QUIC 数据帧的数据混合原始数据和冗余数据，来确保无论到达接收端的 n 次传输内容是什么，接收端都能够恢复所有 n 个原始数据包。FEC 的实质就是异或。示意图： 更多的 Ack 块和增加 Ack Delay 时间。 QUIC 可以同时提供 256 个 Ack Block，因此在重排序时，QUIC 相对于 TCP（使用 SACK）更有弹性，这也使得在重排序或丢失出现时，QUIC 可以在网络上保留更多的在途字节。在丢包率比较高的网络下，可以提升网络的恢复速度，减少重传量。 TCP 的 Timestamp 选项存在一个问题：发送方在发送报文时设置发送时间戳，接收方在确认该报文段时把时间戳字段值复制到确认报文时间戳，但是没有计算接收端接收到包到发送 Ack 的时间。这个时间可以简称为 Ack Delay，会导致 RTT 计算误差。现在就是把这个东西加进去计算 RTT 了。 基于 stream 和 connection 级别的流量控制。 为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。Stream 可以认为就是一条 HTTP 请求。Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。 QUIC 接收者会通告每个流中最多想要接收到的数据的绝对字节偏移。随着数据在特定流中的发送，接收和传送，接收者发送 WINDOW_UPDATE 帧，该帧增加该流的通告偏移量限制，允许对端在该流上发送更多的数据。 除了每个流的流控制外，QUIC 还实现连接级的流控制，以限制 QUIC 接收者愿意为连接分配的总缓冲区。连接的流控制工作方式与流的流控制一样，但传送的字节和最大的接收偏移是所有流的总和。 最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。 快速握手 由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现 0-RTT 或者 1-RTT 来建立连接，可以大大提升首次打开页面的速度。 集成了 TLS 1.3 加密 TLS 1.3 支持 3 种基本密钥交换模式： 123(EC)DHE (基于有限域或椭圆曲线的 Diffie-Hellman)PSK - onlyPSK with (EC)DHE 在完全握手情况下，需要 1-RTT 建立连接。TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。 但是 TLS1.3 也并不完美。TLS 1.3 的 0-RTT 无法保证前向安全性(Forward secrecy)。简单讲就是，如果当攻击者通过某种手段获取到了 Session Ticket Key，那么该攻击者可以解密以前的加密数据。 要缓解该问题可以通过设置使得与 Session Ticket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）。 多路复用 QUIC 是为多路复用从头设计的，携带个别流的的数据的包丢失时，通常只影响该流。QUIC 连接上的多个 stream 之间并没有依赖，也不会有底层协议限制。假如 stream2 丢了一个包，也只会影响 stream2 的处理。 连接迁移 TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。 参考 一文读懂 HTTP/1、HTTP/2、HTTP/3 彻底搞懂HttpsHTTPS本质 HTTPS，其实就是身披SSL协议这层外壳的HTTP HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法： 非对称加密：实现身份认证和密钥协商 对称加密：采用协商的密钥对数据加密 散列函数 ：基于散列函数验证信息的完整性 对称加密 一句话：有一把秘钥，可以加密信息，也可以解密信息。 用对称加密可行？ 秘钥传输过程中，被人劫持了，就能用秘钥解开双方加密的内容 秘钥不传输，事先浏览器保存所有网站的秘钥，就不存在秘钥劫持问题，但成本太高 非对称加密 一句话：有两把密钥，一把叫做公钥、一把叫私钥，公钥加密，私钥解密。 用非对称加密可行？ 服务器将公钥明文传输给客户端，如果公钥被劫持了，虽然保证客户端到服务端安全，但服务端到客户端不安全，服务端私钥加密的会被黑客劫持的公钥解密 改良的非对称加密 一句话：非对称加密只能保证单一方向的安全，那么我们用两对公钥秘钥。如服务器有公钥A私钥A,客户端有公钥B私钥B. 用改良的非对称加密可行？ 服务端将公钥A发给客户端，客户端将公钥B发给服务端，这样秘钥始终不被泄密，安全了，但非对称加密算法非常耗时，开销成本太大 非对称+对称加密 一句话：服务端有公钥A私钥A,服务端将公钥A明文发送给客户端，客户端用公钥A将随机生成的秘钥X加密传输给服务端，随后两端用对称秘钥X通信 Https采用的就是这种，但完美？ 仍有漏洞，在服务端发送公钥A时，黑客劫持并用冒充的公钥B替换了A,客户端用冒充的公钥B传输秘钥X,黑客又劫持并拿私钥B解密得到秘钥X。根本原因是浏览器无法确认收到的公钥是不是网站自己的 数字证书 网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。证书相当于是一个网站的身份证。 数字证书安全？ 黑客容易伪造证书，也不安全 数字签名 一句话：用数字签名保证数字证书也是安全的 流程包括：服务端的数字签名+客户端的数字验证 数字签名 CA机构拥有非对称加密的私钥和公钥。 CA机构对证书明文数据T进行hash。 对hash后的值用私钥加密，得到数字签名S。 数字验证 拿到证书，得到明文T，签名S。 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。 用证书里指明的hash算法对明文T进行hash得到T’。 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。 其他问题 1234567891011中间人有可能篡改该证书吗？假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。既然不可能篡改，那整个证书被掉包呢？中间人有可能把证书掉包吗？假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。为什么制作数字签名时需要hash一次？我初识HTTPS的时候就有这个疑问，因为似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。 既然有 HTTP 协议，为什么还要有 RPC？前言 HTTP 协议（Hyper Text Transfer Protocol），又叫做超文本传输协议。我们用的比较多，平时上网。 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。调用一个网络方法像在本地调用一样，屏蔽掉一些网络细节。 历史原因 其实，TCP 是70年代出来的协议，80年代出来的 RPC，而 HTTP 是 90 年代才开始流行的。 以前QQ客户端工具，客户端（Client）需要跟服务端（Server）建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。 但后来有了浏览器后，就不仅要求能访问自己的服务器，还要访问其他服务器，HTTP 就是那个时代用于统一 Browser/Server (B/S) 的协议。 Http与RPC的区别： 纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。 HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合 RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 才是具体协议。同时RPC底层实现可以基于tcp或UDP或http,都可以。 RPC 其实比 HTTP 出现的要早，现在大部分公司内部还是使用RPC,比Http1.1性能更好。 既然有 HTTP 协议，为什么还要有 WebSocket？前言 Web 实时推送技术对比 方式 类型 技术实现 优点 缺点 适用场景 轮询Polling client→server 客户端循环请求 1、实现简单 2、 支持跨域 1、浪费带宽和服务器资源 2、 一次请求信息大半是无用（完整http头信息） 3、有延迟 4、大部分无效请求 适于小型应用 长轮询Long-Polling client→server 服务器hold住连接，一直到有数据或者超时才返回，减少重复请求次数 1、实现简单 2、不会频繁发请求 3、节省流量 4、延迟低 1、服务器hold住连接，会消耗资源 2、一次请求信息大半是无用 WebQQ、Hi网页版、Facebook IM 长连接iframe client→server 在页面里嵌入一个隐蔵iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。 1、数据实时送达 2、不发无用请求，一次链接，多次“推送” 1、服务器增加开销 2、无法准确知道连接状态 3、IE、chrome等一直会处于loading状态 Gmail聊天 WebSocket server⇌client new WebSocket() 1、支持双向通信，实时性更强 2、可发送二进制文件3、减少通信量 1、浏览器支持程度不一致 2、不支持断开重连 网络游戏、银行交互和支付 Websocket 支持双向通信，实时性更强 可以发送文本，也可以发送二进制数据 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了 12TCP 连接的两端，同一时间里，双方都可以主动向对方发送数据。这就是全双工。HTTP/1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是半双工。 所以基于TCP的新协议的websocket出来了。 注意:其实 socket 和 WebSocket 之间，就跟雷峰和雷峰塔一样，二者接近毫无关系 Websocket建立连接流程： 客户端发送http请求 tcp经历第3次握手时，将http协议升级为websocket。Connection: Upgrade和Upgrade: websocket。 使用webSocket协议收发数据 经历了三次TCP握手之后，利用 HTTP 协议升级为 WebSocket 协议。升级完成之后就跟HTTP没有任何关系 websocket特性 主要有ws(不加密)和wss(加密)；ws是基于http请求建立握手，wss是基于https请求建立握手。 ws的握手基于http的get方式，协议应不小于1.1。 ws和wss的请求头会比单纯的http的请求头多很多特殊的header。 ws请求在建立连接后，通信双方都可以在任何时刻向另一方发送数据。(http只能客户端发送请求给服务端) 属性readyState 0 - 表示连接尚未建立。 1 - 表示连接已建立，可以进行通信。 2 - 表示连接正在进行关闭。 3 - 表示连接已经关闭或者连接不能打开。 事件 onopen：连接建立时触发 onmessage：客户端接收服务端数据时触发 onerror：通信发生错误时触发 onclose： 连接关闭时触发 send：发送数据 close：关闭连接 配置1234567891011// vue2版本proxy: &#123; &#x27;/socket&#x27;: &#123; target: &#x27;wss://ai.threecloud.huawei.com&#x27;, //代理地址， ws: true, changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &#x27;^/socket&#x27;: &#x27;&#x27; &#125; &#125;&#125; 实战调用12345678910111213141516171819202122useWebSocket(questStr, keyword, dataList, uid) &#123; const that = this; const wsuri = `wss://$&#123;window.location.host&#125;/socket/ws`; const ws = new WebSocket(wsuri); ws.onopen = function (e) &#123; // 发送请求 const params = &#123; prompt: questStr, keyword: keyword || questStr, temperature: 0.8, top_p: 0.8, max_length: 4000, history: [], uid: uid ? uid : &#x27;&#x27; &#125;; ws.send(JSON.stringify(params)); &#125;; // 接收到消息的回调方法 ws.onmessage = function (e) &#123; // 赋值并显示 &#125;; &#125; 样例 websocket正确使用 123456789101112131415161718192021222324initWebSocket()&#123; //初始化weosocket const wsuri = &quot;ws://127.0.0.1:8080&quot;; this.websock = new WebSocket(wsuri); this.websock.onmessage = this.websocketonmessage; this.websock.onopen = this.websocketonopen; this.websock.onerror = this.websocketonerror; this.websock.onclose = this.websocketclose; &#125;, websocketonopen()&#123; //连接建立之后执行send方法发送数据 let actions = &#123;&quot;test&quot;:&quot;12345&quot;&#125;; this.websocketsend(JSON.stringify(actions)); &#125;, websocketonerror()&#123;//连接建立失败重连 this.initWebSocket(); &#125;, websocketonmessage(e)&#123; //数据接收 const redata = JSON.parse(e.data); &#125;, websocketsend(Data)&#123;//数据发送 this.websock.send(Data); &#125;, websocketclose(e)&#123; //关闭 console.log(&#x27;断开连接&#x27;,e); &#125;, TCP篇TCP是什么?TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文 特点： 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接。 只能用于端到端的通讯，是一种可靠的数据流服务 采用“带重传”技术来实现传输的可靠性。 采用“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。 什么是TCP连接定义：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket套接字、序列号和窗口大小称为连接。 Socket：由 IP 地址和端口号组成 序列号：用来解决乱序问题等 窗口大小：用来做流量控制 如何唯一确定一个 TCP 连接呢？TCP 四元组确定一个连接: 源地址 源端口 目的地址 目的端口 最大TCP连接数=客户端的IP数X客户端的端口数 TCP三次握手和四次挥手过程三次握手 形象解释 女朋友向程序员提出约会(Seq = x)的建议，然后女朋友进入SYN_SEND状态。 程序员收到后同意了去约会(ACK = x + 1), 然后向女朋友建议去吃麻辣烫吧(Seq = y)，程序员进入SYN_RCVD状态。 女朋友收到建议后，勉为其难的答应了，然后告诉程序员说 那好吧(ACK = y + 1)。女朋友就进入了ESTABLISHED状态， 程序员也进入了 ESTABLISHED状态，整个约会讨论结束。 专业解释 序列号能够保证数据包不重复、不丢弃和按序传输。 第一次握手([SYN], Seq = x) 客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。 第二次握手([SYN,ACK], Seq = y, ACK = x + 1) 服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。 第三次握手([ACK], ACK = y + 1) 客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。 四次挥手 形象解释 女朋友向程序员提出分手 程序员告诉女朋友说，我知道了，但是要考虑一下 程序员考虑清楚后，跟女朋友说那就分手吧 女朋友接收到程序员的消息后，然后还在等程序员发挽留的消息，然而等了两天后没等到，就认为程序员是真的不会再发消息来了，于是就拉黑删除程序员，关闭连接了。 专业解释 第一次挥手（[FIN], Seq = x） 客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。 第二次挥手 ([ACK], ACK = x + 1) 服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。 第三次挥手 ([FIN], Seq = y) 服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。 第四次挥手 ([ACK], ACK = y + 1) 客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。 服务端接收到ACK包后，关闭连接，进入CLOSED状态。 客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。 TCP为什么是三次握手？四次挥手？浅层次说：为了保证客户端知悉服务端的收发能力，服务端知悉客户端的收发能力。 根本原因： 三次握手才可以阻止重复历史连接的初始化（主要原因） 三次握手才可以同步双方的初始序列号 三次握手才可以避免资源浪费 1.避免历史连接 防止「历史连接」初始化了连接。 在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。同时也不能保证服务端知晓客户端的接收能力。 2.同步双方初始序列号 接收方可以去除重复的数据； 接收方可以根据数据包的序列号按序接收； 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）； 3.避免资源浪费 四次握手其实也是可以，但是可以合并为第二次握手，节约资源。 不使用「两次握手」和「四次握手」的原因： 「两次握手」：无法防止历史连接的建立；无法可靠的同步双方序列号即服务端知晓客户端接收能力 「四次握手」：三次握手就已经理论上最少可靠连接建立，四次浪费资源 为什么四次挥手的原因： 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 UDP是什么？特点： 面向无连接的通讯协议，可以实现广播发送 不需要接收方确认，属于不可靠的传输，可能会出现丢包现象 服务需要交换的信息量较小，速度快 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP 与 UDP 的区别TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 1. 连接 TCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是不需要连接，即刻传输数据。 2. 服务对象 TCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信 3. 可靠性 TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。 UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？ 4. 拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 5. 首部开销 TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 6. 传输方式 TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 7. 分片不同 TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。 IP篇网络层作用：实现主机与主机之间的通信，也叫点对点（end to end）通信 跨域跨端基于浏览器存在的同源策略，协议、域名、端口不一样。 目前主要使用JSONP和跨域资源共享CROS. JSON本质就是一段script脚本，脚本是可以不受跨域限制的。只支持get请求，不符合正常业务流程 CROS是服务端设置Access-controll-Allow-Origin:* 网络缓存一文读懂http缓存（超详细） 缓存术语 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率 过期内容：超过设置的有效时间。过期内容不能用于回复客户端的请求，必须重新向源服务器请求新内容 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间 失效：失效就是把内容从缓存中移除。当内容发生改变时，必须移除失效的内容 按照缓存位置分类： Service Worker memory cache disk cache（也叫http缓存） 按照类别分类： 浏览器缓存 本地缓存 Cookie WebStoreage(SessionStorage,LocalStorage) WebSql indexDB Application Cache PWA 默认缓存—往返缓存BFCache http缓存 强缓存 Pragma Cache-Control Expires 协商缓存 ETag/If-None-Match Last-Modified/If-Modified-Since 网络缓存-浏览器缓存分为两大类: 本地缓存 Cookie WebStoreage(SessionStorage,LocalStorage) WebSql/indexDB Application Cache 应用缓存(manifest,PWA即Servie Worker) 默认缓存—往返缓存BFCache Cookies、SessionStorage和LocalStorage定义 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据。cookie 数据始终在同源的http请求中携带，也会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小 cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage可以达到 5M 或更大。 有期时间 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。默认是关闭浏览器后失效。 sessionStorage 数据在当前浏览器窗口关闭后自动删除。 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； CookieCookie机制 Cookie是解决HTTP无状态性的有效手段，服务器可以设置或读取Cookie中所包含的信息。 当用户登录后，服务器会发送包含登录凭据的Cookie到用户浏览器客户端，而浏览器对该Cookie进行某种形式的存储（内存或硬盘）。 用户再次访问该网站时，浏览器会发送该Cookie（Cookie未到期时）到服务器，服务器对该凭据进行验证，合法时使用户不必输入用户名和密码就可以直接登录。 Cookie工作过程 客户端发送一个请求给服务器 服务器发送一个HttpResponse响应给客户端，其中包含Set-Cookie的头部 客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部 服务器返回响应数据 SessionSession机制 Session的工作机制离不开Cookie：在cookie中有一个键名为sessionId，值为Session的id。对于不支持cookie的手机端，可以采用URL重写携带sessionId。 当客户端请求创建一个session时，服务端会先检查客户端的请求里面有没有带着session标识-sessionId。 如果有，则说明服务器以前已为此客户端创建过session，于是就根据这个sessionId把session检索出来。 如果客户端请求中不包含sessionId，则为客户端创建一个session并且生成一个与这个session相关联的sessionId。 这个sessionId将被在本次响应中返回给客户端保存。 WebStoreage 包括：sessionStorage 和 localStorage sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 sessionStorage 和 localStorage可以达到 5M 或更大。 sessionStorage 数据在当前浏览器窗口关闭后自动删除。 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； WebSql/indexDB 前端数据库有WebSql和IndexDB，其中WebSql被规范废弃，他们都有大约50MB的最大容量，可以理解为localStorage的加强版。 Application Cache应用缓存-manifest即HTML5的离线缓存通过manifest文件来注册被缓存的静态资源，已经被废弃，因为他的设计有些不合理的地方，他在缓存静态文件的同时，也会默认缓存html文件。这导致页面的更新只能通过manifest文件中的版本号来决定。所以，应用缓存只适合那种常年不变化的静态网站。如此的不方便，也是被废弃的重要原因。 定义 在用户没有与因特网连接时，可以正常访问站点或应用 原理 HTML5离线缓存是基于manifest(缓存清单文件，后缀名为.appcache)的缓存机制，通过这个文件上的清单解析存储离线资源，就像cookie一样被存在本地，之后当处于离线状态时，就直接使用离线存储的资源进行页面的展示。 好处： 离线浏览，不再需要网络 速度快，已缓存的资源加载更快 减轻服务器压力，用户无需网络请求缓存资源 使用 h5头部标签引入manifest属性，值为manifest清单文件 在manifest清单文件中编写离线存储的资源 操作window.applicationCache进行缓存数据处理 manifest清单文件： 123456789CACHE MANIFEST#v0.11CACHE: // 需要缓存的js/app.jscss/style.cssNETWORK: // 不缓存的resourse/logo.pngFALLBACK: // 网络失败时的替换页面//offline.html window.applicationCache.status的属性值如下： 0：（UNCACHED）无缓，代表没有与当前页面相关的缓存资源； 1：（IDLE）闲置，代表应用缓存未得到更新； 2：（CHECKING）检查中，正在下载描述文件，并检查有无更新； 3：（DOWNLOADING）下载中，应用缓存正在下载描述文件中的资源； 4：（UPDATEREADY）更新完成，所有资源下载完毕； 5：（）废弃，即应用缓存的描述文件不存在了，因此页面无法在访问应用缓存； 更新缓存时机 用户清空浏览器缓存； manifest文件被修改； 由程序来更新应用缓存； h5缓存与浏览器缓存区别 离线缓存是针对整个应用，但是浏览器缓存是针对单个文件； 离线缓存断网了还可以继续访问，浏览器缓存不行； 离线缓存可以主动通知浏览器更新； 应用缓存-PWA即Servie WorkerPWA全称是渐进式网络应用，PWA也运用了manifest文件，不同于manifest简单的将文件通过是否缓存进行分类，PWA用manifest构建了自己的APP骨架，并运用Servie Worker来控制缓存。 PWA即Progressive Web Apps。谷歌给以Service Worker API为核心的实现web应用取名PWA即渐进式增强WEB应用。有点类似移动端小程序一样，在web上运行，不需要独立安装的web微应用。 PWA PWA全称Progressive Web Apps（渐进式WebApp），是通过现代API来构建和增强的，这些API提供了与原生App相似的能力、可靠性、可安装性，而且具备一套代码即可触达任何人、任何地方、任何设备。PWA同时具备这三大特性，这也让PWA的应用体验更接近原生。 三大特性： 功能性（capable） 可靠性（reliable） 可安装性（installable） 功能性 Web App当今时代已经具备了丰富的功能，你可以基于 WebRTC 开发一个视频聊天工具，可以使用 Geolocation API 开发一个地图软件，也可以使用 Notification API 来给你的APP推送消息，让用户可以在APP之外接收到通知。你也可以使用 WebGL 和 WebVR 来虚拟化这些场景。通过 Web Assembly，你可以步入其他生态，比如：C和C++等，给Web生态带来更多能力。 可靠性 可靠的App需要对网络无依赖。用户会期望在弱网或者无网络的情况下打开App。他们期望看到上次他们加载的内容，就像是音频或者视频播放到某个特定时间点，即使网络连接困难，还是要保持可靠和可用。如果请求失败了，比起默默地失败或者崩溃，给用户合理的提示才是最佳。 可安装性 安装好的PWA应用可以在一个独立的窗口启动，而不用在浏览器中。它们也可以从主页、docks或者任务栏启动。 小结 PWA的核心还是WebApp，通过渐进式增强，新的功能被现代浏览器实现。通过使用 service worker 和 app manifest，可以让你的WebApp具备可靠性和可安装性。如果浏览器不支持这些功能，你的网站的核心功能也不受影响。 如果说一个30M的原生App换成PWA，可能只有3M不到。另外，PWA的应用的可触达性是继承了WebApp的，可以通过搜索引擎让触达更多用户，或者通过分享的方式。最后，PWA的应用可随时更新，无需用户下载安装。 Service Worker 什么是Service Worker Service Worker是一项比较新的Web技术，是Chromium团队在吸收了ChromePackaged App的Event Page机制，同时吸取了HTML5 AppCache标准失败的教训之后，提出一套新的W3C规范，旨在提高WebApp的离线缓存能力，缩小WebApp与NativeApp之间差距。 Service Worker从英文翻译过来就是一个服务工人，服务于前端页面的后台线程，基于Web Worker实现。有着独立的js运行环境，分担、协助前端页面完成前端开发者分配的需要在后台悄悄执行的任务。基于它可以实现拦截和处理网络请求、消息推送、静默更新、事件同步等服务。 应用场景 1、离线缓存：可以将H5应用中不变化的资源或者很少变化的资源长久的存储在用户端，提升加载速度、降低流量消耗、降低服务器压力。如中重度的H5游戏、框架数据独立的web资讯客户端、web邮件客户端等 2、消息推送：激活沉睡的用户，推送即时消息、公告通知，激发更新等。如web资讯客户端、web即时通讯工具、h5游戏等运营产品。 3、事件同步：确保web端产生的任务即使在用户关闭了web页面也可以顺利完成。如web邮件客户端、web即时通讯工具等。 4、定时同步：周期性的触发Service Worker脚本中的定时同步事件，可借助它提前刷新缓存内容。如web资讯客户端。 往返缓存-BFCache往返缓存又称为BFCache，是浏览器在前进后退按钮上为了提升历史页面的渲染速度的一种策略。BFCache会缓存所有的DOM结构，但是问题在于，一些页面开始时进行的上报或者请求可能会被影响。这个问题现在主要会出现在微信h5的开发中。 网络缓存-http缓存强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304 分为两大类： 强缓存 Pragma Cache-Control Expires 协商缓存 ETag/If-None-Match Last-Modified/If-Modified-Since Http请求流程图 强制缓存：重点关注1即缓存是否过期 强缓存一般存在Disk Cache硬盘和 Memory Cache内存中。 关键参数 Expires 缓存过期时间。HTTP1.0的产物，会将浏览器的Expires 时间与服务器系统时间对比，Expires=max-age + 请求时间。 Cache-Control max-age：表示缓存内容将在xxx秒后失效 no-cache：不使用强缓存(走协商缓存)，需要与服务器验证缓存是否新鲜 no-store：禁止使用所有缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 Pragma Pragma 只有一个属性值，就是 no-cache,不使用强缓存 强缓存生效条件:当条件1,2,3都成立，才会执行强缓存部分 Cache-Control值为max-age max-age&gt;0 当前 date &lt; 上次请求时的date + max-age 注：如果HTTP为1.0时，则用expires判断是否过期，如果HTTP为1.1及其以上时，则查看cache-control 协商缓存：询问服务器资源是否修改 关键参数 ETag/If-None-Match 值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变。 适用于秒级以下修改频率的文件，优先级更高 Last-Modified/If-Modified-Since 代表的是文件的最后修改时间，前后两者比较时间，有效时间为1s以上 协商缓存生效条件:两种值只要有一对值的前后相同，即生效协商缓存 缓存策略： 不常变化的资源，Cache-Control: max-age=31536000； 经常变化的资源，Cache-Control: no-cache 比较敏感的资源，Cache-Control: max-age=600 常见六大Web安全攻防解析XSSXSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。 跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 按照攻击方式分： 非持久型跨站（也叫反射型） 持久型跨站（也叫存储型） DOM跨站 一、反射型 一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。 特点： 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。 攻击者需要诱骗点击,必须要通过用户点击链接才能发起 反馈率低，所以较难发现和响应修复 盗取用户敏感保密信息 反制： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 二、存储型 黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 特点： 持久性，植入在数据库中 盗取用户敏感私密信息 危害面广 反制： CSP即白名单 转义字符 HttpOnly Cookie CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 这里以设置 HTTP Header 来举例： 只允许加载本站资源 12Content-Security-Policy: default-src &#x27;self&#x27;复制代码 只允许加载 HTTPS 协议图片 12Content-Security-Policy: img-src https://*复制代码 允许加载任何来源框架 12Content-Security-Policy: child-src &#x27;none&#x27;复制代码 如需了解更多属性，请查看Content-Security-Policy文档 HttpOnly Cookie。 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。 三、DOM跨站 攻击者构造出特殊的 URL ，其中包含恶意代码。 用户打开带有恶意代码的 URL 。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型跟前两种区别是： DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 CSRFCSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。 攻击流程： 受害者登录 a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了 b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。 a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com 以受害者的名义执行了 act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。 反制： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token 具体反制： SameSite 可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 Referer Check同源检测 referer 和 origin 的区别，只有 post 请求会携带 origin 请求头，而 referer不论何种情况下都带。 HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。 但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 Anti CSRF Token 目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 验证码 应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 cookie和token cookie 是不能跨域访问的，为什么还会有 csrf？ 浏览器会依据加载的域名附带上对应域名 cookie。如用户在 a 网站登录且生成了授权的 cookies，然后访问 b 网站，b 站故意构造请求 a 站的请求，如删除操作之类的，用不受同源影响的 script，img 或者 iframe 之类的标签加载 a 地址，浏览器会附带上 a 站此登录用户的授权 cookie 信息，这样就构成 crsf，会删除掉当前用户的数据。cookie和session都会有csrf问题，localstorge没有这个问题，因为它有同源策略。 Token 示例： 用户登录输入账号密码，请求登录接口，后端在用户登录信息正确的情况下将 token 放到数据库中，并返回 token 给前端，前端把 token 存放在 localstorage 中，之后再发送请求都会将 token 放到 header 中。 后端写一个过滤器，拦截 POST 请求，注意忽略掉不需要 token 的请求，比如登录接口，获取 token 的接口，以免还没有获取 token 就开始检验 token 。 校验原则：数据库中的 token 和前端 header 中的 token 一致的 post 请求，则说明校验成功，给客户端放行。 点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 特点： 隐蔽性较高，骗取用户操作 “UI-覆盖攻击” 利用iframe或者其它标签的属性 具体反制： 1）X-FRAME-OPTIONS X-FRAME-OPTIONS是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 2）JavaScript 防御 1if (self == top) &#123;...&#125; SQL注入SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 反制： 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。 对进入数据库的特殊字符（’，”，\\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数 参考 常见六大Web安全攻防解析 重定向与请求转发的区别一句话:重定向时浏览器上的网址改变;转发是浏览器上的网址不变 重定向是客户端行为,转发是服务器行为 重定向是两次request,请求转发是一次request","categories":[{"name":"F_计算机网络","slug":"F-计算机网络","permalink":"https://fuyunjinglong.github.io/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"0基础_数据结构","slug":"E_数据结构_0基础","date":"2099-10-31T22:33:16.000Z","updated":"2023-07-16T10:15:50.804Z","comments":true,"path":"2099/11/01/E_数据结构_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/11/01/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法学习前言第一阶段：简答书籍入手 《大话数据结构》和《算法图解》，《趣学数据结构》和《趣学算法》 第二阶段：简单视频加深印象 浙大陈越姥姥数据结构 第三阶段：实践学习-刷题 leetcode刷题，《剑指 offer》《编程珠玑》《编程之美》 左程云四大视频课(《算法和数据结构新手班》《算法和数据结构体系学习班》《大厂算法和数据结构刷题班》《每周有营养的大厂算法面试题》) 算法和数据结构新手班：这个班唯一的目的就是为了让新手学员能熟悉一些算法上常见的coding、简单的算法。算是入门性质的预热课。算法和数据结构体系学习班：非常重要！再牛逼的学员也不可以跳过！讲述了大厂面试中必备的算法、数据结构、编程技巧、解题思路总结，还有188题的真实大厂面试题。大厂算法和数据结构刷题班：纯粹的题！但是不看完“算法和数据结构体系学习班”就来尝试，会非常痛苦。有350道题目。而且所有题目都和“算法和数据结构体系学习班”完全不重复！每周有营养的大厂算法面试题：目前每周三晚上8点直播，会讲一周以内出现的有意思的题，简称算法周更班。每周都是最新题。这个课是给报班的学员保持算法状态的班，但是最好是把上面的课弄完再来听 第四阶段：经典书籍 《算法》《算法导论》《计算机程序设计艺术》 大纲 算法通关之路 吴师兄学算法 参考-必备 leetcode leetCode.cn 炼码 九章算法 UOJ 牛客网 afatcoder整理题库 参考-竞赛 北大POJ 杭电HDU 如何刷题 大家都是如何刷 LeetCode 的？ 刷完 LeetCode 是什么水平？能拿到什么水平的 offer？ LeetCode按照怎样的顺序来刷题比较好？ leetcode闯关 第一轮 题目类别推荐按照这个顺序来说： 数组 -&gt;字符串 -&gt;链表-&gt;二分查找-&gt;排序-&gt;哈希表-&gt; 栈-&gt;队列 -&gt;树 、递归、回溯 -&gt; 堆 ，每一个类别只做简单的题目！而且是从通过率又高向低来刷。 第二轮 开始做第一轮类别里面中等难度的题目 第三轮 这一轮的题目所代表的算法是比较难的，如果之前没有了解过，直接就刷题会很难，所以，建议把相关算法的理论看一遍，再去刷题， 先了解一下 什么是 拓扑排序、 分治，搜索树，贪心，动态规划，以及深搜和广搜，然后再去刷题 推荐按照这个顺序去做：拓扑排序-&gt;分治算法-&gt; 二叉搜索树-&gt;贪心算法-&gt;动态规划-&gt; 深度优先搜索 -&gt; 广度优先搜索–&gt;图-&gt;数学 这里依然还是只做简单难度的题目 按照通过率又高向低 第四轮 开始尝试做第一轮里面的 困难难度的题目 （不强求，仅仅是尝试，面试中也不会太难） 同时开始做第二轮里面 中等难度的题目 （不用全都做，选一下自己一看就有想法的题目） 第五轮 然后开始做做leetcode分类里面 第一轮和第二轮都没有涉及到的类别的题目，相对于其他类型，面试中最常考察的是： 字典树-&gt; 并查集 -&gt; 树状数组-&gt;线段树 ， 这里只做简单难度的就可以了！ 剩余类型题目也凭个人喜好，选一些简单难度的题目做一做就可以了。 总结 达到面试的水平一般到第三轮就可以了，至于要刷多少题呢， 不得不说，现在leetcode上的题太多了，我当时刷leetcode的时候 才500题左右，我是刷了300道才开始面试的，现在的话，我建议刷题刷到400到以上为佳。 而且要注意每轮里面的各个类型都要做到！ 1.面向对象(1)面向过程与面向对象 面向过程：早期我们使用的是过程变成，即自己是执行者，执行代码。 面向对象：自己则变成了指挥者，从始至终都是自己去命令、调度其他资源完成任务。更加符合人思考习惯，从执行者变成指挥者。 (2)面向对象4大特性 软件编程就是将我们的思想转变成计算机能够识别的语言的过程。 面向对象是把一组数据结构和处理他们的方法组成对象。 抽象、封装、继承、多态 抽象：把具有相同行为的对象归为类 封装：通过封装隐藏类的内部细节 继承：通过继承使类得到泛化 多态：通过多态实现基于对象类型的动态分配 面向对象四大特性 抽象：提高代码的扩展性、可维护性，降低复杂度。对方法的具体实现进行隐藏，让调用者只需要关心方法 封装：保护数据和隐藏信息，访问权限控制。通过暴露有限的方法来达到保护数据的作用 继承：解决代码复用问题，提升可维护性。继承最大的作用就是用来实现更好的代码复用，减少重复代码。 多态：提高代码的可扩展性和复用性。需要编程语言提供特殊的语法机制，通过多态使代码变得更加灵活。“同一个事件发生在不同的对象上会产生不同的结果” 2.为什么大厂螺丝钉的岗位需要算法很牛逼人算法是绝对代码能力和耐心的一种证明。算法是智力程度的良好证明。老的框架技术已经没办法筛查人才。 算法是绝对代码能力和耐心的一种证明 好公司考算法与数据结构的比重是比较大的，以前大公司考的现在比重越来越高，现在小公司以前不考的现在也开始考了。早期的程序员是非常在乎算法数据机构，比如阿波罗登月，飞船的控制程序内存不足1M，当时那批老派程序员以极强的算法与数据结构把有限的资源榨取到极致，充分发挥自己在算法与数据结构的设计和能力。在一个很吃紧的资源下也能完成很复杂的任务。 大公司的面经经过记忆性的知识，是可以基本应付的，但是算法不行。你需要理解基础算法与数据结构，还要触类旁通，举一反三，逻辑推导。所以我们国内开始考察这些方向，同时美国外国公司早就考过算法了。因为你进入到工作岗位，记忆性的知识是可以查文档的，你是可以现场现学的，哪怕是面向google编程。但是算法不行，因为门槛比较高。 国外公司只考算法与数据结构，是因为杜绝了其他方向是重要的，或者说对于一个即将进入职场，每天可以查询网络资料的人，记忆性的东西没那么重要。有一个段子，若干年之前，google招了一个接线员，宾夕法尼亚的法律系博士，这行业内卷到这个程度？google招聘精英基本是传统，一个电话接线员都招这么贵，为什么？google招聘两个员工，A员工比B员工的代码性能提升5%-7%，到代码部署到用户真实使用的场景下，带来的收益远远超过招聘成本本身。所以坊间流传着一句话：最贵的就是最省的。可能你觉得美国计算机专业前三的名校的博士，每年给那呢么多钱，然后也写很简单的业务，你觉得是浪费？但是不是的。 招精英员工即最贵的就是最省的。代码性能提升5%到10%，可以省下昂贵的开销。以前是糙快猛，现在公司板块领域瓜分完了，就进入仔细耕耘，好好迭代，优化代码，提升性能。 算法是智力程度的良好证明 刷题，刷题，刷题。从隐隐理解算法，到真正写出算法，不是一般人能坚持的。如果对算法或代码面试稍微了解的人，都知道，公司实际出题目可能是在白纸或编辑器上写出代码的，有些面试官可能因为你一点点边界条件没考虑好，就直接扣分或让你走人都有可能。 老的框架技术已经没办法筛查人才 技术知识可以通过记忆性的东西还原，但是算法不行，必须需要理解并掌握核心思想。 3.经典排序算法算法分类 内部排序(交叉选轨迹) 交换：冒泡、快排 插入：直接插入、希尔排序 选择:简单选择、堆排序 归并排序 基数排序 外部排序 4.topK问题100亿数据找出最大的1000个数字（top K问题） 对于海量数据处理，思路基本上是：必须分块处理，然后再合并起来。 a.理论方法： 全部排序 局部淘汰法 分治法 Hash法 1.全部排序 最容易想到的方法是将数据全部排序。该方法并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。 2.局部淘汰法 用一个容器保存前10000个数，然后将剩余的所有数字一一与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小。 这个容器可以用（小顶堆）最小堆来实现。我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到 底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了（1亿的logN值是26-27的一个浮点数）。基本的思路就是先从文件中取出1000个元素构建一个小顶堆数组k，然后依次对剩下的100亿-1000个数字进行遍历m，如果m大于小顶堆的根元素，即k[0]，那么用m取代k[0]，对新的数组进行重新构建组成一个新的小顶堆。这个算法的时间复杂度是O((100亿-1000)log(1000))，即O((N-M)logM)，空间复杂度是M 这个算法优点是性能尚可，空间复杂度低，IO读取比较频繁，对系统压力大。 3.分治法 a、将100亿个数据分为1000个大分区，每个区1000万个数据 b、每个大分区再细分成100个小分区。总共就有1000*100=10万个分区 c、计算每个小分区上最大的1000个数。 为什么要找出每个分区上最大的1000个数？举个例子说明，全校高一有100个班，我想找出全校前10名的同学，很傻的办法就是，把高一100个班的同学成绩都取出来，作比较，这个比较数据量太大了。应该很容易想到，班里的第11名，不可能是全校的前10名。也就是说，不是班里的前10名，就不可能是全校的前10名。因此，只需要把每个班里的前10取出来，作比较就行了，这样比较的数据量就大大地减少了。我们要找的是100亿中的最大1000个数，所以每个分区中的第1001个数一定不可能是所有数据中的前1000个。 d、合并每个大分区细分出来的小分区。每个大分区有100个小分区，我们已经找出了每个小分区的前1000个数。将这100个分区的1000*100个数合并，找出每个大分区的前1000个数。 e、合并大分区。我们有1000个大分区，上一步已找出每个大分区的前1000个数。我们将这1000*1000个数合并，找出前1000.这1000个数就是所有数据中最大的1000个数。 （a、b、c为map阶段，d、e为reduce阶段） 4.Hash法 如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。 b.实战解法 1.立刻就能想到的解法:快排 2.O(n) 时间复杂度的方法：快排的 partition 划分思想可以用于计算某个位置的数值等问题。虽然时间复杂度是 O(n) ，但是缺点也很明显，最主要的就是内存问题，在海量数据的情况下，我们很有可能没办法一次性将数据全部加载入内存，这个时候这个方法就无法完成使命了 3.利用分布式思想处理海量数据 4.利用最经典的方法，一台机器也能处理海量数据 leecode40 其实提到 Top K 问题，最经典的解法还是利用堆。 维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。 当然，如果是求前 K 个最小的数，只需要改为大顶堆即可 MapReduce 一文读懂MapReduce原文 MapReduce 是一个高性能的分布式计算框架，用于大规模数据集（大于1TB）的并行运算。它极大的方便编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。MapReduce分为Map(映射)和Reduce(化简)两个阶段，是在HDFS存储数据的基础上，将一个较大的计算任务(job)分解成若干小任务(task)，每个小任务都由一个Map任务(task)来计算（这个Map尽量在数据所在节点上完成计算），然后再将每个Map的计算结果由一个或多个Reduce任务(task)合并，得到最终的结果。 5.常见算法-动态规划算法动态规划是算法设计中的一种方法，一种算法设计思想。它将一个问题分解为相互重叠的子问题，通过反复求解子问题，来解决原来的问题。 举例算法题：爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路： 爬到第n阶可以在第n-1阶爬1个台阶，或者在第n-2阶爬2个台阶. F(n)=F(n-1)+F(n-2)。 使用动态规划。 解题步骤： 定义子问题：F(n)=F(n-1)+F(n-2)。 反复执行：从2循环到n,执行上述公式。 解体答案： 1、时间复杂度O(n)，空间复杂度O(n) 12345678910var climbStairs = function(n)&#123; //边界条件 if(n &lt; 2)&#123; return 1; &#125; const dp = [1, 1]; //记录第n阶有多少种方法 for(let i = 2; i&lt;=n; i=+1)&#123; dp[i] = dp[i-1]+dp[i-2]; &#125; console.log(dp); return dp[n];&#125; 2、时间复杂度O(n) 空间复杂度O(1) 123456789101112var climbStairs = function(n)&#123; //边界条件 if(n &lt; 2)&#123; return 1; &#125; let dp0 = 1; let dp1 = 1 for(let i = 2; i&lt;=n; i=+1)&#123; const temp = dp0; dp0 = dp1; dp1 = dp1 + temp; &#125; return dp1;&#125; 常见算法-回溯算法回溯算法是算法设计中的一种方法，算法的一种设计思想。是一种渐进式寻找并构建问题解决方式的策略。回溯算法会从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决。 什么问题适合用回溯算法解决：有很多路。这些路里，有死路，也有出路。通常需要递归来模拟所有的路。 例如：全排列问题：用递归模拟出所有情况。遇到包含重复元素的情况，就回溯（不要在遍历）。收集所有到达递归终点的情况，并返回。 举例算法题一：全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路： 前提要求：1、所有排列情况；2、没有重复元素 有出路，有死路 考虑使用回溯算法 解题步骤： 1、用递归模拟出所有情况。2、遇到包含重复元素的情况，就回溯（不在递归下去）。3、收集所有到达终点的情况，并返回。 解题答案： 12345678910111213141516171819var permute = function(nums)&#123; const res = []; //所有出路 const backrack = (path) =&gt;&#123; //递归 //收集满足要求的排列组合,递归的终点 if(path.length === nums.length)&#123; res.push(path); return; &#125; nums.forEach(n =&gt; &#123; if(path.includes(n))&#123; return;&#125; //一些路是死路,就回溯 backrack(path.concat(n)); //下一次递归加到数组里面 &#125;); &#125; backrack([]); //[1,2,3] return res;&#125;var arr = [1,2,3,4]console.log(permute(arr)) 算法分析： 时间复杂度最复杂的，嵌套的for循环，是 O(n!),n!= 123#…(n-1)*n;空间复杂度是，输出的数组用到递归（堆栈），递归的深度N：O(n)。 举例算法题二：子集给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 解题思路： 要求：1、所有的子集；2、没有重复元素和子集有出路，有死路考虑使用回溯算法 解题步骤： 1、用递归模拟出所有情况。写递归函数遍历每一个数。2、保证接的数字都是后面的数字。3、收集所有到达递归终点的情况，并返回。 解题答案： 12345678910111213141516171819var subsets = function(nums)&#123; const res = []; //用来最为最终输出的大数组 const backtrack = (path, l, start) =&gt;&#123; //backtrack回溯的意思,参数是路径、长度、下标 if(path.length === l)&#123; //收集到终点的情况 res.push(path); return; &#125; for(let i = start; i &lt;= nums.length; i += 1)&#123; backtrack(path.concat(nums[i]), l, i + 1); &#125; &#125; for(let i = 0; i &lt;= nums.length; i += 1)&#123; backtrack([],i,0) //参数是路径、长度、下标 &#125; return res;&#125;var arr = [1,2,3]console.log(subsets(arr)) 算法分析： 时间复杂度:O(2^N),因为每个元素都有可能有两种可能（存在或不存在）；空间复杂度是O(N) 递归堆栈放的临时变量。 其他回溯法最全排列组合问题 常见算法-分而治之算法分而治之是算法设计中的一种方法，算法的一种设计思想。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结果合并一解决原来的问题。 使用场景一： 归并排序 分：把数组从中间一分为二。解：递归地对两个子数组进行归并排序。合：合并有序子数组。 使用场景二： 快速排序 分：选基准，按基准把数组分成两个子数组。解：递归地对两个子数组进行快速排序。合：对两个子数组进行合并。 举例算法题一：猜数字大小猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num返回我选出的数字。 示例 1：输入：n = 10, pick = 6输出：6 示例 2：输入：n = 1, pick = 1输出：1 示例 3：输入：n = 2, pick = 1输出：1 示例 4：输入：n = 2, pick = 2输出：2 提示：1 &lt;= n &lt;= 2^31 – 11 &lt;= pick &lt;= n 解题思路 分：计算中间元素，分割数组。解:递归地在较大或者较小数组进行二分搜索。合：不需要此步，因为在子数组中搜到就返回了。 解题答案 123456789101112131415var guessNumber = function(n)&#123; const rec = (low,high) =&gt;&#123; if(low &gt; high)&#123; return &#125; const mid = Math.floor((low+high) / 2); const res = guess(mid); if(res === 0)&#123; return mid; &#125;else if(res === 1)&#123; return rec(mid + 1,high); &#125;else&#123; return rec(1, mid - 1); &#125; &#125; return rec(1,n);&#125; 解题分析 时间复杂度 O(logn)，空间复杂度 O(logn) 举例算法题二：翻转二叉树翻转一棵二叉树。示例：输入： 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 输出： 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 解题思路： 先反转左右子树，再将子树换个位置。 符合“分、解、和”特性。 考虑用分而治之来做。 解题步骤： 分：获取左右子树。解：递归地翻转左右子树。合：将翻转后的左右子树换个位置放到根节点上。 解题答案： 12345678var invertTree = function(root)&#123; if(!root)&#123; return null; &#125; return &#123; val: root.val, left: invertTree(root.right), right: invertTree(root.left) &#125;&#125; 解题分析： 时间复杂度O(n)，空间复杂度 O(n)。 举例算法题三：相同的树给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 12输入：p = [1,2,3], q = [1,2,3]输出：true 示例 2： 12输入：p = [1,2], q = [1,null,2]输出：false 示例 3： 12输入：p = [1,2,1], q = [1,1,2]输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 解题思路： 两棵树：根节点的值相同，左子树相同，右子树相同 符合“分、解、和”特性。 考虑用分而治之来做。 解题步骤： 分：获取两个树的左子树和右子树。解：递归地判断两个数的左子树是否相同，右子树是否相同。合：将上述结果合并，如果根节点的值也相同，树就相同。 解题答案： 12345678910var inSameTree = function(p,q)&#123; if(!p &amp;&amp; !q)&#123; return true&#125; //如果两个都为空 if( p &amp;&amp; q &amp;&amp; p.val === q.val &amp;&amp; inSameTree(p.left,q.left )&amp;&amp; inSameTree(p.right,q.right) )&#123; return true; &#125; return false;&#125; 举例算法题四：对称二叉树给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 解题思路： 转化为：左右子树是否镜像。 分解为：树1的左子树和树2的右子树是否镜像，树1的右子树和树2的左子树是否镜像。 符合“分、解、和”特性，考虑用分而治之来做。 解题步骤： 分：获取两个树的左子树和右子树。解：递归地判断树1的左子树和树2的右子树是否镜像，树1的右子树和树2的左子树是否镜像。合：如果上述都成立，且根节点值也相同，两个树就镜像。 解题答案： 1234567891011121314var isSymmetric = function(root)&#123; if(!root) return true; const isMirror = (l, r) =&gt; &#123; if(!l &amp;&amp; !r) return true; if(l &amp;&amp; r &amp;&amp; l.val === r.val &amp;&amp; isMirror(l.left, r.right)&amp;&amp; isMirror(l.right, r.left) )&#123; return true; &#125; return false; &#125; return isMirror(root.left, root.right);&#125; 解题分析： 时间复杂度O(n)，空间复杂度 O(LogN)和O(n)。 常见算法-贪心算法贪心算法是算法设计中的一种方法，算法的一种设计思想，期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果并不一定是最优。 举例算法题一：分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 解题思路： 局部最优：既能满足孩子，还消耗最少。 先将“较小的饼干”分给“胃口最小”的孩子。 解题步骤： 对饼干数组和胃口数组升序排序。 遍历饼干数组，找到能满足第一个孩子的饼干。 然后继续遍历饼干数组，找到满足第二、三、……、n个孩子的饼干。 解题答案： 123456789101112131415var findContentChildren = function(g,s)&#123; //升序排序 const sortFunc = function(a,b)&#123; return a - b; //实现降序 b - a &#125; g.sort(sortFunc); s.sort(sortFunc); let i = 0; s.forEach(n =&gt; &#123; if(n &gt;= g[i])&#123; i += 1; &#125; &#125;); return i;&#125; 举例算法题二：买卖股票的最佳时机 II给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 1234输入: prices = [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: prices = [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 解题思路： 前提：上帝视角，知道未来的价格。 局部最优：见好就收，见差就不动，不做任何长远打算。 解题步骤： 新建一个变量，用来统计总利润。 遍历价格数组，如果当前价格比昨天高，就在昨天买，今天卖，否组就不交易。 遍历结束后，返回所有利润之和。 解题答案： 123456789101112131415161718var maxProfit = function(prices)&#123; let profit = 0; //利润 for(let i = 1; i &lt; prices.length; i += 1)&#123; if(prices[i] &gt; prices[i - 1])&#123; //当前价格大于昨天价格 profit += prices[i] - prices[i - 1] &#125; &#125; return profit;&#125;var prices = [7,1,5,3,6,4]console.log(maxProfit(prices)) //7var prices = [1,2,3,4,5]console.log(maxProfit(prices)) //4var prices = [7,6,4,3,1]console.log(maxProfit(prices)) //0 解题分析： 时间复杂度 有一个for循环 O(n) ，空间复杂度 O(1)。 6.LRU算法LRU算法全称是最近最少使用算法（Least Recently Use），广泛的应用于缓存机制中。当缓存使用的空间达到上限后，就需要从已有的数据中淘汰一部分以维持缓存的可用性，而淘汰数据的选择就是通过LRU算法完成的。 LRU算法的基本思想是基于局部性原理的时间局部性： 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 所以顾名思义，LRU算法会选出最近最少使用的数据进行淘汰。 原理一般来讲，LRU将访问数据的顺序或时间和数据本身维护在一个容器当中。当访问一个数据时： 该数据不在容器当中，则设置该数据的优先级为最高并放入容器中。 该数据在容器当中，则更新该数据的优先级至最高。 当数据的总量达到上限后，则移除容器中优先级最低的数据。下图是一个简单的LRU原理示意图： 如果我们按照7 0 1 2 0 3 0 4的顺序来访问数据，且数据的总量上限为3，则如上图所示，LRU算法会依次淘汰7 1 2这三个数据。 朴素的LRU算法那么我们现在就按照上面的原理，实现一个朴素的LRU算法。下面有三种方案： 基于数组 方案：为每一个数据附加一个额外的属性——时间戳，当每一次访问数据时，更新该数据的时间戳至当前时间。当数据空间已满后，则扫描整个数组，淘汰时间戳最小的数据。 不足：维护时间戳需要耗费额外的空间，淘汰数据时需要扫描整个数组。 基于长度有限的双向链表 方案：访问一个数据时，当数据不在链表中，则将数据插入至链表头部，如果在链表中，则将该数据移至链表头部。当数据空间已满后，则淘汰链表最末尾的数据。 不足：插入数据或取数据时，需要扫描整个链表。 基于双向链表和哈希表 方案：为了改进上面需要扫描链表的缺陷，配合哈希表，将数据和链表中的节点形成映射，将插入操作和读取操作的时间复杂度从O(N)降至O(1) 基于双向链表 + 哈希表实现LRU下面我们就基于双向链表和哈希表实现一个LRU算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class LRUCache &#123; private int size; // 当前容量 private int capacity; // 限制大小 private Map&lt;Integer, DoubleQueueNode&gt; map; // 数据和链表中节点的映射 private DoubleQueueNode head; // 头结点 避免null检查 private DoubleQueueNode tail; // 尾结点 避免null检查 public LRUCache(int capacity) &#123; this.capacity = capacity; this.map = new HashMap&lt;&gt;(capacity); this.head = new DoubleQueueNode(0, 0); this.tail = new DoubleQueueNode(0, 0); this.head.next = tail; &#125; public Integer get(Integer key) &#123; DoubleQueueNode node = map.get(key); if (node == null) &#123; return null; &#125; // 数据在链表中，则移至链表头部 moveToHead(node); return node.val; &#125; public Integer put(Integer key, Integer value) &#123; Integer oldValue; DoubleQueueNode node = map.get(key); if (node == null) &#123; // 淘汰数据 eliminate(); // 数据不在链表中，插入数据至头部 DoubleQueueNode newNode = new DoubleQueueNode(key, value); DoubleQueueNode temp = head.next; head.next = newNode; newNode.next = temp; newNode.pre = head; temp.pre = newNode; map.put(key, newNode); size++; oldValue = null; &#125; else &#123; // 数据在链表中，则移至链表头部 moveToHead(node); oldValue = node.val; node.val = value; &#125; return oldValue; &#125; public Integer remove(Integer key) &#123; DoubleQueueNode deletedNode = map.get(key); if (deletedNode == null) &#123; return null; &#125; deletedNode.pre.next = deletedNode.next; deletedNode.next.pre = deletedNode.pre; map.remove(key); return deletedNode.val; &#125; // 将节点插入至头部节点 private void moveToHead(DoubleQueueNode node) &#123; node.pre.next = node.next; node.next.pre = node.pre; DoubleQueueNode temp = head.next; head.next = node; node.next = temp; node.pre = head; temp.pre = node; &#125; private void eliminate() &#123; if (size &lt; capacity) &#123; return; &#125; // 将链表中最后一个节点去除 DoubleQueueNode last = tail.pre; map.remove(last.key); last.pre.next = tail; tail.pre = last.pre; size--; last = null; &#125;&#125;// 双向链表节点class DoubleQueueNode &#123; int key; int val; DoubleQueueNode pre; DoubleQueueNode next; public DoubleQueueNode(int key, int val) &#123; this.key = key; this.val = val; &#125;&#125; 基本上就是把上述LRU算法思路用代码实现了一遍，比较简单，只需要注意一下pre和next两个指针的指向和同步更新哈希表，put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)。 基于LinkedHashMap实现的LRU其实我们可以直接根据JDK给我们提供的LinkedHashMap直接实现LRU。因为LinkedHashMap的底层即为双向链表和哈希表的组合，所以可以直接拿来使用。 1234567891011121314151617public class LRUCache extends LinkedHashMap &#123; private int capacity; public LRUCache(int capacity) &#123; // 注意这里将LinkedHashMap的accessOrder设为true super(16, 0.75f, true); this.capacity = capacity; &#125; @Override protected boolean removeEldestEntry(Map.Entry eldest) &#123; return super.size() &gt;= capacity; &#125;&#125;复制代码 默认LinkedHashMap并不会淘汰数据，所以我们重写了它的removeEldestEntry()方法，当数据数量达到预设上限后，淘汰数据，accessOrder设为true意为按照访问的顺序排序。整个实现的代码量并不大，主要都是应用LinkedHashMap的特性。 正因为LinkedHashMap这么好用，所以我们可以看到Dubbo的LRU缓存LRUCache也是基于它实现的。 LRU算法优化朴素的LRU算法已经能够满足缓存的要求了，但是还是有一些不足。当热点数据较多时，有较高的命中率，但是如果有偶发性的批量操作，会使得热点数据被非热点数据挤出容器，使得缓存受到了“污染”。所以为了消除这种影响，又衍生出了下面这些优化方法。 LRU-KLRU-K算法是对LRU算法的改进，将原先进入缓存队列的评判标准从访问一次改为访问K次，可以说朴素的LRU算法为LRU-1。 LRU-K算法有两个队列，一个是缓存队列，一个是数据访问历史队列。当访问一个数据时，首先先在访问历史队列中累加访问次数，当历史访问记录超过K次后，才将数据缓存至缓存队列，从而避免缓存队列被污染。同时访问历史队列中的数据可以按照LRU的规则进行淘汰。具体如下图所示： 下面我们来实现一个LRU-K缓存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 直接继承我们前面写好的LRUCachepublic class LRUKCache extends LRUCache &#123; private int k; // 进入缓存队列的评判标准 private LRUCache historyList; // 访问数据历史记录 public LRUKCache(int cacheSize, int historyCapacity, int k) &#123; super(cacheSize); this.k = k; this.historyList = new LRUCache(historyCapacity); &#125; @Override public Integer get(Integer key) &#123; // 记录数据访问次数 Integer historyCount = historyList.get(key); historyCount = historyCount == null ? 0 : historyCount; historyList.put(key, ++historyCount); return super.get(key); &#125; @Override public Integer put(Integer key, Integer value) &#123; if (value == null) &#123; return null; &#125; // 如果已经在缓存里则直接返回缓存中的数据 if (super.get(key) != null) &#123; return super.put(key, value);; &#125; // 如果数据历史访问次数达到上限，则加入缓存 Integer historyCount = historyList.get(key); historyCount = historyCount == null ? 0 : historyCount; if (historyCount &gt;= k) &#123; // 移除历史访问记录 historyList.remove(key); return super.put(key, value); &#125; &#125;&#125; 一般来讲，当K的值越大，则缓存的命中率越高，但是也会使得缓存难以被淘汰。综合来说，使用LRU-2的性能最优。 Two QueueTwo Queue可以说是LRU-2的一种变种，将数据访问历史改为FIFO队列。好处的明显的，FIFO更简易，耗用资源更少，但是相比LRU-2会降低缓存命中率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 直接继承LinkedHashMappublic class TwoQueueCache extends LinkedHashMap&lt;Integer, Integer&gt; &#123; private int k; // 进入缓存队列的评判标准 private int historyCapacity; // 访问数据历史记录最大大小 private LRUCache lruCache; // 我们前面写好的LRUCache public TwoQueueCache(int cacheSize, int historyCapacity, int k) &#123; // 注意这里设置LinkedHashMap的accessOrder为false super(); this.historyCapacity = historyCapacity; this.k = k; this.lruCache = new LRUCache(cacheSize); &#125; public Integer get(Integer key) &#123; // 记录数据访问记录 Integer historyCount = super.get(key); historyCount = historyCount == null ? 0 : historyCount; super.put(key, historyCount); return lruCache.get(key); &#125; public Integer put(Integer key, Integer value) &#123; if (value == null) &#123; return null; &#125; // 如果已经在缓存里则直接返回缓存中的数据 if (lruCache.get(key) != null) &#123; return lruCache.put(key, value); &#125; // 如果数据历史访问次数达到上限，则加入缓存 Integer historyCount = super.get(key); historyCount = historyCount == null ? 0 : historyCount; if (historyCount &gt;= k) &#123; // 移除历史访问记录 super.remove(key); return lruCache.put(key, value); &#125; return null; &#125; @Override protected boolean removeEldestEntry(Map.Entry eldest) &#123; return super.size() &gt;= historyCapacity; &#125;&#125; 这里直接继承LinkedHashMap，并且accessOrder默认为false，意为按照插入顺序进行排序，二者结合即为一个FIFO的队列。通过重写removeEldestEntry()方法来自动淘汰最早插入的数据。 Multi Queue相比于上面两种优化，Multi Queue的实现则复杂的多，顾名思义，Multi Queue是由多个LRU队列组成的。每一个LRU队列都有一个相应的优先级，数据会根据访问次数计算出相应的优先级，并放在该队列中。 数据插入和访问：当数据首次插入时，会放入到优先级最低的Q0队列。当再次访问时，根据LRU的规则，会移至队列头部。当根据访问次数计算的优先级提升后，会将该数据移至更高优先级的队列的头部，并删除原队列的该数据。同样的，当该数据的优先级降低时，会移至低优先级的队列中。 数据淘汰：数据淘汰总是从最低优先级的队列的末尾数据进行，并将它加入到Q-history队列的头部。如果数据在Q-history数据中被访问，则重新计算该数据的优先级，并将它加入到相应优先级的队列中。否则就是按照LRU算法完全淘汰。 Multi Queue也可以看做是LRU-K的变种，将原来两个队列扩展为多个队列，好处就是无论是加入缓存还是淘汰缓存数据都变得更加细腻，但是会带来额外开销。 数据结构-1亿数据中访问某数据先来看一下都有哪些题目： 如何从大量的 URL 中找出相同的 URL？（百度） 如何从大量数据中找出高频词？（百度） 如何找出某一天访问百度网站最多的 IP？（百度） 如何在大量的数据中找出不重复的整数？（百度） 如何在大量的数据中判断一个数是否存在？（腾讯） 如何查询最热门的查询串？（腾讯） 如何统计不同电话号码的个数？（百度） 如何从 5 亿个数中找出中位数？（百度） 如何按照 query 的频度排序？（百度） 如何找出排名前 500 的数？（腾讯） 答案呢？往下看~ 如何从大量的 URL 中找出相同的 URL？题目描述 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。 解答思路 每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。 5,000,000,000 * 64B ≈ 5GB * 64 = 320GB 由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。 思路如下： 首先遍历文件 a，对遍历到的 URL 求 hash(URL) % 1000，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。 接着遍历 ai( i∈[0,999])，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。 方法总结 分而治之，进行哈希取余； 对每个子文件进行 HashSet 统计。 如何从大量数据中找出高频词？题目描述 有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。 解答思路 由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。 思路如下： 首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。 接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。 上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。 方法总结 分而治之，进行哈希取余； 使用 HashMap 统计频数； 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。 如何找出某一天访问百度网站最多的 IP？题目描述 现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。 解答思路 这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。 方法总结 分而治之，进行哈希取余； 使用 HashMap 统计频数； 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。 如何在大量的数据中找出不重复的整数？题目描述 在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。 解答思路 方法一：分治法 与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。 方法二：位图法 位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。 位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。 假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0： 120 0 0 0 0 0 0 0复制代码 然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1： 120 0 0 0 1 0 1 0复制代码 依次遍历，结束后，位数组是这样的： 120 1 1 0 1 1 1 0复制代码 每个为 1 的位，它的下标都表示了一个数： 1234for i in range(8): if bits[i] == 1: print(i)复制代码 这样我们其实就已经实现了排序。 对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。 那么对于这道题，我们用 2 个 bit 来表示各个数字的状态： 00 表示这个数字没出现过； 01 表示这个数字出现过一次（即为题目所找的不重复整数）； 10 表示这个数字出现了多次。 那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作： 遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。 方法总结 判断数字是否重复的问题，位图法是一种非常高效的方法。 如何在大量的数据中判断一个数是否存在？题目描述 给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？ 解答思路 方法一：分治法 依然可以用分治法解决，方法与前面类似，就不再次赘述了。 方法二：位图法 40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。 我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。 方法总结 判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。 如何查询最热门的查询串？题目描述 搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。 假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。） 解答思路 每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。 方法一：分治法 分治法依然是一个非常实用的方法。 划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。 方法可行，但不是最好，下面介绍其他方法。 方法二：HashMap 法 虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。 思路如下： 首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。 接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。 遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。 方法三：前缀树法 方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。 思路如下： 在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。 最后依然使用小顶堆来对字符串的出现次数进行排序。 方法总结 前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。 如何统计不同电话号码的个数？题目描述 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。 解答思路 这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。 对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。 思路如下： 申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。 方法总结 求解数据重复问题，记得考虑位图法。 如何从 5 亿个数中找出中位数？题目描述 从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。 解答思路 如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。 方法一：双堆法 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。 若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder &#123; private PriorityQueue&lt;Integer&gt; maxHeap; private PriorityQueue&lt;Integer&gt; minHeap; /** initialize your data structure here. */ public MedianFinder() &#123; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); minHeap = new PriorityQueue&lt;&gt;(Integer::compareTo); &#125; public void addNum(int num) &#123; if (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123; maxHeap.offer(num); &#125; else &#123; minHeap.offer(num); &#125; int size1 = maxHeap.size(); int size2 = minHeap.size(); if (size1 - size2 &gt; 1) &#123; minHeap.offer(maxHeap.poll()); &#125; else if (size2 - size1 &gt; 1) &#123; maxHeap.offer(minHeap.poll()); &#125; &#125; public double findMedian() &#123; int size1 = maxHeap.size(); int size2 = minHeap.size(); return size1 == size2 ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2 : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek()); &#125;&#125;复制代码 见 LeetCode No.295：leetcode.com/problems/fi… 以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。 方法二：分治法 分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。 对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。 划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。 提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。 对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。 注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。 方法总结 分治法，真香！ 如何按照 query 的频度排序？题目描述 有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。 解答思路 如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。 方法一：HashMap 法 如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。 方法二：分治法 分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。 接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。 方法总结 内存若够，直接读入进行排序； 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。 如何找出排名前 500 的数？题目描述 有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？ 解答思路 对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法： 首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。 接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。 重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import lombok.Data;import java.util.Arrays;import java.util.PriorityQueue;/** * @author https://github.com/yanglbme */@Datapublic class DataWithSource implements Comparable&lt;DataWithSource&gt; &#123; /** * 数值 */ private int value; /** * 记录数值来源的数组 */ private int source; /** * 记录数值在数组中的索引 */ private int index; public DataWithSource(int value, int source, int index) &#123; this.value = value; this.source = source; this.index = index; &#125; /** * * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改 * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆 */ @Override public int compareTo(DataWithSource o) &#123; return Integer.compare(o.getValue(), this.value); &#125;&#125;class Test &#123; public static int[] getTop(int[][] data) &#123; int rowSize = data.length; int columnSize = data[0].length; // 创建一个columnSize大小的数组，存放结果 int[] result = new int[columnSize]; PriorityQueue&lt;DataWithSource&gt; maxHeap = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; rowSize; ++i) &#123; // 将每个数组的最大一个元素放入堆中 DataWithSource d = new DataWithSource(data[i][0], i, 0); maxHeap.add(d); &#125; int num = 0; while (num &lt; columnSize) &#123; // 删除堆顶元素 DataWithSource d = maxHeap.poll(); result[num++] = d.getValue(); if (num &gt;= columnSize) &#123; break; &#125; d.setValue(data[d.getSource()][d.getIndex() + 1]); d.setIndex(d.getIndex() + 1); maxHeap.add(d); &#125; return result; &#125; public static void main(String[] args) &#123; int[][] data = &#123; &#123;29, 17, 14, 2, 1&#125;, &#123;19, 17, 16, 15, 6&#125;, &#123;30, 25, 20, 14, 5&#125;, &#125;; int[] top = getTop(data); System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19] &#125;&#125;复制代码 方法总结 求 TopK，不妨考虑一下堆排序？","categories":[{"name":"E_数据结构","slug":"E-数据结构","permalink":"https://fuyunjinglong.github.io/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"0基础_设计模式","slug":"J_设计模式_基础","date":"2099-10-31T22:33:16.000Z","updated":"2023-03-25T03:24:21.876Z","comments":true,"path":"2099/11/01/J_设计模式_基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/11/01/J_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"概述“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》，在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、分类编目、代码设计经验的总结。其目的是为了提高代码的可复用性、可读性和可靠性。 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 优点： 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可复用性高、可读性强、可靠性高、灵活性好、可维护性强。 基本要素 模式名称 每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。 问题 问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。 解决方案 模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。 效果 描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。 MV模式MVC模式 Model（模型）表示应用程序核心（如数据库）。 View（视图）显示效果（HTML页面）。 Controller（控制器）处理输入（业务逻辑）。 流程： View传送指令到Controller Controller完成业务逻辑后，要求Model改变状态 Model将新的数据发送到View，用户得到反馈 MVP模式 模型(Model)：提供数据 视图(View)：用户界面 表示器(Presenter)：逻辑的处理 流程： View与Model无联系，都通过Presenter传递 View中不部署任何业务逻辑 - 被动视图 所有逻辑都部署在Presenter 与MVC的区别，View不能直接从Model中读取数据 MVVM模式-vue使用模式 模型(Model)：保存数据 视图(View)：用户界面 数据驱动(View-Model)：业务逻辑 流程： 操作View时，ViewModel感知变化，通知Model发生相应的变化，若Model改变时，ViewModel感知变化，通知View进行更新 ViewModel与View双向数据绑定，Model通过接口请求数据交互，承上启下。 GoF 的 23 种设计模式根据目的来分 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 根据作用范围来分 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 各个模式的功能 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 五大设计原则原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。 核心五大原则：SOLID、DRY、KISS、YAGNI、LOD SOLID原则 SRP(Single Responsibility Principle) 单一职责 OCP(Open Closed Principle) 开闭原则 LSP(Liskov Substitution Principle) 里氏替换 ISO(Interface Segregation Principle) 接口隔离 DIP(Dependency Inversion Principle) 依赖倒置/依赖反转 设计原则 一句话归纳 目的 开闭原则 对扩展开放，对修改关闭 降低维护带来的新风险 依赖倒置原则 高层不应该依赖低层，要面向接口编程 更利于代码结构的升级扩展 单一职责原则 一个类只干一件事，实现类要单一 便于理解，提高代码的可读性 接口隔离原则 一个接口只干一件事，接口要精简单一 功能解耦，高聚合、低耦合 迪米特法则 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 只和朋友交流，不和陌生人说话，减少代码臃肿 里氏替换原则 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 防止继承泛滥 合成复用原则 尽量使用组合或者聚合关系实现代码复用，少使用继承 降低代码耦合 一、SRP(Single Responsibility Principle) 单一职责 定义：一个类或模块只负责完成一个功能 理解：不要设计大而全的类，要设计粒度小、高性能单一的类。该原则的目的是为了实现代码高内聚、低耦合、提高代码复用性、可读性以及可维护性。 补充：在保证单一职责时，要避免过分拆分，否则会降低内聚性，影响代码可维护性。 以下场景可能会出现类没有指责单一： 类中的代码行数、函数、属性是否过多。可以考虑对该类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想； 私有方法过多，可以考虑将私有方法独立到新类中，设置为 public 方法，提高代码复用性； 当发现类名比较难命名或类名笼统、冗长时，说明该类职责定义不够清晰； 类中大量方法集中操作某几个属性时，可以考虑将这几个属性和方法拆分出去； 举例： 1234567891011121314/*** 如果下面的用户信息类仅在一个场景中使用，则没有什么问题；* 如果后面用户的地址信息在其他模块中使用时，就可以将地址信息进行拆分。* 以及各个属性的操作方法都要进行聚合到一个类中，提高代码的维护性。*/data class UserData(val userId:Long, val userName:String, val email:String, val telephone:String, val provinceOfAddress:String, val cityOfAddress:String, val regionOfAddress:String, //.....其他属性 ) 二、OCP(Open Closed Principle) 开闭原则 定义：(模块、类、方法)对拓展开放，对修改关闭。 理解：对于新功能尽量通过拓展已有代码而非修改的方式完成。 补充：在开发中不需要识别、预留所有拓展点，切勿过度设计。最合理的做法是，保证短期内、可确定的部分进行拓展设计。做常用的代码扩展性的方法：多态、依赖注入、基于接口开发，以及部分设计模式(装饰、策略、模板、责任链、状态等) 举例： 123456789101112131415161718192021222324252627282930313233343536373839/*** 基于接口开发。对于外部调用者，内部逻辑是无感知的，方便后面进行逻辑拓展，例如国内更新逻辑后面可能会支持跳转指定应用商店、H5链接等。*/interface IUpgradeService&#123; fun checkUpgrade(ctx:Activity)&#125;abstract class BaseUpgradeService : IUpgradeService&#123; override fun checkUpgrade(ctx:Activity)&#123; //网络请求 //.... //执行需要更新 startUpgrade() &#125; fun startUpgrade()&#125;class CnUpgradeService : BaseUpgradeService&#123; override fun startUpgrade()&#123; //国内执行更新逻辑。例如应用内下载安装等 &#125;&#125;class I18nUpgradeService : BaseUpgradeService&#123; override fun startUpgrade()&#123; //海外执行更新逻辑。例如跳转google play &#125;&#125;//实际执行Activityclass MainActivity : AppCompactActivity&#123; override fun onCreate(savedInstanceState : Bundle)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //执行更新逻辑 ServiceLoader.instance.load(IUpgradeService::class.java).checkUpgrade(this) &#125;&#125; 三、LSP(Liskov Substitution Principle) 里氏替换 定义：子类对象能够替换程序中父类对象出现的任何地方，并保证原来程序的逻辑行为不变及正确性不被破坏。 理解：在代码中可以用子类来替换父类，和多态类似，区别在于“里氏替换原则”是子类不能违背父类的协议，如父类要实现的功能、入参、出参、异常情况等。 举例： 1234567891011121314151617/*** 下面代码违反里氏替换原则。因为父类并没有对参数进行校验和抛异常，子类违背了父类的协议(入参判断、异常情况)。*/class UpgradeService&#123; fun checkUpgrade(ctx: Activity, appId:Int, channelId:Int)&#123; //... 检查逻辑 &#125;&#125;class CnUpgradeService : UpgradeService&#123; override fun checkUpgrade(ctx: Activity, appId:Int, channelId:Int)&#123; if(appId == 0 || channelId == 0)&#123; throw Exception(...); &#125; //...国内检测逻辑 &#125;&#125; 四、ISO(Interface Segregation Principle) 接口隔离 定义：客户端(接口调用者)不应该被强迫依赖它不需要的接口。 理解：与“单一职责”类似，区别在于“单一职责”针对的是模块、类、接口的设计，“接口隔离”一方面更侧重于接口的设计，另一方面思考的角度不同。 补充：这里的“接口”可以理解为：①一组API接口集合；②单个API接口或函数；③OOP中的接口概念 举例: 一组API接口集合 123456789101112/*** 下面代码违背了接口隔离原则。* 因为后期新增的删除接口，对外所有服务都可以调用，非常容易导致误操作场景。* 在没有做鉴权时，建议将删除接口单独做一个接口服务，供特殊场景使用。*/interface UserService&#123; fun register(userName:String, password:String):Boolean fun login(userName:String, password:String):Boolean //后期新增了删除用户信息的接口 fun deleteUserById(userId:Long):Boolean&#125; 单个API接口或函数 1234567891011121314151617181920enum class ComputeType&#123; ADD, SUBTRACT, MULTIPLY , DIVIDE&#125;/*** 假设下面代码每一种计算方式都比较复杂，则违背了接口隔离原则。* 如果逻辑复杂的情况下，建议将每种情况作为一个单独的接口或函数进行处理。* 例如:* fun dataAdd()&#123;&#125;* fun dataSubtract()&#123;&#125;*/fun dataCompute(firstNum:Int, secondNum:Int, computeType:ComputeType): Int&#123; retrun when(computeType)&#123; ComputeType.ADD -&gt; //.... //.... &#125;&#125; OOP中的接口概念 123456789101112/*** 尽量避免设计大而全的接口，大而全会导致强迫调用者依赖不必要的接口* 例如下面接口，如果调用者只是想配置监控和更新，还必须空实现配置日志数据。推荐根据功能进行拆分。*/interface IConfig&#123; //更新配置信息 fun update() //配置日志输出 fun outputLog():String //配置监控 fun monitorConfig()&#125; 五、DIP(Dependency Inversion Principle) 依赖倒置/依赖反转 定义：高层模块不依赖低层模块，它们共同依赖同一个抽象，抽象不要依赖具体实现细节，具体实现细节依赖抽象。 理解：该原则用于指导框架层面的设计，调用者与被调用者没有直接依赖关系，而是通过一个抽象(规范)来建立关系，同时抽象(规范)不依赖具体的调用者和被调用者的实现细节，而调用者和被调用者需要依赖抽象(规范)。例如，暴露请求参数，由调用者来实现具体的请求，并将结果再返回。 控制反转(IOC)、依赖反转(DIP)、依赖注入(DI)的区别与联系 控制反转：提供一个可拓展的代码骨架，用来组装对象、管理整个执行流程。不是一种具体的实现技巧，而是一种设计思想，一般用于指导框架层面的设计，具体的方式有很多，例如依赖注入、模板模式等。 123456789101112131415161718192021abstract class TestCase&#123; fun run()&#123; if(doTest())&#123; println(&quot;Test success&quot;) &#125;else&#123; println(&quot;Test failed&quot;) &#125; &#125; abstract fun doTest():Boolean&#125;class UserServiceTest: TestCase&#123; override doTest():Boolean&#123; //....控制逻辑 &#125;&#125;fun main()&#123; UserServiceTest().run()&#125; 依赖注入：不通过 new()方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好后，通过构造函数、函数参数等方式传递(或注入)给类使用。 12345678910111213141516171819202122232425262728//Notification类使用通过构造函数传入的类对象messageSender调用发送逻辑class Notification(val messageSender: MessageSender)&#123; fun sendMessage(cellphone: String, message: String)&#123; messageSender.send(cellphone, message) &#125;&#125;interface MessageSender&#123; fun send(cellphone: String, message: String)&#125;class SmsSender: MessgeSender&#123; override fun send(cellphone: String, message: String)&#123; //...短信通知逻辑 &#125;&#125;class EmailSender: MessageSender&#123; override fun send(cellphone: String, message: String)&#123; //...邮件通知逻辑 &#125;&#125;fun main()&#123; val messageSender = SmsSender() val notification = Notification(messageSender) notification.sendMessage(&quot;xxxxx&quot;,&quot;xxxxx&quot;)&#125; 依赖反转：高层模块(调用者)不要依赖底层模块(被调用者代码)。高层模块和底层模块赢通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。 1234567891011121314151617181920212223242526272829303132//抽象层interface ISendTypeConfig&#123; fun httpRequest(params: String) fun socketRequest(params: String)&#125;//底层模块逻辑class SendTypeManager(private val config: ISendTypeConfig)&#123; fun sendMessage(sendByHttp:Boolean, params: String)&#123; if (sendByHttp)&#123; config.httpRequest(params) return &#125; //使用socket进行消息发送 &#125;&#125;//高层模块逻辑class SendTypeConfig: ISendTypeConfig&#123; override fun httpRequest(params: String) &#123; //使用http请求 &#125; override fun socketRequest(params: String) &#123; //使用socket请求 &#125;&#125;fun main()&#123; //这段代码属于[底层模块]逻辑。高层模块只需关注消息发送方式的具体实现，然后调用底层模块的发送消息即可，不会关注底层模块的具体实现。 SendTypeManager(SendTypeConfig()).sendMessage(true, &quot;这是一条http发送的消息&quot;)&#125; DRY原则(Don’t Repeat Yourself)原则，不要重复自己 理解：不要开发重复代码，可以复用或提取公共代码，同时也要注意遵守“单一职责”和“接口隔离”原则。 提升代码复用性的方法： 减少代码耦合 满足单一职责原则 模块化 业务与非业务逻辑分离 通用代码下沉 继承、抽象、多态、封装 应用模板等设计模式 KISS原则(Keep It Simple And Stupid)原则 理解：尽量保证代码简洁，使用通用技术(同事都懂的技术)、不重复造轮子、不过度优化。 举例：对于某个数值的提取或者匹配判断，使用正则表达式可以使代码行数更少，看似更简单，但其实并不是所有同事都熟悉正则表达式，而且在编写正则规则时易出现bug，所以可以采用通用技术来实现。 YAGNI原则(You Aint’t Gonna Need It)原则，你不会用到它的 理解：不去设计与开发当前功能用不到的代码，但并不意味着不考虑拓展性，可以预留好拓展点，后面需要时再开发。 举例：目前项目只对国内市场，未来将会面向国内海外同时使用。所以在开发中不需要提前编写海外部分代码，但是在国内海外有差异的逻辑上要预留好拓展点，方便后面对海外逻辑进行补充。 LOD原则/迪米特法则(Law of Demeter)原则/迪米特法则 理解：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940/*** NetworkTransporter 类负责底层网络通信，根据请求获取数据。** 该类的入参类型为 HtmlRequest 对象，作为底层类，应保证通用性，而不是仅服务于下载HTML。所以违反了迪米特法则，依赖了不该有直接依赖的 HtmlRequest 类。*/public class NetworkTransporter &#123; // 省略属性和其他方法... public Byte[] send(HtmlRequest htmlRequest) &#123; //... &#125;&#125;public class HtmlDownloader &#123; private NetworkTransporter transporter;//通过构造函数或IOC注入 public Html downloadHtml(String url) &#123; Byte[] rawHtml = transporter.send(new HtmlRequest(url)); return new Html(rawHtml); &#125;&#125;/*** Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。** 该类总有如下3个问题:* 1. 构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。* 2. HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。* 3. 从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。*/public class Document &#123; private Html html; private String url; public Document(String url) &#123; this.url = url; HtmlDownloader downloader = new HtmlDownloader(); this.html = downloader.downloadHtml(url); &#125; //...&#125;","categories":[{"name":"J_设计模式","slug":"J-设计模式","permalink":"https://fuyunjinglong.github.io/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"H5_0基础","slug":"C_H5_0基础","date":"2099-09-11T23:33:16.000Z","updated":"2023-06-11T12:52:24.119Z","comments":true,"path":"2099/09/12/C_H5_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/09/12/C_H5_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"浏览器内核的理解内核分为2部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS 引擎 渲染引擎 负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎 解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 web基础及演进史(1)js组成 ECMAScript(js核心)，DOM(文档对象模型),BOM(浏览器对象模型)。 ECMAScript：主要定义JS的语法和数据类型。 DOM：一套操作页面的API. BOM:一套操作浏览器功能的API. (2)web技术演进史 (1.1)历史进程 2005年以前：前后端耦合； 2005年Ajax时代：前后端分离； 2006-2012Jquery时代； 2009年nodejs服务端能力发布； 2012-2016后jquery时代：模块化，MV架构； 2016至今三大框架； 1)前端耦合 前端代码只是View视图层。 2)Ajax时代，允许客户端向服务器异步发送请求，处理后，异步局部刷新页面。划时代意义：前后端分离，服务端更专注于数据处理，前端更专注于数据展示。 3)Jquery时代，精简dom操作和浏览器兼容性 4)NodeJs时代 开始用js开发服务端程序，同时构建了用NPM包管理工具的NodeJs生态系统。 5)后Jquery时代 前端引入模块化。具体有CMD/AMD/commonJS，后面ES6 Module。 AMD/CMD：异步的，主要用于浏览器。模块定义和加载机制稍有不同。AMD推崇前置依赖，CMD推崇就近依赖。AMD是定义时声明依赖，CMD是懒加载，仅在require时才会加载。 CommonJS:是同步的，主要服务端。 ES6 Module:满足ES6标准的模块化输出，设计思想静态化。编译时就确定了依赖关系，是浏览器和服务端的通用模块解决方案。 MV框架 前端的复杂功能驱动MV*框架引入。 MVC框架 View指令传送到Controller; Controller完成业务逻辑后，要求Model改变; Model将新的数据发送到View，用户得到反馈 MVVM框架 双向绑定，view改变自动反馈到viewmodel。view与model不发生联系。 (1.2)三大框架介绍 1)angular 历史:2012开始1.0版本，16年升级2.0版本。新版本支持es6和ts。 基本特点： 双向绑定； 依赖注入； 基于ts的组件； 良好的应用架构； 工具生态完整，angular-cli用于创建、开发、测试等。有整套的解决方案，适合大型项目。 缺点：中文文档较少，框架较重，学习成本高。 2)react 历史：2013年facebook发布版本。2015年版本稳定，同年发布reacr-native。 基本特点： 虚拟dom，跨浏览器兼容，性能较好； 组件化，代码复用; JSX,js语法的扩展，模板简单、直接、语义化。 单项数据流：数据流清晰，组件状态更可控。 缺点： 本身只是view，大型项目需要加上React Router和Redux。 3)VUE 历史： 2015年1.0版本发布，同年vue-router、vuex、vue-cli出现，标志从一个视图层发展成一个渐进式框架。 2016年vue2.0发布，引入虚拟dom，性能大幅提升。 2019年vue2.0公布源码。 基本特点： 渐进式、轻量级框架; 简单易用; 双向数据绑定; 组件化; 轻量高效(使用虚拟dom，压缩后只有20kb) 缺点： vue不支持IE8，生态比较差(语法提示不友好，插件数量比较少) Html语义化参考 开启前端之路——HTML 标签 什么是语义化语义化是指根据内容的结构化(内容语义化),选择合适的标签(代码语义化),便于开发者阅读和写出更优雅的代码的同时,让浏览器的爬虫和机器很好地解析。 为什么要语义化? 让人更容易读懂（增加代码可读性）。 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。 易混淆的HTML标签 i 标签 i 标签效果,i 标签通常表示因为某种原因和正常文本不同的文本,例如专业术语,外语短语或排版用的文字。通常表现为斜体。 em 标签 em 标签效果,em 表示强调的文本,视觉上也是斜体效果。 strong 标签 strong 效果,以加粗的形式展现。表示这个文本的重要性,在 HTMl4 中表示特别强调,HTML5 中描述为“strong importance for its contents”。 b 标签 b 标签效果,表示的风格不同于正常的文本,没有表达任何特殊的重要性和相关性。通常用于关键回顾,回顾中的产品名称,或者是其他需要表现为粗体的文本。另一个例子就是标志每个段落的 lead sentence。 mark 标签 mark 标签效果,表现为高亮文本。例如我们在网页查找关键字时,找到的结果就会以高亮的形式展现。mark 元素通常是表现跨越不同的上下文种的相关文本。 常见的行/块级元素 inline 行级元素 内容决定元素所占位置 不可以通过 Css 改变宽高 都有文字特性 &lt;span&gt;、&lt;strong&gt;、&lt;em&gt;、&lt;a&gt;、&lt;del&gt;、&lt;i&gt; block 块级元素 独占一行 可以通过 Css 改变宽高 &lt;div&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;ol&gt;、&lt;form&gt; inline-block 行块级元素 内容决定大小 可以改变宽高 &lt;img&gt; 写 HTML 代码注意什么 尽可能少的使用无语义的标签 &lt;div&gt; 和 &lt;span&gt; 在语义不明显时既可以使用 &lt;div&gt; 或者 &lt;p&gt; 时,尽量使用 &lt;p&gt;,因为 &lt;p&gt; 在默认情况下有上下间距,对兼容特殊终端有利 不要使用纯样式标签,改用 css 设置 需要强调的文本,可以包含在 &lt;strong&gt; 或者 &lt;em&gt; 标签中(浏览器预设样式,能用 css 指定就不用他们),&lt;strong&gt; 默认样式是加粗(不要用 &lt;b&gt;),&lt;em&gt; 是斜体(不用 &lt;i&gt;) 使用表格时,标题要用 caption,表头用 &lt;thead&gt;,主体部分用 &lt;tbody&gt; 包围,尾部用 &lt;tfoot&gt; 包围。表头和一般单元格要区分开,表头用 &lt;th&gt;,单元格用 &lt;td&gt; 表单域要用 &lt;fieldset&gt; 标签包起来,并用 &lt;legend&gt; 标签说明表单的用途 每个 &lt;input&gt; 标签对应的说明文本都需要使用 label 标签,并且通过 &lt;input&gt; 标签设置 id 属性,在 label 标签中设置 for 来让说明文本和相对应的 &lt;input&gt; 关联起来。 H5新特性 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件：calendar、date、time、email、url、search; 新的技术：webworker, websocket, Geolocation; XML与JSON最根本上来说，XML是一个markup language（标记语言），而JSON是一种用于数据交换（data-interchange）的序列化对象的语言。 标记语言除了文本信息，还包括了一些元信息，这些元信息用来标注如何处理文本信息，比如： 12345&lt;Document&gt; &lt;Paragraph Align=&quot;Center&quot;&gt; Align是元信息 Here &lt;Bold&gt;is&lt;/Bold&gt; some text. &lt;/Paragraph&gt;&lt;/Document&gt; 假如试图用JSON完完整整的表述上述的信息： 1234567891011121314&#123; &quot;Paragraphs&quot;: [ &#123; &quot;align&quot;: &quot;center&quot;, &quot;content&quot;: [ &quot;Here &quot;, &#123; &quot;style&quot; : &quot;bold&quot;, &quot;content&quot;: [ &quot;is&quot; ] &#125;, &quot; some text.&quot; ] &#125; ]&#125; 原因在于，JSON里面没有元数据和数据的区别，所有的东西都是数据。同样的，XML也不擅长做JSON所擅长做的事，那就是序列化对象。 JSON有2点优于XML： 对象的内部结构一目了然，简洁明了。 JSON语法规定[]是数组，{}是对象，而XML没有如此的语法规定，我们只能临时发明一种方式来表示数组，然后自己添加代码来识别这个数组。 作用为： 两者比较：JSON比XML*更小，更快，更易解析 两者作用范围：JSON适用于简单的传值，XML**适用于元数据的标识。 BOM和DOM对象1.BOM BOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。 window对象核心 Location对象 History对象 document navigation screen (1)window对象 12345678910alert() 显示带有一段消息和一个确认按钮的警告框。confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。prompt() 显示可提示用户输入的对话框。open() 打开一个新的浏览器窗口或查找一个已命名的窗口。close() 关闭浏览器窗口。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval() 取消由 setInterval() 设置的 timeout。setTimeout() 在指定的毫秒数后调用函数或计算表达式。clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 (2)Location对象 Location 对象包含有关当前 URL 的信息。 123456location.reload() //重新加载页面，即刷新// 跳转到指定页面（可以返回上一个页面）location.assign(&quot;URL&quot;)location.href=&quot;URL&quot;// 跳转到指定页面（不可以返回上一个页面）location.replace(&quot;URL&quot;) (3)History对象 History 对象包含用户（在浏览器窗口中）访问过的 URL。 12history.forward() // 前进一页history.back() // 后退一页 2.DOM 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点(NODE)： 导航属性： parentNode - 节点（元素）的父节点 （一般用这个） firstChild – 节点下第一个子元素 lastChild – 节点下最后一个子元素 childNodes - 节点（元素）的子节点 (1)查找标签 1234document.getElementsByClassName 根据class属性获取document.getElementsByTagName 根据标签名获取标签合集document.getElementById 根据id属性值获取一个标签document.getElementsByName() 根据name属性值获取一个标签 间接查找 1234567891011parentElement //父节点标签元素children //所有子标签firstElementChild //第一个子标签元素lastElementChild //最后一个子标签元素nextElementtSibling //下一个兄弟标签元素previousElementSibling //上一个兄弟标签元素示例:var ele1=document.getElementsByTagName(&quot;a&quot;)[0];var ele2=ele1.parentElement;console.log(ele2); (2)节点操作 创建节点 1var divEle = document.createElement(&quot;div&quot;); 添加节点 123456789// 追加一个子节点（作为最后的子节点）Anode.appendChild(Bnode)；// 把增加的节点放到某个节点的前边。Anode.insertBefore(Bnode,Cnode); // 在Anode节点下，将Cnode节点插入Bnode节点前面// 示例var imgEle = document.createElement(&quot;img&quot;);imgEle.src = &quot;#&quot;; var d1Ele = document.getElementById(&quot;d1&quot;);d1Ele.appendChild(imgEle); 替换节点 1Anode.replaceChild(Bnode,Cnode); 属性节点 12345// 获取文本节点的值var ele = document.getElementById(&quot;d1&quot;)// 1.如果id为d1的标签内嵌套其他标签ele.innerText // 只取d1标签内的所有文本内容ele.innerHTML // d1标签内嵌套的标签和所有文本内容都取 设置文本节点的值 123var ele = document.getElementById(&quot;d1&quot;)ele.innerText = &quot;在干嘛&quot;ele.innerHTML = &quot;&lt;p&gt;在干嘛&lt;p/&gt;&quot; attribute操作 1234567var ele = document.getElementsByClassName(&quot;c1&quot;)[0];ele.setAttribute(&quot;hobby&quot;,&quot;swimming&quot;);console.log(ele.getAttribute(&quot;hobby&quot;));ele.removeAttribute(&quot;hobby&quot;);// 自带的属性可以直接.属性名来获取和设置ele.id;ele.id = &quot;xxx&quot;; 获取值操作 12var ele = document.getElementById(&quot;i1&quot;);console.log(ele.value); class的操作 123456// elementNode（节点名，简化用ele，像上面那样）ele.className 获取所有样式类名(字符串)ele.classList.remove(cls) 删除指定类ele.classList.add(cls) 添加类ele.classList.contains(cls) 存在返回true，否则返回falseele.classList.toggle(cls) 存在就删除，否则添加 指定CSS操作 12var ele = document.getElementById(&quot;d1&quot;);ele.style.color = &quot;red&quot;; JS操作CSS属性的规律 ①对于没有中横线的CSS属性一般直接使用style.属性名即可。如： 1234ele.style.marginele.style.widthele.style.leftele.style.position ②对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如： 1234ele.style.marginTopele.style.borderLeftWidthele.style.zIndexele.style.fontFamily 事件 12345678910111213141516171819onclick 当用户点击某个对象时调用的事件句柄。ondblclick 当用户双击某个对象时调用的事件句柄。onfocus 元素获得焦点。 //练习：输入框onblur 元素失去焦点。 //应用场景：用于表单验证，用户离开某个输入框时，代表已经输入完了，我们可以对它进行验证。onchange 域的内容被改变。//应用场景：通常用于表单元素,当元素内容被改变时触发，（三级联动）onkeydown 某个键盘按键被按下。//应用场景: 当用户在最后一个输入框按下回车按键时，表单提交。onkeypress 某个键盘按键被按下并松开。onkeyup 某个键盘按键被松开。onload 一张页面或一幅图像完成加载。onmousedown 鼠标按钮被按下。onmousemove 鼠标被移动。onmouseout 鼠标从某元素移开。onmouseover 鼠标移到某元素之上。onmouseleave 鼠标从元素离开onselect 文本被选中。onsubmit 确认按钮被点击。 绑定方式 123456&lt;div id=&quot;d1&quot; onclick=&quot;changeColor(this);&quot;&gt;点我字体变颜色&lt;/div&gt;var ele= document.getElementById(&quot;d1&quot;); ele.onclick = function () &#123; this.innerText=&quot;想干嘛呢？&quot;; &#125; Event对象 123456789var ele1 = document.getElementsByClassName(&quot;inner&quot;)[0]; ele1.onclick = function (e) &#123; alert(&quot;I am inner!&quot;); e.stopPropagation(); &#125;; var ele2 = document.getElementsByClassName(&quot;outer&quot;)[0]; ele2.onclick = function () &#123; alert(&quot;I am outer!&quot;) &#125;; 为什么多个域名来存储网站资源会更有效 确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他域名访问网站。 CDN 缓存更方便。简单来说，CDN 主要用来使用户就近获取资源。 突破浏览器并发限制。同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求 行内、块级、空元素 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p 常见的空元素： img input link meta br hr ，鲜为人知的是：area base col command embed keygen param source track wbr iframe内嵌框架缺点 iframe 会阻塞主页面的 onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题","categories":[{"name":"C_H5和CSS","slug":"C-H5和CSS","permalink":"https://fuyunjinglong.github.io/categories/C-H5%E5%92%8CCSS/"}],"tags":[]},{"title":"CSS_0基础","slug":"C_CSS_0基础","date":"2099-06-25T23:33:16.000Z","updated":"2024-02-28T22:49:43.483Z","comments":true,"path":"2099/06/26/C_CSS_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/06/26/C_CSS_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"入门CSS模块化模块化进程:BEM、OOCSS、SMACSS、ITCSS，以及 CSS Modules 和 CSS-in-JS 等,目前主流的是CSS Modules 和 CSS-in-JS 一、CSS 命名方法论 通过人工的方式来约定命名规则. 社区在早期诞生了一些 CSS 命名方法论，如 BEM、OOCSS、SMACSS、ITCSS、SUITCSS、Atomic CSS 等 1.BEM BEM（Block Element Modifier）是一种典型的 CSS 命名方法论，在 2009 年前提出，它的核心思想是 通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。 BEM 命名规约是 .block-name__element-name--modifier-name，即 .模块名__元素名--修饰器名 三个部分。也可以自定义 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 示例模块 --&gt;&lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card__head&quot;&gt; &lt;ul class=&quot;card__menu&quot;&gt; &lt;li class=&quot;card__menu-item&quot;&gt;menu item 1&lt;/li&gt; &lt;li class=&quot;card__menu-item&quot;&gt;menu item 2&lt;/li&gt; &lt;li class=&quot;card__menu-item card__menu-item--active&quot;&gt;menu item 3&lt;/li&gt; &lt;li class=&quot;card__menu-item card__menu-item--disable&quot;&gt;menu item 4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;card__body&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card__foot&quot;&gt;&lt;/div&gt;&lt;/div&gt;.card &#123;&#125;.card__head &#123;&#125;.card__menu &#123;&#125;.card__menu-item &#123;&#125;.card__menu-item--active &#123;&#125;.card__menu-item--disable &#123;&#125;.card__body &#123;&#125;.card__foot &#123;&#125;使用sass更简单.card &#123; &amp;__head &#123;&#125; &amp;__menu &#123; &amp;-item &#123; &amp;--active &#123;&#125; &amp;--disable &#123;&#125; &#125; &#125; &amp;__body &#123;&#125; &amp;__foot &#123;&#125;&#125; 2.OOCSS OOCSS（Object-Oriented CSS）即面向对象的 CSS，它借鉴了 OOP（面向对象编程）的抽象思维，主张将元素的样式抽象成多个独立的小型样式类，来提高样式的灵活性和可重用性。 OOCSS 有两个基本原则： 独立的结构和样式。即不要将定位、尺寸等布局样式与字体、颜色等表现样式写在一个选择器中。 独立的容器和内容。即让对象的行为可预测，避免对位置的依赖，子元素即使离开了容器也应该能正确显示。 1234567891011&lt;div class=&quot;size1of4 bgBlue solidGray mt-5 ml-10 mr-10 mb-10&quot;&gt;&lt;/div&gt;&lt;style&gt; .size1of4 &#123; width: 25%; &#125; .bgBlue &#123; background: blue; &#125; .solidGray &#123; border: 1px solid #ccc; &#125; .mt-5 &#123; margin-top: 5px; &#125; .mr-10 &#123; margin-right: 10px &#125; .mb-10 &#123; margin-bottom: 10px; &#125; .ml-10 &#123; margin-left: 10px; &#125;&lt;/style&gt; 3.SMACSS SMACSS（Scalable and Modular Architecture for CSS）即可伸缩及模块化的 CSS 结构，由 Jonathan Snook 在 2011 年雅虎时提出。 SAMCSS 按照部件的功能特性，将其划分为五大类： 基础（Base）是为HTML元素定义默认样式，可以包含属性、伪类等选择器。 布局（Layout）会将页面分为几部分，可作为高级容器包含一个或多个模块，例如左右分栏、栅格系统等。 模块（Module）又名对象或块，是可重用的模块化部分，例如导航栏、产品列表等。 状态（State）描述的是任一模块或布局在特定状态下的外观，例如隐藏、激活等。 主题（Theme）也就是换肤，描述了页面的外观，它可修改前面四个类别的样式，例如链接颜色、布局方式等。 SMACSS 推荐使用前缀来区分不同部件： 基础规则是直接作用于元素的，因此不需要前缀。 布局的前缀是 l- 或 layout-，例如 .l-table、.layout-grid 等。 模块的前缀是 m- 或模块自身的命名，例如 .m-nav、.card、.field 等。 状态的前缀是 is-，例如 .is-active、.is-current 等。 主题的前缀是 theme-，例如 .theme-light、.theme-dark 等。 4.ITCSS ITCSS（Inverted Triangle CSS，倒三角 CSS）是一套方便扩展和管理的 CSS 体系架构，它兼容 BEM、OOCSS、SMACSS 等 CSS 命名方法论。ITCSS 使用 分层 的思想来管理你的样式文件，类似服务端开发中的 MVC 分层设计。 ITCSS 将 CSS 的样式规则划分成以下的几个层次： Settings：项目使用的全局变量，比如颜色，字体大小等等。 Tools：项目使用的 mixins 和 functions。到 Tools 为止，不会生成具体的 CSS 代码。 Generic：最基本的设定，比如 reset.css、normalize.css 等。 Base：最基础的元素（elements），比如 img、p、link、list 等。 Objects：某种设计模式，比如水平居中， Components：UI 组件，比如 button、switch、slider 等。 Trumps：用于辅助和微调的样式，只有这一层才可以使用 !important。 ITCSS 的分层逻辑越往下就越具体。 二、CSS Modules 一个 CSS 文件就是一个独立的模块，参考 官网 或 阮老师的《CSS Modules 用法教程》 CSS Modules 特性： 作用域：模块中的名称默认都属于本地作用域，定义在 :local 中的名称也属于本地作用域，定义在 :global 中的名称属于全局作用域，全局名称不会被编译成哈希字符串。 命名：对于本地类名称，CSS Modules 建议使用 camelCase 方式来命名，这样会使 JS 文件更干净，即 styles.className。但是你仍然可以固执己见地使用 styles[&#39;class-name&#39;]，允许但不提倡。🤪 组合：使用 composes 属性来继承另一个选择器的样式，这与 Sass 的 @extend 规则类似。 变量：使用 @value 来定义变量，不过需要安装 PostCSS 和 postcss-modules-values 插件。 使用 CSS Modules 时，推荐配合 CSS 预处理器（Sass/Less/Stylus）一起使用。 三、CSS-in-JS 在 JS 中写 CSS 一些流行的 CSS-in-JS 库： styled-components：https://github.com/styled-com… 33k（推荐） emotion：https://github.com/emotion-js… 13k Radium：https://github.com/Formidable… 7k（已不再维护） Styled System：https://github.com/styled-sys… 7k styled-jsx：https://github.com/vercel/sty… 6k JSS：https://github.com/cssinjs/jss 6k 参考 CSS 模块化方案探讨（BEM、OOCSS、CSS Modules、CSS-in-JS …） CSS模块化演进 BFC定义 BFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。 W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。 一句话：BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。 触发BFC的css属性 overflow: hidden display: inline-block position: absolute position: fixed display: table-cell display: flex BFC规则 BFC是块级元素，会按照瀑布流的方式从上到下排列 BFC是隔离容器，容器里的标签不受外部影响 同一个BFC下的两个相邻的标签外边距会发生重叠 计算BFC的高度时，浮动元素也参与计算 BFC应用 使用Float脱离文档流，高度塌陷，如清除浮动 Margin边距重叠 两栏布局 Float浮动定义 一句话：让block元素无视float元素，让inline元素像流水一样围绕着float元素实现浮动布局 float特性 包裹性 高度塌陷 块状化 没有任何margin合并 1.包裹性,是指包裹和自适应。 包裹：将浮动元素父元素宽度设置为200px，浮动元素的子元素是一个128px宽度的图片，则此时浮动元素宽度表现为”包裹”，即包裹了子元素，宽度也是128px.一句话：对内，浮动元素被内部撑起最小值 自适应：浮动元素自适应父元素的200px，一句话：对外，浮动元素被内部撑起最大值是父元素容器 123456789101112131415161718192021222324/* CSS代码 */.father&#123; border: 1px solid deeppink; width: 200px;&#125;.son &#123; float: left; font-size: 0; border: 1px solid blue; padding: 5px;&#125;.father img &#123; width: 128px;&#125;/* HTML代码 */&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;!--包裹--&gt; &lt;img src=&quot;../../lib/img/mm1.png&quot;&gt; &lt;!--自适应--&gt; &lt;span style=&quot;font-size: 12px&quot;&gt;美女1，美女2，美女3，美女4，美女5，美女6，后宫1，后宫2，后宫3，后宫&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 2.高度塌陷 会让父元素的高度塌陷，即无法撑开父元素高度 3.块状化 浮动元素的display值就是block或者table。注意它不是真正的块状元素，只是有块状的属性，如可以设置宽高。 以下是冗余写法，浮动元素加display: block; 4.没有任何margin合并 设置了float属性的元素没有任何的margin重叠 清除浮动 注意浮动一直还在，并没有清除！只能清除浮动带来的影响。 父级盒子元素触发BFC，overflow:hidden,auto（完美方法） 浮动元素设置clear:both。本质是让自己不和float元素在一行显示，并不是真正意义上的清除浮动 如果clear:both元素前面的元素就是float元素，则设置margin-top无效 clear:both后面的元素依旧可能会发生文字环绕现象 参考 CSS 深入理解之 float 浮动 三栏布局（圣杯、双飞翼等6种）float浮动 1234567891011121314151617181920&lt;div id=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; #left, #right &#123; width: 200px; height: 200px; background: red; &#125; #middle &#123; height: 200px; background: green; &#125; #left &#123; float: left; &#125; #right &#123; float: right; &#125; position定位 1234567891011121314151617181920212223&lt;div id=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; #left, #right &#123; width: 200px; height: 100%; background: red; &#125; #left &#123; position: absolute; left: 0; top: 0; &#125; #right &#123; position: absolute; right: 0; top: 0; &#125; #middle &#123; margin: 0 200px; &#125; 圣杯布局 原理：将基本布局之后使用向左浮动，middle栏用padding留出两边位置，然后使用相对定位将左右两栏通过margin-left,margin-right到相应位置。 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; .wrapper &#123; /* 触发BFC,撑起mid，left,right高度*/ overflow: hidden; /* 预留左右空间，等待left，right插入*/ padding-left: 100px; padding-right: 100px; &#125; .middle &#123; float: left; width: 100%; background: #d9d9d9; &#125; .left &#123; float: left; width: 100px; background: #d5d60f; /*向左偏移100%，并且再偏移一个100px*/ position: relative; margin-left: -100%; right: 100px; &#125; .right &#123; float: left; width: 100px; background: #8cc94c; /*右移100px*/ margin-right: -100px; &#125; 双飞翼布局 原理：将基本布局之后使用向左浮动，middle栏用margin留出两边位置，然后不使用相对定位，将左右两栏通过margin-left到相应位置。 123456789101112131415161718192021222324252627&lt;div class=&quot;middle&quot;&gt; &lt;div id=&quot;middle-wrapper&quot;&gt;middle&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; .middle &#123; float: left; width: 100%; background: #d9d9d9; &#125; #middle-wrapper &#123; margin-left: 100px; margin-right: 100px; &#125; .left &#123; float: left; width: 100px; background: #d5d60f; margin-left: -100%; &#125; .right &#123; float: left; width: 100px; background: #8cc94c; margin-left: -100px; &#125; 优点 缺点 圣杯 使用padding，dom简单 中间宽度过小，会布局混乱 双飞翼 使用margin，支持各种宽高，通用型强 dom复杂 Flex布局 12345678910111213141516171819202122232425 &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; .main&#123; display: flex; align-items: center; &#125; .left&#123; background: red; width: 200px; height: 300px; &#125; .right&#123; background: blue; width: 200px; height: 300px; &#125; .middle&#123; background: green; height: 300px; width: 100%; &#125; Grid布局 12345678910111213141516171819202122232425 &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; .main&#123; display: grid; height: 300px; &#125; .left&#123; background: red; grid-row:1; grid-column:1/2; &#125; .right&#123; background: blue; grid-row:1; grid-column:4/5; &#125; .middle&#123; background: green; grid-row:1; grid-column:2/4; &#125; CSS盒子模型盒子由四个属性组成，从内到外分别是：content 内容、padding 内填充、border 边框、外边距 margin 盒子分类： W3C 盒子模型(标准盒模型) IE 盒子模型(怪异盒模型) 宽度和高度的计算方式: 标准盒模型：width = content 怪异盒模型: width = content+ padding+ border CSS 设置这两个模型: 标准盒模型 box-sizing：content-box,如果加了padding，高度会变化。 怪异盒模型 box-sizing: border-box,比较方便，常用，大量第三方库默认使用此模型。 外边距合并 块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距合并。 CSS 的两种盒模型 如何保持水平垂直居中 ？一、水平居中 （1）行内元素解决方案 只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加如下属性即可。 123.parent &#123; text-align: center;&#125; （2）块状元素解决方案 1234.item &#123; /* 这里可以设置顶端外边距 */ margin: 10px auto;&#125; （3）多个块状元素解决方案将元素的 display 属性设置为 inline-block，并且把父元素的 text-align 属性设置为 center 即可: 123.parent &#123; text-align:center;&#125; （4）多个块状元素解决方案 使用 flexbox 布局，只需要把待处理的块状元素的父元素添加属性 display: flex 及 justify-content: center 即可。 1234.parent &#123; display: flex; justify-content: center;&#125; 二、垂直居中 （1）单行的行内元素解决方案 1234567891011.parent &#123; background: #222; height: 200px;&#125;/* 以下代码中，将 a 元素的 height 和 line-height 设置的和父元素一样高度即可实现垂直居中 */a &#123; height: 200px; line-height:200px; color: #FFF;&#125; （2）多行的行内元素解决方案组合 使用 display: table-cell 和 vertical-align: middle 属性来定义需要居中的元素的父容器元素生成效果，如下： 12345678.parent &#123; background: #222; width: 300px; height: 300px; /* 以下属性垂直居中 */ display: table-cell; vertical-align: middle;&#125; （3）已知高度的块状元素解决方案 123456.item&#123; position: absolute; top: 50%; margin-top: -50px; /* margin-top值为自身高度的一半 */ padding:0;&#125; 三、水平垂直居中 （1）已知高度和宽度的元素解决方案 1 这是一种不常见的居中方法，可自适应，比方案 2 更智能，如下： 12345678.item&#123; position: absolute; margin:auto; left:0; top:0; right:0; bottom:0;&#125; （2）已知高度和宽度的元素解决方案 2 1234567.item&#123; position: absolute; top: 50%; left: 50%; margin-top: -75px; /* 设置margin-left / margin-top 为自身高度的一半 */ margin-left: -75px;&#125; （3）未知高度和宽度元素解决方案 123456.item&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); /* 使用 css3 的 transform 来实现 */&#125; （4）使用 flex 布局实现 12345678.parent&#123; display: flex; justify-content: center; align-items: center; /* 注意这里需要设置高度来查看垂直居中效果 */ background: #AAA; height: 300px;&#125; position、float和display的取值意思position position 属性取值：static(默认)、relative、absolute、fixed、inherit、sticky。 postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让 top，right，bottom，left 的值失效。在切换的时候可以尝试这个方法。 除了 static 值，在其他三个值的设置下，z-index 才会起作用。确切地说 z-index 只在定位元素上有效。 position：relative 和 absolute 都可以用于定位，区别在于前者的 div 还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。 定位原点 relative 是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute 相对于第一个 position 属性值不为 static 的父类。所以设置了 position：absolute，其父类的该属性值要注意，而且 overflow：hidden 也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。 fixed 旧版本 IE 不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。 常用于 header，footer 或者一些固定的悬浮 div，随滚动条滚动又稳定又流畅，比 JS 好多了。fixed 可以有很多创造性的布局和作用，兼容性是问题。 position：inherit。 规定从父类继承 position 属性的值，所以这个属性也是有继承性的，但需要注意的是 IE8 以及往前的版本都不支持 inherit 属性。 sticky ：设置了sticky 的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是 top、left 等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成 fixed，根据设置的 left、top 等属性成固定位置的效果。 float float：left (或 right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。 且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。 任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置 display：block。 如果浮动非替换元素，则要指定一个明确的 width，否则它们会尽可能的窄。 什么叫替换元素 ？根据元素本身的特点定义的， (X)HTML中的 img、input、textarea、select、object 都是替换元素，这些元素都没有实际的内容。 (X)HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。 display display 属性取值：none、inline、inline-block、block、table 相关属性值、inherit。 display 属性规定元素应该生成的框的类型。文档内任何元素都是框，块框或行内框。 display：none 和 visiability：hidden 都可以隐藏 div，区别有点像 absolute 和 relative，前者不占据文档的空间，后者还是占据文档的位置。 display：inline 和 block，又叫行内元素和块级元素。 表现出来的区别就是 block 独占一行，在浏览器中通常垂直布局，可以用 margin 来控制块级元素之间的间距（存在 margin 合并的问题，只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。）； 而 inline 以水平方式布局，垂直方向的 margin 和 padding 都是无效的，大小跟内容一样，且无法设置宽高。 inline 就像塑料袋，内容怎么样，就长得怎么样；block 就像盒子，有固定的宽和高。 inline-block 就介于两者之间。 table 相关的属性值可以用来垂直居中，效果一般。 flex CSS常用3种引入方式第一：外链式 这种方法可以说是现在占统治地位的引入方法。 如同 IE 与浏览器。这也是最能体现 CSS 特点的方法； 最能体现 DIV+CSS 中的内容离的思想，也最易改版维护，代码看起来也是最美观的一种。 第二：内部样式表 这种方法的使用情况要少的多，最长见得就是访问量大的门户网站。或者访问量较大的企业网站的首页。 与第一种方法比起来，优弊端也明显。 优点：速度快，所有的 CSS 控制都是针对本页面标签的，没有多余的 CSS 命令；再者不用外链 CSS 文件。直接在文档中读取样式。 缺点：就是改版麻烦些，单个页面显得臃肿，CSS 不能被其他 HTML 引用造成代码量相对较多，维护也麻烦些采用这种方法的公司大多有钱，对他们来说用户量是关键，他们不缺人进行复杂的维护工作。 第三：行内样式 认为 HTML 里不能出现 CSS 命令。其实有时候没有什么大不了。比如通用性差，效果特殊，使用 CSS 命令较少，并且不常改动的地方，使用这种方法反而是很好的选择。 第四、@import 引入方式 123&lt;style type=&quot;text/css&quot;&gt;@import url(my.css);&lt;/style&gt; CSS Sprite雪碧图精灵图将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background-repeat，background-position 的组合进行背景定位。 能很好地减少了网页的 http 请求，从而大大的提高了页面的性能， CSS Sprites 能减少图片的字节，曾经比较过多次 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的和。 解决了网页设计师在图片命名上的困扰 更换风格方便，只需要在一张图片上修改样式，整个网页的风格就可以改变。维护起方便。 也存在一些不可忽视的缺点，如下： 在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内不不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容背景断裂； CSS Sprites 在开发的时候比较麻烦，你要通过 photoshop 或其他工具测量计算每一个背景单元的精确位是针线活，没什么难度，但是很繁琐； CSS Sprites 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的好不要动，这样避免改动更多的 css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字加了，还要改动 css。 CSS选择符有哪些？哪些属性可以继承？优先级？CSS 选择符 id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a: hover, li: nth - child） 可继承的样式 font-size，font-family，color，ul，li，dl，dd，dt； 不可继承的样式 border padding margin width height 事实上，宽度也不是继承的，而是如果你不指定宽度，那么它就是 100%。由于你子 DIV 并没有指定宽度，那它就是 100%，也就是与父 DIV 同宽，但这与继承无关，高度自然也没有继承一说。 CSS选择器优先级 第一优先级：!important会覆盖页面内任何位置的元素样式 1.内联样式，如style=&quot;color: green&quot;，权值为1000 2.ID选择器，如#app，权值为0100 3.类、伪类、属性选择器，如.foo, :first-child, div[class=&quot;foo&quot;]，权值为0010 4.标签、伪元素选择器，如div::first-line，权值为0001 5.通配符、子类选择器、兄弟选择器，如*, &gt;, +，权值为0000 6.继承的样式没有权值 清除浮动1.父级div定义 overflow: auto（注意：是父级div也就是这里的 div.outer），最常用。2.添加新的子元素 、应用 clear：both； css modules和scoped区别vue项目中有两种解决css冲突的方案，一种是比较常见的使用scoped。另一种就是css modules。 (1)scoped方案 当在style标签中加上scoped，编译后会在该vue组件元素上加上hash标识属性，在vue组件里的每个元素都有同一个hash标识属性。无法完全避开css权重和类名重复的问题。 1&lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt; (2)css modules方案 产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，为所有类名重新生成类名，有效避开了css权重和类名重复的问题，这就是 CSS Modules 的做法。css module直接替换了类名，排除了用户设置类名影响组件样式的可能性。 区别： scoped方案在其他地方使用相同类名可能还是会影响组件样式，如果你子组件的某元素上有一个类已经在这个父组件中定义过了，那么这个父组件的样式就会泄露到子组件中。但是css modules方案通过算法计算出唯一类名替换原始类名避免了这种样式冲突。 还有一些情况是我们需要对我们的子组件的深层结构设置样式——虽然这种做法并不受推荐且应该避免。为了简便起见，我们假设我们的父组件现在要对子组件设置样式，在 scoped 样式中，这种情况可以使用 &gt;&gt;&gt; 连接符（或者 /deep/ ）实现。 scoped会使标签选择器渲染变慢很多倍，而使用class或id则不会。 模块式 CSS 与 JS 有着很好的互操作性 (interoperability)，这一点不只局限于 CSS 类。 flex=1代表什么，用于什么场景 flex：1 适用等分布局，在尺寸不足时依然与其他元素保持等分，会优先压缩自身 flex：auto 适用基于内容动态适配的布局，挤压其他元素的空间 flex: 1等价于flex: 1 1 0，也就是 123flex-grow : 1;flex-shrink : 1;flex-basis : 0; flex-grow 表示当有剩余空间的时候，分配给项目的比例,应用到内容区域高度不够的时候。 flex-shrink 表示空间不足的时候，项目缩小的比例 flex-basis 表示分配空间之前，项目占据主轴的空间 flex-grow 假设有一个宽度为 800 的容器，里面有 3 个项目，宽度分别是 100，200，300： 123456789101112131415161718192021222324252627&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;.container &#123; display: flex; width: 800px; height: 300px; background: grey;&#125;.left &#123; flex-basis: 100px; background: linear-gradient(to bottom right, green, white);&#125;.middle &#123; flex-basis: 200px; background: linear-gradient(to bottom right, yellow, white);&#125;.right &#123; flex-basis: 300px; background: linear-gradient(to bottom right, purple, white);&#125; 这时候就出现了多余的 200 的空间（灰色部分）。这时候如果我们对左中右分别设置flex-grow为 2，1，1，各个项目的计算逻辑如下： 首先将多余空间 200 除以 4（2 + 1 + 1），等于 50 left = 100 + 2 x 50 = 200 middle = 200 + 1 x 50 = 250 right = 300 + 1 x 50 = 350 flex-shrink（默认值 1） 假设父容器宽度调整为 550，里面依然是 3 个项目，宽度分别是 100，200，300，这时候空间就不够用溢出了。首先要理解清楚，当我们定义一个固定宽度容器为flex的时候，flex会尽其所能不去改变容器的宽度，而是压缩项目的宽度。这时我们对左中右分别设置flex-shrink为 1，2，3，计算逻辑如下： 溢出空间 = 100 + 200 + 300 - 550 = 50 总权重 = 1 x 100 + 2 x 200 + 3 x 300 = 1400 left = 100 - (50 x 1 x 100 / 1400) = 96.42 middle = 200 - (50 x 2 x 200 / 1400) = 185.72 right = 300 - (50 x 3 x 300 / 1400) = 267.86 flex-basis（默认值 auto） flex-basis指定项目占据主轴的空间，如果不设置，则等于内容本身的空间 对reflow和repaint的理解回流比重绘的代价要更高。 1.回流(对应排列) 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 123456789101112131415161718会导致回流的操作：页面首次渲染浏览器窗口大小发生改变元素尺寸或位置发生改变元素内容变化（文字数量或图片大小等等）元素字体大小变化添加或者删除可见的DOM元素激活CSS伪类（例如：:hover）查询某些属性或调用某些方法导致回流的属性和方法：clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()getComputedStyle()getBoundingClientRect()scrollTo() 2.重绘(对应绘制) 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它。 3.为什么要优化？ 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 重排和重绘不只是对单个的dom元素进行操作，而是对整个【图层】进行操作，需要花费时间，如果频率高，非常的影响性能。所以有时候有必要开启另一个图层操作。 123456那么什么情况可以开启图层？1、css 3D变化的图形 ---- transform: translateX(0)2、html5中的&lt;video&gt;标签3、canvas绘图中的节点4、css 动画的节点 --- keyframes animation5、拥有css加速属性 --- will-change: transform 优化手段： (1)CSS 123456789使用 transform 替代 top使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。避免使用CSS表达式，可能会引发回流。将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 (2)JS 1234避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 first-child与:first-of-type的区别 :first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。 :first-of-type 匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。 同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。 页面样式导入link和@import区别 link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS(是一种描述和同步网站内容的格式，是使用最广泛的 XML 应用), 定义 rel 连接属性等作用； 而 @import 是 CSS 提供的，只能用于加载 CSS; 页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载; import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题。 总之，link 要优于 @import。 Grid布局张鑫旭的grid 最大强大Grid Grid布局相关属性 flex 布局是一维布局，主要用于局部布局，Grid 布局是二维布局，用于大结构布局 给&lt;div&gt;这类块状元素元素设置display:grid或者给&lt;span&gt;这类内联元素设置display:inline-grid，Grid布局即创建 基础概念的演示地址 作用在grid容器上 作用在grid子项上 grid-template-columns：纵向分块 grid-column-start：设置元素网格线的列起点 grid-template-rows：横向分块 grid-column-end：设置元素网格线的列终点 grid-template-areas：定制区域结构 grid-row-start：设置元素网格线的行起点 grid-template：行列分块的缩写 grid-row-end：设置元素网格线的行终点 grid-column-gap：列块间距 grid-column：子项的列起始点的缩写 grid-row-gap：行块间距 grid-row：子项的行起始点的缩写 grid-gap：行列块间距的缩写 grid-area：子项的行列起始点的缩写 justify-items：每个子项的水平的左中右对齐 justify-self：子项内部的水平对齐方式 align-items：每个子项的垂直的上中下对齐 align-self：子项内部的垂直对齐方式 place-items：每个子项的水平垂直的缩写 place-self：子项内部的水平垂直的缩写 justify-content：子项整体的水平的左中右对齐 align-content：子项整体的垂直的上中下对齐 place-content：子项整体的水平垂直的缩写 grid-auto-columns：超出容器的部分，纵向分块 grid-auto-rows：超出容器的部分，横向分块 grid-auto-flow：排列方式为先行或先列 grid：大集合 双命名 由于网格中中间区域的网格线是两边格子公用的，就像道路有两边，因此，我们起名字的时候可以起两个名称（使用空格分隔），分别表示两侧。例如： 123.container &#123; grid-template-columns: [第一根纵线] 80px [第1根纵线结束 第2根纵线开始] 100px [最后的结束线];&#125; repeat语法 有时候，我们网格的划分是很规律的，例如，基于40px创建栅格，要是我们布局宽度960px，岂不是要写24次40px，实在套啰嗦了，此时，就可以使用repeat()语法，如下示意： 123.container &#123; grid-template-columns: repeat(24, 40px);&#125; 等同于： 123.container &#123; grid-template-columns: 40px, 40px, /* ...省略20个...*/, 40px, 40px;&#125; fr单位是什么？ fr是单词fraction的缩写，表示分数。 先从简单例子看起： 123.container &#123; grid-template-columns: 1fr 1fr 1fr;&#125; 1:1:1，网格宽度三等分 如果有固定尺寸值，则划分剩余空间大小，例如： 123.container &#123; grid-template-columns: 200px 1fr 1fr 1fr;&#125; 4列，后面3列宽度是grid容器宽度减去200像素后的1/3大小 如果和auto混用会如何呢？ 123.container &#123; grid-template-columns: auto 1fr 1fr 1fr;&#125; auto的尺寸表现为“包裹”，为内容宽度 作用在grid容器上的CSS属性grid-template-columns 纵向分块，分多少个块，每块多少单位 1234.container &#123; grid-template-columns: 80px auto 100px; grid-template-rows: 25% 100px auto 60px;&#125; grid-template-rows 横向分块，分多少个块，每块多少单位 1234.container &#123; grid-template-columns: 80px auto 100px; grid-template-rows: 25% 100px auto 60px;&#125; grid-template-areas 定制区域结构。 张老板承包了一块地，然后划分成了3*4共12个小格子，然后张老板希望最上面3个格子种葡萄，最下面3个格子种西瓜，中间6个格子，左边2个养龙虾，右边4个养鱼。 123456789.container &#123; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr 1fr; grid-template-areas: &quot;葡萄 葡萄 葡萄&quot; &quot;龙虾 养鱼 养鱼&quot; &quot;龙虾 养鱼 养鱼&quot; &quot;西瓜 西瓜 西瓜&quot;;&#125; 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;putao&quot;&gt;&lt;/div&gt; &lt;div class=&quot;longxia&quot;&gt;&lt;/div&gt; &lt;div class=&quot;yangyu&quot;&gt;&lt;/div&gt; &lt;div class=&quot;xigua&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234.putao &#123; grid-area: 葡萄; &#125;.longxia &#123; grid-area: 龙虾; &#125;.yangyu &#123; grid-area: 养鱼; &#125;.xigua &#123; grid-area: 西瓜; &#125; grid-template 行列分块的缩写 grid-template是grid-template-rows，grid-template-columns和grid-template-areas属性的缩写。 123.container &#123; grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;&#125; grid-column-gap 列块间距 grid-row-gap 行块间距 grid-gap 行列块间距的缩写 grid-gap属性是grid-column-gap和grid-row-gap属性的缩写 推荐使用gap属性作为缩写，grid-gap已经很老了。 123.container &#123; grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;&#125; align-items和align-content的区别 align-items属性是针对单独的每一个flex子项起作用，它的基本单位是每一个子项，在所有情况下都有效果（当然要看具体的属性值）。 align-content属性是将flex子项作为一个整体起作用，它的基本单位是子项构成的行，只在两种情况下有效果：①子项多行且flex容器高度固定 ②子项单行，flex容器高度固定且设置了flex-wrap:wrap; justify-items 每个子项的水平的左中右对齐 align-items 每个子项的垂直的上中下对齐 place-items 每个子项的水平垂直的缩写 place-items是align-items和justify-items的缩写 123.container &#123; place-items: &lt;align-items&gt; &lt;justify-items&gt;?;&#125; justify-content 子项整体的水平的左中右对齐 align-content 子项整体的垂直的上中下对齐 place-content 子项整体的水平垂直的缩写 place-content是align-content和justify-content的缩写 123.container &#123; place-content: &lt;align-content&gt; &lt;justify-content&gt;?;&#125; grid-auto-columns 对超出容器后的部分，纵向分块 grid-auto-rows 对超出容器后的部分，横向分块 grid-auto-flow 指定排列方式：默认row,横向排列。也可以column纵向排列 grid 大集合，grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns和grid-auto-flow。 1grid: &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;? 具体说明： auto-flow &amp;&amp; dense?其实就是grid-auto-flow属性的值，等同于row或column或row dense或column dense。 但这里row和column这两个关键字却使用了auto-flow这一个关键字代替了。那岂不有问题：什么时候解析成row，什么时候解析成column呢？ 原来，是根据auto-flow关键字是在斜杠的左侧还是右侧决定的。如果auto-flow关键字在斜杠左侧，则解析为row，如果是在右侧，则解析为column。这里的语法是在斜杠的右侧，因此，会将grid-auto-flow解析为column。 &lt;grid-auto-columns&gt;后面有个问号?，因此是可以省略的，如果省略，则将grid-auto-columns解析为auto。 作用在grid子项上的CSS属性grid-column-start 设置元素网格线的列起点。索引从1开始。 123456789101112131415161718&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item-a&quot;&gt;&lt;/div&gt;&lt;/div&gt;.container &#123; display:grid; grid-template-columns: 80px auto 100px ; grid-template-rows: 25% 100px auto ; height:300px; backGround-color:red;&#125;.item-a &#123; grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3; backGround-color:blue;&#125; grid-column-end 设置元素网格线的列终点 grid-row-start 设置元素网格线的行起点 grid-row-end 设置元素网格线的行终点 grid-column 子项的列起始点的缩写。 grid-column是grid-column-start+ grid-column-end的缩写 1234.item-b &#123; grid-column: 2 / span 纵线3; grid-row: 第一行开始 / span 3;&#125; grid-row 子项的行起始点的缩写。 grid-row是grid-row-start + grid-row-end的缩写 grid-area 子项的行列起始点的缩写。 grid-area其实是grid-row-start, grid-column-start, grid-row-end 以及 grid-column-end属性的缩写。 12345678910.item &#123; grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125;.container &#123; grid-template: 1fr 1fr 1fr/1fr 1fr 1fr 1fr;&#125;.item-c &#123; grid-area: 1 / 2 / 3 / 4;&#125; justify-self 子项内部的水平对齐方式 align-self 子项内部的垂直对齐方式 place-self 子项内部的水平垂直的缩写 place-self 是设置 align-self 和 justify-self 的缩写。 123.item &#123; place-self: &lt;align-self&gt; &lt;justify-self&gt;?&#125; 注意 在Grid布局中，float，display:inline-block，display:table-cell，vertical-align以及column-*这些属性和声明对grid子项是没有任何作用的。这个可以说是Grid布局中的常识，面试经常会问的，一定要记得。 Grid布局则适用于更大规模的布局（二维布局），而Flexbox布局最适合应用程序的组件和小规模布局（一维布局），关Flex布局请参见“写给自己看的display: flex布局教程”一文。 命名虽然支持中文，但由于CSS文件中文存在乱码的风险，所以……创新还是保守就看大家自己的抉择了。 IE10-IE15虽然名义上支持Grid布局，但支持的是老版本语法（本文是介绍的全是2.0全新语法），还需要加-ms-私有前缀，精力原因，IE下的使用并未深究，以后有机会再补充。 Flex弹性布局flex实战原文 容器属性flex-direction flex-direction 属性决定主轴的方向，继而决定子项在容器中的位置。 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：表示子项从左向右排列。此时水平方向轴为主轴。 row-reverse：表示子项从右向左排列。 column：表示子项从上向下排列。此时垂直方向轴为主轴。 column-reverse：表示子项从下向上排列。 flex-wrap flex-wrap 属性用于指定弹性布局中子项是否换行。 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认值）：表示不换行，所有子项目单行排列，子项可能会溢出。 wrap：表示换行，所有子项目多行排列，溢出的子项会被放到下一行，按从上向下顺序排列。 wrap-reverse：所有子项目多行排列，按从下向上顺序排列。 flex-flow flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 123.container &#123; flex-flow: &lt; &#x27;flex-direction&#x27; &gt; || &lt; &#x27;flex-wrap&#x27; &gt;;&#125; justify-content justify-content 属性定义了子项在 主轴（水平方向）上的对齐方式。 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：表示弹性容器子项按主轴起点线对齐 flex-end：表示弹性容器子项按主轴终点线对齐 center： 居中排列 space-between：弹性容器子项均匀分布，第一项紧贴主轴起点线，最后一项紧贴主轴终点线，子项目之间的间隔都相等。要注意特殊情况，当剩余空间为负数或者只有一个项时，效果等同于 flex-start。 space-around：弹性容器子项均匀分布，每个项目两侧的间隔相等，相邻项目之间的距离是两个项目之间留白的和。所以，项目之间的间隔比项目与边框的间隔大一倍。要注意特殊情况，当剩余空间为负数或者只有一个项时，效果等同于center。 space-evenly：弹性容器子项均匀分布，所有项目之间及项目与边框之间的距离相等。 仅当 flex-direction 为 row 时生效，因为 justify-content 仅定义子项在水平方向上的对齐方式 align-items align-items 属性定义弹性容器子项在交叉轴（垂直方向）上的对齐方式。 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; stretch（默认值）：当子项未设置高度或者高度为 atuo 时，子项的高度设为行高。这里需要注意，在只有一行的情况下，行的高度为容器的高度，即子项高度为容器的高度。（当子项设定了高度时无法展开） flex-start：表示子项与交叉轴的起点线对齐。 flex-end：表示子项与交叉轴的终点线对齐。 center：表示与交叉轴的中线对齐。 baseline：表示基线对齐，当行内轴与侧轴在同一线上，即所有子项的基线在同一线上时，效果等同于flex-start。 align-content align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 核心是一定是盒子内部的元素超过了盒子项的宽度（默认）出现了换行，也就是有多行才可以。 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; stretch（默认值）：轴线占满整个交叉轴。（当子项设定了高度时无法展开） flex-start：表示各行与交叉轴的起点线对齐。 flex-end：表示各行与交叉轴的终点线对齐。 center：表示各行与交叉轴的中线对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。要注意特殊情况，当剩余空间为负数时，效果等同于flex-start。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。要注意特殊情况，当剩余空间为负数时，效果等同于center。 ⚠️ 注意：该属性只作用于多行的情况（flex-warp: wrap / warp-reverse），在只有一行的弹性容器上无效，另外该属性可以很好的处理，换行以后相邻行之间产生的间距。 子项属性order 缺省情况下，Flex 子项是按照在代码中出现的先后顺序排列的。CSS3 新增加 order 属性定义项目的排列顺序，是数值类型。数值越小，排列越靠前，默认为 0。 注意此属性设置在子项上，浏览器自动按照 order 的大小排序盒子，默认都是 0，如果相同的 order 则按照编写标签的顺序排放盒子。 123.item &#123; order: 1;&#125; flex-grow flex-grow 属性定义子项的扩展比例，取值必须是一个单位的正整数，表示放大的比例。默认为 0，即如果存在额外空间，也不放大，负值无效。Flex 容器会根据子项设置的扩展比例作为比率来分配剩余空间 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 一行的子盒子同时设置 flex-grow 属性的话，会根据设置的值的大小按比例排放子项。 flex-grow 属性决定了子项要占用父容器多少剩余空间 计算方式： 假设剩余空间 x（弹性容器宽度与所有弹性子项宽度总和之差） 假设有三个弹性子项元素，flex-grow 设定值分别为 a、b 和 c 每个元素可以分配的剩余空间为：a/(a+b+c) * x、b/(a+b+c) * x 和 c/(a+b+c) * x 假设剩余空间为 150px，a、b 和 c 的 flex-grow 分别为 1、2 和 3，那么 a 占比剩余空间：1/(1+2+3) = 1/6，那么 a 瓜分到的剩余空间宽度是 150*(1/6)=25，加上 a 原本的宽度，实际的宽度为 &lt;origin-width&gt; + 25。 flex-shrink 如果子容器宽度超过父容器宽度，即使是设置了 flex-grow，但是由于没有剩余空间，就分配不到剩余空间了。这时候有两个办法：换行和压缩。由于 flex 默认不换行，那么压缩的话，怎么压缩呢，压缩多少？此时就需要用到 flex-shrink 属性了。 flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 此时，剩余空间的概念就转化成了 溢出空间。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 负值对该属性无效。且如果弹性子项总和没有超出父容器，设置 flex-shrink 将无效。 计算方式： 假设三个子项的 width 为：w1、w2、w3 假设三个子项的 flex-shrink 为：a、b、c 计算总压缩权重：sum = a * w1 + b * w2 + c * w3 计算每个元素压缩率：s1 = a * w1 / sum、s2 = b * w2 / sum、s3 = c * w3 / sum 计算每个元素宽度：width - 压缩率 * 溢出空间 flex-basis flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;number&gt; | &lt;percentage&gt; | auto; /* default auto */&#125; ⚠️ 注意： 设置 flex-grow 进行分配剩余空间，或者使用 flex-shrink 进行收缩都是在 flex-basis 的基础上进行的； 当 flex-basis 的值以及 width（或者 height）的值均为非 auto 时， 若 content 长度同时大于 flex-basis 的值以及 width（或者 height）的值，此时以 flex-basis 与 width（或者 height）中值大的为准 ，但是，如果子项设置了overflow: hidden 或者 overflow: auto，此时以flex-basis值为准； 若 content 长度同时小于 flex-basis 的值以及 width（或者 height）的值，此时以 flex-basis 值为准 若 content 长度小于 flex-basis 的值，大于 width（或者 height）的值，此时以 flex-basis 值为准 若 content 长度大于 flex-basis 的值，小于 width（或者 height）的值，此时以 content 自身长度值为准； 当 width（或者 height）的值为 auto 时，且内容的长度大于 flex-basis设置的值，此时以 content 自身长度值为准，且不能进行 flex-shrink 收缩。相反如果内容的长度小于 flex-basis 设置的值，则会使用 flex-basis 设置的值 当存在最小值 min-width（min-height）时，且 flex-basis 的值小于最小值时，宽度以最小值为准，当 flex-basis 的值大于最小值时，以 flex-basis 的值为准。 属性优先级：max-width / min-width -&gt; flex-basis -&gt; width -&gt; box flex flex 属性是 flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt; &#x27;flex-grow&#x27; &gt; &lt; &#x27;flex-shrink&#x27; &gt;? || &lt; &#x27;flex-basis&#x27; &gt; ];&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self align-self 属性用于指定子项的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 123.item &#123; align-self: auto || flex-start || flex-end || center || baseline || stretch;&#125; 重设样式使用的是Yahoo(YUI) 的reset.css 1234567891011121314151617181920212223242526272829303132body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre, form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; fieldset,img &#123; border: 0; &#125; address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal; &#125; ol,ul &#123; list-style: none; &#125; caption,th &#123; text-align: left; &#125; h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%; &#125; q:before,q:after &#123; content:”; &#125; abbr,acronym &#123; border: 0; &#125; line-height 腾讯ISD团队-深入理解CSS行高 line-height，是指同一个元素中，两个文本行基线间的垂直距离。 应用场景 单行文字的垂直居中对齐：把line-height设置为您需要的box的大小可以实现单行文字的垂直居中，不需要设置height 多行文字的垂直居中：使用padding就好了 进阶伪类和伪元素伪类 伪类即假的类，通常可以添加类来达到效果。伪类是选择器的一种，它用于选择处于特定状态的元素。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。伪类开头为冒号: 用户行为伪类，一些伪类只会在用户以某种方式和文档交互的时候应用。这些用户行为伪类，有时叫做动态伪类，如:hover，:focus。 常见伪类 :active 在用户激活（例如点击）元素的时候匹配。 :checked 匹配处于选中状态的单选或者复选框。 :disabled 匹配处于关闭状态的用户界面元素 :first-child 匹配兄弟元素中的第一个元素。 :first-of-type 匹配兄弟元素中第一个某种类型的元素。 :focus 当一个元素有焦点的时候匹配。 :hover 当用户悬浮到一个元素之上的时候匹配。 :last-child 匹配兄弟元素中最末的那个元素。 :last-of-type 匹配兄弟元素中最后一个某种类型的元素。 :is() 匹配传入的选择器列表中的任何选择器。 :not 匹配作为值传入自身的选择器未匹配的物件。 :nth-child 匹配一列兄弟元素中的元素——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。 :nth-of-type 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素）——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。 :nth-last-child 匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :nth-last-of-type 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素），从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :only-child 匹配没有兄弟元素的元素。 :only-of-type 匹配兄弟元素中某类型仅有的元素。 伪元素 伪元素即假元素，需要通过添加元素才能达到效果。伪元素以类似方式表现，不过表现得是像你往文档中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号:: 常见伪元素 ::before在被选元素前插入内容,属性 content 是必须设置的，它的值可以为字符串，也可以有其它形式 ::after在被元素后插入内容，属性 content 是必须设置的，它的值可以为字符串，也可以有其它形式 ::first-line作用于第一行的所有字符 ::first-letter作用于第一行的首字符 伪类和伪元素的区别 伪类和伪元素都是用来表示文档树以外的”元素”。 伪类和伪元素分别用单冒号:和双冒号::来表示。 伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。 sass（scss）、less、stylus、postcss它们都是css预处理器。css预处理器的概念：CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。 sass:Sass是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。 对Sass的缩排语法优化，用{}取代了原来的缩进，变成了Scss(sassy css)，与原来的语法兼容。变量符是$。 less:也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。在客户端上和服务端都可以运行。变量符是@。 Stylus：主要用来给Node项目进行CSS预处理支持。提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。支持缩进和CSS常规样式书写规则。写法更接近js,学习曲线陡峭。变量符是随意。 PostCSS：它是一个对 CSS 进行处理的工具（平台），不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 一般不单独使用，而是与已有的构建工具进行集成。PostCSS 与主流的构建工具，如 Webpack、Grunt 和 Gulp 都可以进行集成。 CSS动画css实现动画有三种方式： transition 实现渐变动画 transform 转变动画 animation 实现自定义动画 属性 含义 transition（过度） 用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同 transform（变形） 用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表” translate（移动） 只是transform的一个属性值，即移动 animation（动画） 用于设置动画属性，他是一个简写的属性，包含6个属性 transition 实现渐变动画 transition的属性如下： property:填写需要变化的css属性 duration:完成过渡效果需要的时间单位(s或者ms) timing-function:完成效果的速度曲线 delay: 动画效果的延迟触发时间 其中timing-function的值有如下： 值 描述 linear 匀速（等于 cubic-bezier(0,0,1,1)） ease 从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)） ease-in 慢慢变快（等于 cubic-bezier(0.42,0,1,1)） ease-out 慢慢变慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值 注意：并不是所有的属性都能使用过渡的，如display:none&lt;-&gt;display:block 123456789101112131415161718192021222324&lt;div class=&quot;base&quot;&gt;&lt;/div&gt;.base &#123; width: 100px; height: 100px; display: inline-block; background-color: #0ea9ff; border-width: 5px; border-style: solid; border-color: #5daf34; // transition-property: width, height, background-color, border-width; // transition-duration: 2s; // transition-timing-function: ease-in; // transition-delay: 500ms; /*简写*/ transition: all 2s ease-in 500ms;&#125;.base:hover &#123; width: 200px; height: 200px; background-color: #5daf34; border-width: 10px; border-color: #3a8ee6;&#125; transform 转变动画 包含四个常用的功能： translate：位移 scale：缩放 rotate：旋转 skew：倾斜 一般配合transition过度使用 注意的是，transform不支持inline元素，使用前把它变成block 1234567891011121314151617181920.base &#123; width: 100px; height: 100px; display: inline-block; background-color: #0ea9ff; border-width: 5px; border-style: solid; border-color: #5daf34; // 搭配transition transition: all 2s ease-in 500ms;&#125;.base:hover &#123; width: 200px; height: 200px; background-color: #5daf34; border-width: 10px; border-color: #3a8ee6; transform: scale(0.8, 1.5) rotate(35deg) skew(5deg) translate(15px, 25px);&#125; animation 实现自定义动画 animation是由 8 个属性的简写，分别如下： 属性 描述 属性值 animation-duration 指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0 animation-timing-function 指定动画计时函数，即动画的速度曲线，默认是 “ease” linear、ease、ease-in、ease-out、ease-in-out animation-delay 指定动画延迟时间，即动画何时开始，默认是 0 animation-iteration-count 指定动画播放的次数，默认是 1 animation-direction 指定动画播放的方向 默认是 normal normal、reverse、alternate、alternate-reverse animation-fill-mode 指定动画填充模式。默认是 none forwards、backwards、both animation-play-state 指定动画播放状态，正在运行或暂停。默认是 running running、pauser animation-name 指定 @keyframes 动画的名称 CSS 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来， 通过 @keyframes 来定义关键帧 123456789101112131415161718192021.base &#123; width: 100px; height: 100px; display: inline-block; background-color: #0ea9ff; border-width: 5px; border-style: solid; border-color: #5daf34;&#125;.base:hover &#123; animation: rotate 2s;&#125;@keyframes rotate &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; ::before 和 :after 双冒号和单冒号的区别 单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素。 ::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。 :before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。 起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为 ::before、 ::after 。 CSS3 新增伪类举例 :root 选择文档的根元素，等同于 html 元素 :empty 选择没有子元素的元素 :target 选取当前活动的目标元素 :not(selector) 选择除 selector 元素以外的元素 :enabled 选择可用的表单元素 :disabled 选择禁用的表单元素 :checked 选择被选中的表单元素 :after 选择器在被选元素的内容后面插入内容 :before 选择器在被选元素的内容前面插入内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n，从后向前数 :nth-child(odd) 奇数 :nth-child(even) 偶数 :nth-child(3n+1) :first-child :last-child :only-child :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n，从后向前数 :nth-of-type(odd) :nth-of-type(even) :nth-of-type(3n+1) :first-of-type :last-of-type :only-of-type ::selection 选择被用户选取的元素部分 :first-line 选择元素中的第一行 :first-letter 选择元素中的第一个字符 CSS3有哪些新特性？ CSS3 实现圆角（border-radius:8px） 阴影（box-shadow:10px） 对文字加特效（text-shadow） 线性渐变（gradient） 旋转、缩放、定位、倾斜 1transform: rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg); 增加了更多的 CSS 选择器 多背景 rgba canvas与svg的区别？Canvas是使用JavaScript程序绘图(动态生成)，SVG是使用XML文档描述来绘图。 SVG是基于矢量的，所有它能够很好的处理图形大小的改变。Canvas是基于位图的图像，它不能够改变大小，只能缩放显示； 历史对比 canvas svg 历史 较新，由Apple私有技术发展而来 历史悠久,2003年成为W3C标准 功能 功能简单，2D绘图API 功能丰富，各种图形、滤镜、动画 特点 像素,只能脚本驱动 矢量，XML,CSS,元素操作 支持 主流浏览器，IE9+ 主流浏览器，IE9+,其他svg阅读器 性能对比 canvas svg 操作对象 基于像素(动态点阵图) 基于图形元素 元素 单个HTML元素 多种图形元素(Rect,Path,Line) 驱动 只能脚本驱动 支持脚本和CSS 事件交互 交互到像素点(x,y) 交互到图形元素(rect,path) 性能 适合小面积，大数量的场景 适合大面积，小数量的场景 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 css2.0与css3.0css3加强了css2的功能，增加了新的属性和新的标签，并且删除了一些冗余的标签，在布局方面减少了代码量。 例如圆角、阴影、:last-child与:nth-last-child()伪类选择器等。 css3代码更简洁、结构更合理、性能和效果得到兼顾； css3兼容性没有css2兼容性好，很多新属性需要加上浏览器兼容前缀； css3能仅使用代码就实现的效果，css2需要使用图片来实现； css2请求服务器次数高于css3； CSS实现节流实现过程： 函数节流是一个非常常见的优化方式，可以有效避免函数过于频繁的执行 CSS 的实现思路和 JS 不同，重点在于在于找到和该场景相关联的属性 CSS 实现“节流”其实就是控制一个动画的精准控制，假设有一个动画控制按钮从禁用-&gt;可点击的变化，每次点击时让这个动画重新执行一遍，在执行的过程中，一直处于禁用状态，这样就达到了“节流”的效果 还可以通过 transition 的回调函数动态设置按钮禁用态 这种实现的好处在于禁用逻辑和业务逻辑是完全解耦的 1234567891011121314151617181920212223242526272829&lt;button onclick=&quot;console.log(&#x27;保存1&#x27;)&quot;&gt;我是“普通”保存&lt;/button&gt;&lt;button class=&quot;throttle&quot; onclick=&quot;console.log(&#x27;保存2&#x27;)&quot;&gt;我是“节流”保存&lt;/button&gt; body&#123; display: grid; place-content: center; height: 100vh; margin: 0; gap: 15px; background: #f1f1f1;&#125;button&#123; user-select: none;&#125;.throttle&#123; opacity: .99; transition: opacity 2s;&#125;.throttle:not(:disabled):active&#123; opacity: 1; transition: 0s;&#125;document.addEventListener(&#x27;transitionstart&#x27;, function(ev)&#123; ev.target.disabled = true &#125;) document.addEventListener(&#x27;transitionend&#x27;, function(ev)&#123; ev.target.disabled = false &#125;) 高级Tailwind CSS[一次就能看懂的Tailwind CSS介绍] CSS 发展阶段基本经历了三个阶段。 第一个阶段，原生写法是类似于编程中面向过程的写法，需要什么样式，自己在 css 中写什么样式。对代码有洁癖的程序员会进行简单的 css 复用。但是也只是简单的复用，大多数时候还是需要什么写什么，想怎么写怎么写。 第二个阶段，CSS 组件化。类似于编程中面向对象的写法，将相同视觉的 UI 封装成一个组件。比如一个按钮，整个项目中，这个按钮被多次使用，并且样式一致。那么就可以封装成一个按钮类。使用的时候直接使用这个类名称就 OK。 这也是 bootstrap，element ui，Antd，bulma 的做法。 这种框架的优势在于，封装了大量常见的 UI。比如你需要一个表单，，需要一个导航，需要一个弹窗，Card 卡片。有现成的 class。直接拿过来用，就可以快速的完成效果。完全不需要动手写 css。 这也是目前比较流行的方法。这几年几乎很少有项目是自己一点一点手写样式的了，多多少少都会使用到一些 css 框架。 对于一些需要快速交付的项目，非常适合使用这种组件化 css 框架。 第三个阶段，CSS 零件化。也叫做 CSS 原子化。和上面第一个阶段第二个阶段都有类似的地方。依旧是组件，只是每个组件都是一个单一功能的 css 属性。 上面第一个阶段的时候，我们讲了有些有对代码有追求的人，会开始复用 css。比如页面中大量的用到 float:left。那么就可以封装一个类，比如是这样 .left {float:left}然后需要使用 float:left 的时候，直接使用.left 就可以。 什么是Tailwind CSSTailwind CSS 是一个利用公用程序类（Utilize Class，下文皆称Utilize Class）的 CSS 框架。许多人会想到 CSS 框架，有很多，例如 Bootstrap、Bulma 和 Material UI。Bootstrap 和 Bulma 等框架利用预先准备好的组件（例如按钮、菜单和面包屑）进行设计。在 Tailwind CSS 中，没有准备任何组件，而是使用Utilize Class来创建和设计自己的组件。 Tailwind CSS 还提供了一个Headless UI (https://headlessui.dev)，如果你想创建复杂的组件（例如下拉菜单和对话框），你可以使用它。 原来Bootstrap等框架可以通过提前准备组件集合来高效地设计网站，但是有一个缺点，就是因为使用了相同的设计，所以没有原创性。相比之下，Tailwind CSS 没有组件集合，所以即使你创建一个名为相同按钮的组件，每个人都会应用不同的Utilize Class创建它，可以创建出一个高度原创的网站。 Tailwind CSS优缺点优点： 1.可定制化程度极高。你可以随心所欲写出自己的样式。想怎么折腾怎么折腾。如果使用 bootstrap，你如果想改变一个按钮的样式，就会比较困难。你得用覆盖式的写法，通过自己的样式覆盖掉 bootstrap 自带的样式。如果框架本身不支持修改，你通过自己的写法去修改框架本身的特性，这是一种很脏的写法。非常别扭。但是这个问题在 Tailwind CSS 完全不存在。Tailwind CSS 没有自以为是的封装任何样式给你。 2.不需要在写 css。使用 Tailwind CSS，基本可以不用再写 css。所有的效果都可以通过 class 名来完成。我用 Tailwind CSS 写了几个页面，到目前为止，还没有写过一行 css。 3.不需要再为 class 取个什么名字而苦恼。对于经常手写 css 的程序员来说，最大的噩梦可能就是怎么给 class 取名了。尤其是在同一个区块里面，区块名称，子元素名称，等等，一个页面动辄几十个几百个类名。非常痛苦。而这其中，真正能复用的 class 可能就个别几个。 使用 Tailwind CSS 完全不用为取名字烦恼，因为所有的 css 属性都被框架语义化封装好了。只需要在 class 里面引用就好。 4.响应式设计Tailwind CSS 遵循移动优先的设计模式。断点系统很灵活。也是目前所有 css 框架里做的最好的。比如你要实现一个媒体查询，根据不同的屏幕宽度实现不同的图片宽度。 缺点： 1.类名很长正如 Tailwind CSS 官网首页的口号一样，从此让你写样式不再离开 html 页面。Tailwind CSS 将 HTML 与 CSS 高度解耦，把本来 CSS 的一些工作转嫁给了 HTML。好处是使用 Tailwind CSS 你可以从此不再写 css。但坏处是你的 html 标签的类名会很长很长。比如 1&lt;a href=&quot;#&quot; class=&quot;text-sm font-medium bg-purple-600 rounded-full py-4 px-11 text-white inline-block border border-solid shadow hover:text-purple-600 hover:bg-white hover:border-purple-600 transition duration-300&quot; role=&quot;button&quot;&gt;Start Ticketing&lt;/a&gt; 2.熟悉使用有成本这一点逃避不了，所有的新技术，所有的 css 框架都有熟悉成本。Tailwind CSS 也一样。比如你想做一个圆角，那你得知道 Tailwind CSS 里面的圆角属性怎么写，边框怎么写，边框样式怎么写等等。你需要不断的去看文档。 常见兼容性问题？ 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin: 0; padding: 0;} 来统一。 IE下 event 对象有 event.x，event.y 属性，而 Firefox 下没有。Firefox 下有 event.pageX，event.PageY 属性，而 IE 下没有。 解决办法：var mx = event.x?event.x:event.pageX; Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了，解决方法是改变 CSS 属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 图片裁剪压缩技术一张 4px × 4px 的彩色图片，未压缩的的原始图像数据，就是一个 4 × 4 矩形网格，每一个网格代表一个像素。每一个像素，又是由 红，绿，蓝 三基色构成，1 个像素点需要 3 个字节。 一、图片压缩的原理 1.有损压缩 有损压缩是利用了人类对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比 本质和尺寸压缩本质上一样，用最中间的一个像素点代替周围的像素点 2.行程长度编码法（无损压缩） 常用的无损压缩算法，将一扫描行中颜色值相同的相邻像素用两个字节来表示， 第一个字节是一个计数值， 用于指定像素重复的次数； 第二个字节是具体像素的值。能够比较好地保存图像的质量，但是相对有损压缩来说这种方法的压缩率比较低 例如：499 500 500 500 501 → 499 500×3 501 3.熵编码法（无损压缩） 熵编码法是一种进行无损数据压缩的技术，在这个技术中一段文字中的每个字母被一段不同长度的比特(Bit)所代替。与此相对的是LZ77或者LZ78等数据压缩方法，在这些方法中原文的一段字母列被其它字母取代。 本质上看就是利用一个算法，把一段字母用一个或单个字母代替（端到端之间可以存一个压缩字符映射表） 例如：499 500 500 500 501 → -1 0 500 0 1 二、使用 Canvas 压缩图片 图片的本质和图片压缩原理及实现 压缩思路： 获取上传 Input 中的图片对象 File 将图片转换成 base64 格式 base64 编码的图片通过 Canvas 转换压缩，这里会用到的 Canvas 的 drawImage 以及 toDataURL 这两个 Api，一个调节图片的分辨率的，一个是调节图片压缩质量并且输出的，后续会有详细介绍 转换后的图片生成对应的新图片，然后输出 base64 编码指的是把二进制变成字符的过程，base64 解码就是把字符变回二进制的过程示例： 转换前 10101101,10111010,01110110 按照 编码规则 转换后 00101011, 00011011 ,00101001 ,00110110 十进制 43 27 41 54 对应 码表 中的值 r b p 2 所以上面的24位编码，编码后的Base64值为 rbp2 优点：实现简单，参数可以配置化，自定义图片的尺寸，指定区域裁剪等等。 缺点：只有 jpeg 、webp 支持原图尺寸下图片质量的调整来达到压缩图片的效果，其他图片格式，仅能通过调节尺寸来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;input-img&quot; @change=&quot;compress&quot; /&gt; &lt;a :download=&quot;fileName&quot; :href=&quot;compressImg&quot; &gt;普通下载&lt;/a&gt; &lt;button @click=&quot;downloadImg&quot;&gt;兼容 IE 下载&lt;/button&gt; &lt;div&gt; &lt;img :src=&quot;compressImg&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;compress&#x27;, data: function() &#123; return &#123; compressImg: null, fileName: null, &#125;; &#125;, components: &#123;&#125;, methods: &#123; compress() &#123; // 获取文件对象 const fileObj = document.querySelector(&#x27;#input-img&#x27;).files[0]; // 获取文件名称，后续下载重命名 this.fileName = `$&#123;new Date().getTime()&#125;-$&#123;fileObj.name&#125;`; // 获取文件后缀名 const fileNames = fileObj.name.split(&#x27;.&#x27;); const type = fileNames[fileNames.length-1]; // 压缩图片 this.handleCompressImage(fileObj, type); &#125;, handleCompressImage(img, type) &#123; const vm = this; let reader = new FileReader(); // 读取文件 reader.readAsDataURL(img); reader.onload = function(e) &#123; let image = new Image(); //新建一个img标签 image.src = e.target.result; image.onload = function() &#123; let canvas = document.createElement(&#x27;canvas&#x27;); let context = canvas.getContext(&#x27;2d&#x27;); // 定义 canvas 大小，也就是压缩后下载的图片大小 let imageWidth = image.width; //压缩后图片的大小 let imageHeight = image.height; canvas.width = imageWidth; canvas.height = imageHeight; // 图片不压缩，全部加载展示 context.drawImage(image, 0, 0); // 图片按压缩尺寸载入 // let imageWidth = 500; //压缩后图片的大小 // let imageHeight = 200; // context.drawImage(image, 0, 0, 500, 200); // 图片去截取指定位置载入 // context.drawImage(image,100, 100, 100, 100, 0, 0, imageWidth, imageHeight); vm.compressImg = canvas.toDataURL(`image/$&#123;type&#125;`); &#125;; &#125;; &#125;, // base64 图片转 blob 后下载 downloadImg() &#123; let parts = this.compressImg.split(&#x27;;base64,&#x27;); let contentType = parts[0].split(&#x27;:&#x27;)[1]; let raw = window.atob(parts[1]); let rawLength = raw.length; let uInt8Array = new Uint8Array(rawLength); for(let i = 0; i &lt; rawLength; ++i) &#123; uInt8Array[i] = raw.charCodeAt(i); &#125; const blob = new Blob([uInt8Array], &#123;type: contentType&#125;); this.compressImg = URL.createObjectURL(blob); if (window.navigator.msSaveOrOpenBlob) &#123; // 兼容 ie 的下载方式 window.navigator.msSaveOrOpenBlob(blob, this.fileName); &#125;else&#123; const a = document.createElement(&#x27;a&#x27;); a.href = this.compressImg; a.setAttribute(&#x27;download&#x27;, this.fileName); a.click(); &#125; &#125;, &#125;&#125;;&lt;/script&gt; 三、使用第三方库裁剪 Cropper.js 常用CSS巧用not选择器 有些情况下所有的元素都需要某些样式，唯独最后一个不需要，这时候使用not选择器将会特别方便 123li:not(:last-child)&#123; border-bottom: 1px solid #ebedf0;&#125; 使用flex布局实现智能固定底部 内容不够时，规则说明要处于底部，内容足够多时，规则说明随着内容往下沉，大家一定也遇到过类似的需求，使用flex巧妙实现布局。 123456789101112131415161718192021222324252627&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;我是内容区域&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;规则说明&lt;/div&gt;&lt;/div&gt; .container&#123; height: 100vh; /* 关键css处 */ display: flex; flex-direction: column; justify-content: space-between;&#125;.main&#123; /* 关键css处 */ flex: 1; background-image: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%); display: flex; align-items: center; justify-content: center; color: #fff;&#125;.footer&#123; padding: 15px 0; text-align: center; color: #ff9a9e; font-size: 14px;&#125; 文本超出中英文超过换行 word-break:break-word word-wrap:break-word 单行文本超过部分显示省略号 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行文本超过部分显示省略号 123456overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;word-break: break-all; 若使用vue，则可使用下面这种方式 12345display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden;word-break: break-all; 禁止选择文本1user-select: none; 画三角形12345678910111213141516171819202122232425262728293031&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-inner&quot;&gt; &lt;div class=&quot;triangle bottom&quot;&gt;&lt;/div&gt; &lt;div class=&quot;triangle right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;triangle top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;triangle left&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.triangle &#123; display: inline-block; margin-right: 10px; /* 基础样式 */ border: solid 10px transparent;&#125; /*下*/.triangle.bottom &#123; border-top-color: #0097a7;&#125; /*上*/.triangle.top &#123; border-bottom-color: #b2ebf2;&#125;/*左*/.triangle.left &#123; border-right-color: #00bcd4;&#125;/*右*/.triangle.right &#123; border-left-color: #009688;&#125; 画小箭头12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-inner&quot;&gt; &lt;div class=&quot;arrow bottom&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arrow top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arrow right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;arrow left&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.arrow &#123; display: inline-block; margin-right: 10px; /* 基础样式 */ width: 0; height: 0; /* 基础样式 */ border: 16px solid; border-color: transparent #CDDC39 transparent transparent; position: relative; &#125; .arrow::after &#123; content: &quot;&quot;; position: absolute; /* 通过位移覆盖背景 */ right: -20px; top: -16px; border: 16px solid; border-color: transparent #fff transparent transparent; &#125; /*下*/ .arrow.bottom &#123; transform: rotate(270deg); &#125; /*上*/ .arrow.top &#123; transform: rotate(90deg); &#125; /*左*/ .arrow.left &#123; transform: rotate(180deg); &#125; /*右*/ .arrow.right &#123; transform: rotate(0deg); &#125; 网页呈现哀悼模式123body&#123; filter: grayscale(1);&#125;","categories":[{"name":"C_H5和CSS","slug":"C-H5和CSS","permalink":"https://fuyunjinglong.github.io/categories/C-H5%E5%92%8CCSS/"}],"tags":[]},{"title":"0基础_JS","slug":"B_JS_0基础","date":"2099-05-28T23:33:16.000Z","updated":"2024-09-03T23:07:51.808Z","comments":true,"path":"2099/05/29/B_JS_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基础电脑是怎么把代码转换成可执行程序的编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成 编译器是一种翻译程序，它用于将源语言（程序设计语言写成）翻译为用二进制表示的伪机器代码程序，通常有两种方式进行翻译，一种是编译，另一种是解释。 想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，你可以通过两种方式遵循其指示。 首先是有人已经为你翻译成英文，你可以阅读食谱的英语版本，做鹰嘴豆泥。那么翻译的配方就是 编译版本。 第二种方法是，如果你有一位了解古希腊语的朋友，当你准备制作鹰嘴豆泥时，你的朋友会坐在你的旁边，将菜谱逐行翻译成英语。在这种情况下，你的朋友是食谱 解释版本 的解释者。 编译型 解释型 特点 可直接执行，每次需要进行更改时，你都需要“重建”程序 一边编译一边执行，逐行解释，逐行执行程序的每个命令 优点 快 语言更加灵活，并且通常具有诸如动态键入和程序较小。解释器自己执行源程序代码，因此代码本身相对于平台是独立的 缺点 编译步骤需要额外的时间，生成的二进制代码对平台的依赖性 慢，因为在运行时翻译代码的过程增加了开销，并可能导致程序整体变慢。 举例 java,C，C ++，Erlang，Rust 和 Go PHP，Ruby，Python 和 JavaScript 8种数据类型 基本类型：Number,String,Boolean,Null,undefined,symbol 引用类型：Object,Array,function null和undefined null 表示“定义了但是为空”,判空：if(a)。null是JS中的关键字，null会自动转为0。null 典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 undefined 表示未定义，它的类型只有一个值，就是 undefined，判空：if(a===undefined)，未定义的值和定义未赋值的为 undefined。undefined是JS中的全局变量。undefined会自动转为NaN。 变量被声明了，但没有赋值时，就等于 undefined。 调用函数时，应该提供的参数没有提供，该参数等于 undefined。 对象没有赋值的属性，该属性的值为 undefined。 函数没有返回值时，默认返回 undefined。 从内存来看 null 和 undefined 本质的区别是什么？ 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。 给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值 isNaN和Number.isNaN isNaN是es5的语法特性,自动进行隐式转为数字类型，如果非数字则为true,数字则为false Number.isNaN是es6的语法特性，除了Number.isNaN(NaN)返回true,其他任意值都是返回false 1234567891011121314151617&lt;html&gt;&lt;script &gt;console.log(isNaN(NaN));// trueconsole.log(isNaN(12));// falseconsole.log(isNaN(&#x27;d&#x27;));// trueconsole.log(isNaN(&#x27;0xd&#x27;));// false,十六进制console.log(isNaN(&#x27;123abc&#x27;));// trueconsole.log(NaN === NaN);// falseconsole.log(NaN === undefined);// falseconsole.log(typeof NaN);// numberconsole.log(Object.prototype.toString.call(NaN));// [object,Number]console.log(Number.isNaN(NaN));// trueconsole.log(Number.isNaN(123));// falseconsole.log(Number.isNaN(&#x27;abc&#x27;));// false &lt;/script&gt;&lt;/html&gt; JS 类型判断-对象,数组第一，使用 typeof 加 length 属性 数组有 length 属性，object 没有，而 typeof 数组与对象都返回 object，所以我们可以这么判断 1234567891011var getDataType = function(o)&#123; if(typeof o == &#x27;object&#x27;)&#123; if( typeof o.length == &#x27;number&#x27; )&#123; return &#x27;Array&#x27;; &#125; else &#123; return &#x27;Object&#x27;; &#125; &#125; else &#123; return &#x27;param is no object type&#x27;; &#125;&#125;; 第二，使用 instanceof 利用 instanceof 判断数据类型是对象还是数组时应该优先判断 array，最后判断 object。 123456789var getDataType = function(o)&#123; if(o instanceof Array)&#123; return &#x27;Array&#x27; &#125; else if ( o instanceof Object )&#123; return &#x27;Object&#x27;; &#125; else &#123; return &#x27;param is no object type&#x27;; &#125;&#125;; JS类型判断-完整typeof 缺点：无法区分null，数组，对象 123456789101112typeof null ------------------&gt;&quot;object&quot;typeof [1,2,3] ------------------&gt;&quot;object&quot;typeof ibj ------------------&gt;&quot;object&quot;typeof new Date() ------------------&gt;&quot;object&quot;typeof new RegExp() ------------------&gt;&quot;object&quot;typeof &quot;helloworld&quot; ------------------&gt;&quot;string&quot; typeof 123 ------------------&gt;&quot;number&quot;typeof new Function() ------------------&gt;&quot;function&quot;typeof Symbol() ------------------&gt;&quot;symbol&quot;typeof true ------------------&gt;&quot;true&quot;typeof undefined ------------------&gt;&quot;undefined&quot;typeof &#x27;undefined&#x27; ------------------&gt;&quot;string&quot; instanceof 缺点：不能区分undefined和null，不能区分Object和Function。对于基本类型如果不是用new声明的则也测试不出来，对于是使用new声明的类型，它还可以检测出多层继承关系。 123456789101112131415161718192021222324252627console.log(bool instanceof Boolean);// falseconsole.log(num instanceof Number);// falseconsole.log(str instanceof String);// falseconsole.log(und instanceof Object);// falseconsole.log(arr instanceof Array);// trueconsole.log(nul instanceof Object);// falseconsole.log(obj instanceof Object);// trueconsole.log(fun instanceof Function);// truevar bool2 = new Boolean()console.log(bool2 instanceof Boolean);// truevar num2 = new Number()console.log(num2 instanceof Number);// truevar str2 = new String()console.log(str2 instanceof String);// truefunction Person()&#123;&#125;var per = new Person()console.log(per instanceof Person);// truefunction Student()&#123;&#125;Student.prototype = new Person()var haoxl = new Student()console.log(haoxl instanceof Student);// trueconsole.log(haoxl instanceof Person);// true 手写instanceof 123456789101112131415const self_instanceof = function (instance, constructor) &#123; let instance_proto = instance.__proto__; let constructor_proto = constructor.prototype; while(true) &#123; // 找到终点返回false if (instance_proto === null) &#123;return false&#125;; // 找到返回true if (instance_proto === constructor_proto) &#123;return true&#125;; // 当实例与构造函数原型不相同, 沿着原型链继续向上查找 instance_proto = instance_proto.__proto__; &#125;&#125;console.log([] instanceof Array) // trueconsole.log(self_instanceof([], Array)) // true constructor constructor主要是利用原型上的prototype.constructor指向实例的构造函数来进行判断的。 缺点：不能判断undefined和null，并且使用它是不安全的，因为contructor的指向是可以改变的 123456console.log(&#x27;1&#x27;.constructor === String); // trueconsole.log(new Number(1).constructor === Number); // trueconsole.log(true.constructor === Boolean); // trueconsole.log(alert.constructor === Function); // trueconsole.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // true toString toString是Object.prototype上的一个方法, 常用方式为 Object.prototype.toString.call(target)返回值是 [object 类型]字符串,该方法基本上能判断所有的数据类型(自定义数据类型除外) 1234567891011121314// 定义判断类型函数let getType = target =&gt; Object.prototype.toString.call(target)console.log(getType(&#x27;&#x27;)); // [object String]console.log(getType(2)); // [object Number]console.log(getType(true)); // [object Boolean]console.log(getType(undefined)); // [object Undefined]console.log(getType(null)); // [object Null]console.log(getType(Symbol())); // [object Symbol]console.log(getType(&#123;&#125;)); // [object Object]console.log(getType([])); // [object Array]console.log(getType(alert)); // [object Function]console.log(getType(new RegExp())); // [object RegExp]console.log(getType(new Date())); // [object Date] 模块化规范参考 前端模块化详解(完整版) 模块化是什么？ 按照一定的规则(规范)封装成几个块(文件), 并自由组合在一起 对内数据封装，对外暴露接口 模块化详解 ESModule支持es6语法的浏览器规范 CommonJS 是同步支持nodejs的后端规范 UMD统一模块规范，支持amd和cmd(amd和cmd一般不单独使用)，支持全局变量Vue 12常用的是ESM和CJS,其中UMD还可以指定全局变量浏览器端使用ESM和UMD,nodejs使用CJS ESModule 简称ESM,是一个符合ES6语法的模块化规范，语法为：import export。 ECMAScript 6 的一个目标是解决作用域的问题，也为了使 JS 应用程序显得有序，于是引进了模块。目前部分主流浏览器已原生支持 ES Module，使用 type = module 指定为模块引入即可注意：使用该方式执行 JS 时自动应用 defer 属性。 ESM由于具有简单的语法，同步异步加载的特性，适用于前后端，以及Tree-shakeable的特性.具有Tree-shakeable的特性，这是由于ES6的静态模块结构。 1234567import &#123;foo, bar&#125; from &#x27;./myLib&#x27;;...export default function() &#123; // your Function&#125;;export const function1() &#123;...&#125;;export const function2() &#123;...&#125;; 在很多现代浏览器可以使用 它兼具两方面的优点：具有 CJS 的简单语法和 AMD 的异步 得益于 ES6 的静态模块结构，可以进行 Tree Shaking ESM 允许像 Rollup 这样的打包器，删除不必要的代码，减少代码包可以获得更快的加载 可以在 HTML 中调用，只要如下 12345&lt;script type=&quot;module&quot;&gt; import &#123;func1&#125; from &#x27;my-lib&#x27;; func1();&lt;/script&gt; **CommonJS ** 简称CJS,是同步支持nodejs的后端规范。语法为：module.exports，require。 12345678// importing const doSomething = require(&#x27;./doSomething.js&#x27;); // exportingmodule.exports = function doSomething(n) &#123; // do something&#125;复制代码 很多人可以从 Node 中立刻认出 CJS 的语法。这是因为 Node 就是使用 CJS 模块的 CJS 是同步导入模块 你可以从 node_modules 中引入一个库或者从本地目录引入一个文件 。如 const myLocalModule = require(&#39;./some/local/file.js&#39;) 或者 var React = require(&#39;react&#39;); ，都可以起作用 当 CJS 导入时，它会给你一个导入对象的副本 CJS 不能在浏览器中工作。它必须经过转换和打包 CommonJS和es6区别 因为CommonJS的require语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ； CommonJS 模块输出的是一个值的拷贝，而ES6 模块输出的是值的引用； CommonJS 模块是动态引入，执行时引入，而ES6 模块是静态引入，编译时引入； 因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值； 关于模块顶层的this指向问题，在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined； UMD 简称统一模块规范，支持amd和cmd(amd和cmd一般不单独使用)，支持全局变量Vue 当使用 Rollup/Webpack 之类的打包器时，UMD 通常用作备用模块 AMD 代表异步模块定义。 12345678910define([&#x27;dep1&#x27;, &#x27;dep2&#x27;], function (dep1, dep2) &#123; //Define the module value by returning a value. return function () &#123;&#125;;&#125;);或者define(function (require) &#123; var dep1 = require(&#x27;dep1&#x27;), dep2 = require(&#x27;dep2&#x27;); return function () &#123;&#125;;&#125;); AMD 是异步(asynchronously)导入模块的(因此得名) 一开始被提议的时候，AMD 是为前端而做的(而 CJS 是后端) AMD 的语法不如 CJS 直观。我认为 AMD 和 CJS 完全相反 模块化进化过程 全局function模式 将不同的功能封装成不同的全局函数 编码: 将不同的功能封装成不同的全局函数 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系 namespace模式 简单对象封装 作用: 减少了全局变量，解决命名冲突 问题: 数据不安全(外部可以直接修改模块内部的数据) 1234567891011let myModule = &#123; data: &#x27;www.baidu.com&#x27;, foo() &#123; console.log(`foo() $&#123;this.data&#125;`) &#125;, bar() &#123; console.log(`bar() $&#123;this.data&#125;`) &#125;&#125;myModule.data = &#x27;other data&#x27; //能直接修改模块内部的数据myModule.foo() // foo() other data IIFE模式 匿名函数自调用(闭包) 作用: 数据是私有的, 外部只能通过暴露的方法操作 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 问题: 如果当前这个模块依赖另一个模块怎么办? 123456789101112131415161718192021222324252627// index.html文件&lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; myModule.data = &#x27;xxxx&#x27; //不是修改的模块内部的data myModule.foo() //没有改变&lt;/script&gt;// module.js文件(function(window) &#123; let data = &#x27;www.baidu.com&#x27; //操作数据的函数 function foo() &#123; //用于暴露有函数 console.log(`foo() $&#123;data&#125;`) &#125; function bar() &#123; //用于暴露有函数 console.log(`bar() $&#123;data&#125;`) otherFun() //内部调用 &#125; function otherFun() &#123; //内部私有的函数 console.log(&#x27;otherFun()&#x27;) &#125; //暴露行为 window.myModule = &#123; foo, bar &#125; //ES6写法&#125;)(window) IIFE模式增强 引入依赖,这就是现代模块实现的基石。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。 123456789101112131415161718192021// module.js文件(function(window, $) &#123; let data = &#x27;www.baidu.com&#x27; //操作数据的函数 function foo() &#123; //用于暴露有函数 console.log(`foo() $&#123;data&#125;`) $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;) &#125; function bar() &#123; //用于暴露有函数 console.log(`bar() $&#123;data&#125;`) otherFun() //内部调用 &#125; function otherFun() &#123; //内部私有的函数 console.log(&#x27;otherFun()&#x27;) &#125; //暴露行为 window.myModule = &#123; foo, bar &#125;&#125;)(window, jQuery) slice(),splice()两种方法slice(start,end)有两个参数(start必需,end选填),都是索引,返回值不包括end,不改变原数组 123var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];console.log(heroes.slice(1,4))// [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ]开始索引为1 结束索引为4(不包括4)console.log(heroes)// 不改变原数组 [&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;] splice(index,howmany,item1…itemX)只返回被删除的数据,类型为数组(改变原数组) 123var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];console.log(heroes.splice(1,2))// [ &quot;1&quot;, &quot;2&quot;]开始索引为1 删除2个元素console.log(heroes)// 不改变原数组 [&quot;0&quot;,&#x27;3&#x27;,&#x27;4&#x27;] typeof 与 instanceof 区别6种基本数据类型：string,Number,boolean,undefined,null,symbol,其他类型如object,function,Array等 typeof会返回一个变量的基本类型，typeof ‘1’ // ‘string’ instanceof 可以准确地判断复杂引用数据类型，[1] instanceof Array //true 其中instance原理参考： 1234567891011function myInstanceof(left, right) &#123; // 这里先用typeof来判断基础数据类型，如果是，直接返回false if(typeof left !== &#x27;object&#x27; || left === null) return false; // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象 let proto = Object.getPrototypeOf(left); while(true) &#123; if(proto === null) return false; if(proto === right.prototype) return true;//找到相同原型对象，返回true proto = Object.getPrototypeof(proto); &#125;&#125; 终极检查数据类型工具 1234567891011121314151617181920212223Object.prototype.toString(&#123;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也okObject.prototype.toString.call(1) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;1&#x27;) // &quot;[object String]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(function()&#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) //&quot;[object Null]&quot;Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;Object.prototype.toString.call(/123/g) //&quot;[object RegExp]&quot;Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;Object.prototype.toString.call([]) //&quot;[object Array]&quot;Object.prototype.toString.call(document) //&quot;[object HTMLDocument]&quot;Object.prototype.toString.call(window) //&quot;[object Window]&quot;function getType(obj)&#123; let type = typeof obj; if (type !== &quot;object&quot;) &#123; // 先进行typeof判断，如果是基础数据类型，直接返回 return type; &#125; // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, &#x27;$1&#x27;); &#125;getType(&#x27;123&#x27;) // &quot;string&quot; JS对象的两类属性第一类属性，数据属性具有四个特征 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 第二类属性是访问器（getter/setter）属性，它也有四个特征。 getter：函数或undefined，在取属性值时被调用。 setter：函数或undefined，在设置属性值时被调用。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 JavaScript、ES5、ES6什么是JavaScript JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能 JavaScript由三部分组成： ECMAScript（核心） DOM（文档对象模型） BOM （浏览器对象模型） 1.ECMAScript（核心） 作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象 2.DOM（文档对象模型） DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。 3.BOM （浏览器对象模型） 支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 PS：BOM未形成规范 什么是ES5 作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下： 1.strict模式 严格模式，限制一些用法，’use strict’; 2.Array增加方法 增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法 PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now 3.Object方法 Object.getPrototypeOf Object.create Object.getOwnPropertyNames Object.defineProperty Object.getOwnPropertyDescriptor Object.defineProperties Object.keys Object.preventExtensions / Object.isExtensible Object.seal / Object.isSealed Object.freeze / Object.isFrozen PS：只讲有什么，不讲是什么。 什么是ES6 ECMAScript6在保证向下兼容的前提下，提供大量新特性： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand） 3.赋值解构 4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread） 5.箭头函数 Arrow functions (1).简化了代码形式，默认return表达式结果。 (2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 6.字符串模板 Template strings 7.Iterators（迭代器）+ for..of 迭代器有个next方法，调用会返回： (1).返回迭代对象的一个元素：{ done: false, value: elem } (2).如果已到迭代对象的末端：{ done: true, value: retVal } 8.生成器 （Generators） 9.Class,有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用） 10.Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点： (1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。 (2).类似AMD，支持异步加载和可配置的模块加载。 11.Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 12.Math + Number + String + Array + Object APIs 13.Proxy,使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 14.Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。 15.Promises,Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。 合并数组使用 Array.concat() 123var array1 = [1, 2, 3];var array2 = [4, 5, 6];console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存. 可以使用 Array.push.apply(arr1, arr2) 来代替创建新的数组，它可以把第二个数组合并到第一个中，从而较少内存消耗。 1console.log(array1.push.apply(array1, array2)); // [1, 2, 3, 4, 5, 6] async和defer的作用是什么？有什么区别? script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。 async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。 defer script：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。 0.1+0.2!==0.3精度丢失JS中数字的范围 JS中所有数字都是64位，JS引擎会默认保留最多17位的有效小数，数据范围是(-2^53, 2^53)。最大的安全的整数为什么是2的53次方减一？ 说明： 第0位：符号位，0表示正数，1表示负数(s) 第1位到第11位：储存指数部分（e） 第12位到第63位：储存小数部分（即有效数字）f 十进制转为二进制原理 0.1：0.0 0011 0011 0011…(无限循环) 0.2：0.0011 0011 0011…(无限循环) 小数取17位最后得到0.300…4 三大山-原型和原型链彻底搞懂this小结： 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例 call、apply和bind：this 是第一个参数 箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。 为什么要有 this？ 官方解释： this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。 看一段代码： 1234567891011function say() &#123; console.log(&quot;你好！&quot;, this.name);&#125;let person1 = &#123; name: &#x27;小猪课堂&#x27;&#125;let person2 = &#123; name: &#x27;张三&#x27;&#125;say.call(person1); // 你好！ 小猪课堂say.call(person2); // 你好！ 张三 如果我们没有 this，那么我们就需要显式的将上下文对象传入函数，即显式传入 person1 和 person2 对象。 this的定义 this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this 是在运行时绑定的，不是在编写时绑定 this 的绑定与函数的声明和位置没有任何关系 函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。 this的绑定规则 绑定流程：先确定函数调用位置，然后确定使用哪条规则，然后根据规则确定 this 绑定。 绑定优先级：默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定 4条核心绑定规则 默认绑定(函数的普通调用)：this 绑定到全局对象 隐式绑定(函数作为对象方法调用)：一般绑定到调用对象，如 obj.foo 绑定到 obj 显示绑定(函数通过call、apply、bind间接调用)：通过 call、apply 指定 this 绑定到哪里。使用 bind 函数硬绑定 new绑定(函数作为构造函数调用)：使用 new 关键词，绑定到当前函数对象 判断 this 最终指向，总体流程： 判断函数调用时是否使用了 new，即 new 绑定，如果使用了，则 this 绑定的是新创建的对象。 函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。 函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。 以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，在严格模式下，默认绑定的 this 是 undefined，非严格模式下绑定到全局对象。 1.默认绑定(函数的普通调用) 当函数不带用任何修饰进行调用时，此时 this 的绑定就是默认绑定规则，this 指向全局对象。 let变量声明不会绑定在window上面，只有var声明的才会，这是需要注意的。除此之外，严格模式下上段代码的 this 是 undefined， 123456var name = &#x27;小猪课堂&#x27;;function foo()&#123; console.log(this) // Window&#123;&#125; console.log(this.name) // 小猪课堂&#125;foo(); // 小猪课堂 在全局作用域中定义了一个变量name，然后我们在函数 foo 中使用this.name，输出的结果就是全局变量name，这说明我们 this 指向了全局作用域，也就是说 this 绑定到了 window 对象上。 函数的这种调用方式就被称为默认绑定，默认绑定规则下的 this 指向全局对象。 2.隐式绑定(函数作为对象方法调用) 1234567891011//var foo=()=&gt; &#123;// console.log(this.name) // undefined//&#125;function foo() &#123; console.log(this.name) // 小猪课堂&#125;let obj = &#123; name: &#x27;小猪课堂&#x27;, foo: foo&#125;obj.foo(); 在 obj 对象中引用了函数 foo，然后我们使用 obj.foo（函数别名）的方式调用了该函数，此时不是独立函数调用，我们不能使用默认绑定规则。 此时 this 的绑定规则称为隐式绑定规则，因为我们不能直接看出函数的调用位置，它的实际调用位置在 obj 对象里面，调用 foo 时，它的执行上下文对象为 obj 对象，所以 this 将会被绑定到 obj 对象上，所以我们函数中的 this.name 其实就是obj.name。这就是我们的隐式绑定规则。 i.多个引用调用 如果我们调用函数时有多个引用调用，比如obj1.obj2.foo()。这个时候函数 foo 中的 this 指向哪儿呢？其实不管引用链多长，this 的绑定都由最顶层调用位置确定，即obj1.obj2.foo()的 this 还是绑定带 obj2。 ii隐式绑定中 this 丢失 在隐式绑定规则中，我们认为谁调用了函数，this 就绑定谁，比如 obj.foo 中 this 就绑定到 obj，但是有一些情况比较特殊，即使采用的隐式绑定规则，但是 this 并没有按照我们的想法去绑定，这就是所谓的隐式绑定 this 丢失，常见于回调函数中。 12345678910111213function foo() &#123; console.log(this.name) // 小猪课堂&#125;function doFoo(fn) &#123; fn(); // 函数调用位置&#125;let obj = &#123; name: &#x27;张三&#x27;, foo: foo&#125;let name = &#x27;小猪课堂&#x27;;doFoo(obj.foo); // 小猪课堂 上段代码中我们很容易会以为 foo 绑定的 this 是 obj 对象，因为我们使用了 obj.foo 的方式，这种方式就是遵循隐式绑定规则。但是事实上 this 却绑定到了全局对象上去，这是因为我们在 doFoo 函数中调用 fn 时，这里才是函数的实际调用位置，此时是独立函数调用，所以 this 指向了全局对象。 实际项目中我们容易遇到这种问题的场景可能就是定时器了，比如下面的代码： 1setTimeout(obj.foo, 100) 这种写法就很容易造成 this 丢失。 3.显示绑定(函数通过call、apply、bind间接调用) 明确的将函数的 this 绑定在某个对象上。使用call、apply、bind。其中bind就是硬绑定。 虽然显式绑定本身不能解决 this 绑定丢失的问题，但是我们可以通过变通的方式来解决这个问题，也被称作硬绑定。 硬绑定： 123456789101112131415function foo() &#123; console.log(this.name) // 小猪课堂&#125;function doFoo(fn) &#123; fn(); // 函数调用位置&#125;let obj = &#123; name: &#x27;张三&#x27;,&#125;let bar = function () &#123; foo.call(obj)&#125;let name = &#x27;小猪课堂&#x27;;doFoo(bar); // 张三setTimeout(bar, 100); // 张三 其实思路也比较简单，出现 this 绑定丢失原因无非就是我们传入的回调函数在被执行时，this 绑定规则变为了默认绑定，那么为了解决这个问题，我们不妨在封装一个函数，将 foo 函数的 this 显式绑定到 obj 对象上去即可。 这里提一点，下面写法是错误的： 1doFoo(foo.call(obj)); 因为回调函数是在 doFoo 里面执行的，上面的写法相当于 foo 函数立即执行了。 4.new绑定(函数作为构造函数调用) 使用 new 来调用函数时，会执行下面操作： 创建一个全新的对象 这个新对象会被执行原型连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其它对象，那么 new 表达式种的函数调用会自动返回这个新对象 我们可以看到 new 的操作中就有 this 的绑定，我们在来看看代码。 代码如下： 123456function foo(name) &#123; this.name = name;&#125;let bar = new foo(&#x27;小猪课堂&#x27;);console.log(bar.name); // 小猪课堂复制代码 上段代码我们使用 new 关键词调用了 foo 函数，大家注意这不是默认调用规则，这是 new 绑定规则。 练习绑定： 1234567891011121314151617181920212223242526272829303132var name = &#x27;window&#x27;const person1 = &#123; name: &#x27;person1&#x27;, show1: function () &#123; console.log(this.name) &#125;, show2: () =&gt; console.log(this.name), show3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, show4: function () &#123; return () =&gt; console.log(this.name) &#125;&#125;const person2 = &#123; name: &#x27;person2&#x27; &#125;person1.show1() // person1 函数作为对象方法调用，this指向对象person1.show1.call(person2) // person2 使用call间接调用函数，this指向传入的person2person1.show2() // window 箭头函数无this绑定，在全局环境找到this，指向windowperson1.show2.call(person2) // window 间接调用改变this指向对箭头函数无效person1.show3()() // window person1.show3()返回普通函数，相当于普通函数调用，this指向windowperson1.show3().call(person2) // person2 使用call间接调用函数，this指向传入的person2person1.show3.call(person2)() // window person1.show3.call(person2)仍然返回普通函数person1.show4()() // person1 person1.show4调用对象方法，this指向person1，返回箭头函数，this在person1.show4调用时的词法环境中找到，指向person1person1.show4().call(person2) // person1 间接调用改变this指向对箭头函数无效person1.show4.call(person2)() // person2 改变了person1.show4调用时this的指向，所以返回的箭头函数的内this解析改变 参考 面试官：JS中this指向哪儿？你是如何确定this的？ call/apply/bind回顾call/apply/bind用法 123456789101112131415161718192021function sayHelloTo (to) &#123; console.log(`$&#123;this.name&#125; say hello to $&#123;to&#125;`)&#125;var Jerry = &#123; name: &#x27;Jerry&#x27;&#125;sayHelloTo.call(Jerry, &#x27;Tom&#x27;)//Jerry say hello to Tom.var Foo = &#123; name: &#x27;Foo&#x27;&#125;sayHelloTo.apply(Foo, [&#x27;Bar&#x27;])//Foo say hello to Bar.var XYZ = &#123; name: &#x27;XYZ&#x27;&#125;var say = sayHelloTo.bind(XYZ)say(&#x27;ABC&#x27;)//XYZ say hello to ABC. call/apply 123- 第一个参数就是改变 this 的指向，写谁就是谁，在非严格模式下，null/undefined 指向的是 window。- call/apply 的唯一区别就是，传递参数不一样，apply 第二个参数是数组，call的参数是一个一个传递。- call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候） bind 1- call/apply都是改变this的同时就把函数执行了，但是bind不是立即执行函数，属于预先改变this和传递一些内容，利用的是柯理化的思想。 小结： 当我们使用一个函数需要改变this指向的时候才会用到call``apply``bind 如果你要传递的参数不多，则可以使用fn.call(thisObj, arg1, arg2 ...) 如果你要传递的参数很多，则可以用数组将参数整理好调用fn.apply(thisObj, [arg1, arg2 ...]) 如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用const newFn = fn.bind(thisObj); newFn(arg1, arg2...) 经典面试题： 12345678910111213141516171819202122// 谁调用我，我就指向谁var name = 222var a=&#123; name:111, say:function()&#123; console.log(this.name); &#125;&#125;var fun = a.sayfun() // fun.call(window)a.say() // a.say.call(a)var b=&#123; name:333, say:function(fn)&#123; fn(); // fn.call(window),难点 &#125;&#125;b.say(a.say) // 相当于把函数当进去执行，这种函数作为入参的，都是指向全局window，所以就是fn.call(window)b.say=a.sayb.say() // b.say.call(b) call、apply、bind更详细用法 怎么利用 call、apply 来求一个数组中最大或者最小值 ? 如何利用 call、apply 来做继承 ? apply、call、bind 的区别和主要应用场景 ? 利用 call、apply 来求一个数组中最大或者最小值 1234const arr = [1,8,6]Math.max.apply(Math或null, arr); //8Math.max.call(Math或null, 1,8,6); //8Math.max(...arr); //8 es6扩展运算符法 手写call 核心思路是： 为传入的context扩展一个属性，将原函数指向这个属性 将context之外的所有参数全部传递给这个新属性，并将运行结果返回。 一些细节： 利用rest 参数(…args)可以存储函数多余的参数 为传入的context扩展参数扩展新属性使用了**Symbol()数据类型**，这样确保不会影响到传入的context，因为Symbol值一定是独一无二的。 用扩展运算符(…)将原来是数组的args转发为逗号分隔一个个参数传入到函数中 为什么能找到this.name呢？因为context[fnSymbol]中的this指向的是context。 1234567891011121314Function.prototype.myCall = function(context, ...args) &#123; // 判断是否是undefined和null if (typeof context === &#x27;undefined&#x27; || context === null) &#123; context = window &#125; // 思路和call是一样的只是传参不同方式 let fnSymbol = Symbol() context[fnSymbol] = this //通过隐式绑定的方式调用函数 let fn = context[fnSymbol] (...args) //删除添加的属性 delete context[fnSymbol] return fn&#125; 手写apply 思路和call是一样的只是传参不同方式 12345678910Function.prototype.myApply = function(context, args) &#123; // 判断是否是undefined和null if (typeof context === &#x27;undefined&#x27; || context === null) &#123; context = window &#125; let fnSymbol = Symbol() context[fnSymbol] = this let fn = context[fnSymbol] (...args) return fn&#125; 手写bind 12345678910Function.prototype.myBind = function(context) &#123;// 判断是否是undefined和null if (typeof context === &quot;undefined&quot; || context === null) &#123; context = window; &#125; self = this; return function() &#123; return self.apply(context); &#125;&#125; 参考 手写源码系列（一）——call、apply、bin 三大山-作用域和闭包作用域-执行上下文参考 JavaScript 深入之执行上下文栈； JavaScript 深入之变量对象； JavaScript 深入之作用域链； JavaScript 深入之执行上下文。 执行上下文 定义：执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。 它包含三部分 变量对象（VO） 作用域链（词法作用域） this 指向 它的类型： 全局执行上下文 函数执行上下文 eval 执行上下文 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。 Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。 代码执行过程： 创建 全局上下文（global EC） 全局执行上下文（caller）自上而下 逐行执行。遇到函数时，函数执行上下文（callee）被 push 到执行栈顶 函数执行上下文被激活，成为 active EC，开始执行函数中的代码，caller 被挂起 函数执行完后，callee 被 pop 移除出执行栈，控制权交还给全局上下文（caller）继续执行 包括三个阶段：创建阶段→执行阶段→回收阶段 1.创建阶段 当函数被调用，但未执行任何其内部代码之前，会做以下三件事： 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。 确定this指向：包括多种情况，下文会详细说明 在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。 另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。 2.执行阶段 执行变量赋值、代码执行 3.回收阶段 执行上下文出栈等待虚拟机回收执行上下文 作用域与执行上下文 JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段。解释阶段确定作用域规则，执行阶段确定上下文。太妙了 解释阶段： 词法分析 语法分析 作用域规则确定 执行阶段： 创建执行上下文 执行函数代码 垃圾回收 作用域和执行上下文之间最大的区别是：执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 作用域-变量对象(VO/AO/GO)JS有两个特性，一个是单线程，一个是解释性语言。 JS运行步骤：1.语法分析2.预编译3.解释执行 函数执行四部曲： 1.创建AO对象，供js引擎自己去访问 activation object （活跃对象/执行期上下文） 2.找变量和形参的声明，作为AO对象的属性名，值是undefined 3.实参和形参相统一，实参赋值给形参 4.找函数声明(注意不是函数表达式)，会覆盖变量的声明。 123456789101112131415161718192021222324 function fn(a,c)&#123;console.log(a);//function a()&#123;&#125;var a=123;console.log(a);//123console.log(c);//function c()&#123;&#125;function a()&#123;&#125;if(false)&#123;var d= 678;&#125;console.log(d);//undefinedconsole.log(b);//undefinedvar b=function()&#123;&#125;console.log(b);//function ()&#123;&#125;function c()&#123;&#125;console.log(c);//function c()&#123;&#125;&#125;fn(1,2);AO&#123;a:undefined,1,function a()&#123;&#125;c:undefined,2,function c()&#123;&#125;d:undefined,b:undefined,&#125; 静态作用域与动态作用域 JavaScript 采用词法作用域(lexical scoping)，就是静态作用域。 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 12345678910var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value (价值) ，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value (价值) 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value (价值) 。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value (价值) 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 来自《JavaScript权威指南》中的例子： 123456789var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印：local scope。因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope (范围) 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 变量提升 变量声明提升 函数声明提升 有个细节必须注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。 1234567891011121314151617181920212223242526272829303132333435// 变量声明提升console.log(a)// undefinedvar a = 10// 函数声明提升function test() &#123; foo(); // Uncaught TypeError &quot;foo is not a function&quot; bar(); // &quot;this will run!&quot; var foo = function () &#123; // function expression assigned to local variable &#x27;foo&#x27; alert(&quot;this won&#x27;t run!&quot;); &#125; function bar() &#123; // function declaration, given the name &#x27;bar&#x27; alert(&quot;this will run!&quot;); &#125;&#125;test();// 复杂点例子function test(arg)&#123; // 1. 形参 arg 是 &quot;hi&quot; // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function console.log(arg); var arg = &#x27;hello&#x27;; // 3.var arg 变量声明被忽略， arg = &#x27;hello&#x27;被执行 function arg()&#123; console.log(&#x27;hello world&#x27;) &#125; console.log(arg); &#125;test(&#x27;hi&#x27;);/* 输出：function arg()&#123; console.log(&#x27;hello world&#x27;) &#125;hello */ 作用域-作用域与作用域链作用域 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。 作用域链 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。 作用域具体可细分为四种：**全局作用域、模块作用域、函数作用域、块级作用域** 全局作用域： 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。 模块作用域： 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（AMD、CommonJS、UMD、ES6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。 函数作用域： 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。 块级作用域： 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。 1234567891011// var demofor(var i=0; i&lt;10; i++) &#123; console.log(i);&#125;console.log(i); // 10// let demofor(let i=0; i&lt;10; i++) &#123; console.log(i);&#125;console.log(i); //ReferenceError：i is not defined 深浅拷贝var obj={} obj存放在栈内存中，{}实例存在在堆中。 12345678910111213141516171819//example 1let a=&#123;&#125;, b=&#x27;0&#x27;, c=0;a[b]=&#x27;珠峰&#x27;;a[c]=&#x27;培训&#x27;;console.log(a[b]); // &#x27;培训&#x27;, 对象的key数字和字符串等效// ---------------------//example 2let a=&#123;&#125;, b=Symbol(&#x27;1&#x27;), c=Symbol(&#x27;1&#x27;);a[b]=&#x27;珠峰&#x27;;a[c]=&#x27;培训&#x27;;console.log(a[b]); // &#x27;珠峰&#x27;, Symbol的特点，都是唯一的// ---------------------//example 3let a=&#123;&#125;, b=&#123;n:&#x27;1&#x27;&#125;, c=&#123;m:&#x27;2&#x27;&#125;;a[b]=&#x27;珠峰&#x27;;a[c]=&#x27;培训&#x27;;console.log(a[b]); // &#x27;培训&#x27;, key会转化成字符串[Obejct object] 赋值、浅拷贝、深拷贝 赋值：把一个对象赋给一个新变量，赋的其实是该对象在栈中的地址，所有值都会相互影响 浅拷贝：重新在堆中创建内存，拷贝后的基本数据类型不影响，但是引用类型属性是相互影响共用 深拷贝：重新在堆中创建内存，所有值都不相互影响 12345678910//赋值，全部影响var person=&#123; name:&#x27;jack&#x27;, play:[&#x27;篮球&#x27;,&#x27;足球&#x27;]&#125;var person2 =person;person2.name=&#x27;lucy&#x27;;person2.play[0]=&#x27;爵士&#x27;;console.log(person);console.log(person2); 123456//浅拷贝，基本类型不影响，引用类型数据共用// 1. ...扩展运算符实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 123456789101112131415//深拷贝，所有数据不影响// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === &#x27;object&#x27; ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; V8引擎1.定义 V8是一个由Google开源的采用C++编写的高性能JavaScript和WebAssembly引擎。 主要工作： 编译和执行js代码，即将js代码转换为机器代码； 处理调用栈； 内存分配和垃圾回收； 2.原理 V8的内部有很多模块，其中最重要的4个： Parser解析器:负责将js源代码解析成AST抽象语法树 Interpreter解释器:负责将AST解释为bytecode字节码文件，同时也有直接解释执行bytecode能力 complier编译器:负责编译出运行更加高效的机器代码 Orinoco: 垃圾回收器，负责进行内存空间回收 (1)AST抽象语法树 AST 抽象语法树——最基础的 javascript 重点知识，99% 的人根本不了解 Parser解析器在转换过程中有两个重要的阶段：词法分析（Lexical Analysis）和语法分析（Syntax Analysis）. 词法分析,也称为分词，是将字符串形式的代码转换为标记（token）序列的过程。 语法分析,语法分心是将词法分析产生的token按照某种给定的形式文法转换成AST的过程。也就是把单词组合成句子的过程. (2)byteCode (3)machine code 3.V8发展史 (1)早期的V8 早期的版本5.8以前，V8没有解释器，只有2个编译器。 所以流程是这样的： 解析器对js解析成AST，Full-codegen编译器(也叫基准编译器)对AST编译成机器代码(省去了bytecode，执行效率更高)。 在执行的过程，有分析线程对机器代码进行优化，需要解析器对js解析成AST，Crankshaft编译器(也称为优化编译器)对代码进行优化。 123456优点：省去了bytecode的转化，直接生成更加高效的machine code机器代码.缺点：V8团队的官方博客这样说,a.生成的机器码占用了大量内存b.缺少中间层的bytecode，很多性能优化策略无法实施c.js引擎无法很好的支持新的语法 (2)2017年4月新的V8架构 V8团队这样评价新架构：它代表了V8团队通过实际测量Javascript性能，并仔细研究Full-codegen和Crankshaft的缺点后收集到的共同见解的顶峰。 所以新的流程是这样的： 解析器对js解析成AST，Igniton基准解释器解释成bytecode字节码，并执行 执行一段时间后，TruboFan优化编译对bytecode字节码优化为更加高效的机器码 有几个优化点： 1.函数只声明未被调用，不会被解析成AST 2.函数只被调用一次，bytecode直接被解释执行，TruboFan不会进行优化编译 3.函数被调用多次，可能被标记为热点函数，可能被编译成机器代码 (3)新架构的特点 将优化后的bytecode和machine code形成共存的状态。 这里要注意deoptimization即回退字节码，即由解释器解释执行。函数类型发生变化时，Igniton会检测到变化，会将字节码回退，重新解释为新的字节码。 建议： 1.不要将函数的类型变来变去，尽量保证类型一致，如sum(x,y) x一会是int,一会儿是num 优点： 1.第一次执行，直接使用中间层的字节码，省去了机器码，同时编译器生成字节码的速度远远大于机器码 2.优化线程不需要从源码从新编译，而是从bytecode字节码开始优化就可以了。同时deoptimization只需要回退到字节码即可。 优化点： 12345671.隐藏类（hidden class）2.内联缓存（incline caching）3.优化 Orinoco3.1增量标记 - Incremental marking3.2懒性清理 - Lazy sweeping3.3并发 - Concurrent3.4并行 - Parallel 内存空间JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放基本变量，堆存放应用对象(引用地址存放在栈，真实变量在堆)，池存放常量，所以也叫常量池。 几个问题 问题1： 1234var a = 20;var b = a;b = 30;// 这时a的值是多少？ 问题2： 1234var a = &#123; name: &#x27;前端开发&#x27; &#125;var b = a;b.name = &#x27;进阶&#x27;;// 这时a.name的值是多少 问题3： 1234var a = &#123; name: &#x27;前端开发&#x27; &#125;var b = a;a = null;// 这时b的值是多少 现在来解答一下，三个问题的答案分别是20、‘进阶’、&#123; name: &#39;前端开发&#39; &#125; 对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。 对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。 对于问题3，首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。 JS的内存生命周期 1、分配你所需要的内存 2、使用分配到的内存（读、写） 3、不需要时将其释放、归还 垃圾回收(1)定义 JavaScript 中自动垃圾回收机制的原理为： 12找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。 (2)内存生命周期 不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放归还 对于javascript而言， 简单类型，内存是保存在栈（stack）空间 复杂数据类型，内存是保存在堆（heap）空间 (3)为什么需要垃圾回收机制？ 在Chrome中，v8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制？ 表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景。JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。 深层原因是，V8的垃圾回收机制的限制（垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，那么性能和应用直线下降） (4)垃圾收集机制 V8的垃圾回收策略主要是基于分代垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。 (1.1)内存模型 新生代：生存时间短的对象，支持 1～8M 的容量 老年代：生存时间长的对象，容量较大 为了提高回收效率，V8 分别使用两个不同的垃圾回收器， 副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。 主垃圾回收器 - Mark-Sweep &amp; Mark-Compact：主要负责老生代的垃圾回收。 (1.2)新生代回收 在新生代中，主要使用Scavenge算法进行垃圾回收，Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。 Scavange算法将新生代堆分为两部分，分别叫from-space和to-space。 工作过程如下： 标记活动对象和非活动对象 复制 from space 的活动对象到 to space 并对其进行排序 释放 from space 中的非活动对象的内存 将 from space 和 to space 角色互换 新生代又细分为nursery子代和intermediate子代两个区域。一个对象第一次分配内存时会被分配到新生代中的nursery子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 intermediate 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。 对象晋升的条件主要有以下两个： 对象是否经历过一次Scavenge算法 To空间的内存占比是否已经超过25%(之所以有25%的内存限制是因为To空间在经历过一次Scavenge算法后会和From空间完成角色互换，会变为From空间，后续的内存分配都是在From空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理) (1.3)老年代回收 scavenge算法缺陷： scavenge为复制算法，重复复制活动对象会使得效率低下 scavenge是牺牲空间来换取时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题 老年代采用 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。 1.）Mark-Sweep Mark-Sweep处理时分为两阶段，标记阶段和清理阶段。看起来与Scavenge类似，不同的是，Mark-Sweep在标记了活动对象和非活动对象之后，直接把非活动对象清除。 标记阶段：对老生代进行第一次扫描，标记活动对象 清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象 但是遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。 2.)Mark-Compact 若不清理这些内存碎片，如果出现需要分配一个大对象的时候，这时所有的碎片空间都完全无法完成分配，就会提前触发垃圾回收,而这次回收其实不是必要的。 Mark-Compact被提出，它是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。 (1.4)全停顿 Stop-The-World 由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为全停顿（stop-the-world）。 在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。 (5)标记活动对象和非活动对象的策略 通常有两个：引用计数和标记清除 引用计数-dom的垃圾回收机制 标记清除-js的垃圾回收机制 (1.1)引用计数 定义：每个值被引用的次数。声明一个变量后，当使用引用类型值赋值时，+1，当这个变量又赋值另外一值，计数-1。 这是最初级的垃圾收集算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 缺陷:在循环的情况下，引用计数算法存在很大的局限性。 1234567891011121314存在内存泄漏function problem() &#123;var objA = new Object();var objB = new Object();objA.someOtherObject = objB;objB.anotherObject = objA;&#125;objectA 和objectB 通过各自的属性相互引用，即这两个对象的引用次数都是2，在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和objectB 还说明将继续存在，因为它们的引用次数永远不会是0。DOM中也如此var element=document.getElementById（&#x27;&#x27;）；var myObj=new Object();myObj.element=element;element.someObject=myObj; (1.2)标记清除 定义：当变量进入环境时，标记“进入环境”。当变量离开环境时，标记“离开环境”。 垃圾回收器创建了一个“roots”列表,“window”对象是一个全局变量，被当作root. 从root开始的所有对象如果是可达的，它就不被当作垃圾。所有未被标记的内存会被当做垃圾，收集器现在可以释放内存。 循环引用的问题迎刃而解，缺点: 算法运行时程序执行被暂停。 1234以下几种情况都可以作为根节点：全局对象本地函数的局部变量和参数当前嵌套调用链上的其他函数的变量和参数 内存溢出和内存泄漏概念 内存溢出：当程序需要的内存超过了剩余内存，就会抛出内存溢出错误。 内存泄漏：不再用到的内存，没有及时释放，就叫做内存泄漏。应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。 内存泄漏的几种原因 意外的全局变量 被遗忘的定时器或回调函数 被遗忘的dom引用 闭包 (1)意外的全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;; this.bar = &quot;potential accidental global&quot;&#125;真相是：function foo(arg) &#123; window.bar = &quot;this is an explicit global variable&quot;;&#125;实战：&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;botton onclick=&quot;grow()&quot;&gt;点击测试内存泄漏&lt;/botton&gt;&lt;botton onclick=&quot;clearGrow()&quot;&gt;点击释放内存&lt;/botton&gt;&lt;div id=&quot;nodes&quot;&gt;&lt;/div&gt;&lt;script&gt;var largeObj = []function grow()&#123;grow3()&#125;function clearGrow()&#123;clearGrow3()&#125;function getBigData()&#123;let res = []for (var i = 0; i &lt; 100; i++) &#123;let obj = &#123;&#125;for(let i=0;i&lt;10000;i++)&#123; obj[`key-$&#123;i&#125;`] = `js创建一个很大内存的对象？`&#125;res.push(obj)&#125;return res&#125;function grow0()&#123; largeObj=[...largeObj,getBigData()]&#125;var timerfunction grow1()&#123;let someResource = getBigData(); timer = setInterval(function() &#123; var node = document.getElementById(&#x27;nodes&#x27;); if(node) &#123; node.innerHTML = JSON.stringify(someResource); // 定时器也没有清除 &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000);&#125;function clearGrow1()&#123;window.clearInterval(timer)&#125;var childNode = document.createElement(&#x27;p&#x27;);function grow2()&#123;let someResource = getBigData();var node = document.getElementById(&#x27;nodes&#x27;); if(node) &#123;childNode.innerHTML = JSON.stringify(someResource);node.appendChild(childNode) &#125;&#125;function clearGrow2()&#123;var node = document.getElementById(&#x27;nodes&#x27;);node.remove();//childNode = null;&#125;function grow3()&#123;var theThing = null var replaceThing = function () &#123; var originalThing = theThing var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;) &#125; theThing = &#123; longStr: new Array(1000000).join(&#x27;*&#x27;), someMethod: function someMethod() &#123; console.log(&#x27;someMessage&#x27;) &#125; &#125;; &#125;; setInterval(replaceThing,100)&#125;function clearGrow3()&#123;解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解决方法： 避免创建全局变量 在 JavaScript 文件头部加上 &#39;use strict&#39;，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量 (2)被遗忘的定时器或回调函数 12345678910111213141516171819var timerfunction grow1()&#123;let someResource = getBigData(); timer = setInterval(function() &#123; var node = document.getElementById(&#x27;nodes&#x27;); if(node) &#123; node.innerHTML = JSON.stringify(someResource); // 定时器也没有清除 &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000);&#125;function clearGrow1()&#123;window.clearInterval(timer)&#125;原因:与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。解决方法： 在定时器完成工作的时候，手动清除定时器和回调函数。现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。 (3)被遗忘的dom引用 1234567891011121314function grow2()&#123;let someResource = getBigData();var node = document.getElementById(&#x27;nodes&#x27;); if(node) &#123;childNode.innerHTML = JSON.stringify(someResource);node.appendChild(childNode) &#125;&#125;function clearGrow2()&#123;var node = document.getElementById(&#x27;nodes&#x27;);node.remove();//childNode = null;必须主动释放dom引用&#125; 原因: 保留了DOM节点的引用,导致GC没有回收 解决办法：断开引用，childNode=null (4)闭包 使用闭包只是让内存常驻，滥用闭包才会导致内存泄漏。 123456789101112131415161718192021function grow3()&#123;var theThing = null var replaceThing = function () &#123; var originalThing = theThing var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;) &#125; theThing = &#123; longStr: new Array(1000000).join(&#x27;*&#x27;), someMethod: function someMethod() &#123; console.log(&#x27;someMessage&#x27;) &#125; &#125;; &#125;; setInterval(replaceThing,100)&#125;function clearGrow3()&#123;解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.&#125; 首先我们明确一下，unused是一个闭包，因为它引用了自由变量 originalThing，虽然它被没有使用，但v8引擎并不会把它优化掉，因为 JavaScript里存在eval函数，所以v8引擎并不会随便优化掉暂时没有使用的函数。 theThing 引用了someMethod，someMethod这个函数作用域隐式的和unused这个闭包共享一个闭包上下文。所以someMethod也引用了originalThing这个自由变量。 1GCHandler -&gt; replaceThing -&gt; theThing -&gt; someMethod -&gt; originalThing -&gt; someMethod(old) -&gt; originalThing(older)-&gt; someMethod(older) 这里面的引用链是： 随着setInterval的不断执行，这条引用链是不会断的，所以内存会不断泄漏，直致程序崩溃。因为是闭包作用域引起的内存泄漏，这时候最好的选择是使用 chrome的heap snapshot的container视图，我们通过container视图能清楚的看到这条不断泄漏内存的引用链 这是一段糟糕的代码,每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了theThing）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。 解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null. 4.内存泄漏排查手段 打开ChromeDevTools-Performance 勾选 Screenshots 和 memory 左上角小圆点开始录制(record) 停止录制 查看heap对内存是否周期性变化 内存泄漏优化 数组优化，用完arr=[] 对象复用，t=null 在循环中的表达式，最好放在循环外面 (1)chrome devtools-memory工具 主要功能分为：Head snapshot堆快照，Allocaiton instrumentastion on timeline(js堆内存在时间线上的回收情况) 12345678910&lt;botton @click=&quot;grow()&quot;&gt;&lt;/botton&gt;function largeObj()&#123;var largeArr= new Array(1000_10000);&#125;var x= [];fucntion grow()&#123;var o = new larfeObj();x.push(new Array(1000_10000));&#125; 1)Head snapshot堆快照 123456789101112131415161718192021221.核心参数Summary：摘要视图Comparison：对比视图，与其它快照对比，看增、删、Delta数量及内存大小Containment：俯瞰视图，自顶向下看堆的情况，根节点包括window对象，GC root，原生对象等等列头Shallow Size ： 对象本身占用的内存Retained Size ： 对象本身及其引用总共占用的内存Distance ：当前对象到根的引用层级距离Alloc. Size : 新分配的内存Freed Size ： 释放的内存2.其他参数Detached DOM tree：表示它已经不在DOM树上了，但Javascript仍旧对它有引用(compiled code) — 未知，估计是程序代码区(closure) — 闭包(array) — 未知Object — JS对象类型(system) — 未知(string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里Array — JS数组类型cls — 游戏大厅特有的继承类Window — JS的window对象Quark.DisplayObjectContainer — Quark引擎的显示容器类Quark.ImageContainer — Quark引擎的图片类Quark.Text — Quark引擎的文本类Quark.ToggleButton — Quark引擎的开关按钮类 功能：查看两次快照之间的新建对象情况 录制两次可以操作之间的快照，使用object allocation between snashot1 and snapshot选项，比较两次快照间创建的对象，常用这个功能； 使用comparison，比较两次快照的内存增减情况 largeObj的第0个元素，被window全局变量x引用着。 2)Allocaiton instrumentastion on timeline分配栈时间轴 功能：查看内存分配在代码中的位置，查看内存回收的时机和频率，要勾选Record stack 蓝色竖条表示内存未被回收，灰色表示内存回收。 选中蓝色竖条，不仅可以查看Retainer表示的泄漏的对象，还可以通过Allocaiton stack分配栈，定位具体代码位置。 在class filter中输入detached,查看是否存在分离的dom节点，如果能搜索出结果，说明有分离的dom节点 查看Constructor构造器中出现system/Context,说明有函数导致闭包留存，下面的Retainer可以找到是inner函数引起的闭包内存泄漏。 (2)在控制台使用ctrl+shift+p打开command menu，输入performance monitor来监听 内存溢出的几种场景 i.溢出原因 由于过多的函数调用，导致调用堆栈无法容纳这些调用的返回地址，一般在递归中产生。堆栈溢出很可能由无限递归（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级 ii.如何解决堆栈溢出 解决方案：1，引入闭包； 2，引入计时器； 3，尾调优化 (2.1)引入闭包 错误代码 123456 function isEven(num)&#123; if(num == 0)&#123;return true;&#125; if(num == 1)&#123;return false;&#125; return isEven(Math.abs(num)-2);&#125;console.log(isEven(100000))//堆栈溢出 引入闭包代码 123456789101112131415161718function isEven(num)&#123; function isEvenInner(num)&#123; if(num === 0)&#123;return true;&#125; if(num === 1)&#123;return false;&#125; return function()&#123; return isEvenInner(Math.abs(num)-2); &#125; &#125; function simplify(func,num)&#123; var value=func(num); while(typeof value == &#x27;function&#x27;)&#123; value=value(); &#125; return value; &#125; return simplify.bind(null,isEvenInner)(num)&#125;console.log(isEven(100000));//这种方法num太大也不可以 (2.3)使用尾递归(尾调用) 错误代码 12345function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;console.log(tailFactorial(5,1)) 尾调优化（新增简化函数） 123456789function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;console.log(tailFactorial(5,1))function factorial(n) &#123; return tailFactorial(n, 1);&#125;console.log(factorial(10000)) 尾调优化（柯里化） 1234567function currying(fn,n)&#123;//柯里化要绑定的参数 return function(m)&#123;//柯里化的函数，m对应输入的唯一一个参数 return fn.call(this,m,n) &#125;//柯里化&#125;var factorial_1=currying(tailFactorial,1);console.log(factorial_1(5)); 尾调优化（ES6） 12345function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 如何创建私有变量1.使用闭包 使用闭包可以使用私有属性或者方法的封装。利用闭包可以访问外部函数的变量特征 1234567891011function MyProfile() &#123; const myTitle = &quot;DevPoint&quot;; return &#123; getTitle: function () &#123; return myTitle; &#125;, &#125;;&#125;const myProfile = MyProfile();console.log(myProfile.getTitle()); // DevPoint 2.在constructor中用Symbol代替key 12345678910111213141516171819// 类的开发者， 调用者class Login&#123; constructor(username,password)&#123; const PASSWORD = Symbol(); this.username = username // 使用Symbol 规避了公共访问 this[PASSWORD] = password; // 1. &#123;&#125; key // 2. 怎么存进对象？ key不可访问呢？私有 // 3. symbol &#125; checkPassword(pwd)&#123; return this[PASSWORD] == pwd &#125;&#125;var userA = new Login(&#x27;aa&#x27;,&#x27;123456&#x27;);// userA.password = &#x27;123456&#x27;;console.log(userA.username) //aaconsole.log(userA.password) //undefined 3.用对象以Symbol定义 1234567891011const gender = Symbol(&#x27;gender&#x27;);const obj = &#123; name:&#x27;大胖猫&#x27;, age:&#x27;3&#x27;, [gender]:&#x27;公&#x27;&#125;//obj.name obj[gender] //调用成功 // 不可枚举console.log(Object.keys(obj));console.log(JSON.stringify(obj)); 4.使用Class优化面向对象的读写操作 12345678910111213141516class Person&#123; constructor(name)&#123; this.name = name; // 公有属性 &#125; get name()&#123; console.log(&#x27;get 方法&#x27;); return this.name; &#125; set name(str)&#123; console.log(&#x27;设置了name 方法&#x27;); this.name = str; &#125;&#125;let coco = new Person(&#x27;coco&#x27;);console.log(coco.name); 5.使用 ES2020 提案 还处于 ES2020 试验草案中，引入了私有方法或者属性的定义，语法比较奇怪，以 # 作为前缀。 1234567891011121314151617181920class ButtonCreator &#123; #width; #height; constructor(width, height) &#123; this.#width = width; this.#height = height; &#125; // 私有方法 #calculateWidth() &#123; return this.#width; &#125; getWidth = () =&gt; this.#calculateWidth(); getHeight = () =&gt; this.#height; setWidth = (width) =&gt; (this.#width = width); setHeight = (height) =&gt; (this.#height = height);&#125;const button = new ButtonCreator(600, 360);console.log(button.width); // undefinedconsole.log(button.getWidth()); // 600 6.使用 WeakMap 这种方法建立在闭包方法之上，使用作用域变量方法创建一个私有 WeakMap，然后使用该 WeakMap 检索与此相关的私有数据。这比作用域变量方法更快，因为所有实例都可以共享一个 WeakMap，所以不需要每次创建实例时都重新创建方法。 1234567891011121314151617181920const ButtonCreator = (function () &#123; const privateProps = new WeakMap(); class ButtonCreator &#123; constructor(width, height, name) &#123; this.name = name; // 公共属性 privateProps.set(this, &#123; width, // 私有属性 height, // 私有属性 calculateWidth: () =&gt; privateProps.get(this).width, // 私有方法 &#125;); &#125; getWidth = () =&gt; privateProps.get(this).calculateWidth(); getHeight = () =&gt; privateProps.get(this).height; &#125; return ButtonCreator;&#125;)();const button = new ButtonCreator(600, 360);console.log(button.width); // undefinedconsole.log(button.getWidth()); // 600 7.使用 TypeScript 可以将 TypeScript 用作 JavaScript 的一种风格，可以使用 private 关键字从面向对象的语言中真正重新创建功能。 三大山-异步和单线程JS异步编程六大方案参考：异步编程方案 回调函数（Callback） 事件监听 发布订阅 Promise/A+ 生成器Generators/ yield async/await 回调函数致命的弱点，就是容易写出回调地狱（Callback hell）。 优点：简单、容易理解和实现 缺点：不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪 123ajax(url, () =&gt; &#123; // 处理逻辑&#125;) 事件监听 这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。 缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 发布订阅 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 优点：与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promise/A+ Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 生成器Generators/ yield Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 Generator 函数除了状态机，还是一个遍历器对象生成函数。 可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 async/await 它可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点： async/await是基于Promise实现的，它不能用于普通的回调函数。 async/await与Promise一样，是非阻塞的。 async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 消息队列和事件循环js是单线程阻塞执行的，js 引擎执行异步代码和支持多线程，主要依靠消息队列和事件循环机制。 为什么js是一门单线程语言呢？最初设计JS是用来在浏览器验证表单以及操控DOM元素，为了避免同一时间对同一个DOM元素进行操作从而导致不可预知的问题，JavaScript从一诞生就是单线程。 基本概念 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复异步任务压入消息队列，从消息队列中取消息、执行回调函数的过程。 核心流程 主线程(调用栈)执行同步代码，异步任务就放入到消息队列中 消息队列按照先进先出原则，异步处理不阻塞主线程 当主线程的同步任务执行完后，开始执行回调函数，处理从消息队列的出来的返回值 主线程执行的回调函数，一定是在下一轮事件循环中的开始，属于下一轮。 消息队列 按照异步任务优先级，分为微任务(microtask队列)和宏任务(macrotask队列)。 微任务包括 process.nextTick ，promise ，MutationObserver。 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 经典题 js异步任务 js 异步执行顺序 12345678910111213141516171819202122232425262728293031323334加强版练习console.log(&#x27;script start&#x27;)async function async1() &#123; await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2 end&#x27;)&#125;async1()setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;) .then(function() &#123; console.log(&#x27;promise1&#x27;) &#125;) .then(function() &#123; console.log(&#x27;promise2&#x27;) &#125;)console.log(&#x27;script end&#x27;)1. 定义函数`async1`、`async2`，**打印`script start`**；2. 执行`setTimeout`，回调交由`Web API`处理，`Web API`将其加入宏任务队列；3. 执行`async1`，**打印`async1 start`**；4. 执行`async2`，**打印`async2`**，由于左边有`await`，将`console.log(&#x27;async1 end&#x27;)`放入微任务队列；5. 执行`new Promise`，同步执行传入构造函数的函数，**打印`promise1`**；6. promise完成，将`console.log(&#x27;promise2&#x27;)`所在函数放入微任务队列；7. **打印`script end`**，当前任务执行完毕；8. 检查微任务队列并依次取出执行，**打印`async1 end`**、**打印`promise2`**；9. 微任务队列为空，执行栈为空，检查宏任务队列，取出任务执行，**打印`setTimeout`**；10. 执行完毕。 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的 123456789101112async function async1() &#123; console.log(&#x27;async1 start&#x27;); await async2(); console.log(&#x27;async1 end&#x27;);&#125;等价于async function async1() &#123; console.log(&#x27;async1 start&#x27;); Promise.resolve(async2()).then(() =&gt; &#123; console.log(&#x27;async1 end&#x27;); &#125;)&#125; 防抖和节流小结 函数防抖和函数节流都是防止某一时间频繁触发，但原理不一样。 防抖是多次操作变成一次，而节流是一定时间内只调用一次。 应用场景 debounce防抖 search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle节流 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 本质上是优化高频率执行代码的一种手段 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻: 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制 电梯第一个人进来后，15秒后准时运送一次，这是节流 电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖 节流 完整节流可以使用定时器与时间戳的写法 使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行 简单版本 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;style&gt; .box&#123; width: 500px; height: 500px; background-color: aqua; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script &gt; let tBox = document.querySelector(&#x27;.box&#x27;) tBox.addEventListener(&#x27;touchmove&#x27;,demo); function throttled1(fn, delay = 500) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) timer = null &#125;, delay); &#125; &#125;&#125; function demo()&#123; console.log(&#x27;发起请求&#x27;) &#125;&lt;/script&gt; 使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行 12345678910function throttled2(fn, delay = 500) &#123; let oldtime = Date.now() return function (...args) &#123; let newtime = Date.now() if (newtime - oldtime &gt;= delay) &#123; fn.apply(null, args) oldtime = Date.now() &#125; &#125; &#125; 可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下 1234567891011121314151617function throttled(fn, delay) &#123; let timer = null let starttime = Date.now() return function () &#123; let curTime = Date.now() // 当前时间 let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间 let context = this let args = arguments clearTimeout(timer) if (remaining &lt;= 0) &#123; fn.apply(context, args) starttime = Date.now() &#125; else &#123; timer = setTimeout(fn, remaining); &#125; &#125; &#125; 防抖 简单版本 1234567891011121314151617181920&lt;html&gt;&lt;body&gt; &lt;input/&gt;&lt;/body&gt;&lt;/html&gt;&lt;script &gt; let tInput = document.querySelector(&#x27;input&#x27;) tInput.addEventListener(&#x27;input&#x27;,debounce(demo,2000)); function debounce(fn,wait)&#123; let timeOut = null; return args=&gt;&#123; if(timeOut) clearTimeout(timeOut); timeOut = setTimeout(fn,wait); &#125; &#125; function demo()&#123; console.log(&#x27;发起请求&#x27;) &#125;&lt;/script&gt; 防抖如果需要立即执行，可加入第三个参数用于判断，实现如下： 12345678910111213141516171819202122 function debounce(func, wait, immediate) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); // timeout 不为null if (immediate) &#123; let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发 timeout = setTimeout(function () &#123; timeout = null; &#125;, wait) if (callNow) &#123; func.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait); &#125;&#125; &#125; DOM获取节点querySelector() 方法选择指定 CSS 选择器的第一个元素； querySelectorAll() 方法选择指定的所有元素 比较： query 选择符选出来的元素是静态的，而 getElement 这种方法选出的元素的动态的 Chrome 浏览器下 getElementBy 方法的执行速度基本都高于 querySelector querySelector和getElementById的api相同 添加class:el.classList.add(“mystyle”, “anotherClass”) 移除class:el.classList.remove(“mystyle”, “anotherClass”) 设置style:el.setAttribute(“class”,classVal ) 设置style:el.style.top=’100px’ el.style[“border-width”]=”10px” 创建节点添加节点1234567891011window.onload = function() &#123; var childNode = document.createElement(&#x27;p&#x27;); childNode.innerHTML = &#x27;这里是提示信息〜〜&#x27;; //childNode.setAttribute(&#x27;class&#x27;, &#x27;alerts&#x27;); //childNode.setAttribute(&#x27;onclick&#x27;, &#x27;this.style.display = &quot;none&quot;&#x27;); childNode.className = &#x27;alerts&#x27;; childNode.onclick = function () &#123; this.style.display = &#x27;none&#x27;; &#125; document.getElementsByTagName(&#x27;body&#x27;)[0].appendChild(childNode);&#125; 获取屏幕或容器的宽高123456789获取宽高元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop设置宽高document.getElementById(&quot;div&quot;).style.width = &quot;120px&quot;;//可行document.getElementById(&quot;div&quot;).style.offsetWidth = &quot;120px&quot;;//不可行 JS绑定解除事件事件有三要素 : 事件源、事件、监听器 。 第一种 缺点：HTML与js代码紧密耦合。如果要更换 事件，就要改动两个地方:HTML代码和JS代码，这就不利于后期代码的维护。 第二种 优点：它最大的优点是就是兼容性很好，所有浏览器都支持 缺点：同一个 dom 元素上，on 只能绑定一个同类型事件，后者会覆盖前者，不同类型的事件可以绑定多个。有一个问题，无法允许团队不同人员对同一元素监听同一事件但做出不用的响应 第三种 优点：它们可以支持绑定多个同类型事件 缺点：兼容性并不好,它们只兼容相对应的浏览器才有用。 12345678910111213&lt;!-- 第一种 直接在标签里绑定 --&gt;&lt;button id=&quot;btn&quot; onclick=&quot;handleClick()&quot;&gt; 自定义函数&lt;/button&gt;&lt;script&gt; // 利用 DOM0 进行绑定 var btn = document.getElementById(&#x27;btn&#x27;) btn.onclick = handleClick() // 利用 DOM3 进行绑定 btn.addEventListener(&#x27;click&#x27;, handleClick)&lt;/script&gt; JS事件冒泡和事件捕获(事件委托)DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播。 事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。 1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段； 123456789userCapture 为false事件冒泡执行顺序：从内部到外部Document。userCapture 为true事件捕获执行顺序：从Document向内部执行Dom事件流：包含userCapture ture 和 false捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数，先注册的先执行，后注册的后执行。 事件委托 12345678var ul = document.getElementById(&#x27;ul&#x27;);ul.onclick = function(event)&#123; event= event||window.event; const target = event.target; if(target.nodeName===&#x27;LI&#x27;)&#123; alert(target.innerHTML) &#125;&#125; 监听串口变化Resize事件 123window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; this.helpHeight = window.innerHeight - 90 &#125;) ResizeObserverAPI监听元素容器 1234567891011121314const resizeObserver = new ResizeObserver(entries =&gt; &#123; //回调 this.$chart.resize();&#125;);resizeObserver.observe(this.$refs.chart);// 取消某个元素监听//resizeObserver.unobserve(this.$refs.chart)// 取消全部元素监听//resizeObserver.disconnect()缺点：但是坏处是，兼容性不高解决：github上，已经提供了能够兼容至IE9的 resizeObserver polyfillyarn add @juggle/resize-observerimport ResizeObserver from &#x27;@juggle/resize-observer&#x27;; Ajax原理AJAX全称(Async Javascript and XML)即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页. 12345678910111213141516(1)创建对象var xhr = new XMLHttpRequest();(2)打开请求xhr.open(&#x27;GET&#x27;, &#x27;example.txt&#x27;, true);(3)发送请求xhr.send(); 发送请求到服务器(4)接收响应xhr.onreadystatechange =function()&#123;&#125;(1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。(2)当readystate==4时，表示已经接收到全部响应数据。(3)当status ==200时，表示服务器成功返回页面和数据。(4)如果(2)和(3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。 服务器响应处理 同步处理 1231. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false); 2. xhr.send(); 3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上 异步处理 123451. xhr.onreadystatechange=function() &#123; 2. if (xhr.readyState==4 &amp;&amp;xhr.status==200) &#123; 3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; 4. &#125;5. &#125; 什么是readyState？ readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。 readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义。 0：未初始化 – 尚未调用.open()方法； 1：启动 – 已经调用.open()方法，但尚未调用.send()方法； 2：发送 – 已经调用.send()方法，但尚未接收到响应； 3：接收 – 已经接收到部分响应数据； 4：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了； 什么是status？ 1：服务器收到请求 2：成功 3：重定向 4：客户端错误 5：服务端错误 手写setTimeout实现setInterval为什么要用setTimeout来模拟setInterval的行为？ 这里用setInerval不是更方便吗？ 12setTimeout(function()&#123;··· &#125;, n); // n毫秒后执行functionsetInterval(function()&#123;··· &#125;, n); // 每隔n毫秒执行一次function 可以看看setInterval有什么缺点： 再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。 12setInterval(function, N) //即：每隔N秒把function事件推到消息队列中 上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果。 综上所述，setInterval有两个缺点： 使用setInterval时，某些间隔会被跳过； 可能多个定时器会连续执行； 可以这么理解：**每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)**。因而我们一般用setTimeout模拟setInterval，来规避掉上面的缺点。 使用setTimeout实现setInterval setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。 针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。 实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效 123456789101112131415161718192021222324 // 可避免setInterval因执行时间导致的间隔执行时间不一致function myInterval(fn,time)&#123; let interval=()=&gt;&#123; fn() setTimeout(interval,time) &#125; setTimeout(interval,time)&#125;function mySetInterval2(fn, timeout) &#123; // 控制器，控制定时器是否继续执行 let timer = &#123; flag: true &#125;; // 设置递归函数，模拟定时器执行 function interval() &#123; if (timer.flag) &#123; fn(); setTimeout(interval, timeout); &#125; &#125; // 启动定时器 setTimeout(interval, timeout); // 返回控制器 return timer; &#125; 使用setInterval实现setTimeout 12345678910function mySetInterval(fn, timeout) &#123; //timer用来接收setInterval返回的编号，用于后面清除setInterval //setInterval会一直执行，但是在setInterval里面执行clearInterval()将会被清除 const timer = setInterval(() =&gt; &#123; //执行传入函数 fn(); //清除该次setInterval clearInterval(timer); &#125;, timeout); &#125; 手写-EventBus通俗理解： 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。 小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 有三个要点： 发布者：dep 对象 缓存列表：dep.subscribers 发布消息：dep.notify() 首先要指定好谁充当发布者（比如售楼处） 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册） 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信） 极简版本 123456789101112131415class SyncHook &#123; constructor() &#123; this.taps = []; &#125; //注册监听函数，这里的name其实没啥用 tap(name, fn) &#123; this.taps.push(&#123; name, fn &#125;); &#125; //执行函数 call(...args) &#123; this.taps.forEach((tap) =&gt; tap.fn(...args)); &#125;&#125; 一般版本 123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener(&#x27;ages&#x27;, age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit(&#x27;ages&#x27;, 18) // 18 手写-JSON.stringfy()和JSON.parse()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263if (!window.JSON) &#123; window.JSON = &#123; parse: function(jsonStr) &#123; return eval(&#x27;(&#x27; + jsonStr + &#x27;)&#x27;); &#125;, stringify: function(jsonObj) &#123; var result = &#x27;&#x27;, curVal; if (jsonObj === null) &#123; return String(jsonObj); &#125; switch (typeof jsonObj) &#123; case &#x27;number&#x27;: case &#x27;boolean&#x27;: return String(jsonObj); case &#x27;string&#x27;: return &#x27;&quot;&#x27; + jsonObj + &#x27;&quot;&#x27;; case &#x27;undefined&#x27;: case &#x27;function&#x27;: return undefined; &#125; switch (Object.prototype.toString.call(jsonObj)) &#123; case &#x27;[object Array]&#x27;: result += &#x27;[&#x27;; for (var i = 0, len = jsonObj.length; i &lt; len; i++) &#123; curVal = JSON.stringify(jsonObj[i]); result += (curVal === undefined ? null : curVal) + &quot;,&quot;; &#125; if (result !== &#x27;[&#x27;) &#123; result = result.slice(0, -1); &#125; result += &#x27;]&#x27;; return result; case &#x27;[object Date]&#x27;: return &#x27;&quot;&#x27; + (jsonObj.toJSON ? jsonObj.toJSON() : jsonObj.toString()) + &#x27;&quot;&#x27;; case &#x27;[object RegExp]&#x27;: return &quot;&#123;&#125;&quot;; case &#x27;[object Object]&#x27;: result += &#x27;&#123;&#x27;; for (i in jsonObj) &#123; if (jsonObj.hasOwnProperty(i)) &#123; curVal = JSON.stringify(jsonObj[i]); if (curVal !== undefined) &#123; result += &#x27;&quot;&#x27; + i + &#x27;&quot;:&#x27; + curVal + &#x27;,&#x27;; &#125; &#125; &#125; if (result !== &#x27;&#123;&#x27;) &#123; result = result.slice(0, -1); &#125; result += &#x27;&#125;&#x27;; return result; case &#x27;[object String]&#x27;: return &#x27;&quot;&#x27; + jsonObj.toString() + &#x27;&quot;&#x27;; case &#x27;[object Number]&#x27;: case &#x27;[object Boolean]&#x27;: return jsonObj.toString(); &#125; &#125; &#125;;&#125; 手写-简单路由1234567891011121314151617181920212223// hash路由class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = &#x27;&#x27; // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener(&#x27;load&#x27;, this.freshRoute, false) window.addEventListener(&#x27;hashchange&#x27;, this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || &#x27;/&#x27; this.routes[this.currentHash]() &#125; &#125; 手写-JS实现图片懒加载12345678910111213141516let imgs = document.querySelectorAll(&#x27;img&#x27;)// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 图片在可视区冒出的高度 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute(&#x27;data&#x27;) &#125; &#125; &#125;// addEventListener(&#x27;scroll&#x27;, lazyLoad) or setInterval(lazyLoad, 1000) 手写-rem实现原理123456789// 原始配置function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width let rem = width / 75 doc.style.fontSize = rem + &#x27;px&#x27;&#125;// 监听窗口变化addEventListener(&quot;resize&quot;, setRem) 手写-AJAX12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 1. 简单流程// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现 function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || &#x27;get&#x27; // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject(&#x27;请求超时&#x27;) // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join(&#x27;&amp;&#x27;) &#125; // get请求拼接参数 if (method === &#x27;get&#x27;) &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf(&#x27;?&#x27;) if (index === -1) url += &#x27;?&#x27; else if (index !== url.length -1) url += &#x27;&amp;&#x27; // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === &#x27;get&#x27;) xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;) xhr.send(encodeData) &#125; &#125;)&#125; 手写-实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById(&#x27;box&#x27;) drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + &#x27;px&#x27; drag.style.top = top + &#x27;px&#x27; &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 手写-其他手写forEach123456789101112if(!Array.prototype.forEach) &#123; Array.prototype.forEach = function(fn, context) &#123; var context = arguments[1]; if(typeof fn !== &quot;function&quot;) &#123; throw new TypeError(fn + &quot;is not a function&quot;); &#125; for(var i = 0; i &lt; this.length; i++) &#123; fn.call(context, this[i], i, this); &#125; &#125;;&#125; 手写map1234567Array.prototype.map = function (fn) &#123; let arr = [] for (let i = 0; i &lt; this.length; i++) &#123; arr.push(fn(this[i], i, this)) &#125; return arr&#125; 手写reduce1234567Array.prototype.myReduce = function (fn, initVal) &#123; let res = initVal ? initVal : 0 for (let i = 0; i &lt; this.length; i++) &#123; res = fn(res, this[i], i, this) &#125; return res&#125; 手写filter123456789Array.prototype.myFilter = function (fn) &#123; let arr = [] for (let i = 0; i &lt; this.length; i++) &#123; if (fn(this[i], i, this)) &#123; arr.push(this[i]) &#125; &#125; return arr&#125; 手写push1234567Array.prototype.myPush = function () &#123; let args = arguments for (let i = 0; i &lt; args.length; i++) &#123; this[this.length] = args[i] &#125; return this.length&#125; 创建函数的几种方式说完函数的类型，还需要了解JS中创建函数都有几种创建方法。 1、声明函数 最普通最标准的声明函数方法，包括函数名及函数体。 1function fn1()&#123;&#125; 2、创建匿名函数表达式 创建一个变量，这个变量的内容为一个函数 1var fn1=function ()&#123;&#125; 注意采用这种方法创建的函数为匿名函数，即没有函数name 12var fn1=function ()&#123;&#125;;getFunctionName(fn1).length;//0 3、创建具名函数表达式 创建一个变量，内容为一个带有名称的函数 1var fn1=function xxcanghai()&#123;&#125;; 注意：具名函数表达式的函数名只能在创建函数内部使用 即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用 测试： 1234567var fn1=function xxcanghai()&#123; console.log(&quot;in:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);&#125;;console.log(&quot;out:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);fn1();//out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt;//in:fn1&lt; function &gt;xxcanghai:&lt; function &gt; 可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。 注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式 4、Function构造函数 可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是匿名函数。 5、自执行函数 12(function()&#123;alert(1);&#125;)();(function fn1()&#123;alert(1);&#125;)(); 自执行函数属于上述的“函数表达式”，规则相同 6、其他创建函数的方法 当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 eval ， setTimeout ， setInterval 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开 三个fun函数的关系是什么？ 说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。 这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数是相同的。 12345678function fun(n,o) &#123; console.log(o) return &#123; fun:function(m)&#123; //... &#125; &#125;;&#125; 先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。 这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。 注意：所有声明的匿名函数都是一个新函数。 所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。 try…catch…finally总原则：顺序执行(如遇异常或throw,则进入catch),最后进入finally，最后再执行return语句(如果有return语句的话)。 catch 一旦出现异常或throw抛出异常，就进入catch 1234567891011try&#123; console.log(&#x27;begin throw error&#x27;) throw new Error(&#x27;this is a error&#x27;) console.log(&#x27;Will it work here ? &#x27;)&#125; catch(e)&#123; console.log(&#x27;e:&#x27;,e)&#125;//打印结果begin throw errore: this is a error finally 123456789101112131415161718function test() &#123; try &#123; console.log(1); throw new Error(&quot;throw&quot;); &#125; catch (e) &#123; console.log(e.message); return &quot;from_catch&quot;; &#125; finally &#123; console.log(2); &#125; &#125; console.log(test()); /*打印 1 throw 2 from_catch */ 九种跨域方式原理九种跨域方式实现原理（完整版） JS 识别不同浏览器信息12345678910111213141516171819function myBrowser() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; if (isOpera) &#123; return &quot;Opera&quot; &#125;; //判断是否Opera浏览器 if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) &#123; return &quot;Firefox&quot;; &#125; //判断是否Firefox浏览器 if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1) &#123; return &quot;Chrome&quot;; &#125; //判断是否Google浏览器 if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) &#123; return &quot;Safari&quot;; &#125; //判断是否Safari浏览器 if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) &#123; return &quot;IE&quot;; &#125;; //判断是否IE浏览器 &#125; 隐式转换逻辑非，会将类型转换为Boolean类型，只有6种值取反会转为true,其他都是false。6种：0,NaN,undefined,null,’’,false。 两边都是引用类型时，不会隐式转换，比较的是地址。 12345678910111213141516console.log([]==0);console.log(![]==0);console.log([]==![]);console.log([]==[]);console.log(&#123;&#125;==!&#123;&#125;);console.log(&#123;&#125;==&#123;&#125;);结果：VM2986:1 trueVM2986:2 trueVM2986:3 trueVM2986:4 falseVM2986:5 falseVM2986:6 false解析：[].valueof.toString() 转为&#x27;&#x27;&#123;&#125;.valueof.toString() 转为[object,Object] 数值运算 12345678910console.log(1+&quot;true&quot;);console.log(1+true);console.log(1+undefined);console.log(1+null);结果：1true2NAN1解析：都会转成1+Number(xx) 关系运算符比较，只要有一个是数值类型，都会被转为数值型。如果都不值数值型，则转为unicode码进行比较 123456789101112131415161718console.log(&quot;2&quot;&gt;10);console.log(&quot;2&quot;&gt;&quot;10&quot;);console.log(&quot;abc&quot;&gt;&quot;b&quot;);console.log(&quot;abc&quot;&gt;&quot;aad&quot;);console.log(undefined==undefined);console.log(undefined==null);console.log(null==null);console.log(NaN==NaN);结果：VM2590:1 falseVM2590:2 trueVM2590:3 falseVM2590:4 trueVM2590:5 trueVM2590:6 trueVM2590:7 trueVM2590:8 false解析：都会转成1+Number(xx) 高级函数函数是一等公民 scheme语言，将函数提升为一等公民。指的是函数可以作为参数，也可作为返回值，也可赋值给变量，是灵活的。 函数式编程概述 函数式编程：一个函数的返回值，仅仅依赖于参数的值，而不会因为其他外部的状态而不同。 命令式编程：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。 声明式编程：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。 12345678910111213// 函数式function test(a) &#123; return a + 1;&#125;//命令式var CEOs = [];for(var i = 0; i &lt; companies.length; i++)&#123; CEOs.push(companies[i].CEO)&#125;//声明式var CEOs = companies.map(c =&gt; c.CEO); 函数式编程有两个基本特点： 通过函数来对数据进行转换 通过串联多个函数来求结果 特点 无状态(引用透明) 数据不可变(没有副作用) 纯函数 惰性执行 1.无状态(引用透明) 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。 2.数据不可变(没有副作用) 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。 3.纯函数 具有2个特点 无状态： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。 数据不可变： 不修改全局变量，不修改入参。 4.惰性执行 所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 convertName 产生实际的结果。 自执行函数一、函数的声明与执行 函数申明方式 1234567// 声明函数fun0function fun0()&#123; console.log(&quot;fun0&quot;);&#125;//执行函数fun0fun0(); // fun0 变量赋值方式 1234567// 声明函数fun1 - 变量方式var fun1 = function()&#123; console.log(&quot;fun1&quot;);&#125;// 执行函数fun1fun1(); // fun1 二、 函数的一点猜想 既然函数名加上括号fun1()就是执行函数。 思考：直接取赋值符号右侧的内容直接加个括号，是否也能执行？ 试验如下，直接加上小括弧： 123function()&#123; console.log(&quot;fun&quot;);&#125;(); 以上会报错 line1：Uncaught SyntaxError: Unexpected token (。 分析： function 是声明函数关键字，若非变量赋值方式声明函数，默认其后面需要跟上函数名的。 加上函数名看看： 123function fun2()&#123; console.log(&quot;fun2&quot;);&#125;(); 以上会报错 line3：Uncaught SyntaxError: Unexpected token )。 分析： 声明函数的结构花括弧后面不能有其他符号（比如此处的小括弧）。 不死心的再胡乱试一下，给它加个实参（表达式）： 123function fun3()&#123; console.log(&quot;fun3&quot;);&#125;(1); 不会报错，但不会输出结果fun3。 分析： 以上代码相当于在声明函数后，又声明了一个毫无关系的表达式。相当于如下代码形式： 12345678 function fun3()&#123; console.log(&quot;fun3&quot;); &#125;(1);// 若此处执行fun3函数，可以输出结果fun3(); //&quot;fun3&quot; 三、自执行函数表达式 1. 正儿八经的自执行函数 想要解决上面问题，可以采用小括弧将要执行的代码包含住（方式一），如下： 1234// 方式一 (function fun4()&#123; console.log(&quot;fun4&quot;); &#125;()); // &quot;fun4&quot; 分析：因为在JavaScript语言中，()里面不能包含语句（只能是表达式），所以解析器在解析到function关键字的时候，会把它们当作function表达式，而不是正常的函数声明。 除了上面直接整个包含住，也可以只包含住函数体（方式二），如下： 1234// 方式二 (function fun5()&#123; console.log(&quot;fun5&quot;); &#125;)();// &quot;fun4&quot; 写法上建议采用方式一（这是参考文的建议。但实际上，我个人觉得方式二比较常见）。 2. “歪瓜裂枣”的自执行函数 除了上面()小括弧可以把function关键字作为函数声明的含义转换成函数表达式外，JavaScript的&amp;&amp; 与操作、||或操作、,逗号等操作符也有这个效果。 123456 true &amp;&amp; function () &#123; console.log(&quot;true &amp;&amp;&quot;) &#125; (); // &quot;true &amp;&amp;&quot; false || function () &#123; console.log(&quot;true ||&quot;) &#125; (); // &quot;true ||&quot; 0, function () &#123; console.log(&quot;0,&quot;) &#125; (); // &quot;0,&quot;// 此处要注意： &amp;&amp;, || 的短路效应。即： false &amp;&amp; (表达式1) 是不会触发表达式1；// 同理，true || (表达式2) 不会触发表达式2 如果不在意返回值，也不在意代码的可读性，我们甚至还可以使用一元操作符（! ~ - + ），函数同样也会立即执行。 1234!function () &#123; console.log(&quot;!&quot;); &#125; (); //&quot;!&quot;~function () &#123; console.log(&quot;~&quot;); &#125; (); //&quot;~&quot;-function () &#123; console.log(&quot;-&quot;); &#125; (); //&quot;-&quot;+function () &#123; console.log(&quot;+&quot;); &#125; (); //&quot;+&quot; 甚至还可以使用new关键字： 12345// 注意：采用new方式，可以不要再解释花括弧 `&#125;` 后面加小括弧 `()` new function () &#123; console.log(&quot;new&quot;); &#125; //&quot;new&quot;// 如果需要传递参数new function (a) &#123; console.log(a); &#125; (&quot;newwwwwwww&quot;); //&quot;newwwwwwww&quot; 嗯，最好玩的是赋值符号=同样也有此效用（例子中的i变量方式）： 12345//此处 要注意区分 i 和 j 不同之处。前者是函数自执行后返回值给 i ；后者是声明一个函数，函数名为 j 。 var i = function () &#123; console.log(&quot;output i:&quot;); return 10; &#125; (); // &quot;output i:&quot; var j = function () &#123; console.log(&quot;output j:&quot;); return 99;&#125; console.log(i); // 10 console.log(j); // ƒ () &#123; console.log(&quot;output j:&quot;); return 99;&#125; 上面提及到，要注意区分 var i和 var j 不同之处（前者是函数自执行后返回值给i ；后者是声明一个函数，函数名为j）。如果是看代码，我们需要查看代码结尾是否有没有()才能区分。一般为了方便开发人员阅读，我们会采用下面这种方式： 123 var i2 = (function () &#123; console.log(&quot;output i2:&quot;); return 10; &#125; ()); // &quot;output i2:&quot; var i3 = (function () &#123; console.log(&quot;output i3:&quot;); return 10; &#125;) (); // &quot;output i3:&quot;// 以上两种都可以，但依旧建议采用第一种 i2 的方式。（个人依旧喜欢第二种i3方式） 四、自执行函数的应用 1. for循环 + setTimeout 例子 因为是全局变量，所以输出都是同一个值 1234567for( var i=0;i&lt;3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125; ,300);&#125;// 输出结果 3,3,3 那怎么样才能输出1,2,3呢？ 看看下面的方式（写法一）：把setTimeout代码包含在匿名自执行函数里面，就可以实现“锁住”索引i，正常输出索引值。 123456789for( var i=0;i&lt;3;i++)&#123; (function(lockedIndex)&#123; setTimeout(function()&#123; console.log(lockedIndex); &#125; ,300); &#125;)(i);&#125;// 输出 &quot;1,2,3&quot; 分析：尽管循环执行结束，i值已经变成了3。但因遇到了自执行函数，当时的i值已经被 lockedIndex锁住了。也可以理解为 自执行函数属于for循环一部分，每次遍历i，自执行函数也会立即执行。所以尽管有延时器，但依旧会保留住立即执行时的i值。 上面的分析有点模糊和牵强，也可以从 *闭包* 角度出发分析的。 除了上面的写法，也可以直接在 setTimeout 第一个参数做自执行（写法二），如下： 123456for( var i=0;i&lt;3;i++)&#123; setTimeout((function(lockedInIndex)&#123; console.log(lockedInIndex); &#125;)(i) ,300);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 1. lockedInIndex变量，也可以换成i，因为和外面的i不在一个作用域for( var i=0;i&lt;3;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); // 1,2,3 &#125; ,300); &#125;)(i);&#125;for( var i=0;i&lt;3;i++)&#123; setTimeout((function(i)&#123; console.log(i); // 1,2,3 &#125;)(i) ,300);&#125;// 2. 自执行函数不带入参数 for( var i=0;i&lt;3;i++)&#123; (function()&#123; setTimeout(function()&#123; console.log(i); // 3,3,3 &#125; ,300); &#125;)();&#125;for( var i=0;i&lt;3;i++)&#123; setTimeout((function()&#123; console.log(i); // 1,2,3 &#125;)() ,300);&#125;// 3. 自执行函数只有实参没有写形参for( var i=0;i&lt;3;i++)&#123; (function()&#123; setTimeout(function()&#123; console.log(i); // 3,3,3 &#125; ,300); &#125;)(i);&#125;for( var i=0;i&lt;3;i++)&#123; setTimeout((function()&#123; console.log(i); // 1,2,3 &#125;)(i) ,300);&#125;// 4. 自执行函数只有形参没有写实参，这种情况不行。因为会导致输出 undefined。for( var i=0;i&lt;3;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); // undefined,undefined,undefined &#125; ,300); &#125;)();&#125;for( var i=0;i&lt;3;i++)&#123; setTimeout((function(i)&#123; console.log(i); // undefined,undefined,undefined &#125;)() ,300);&#125; 尾调用PS:ES6尾调用优化只能在严格模式下使用，详见尾调用优化 阮一峰 定义：某个函数的最后一步是调用另一个函数。 12345678910111213141516171819function f(x)&#123; return g(x);&#125;//尾调用// 情况一 非尾调用function f(x)&#123; let y = g(x); return y;&#125;// 情况二 非尾调用function f(x)&#123; return g(x) + 1;&#125;//尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; (1)尾调用优化（Tail call optimization） 如图所示，函数调用会在内存形成调用栈（call stack），尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 优点：减小调用栈，节省内存使用。 12345678910111213function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); (2)尾递归 定义：尾调用自身。 “尾调用优化”对递归操作意义重大。ES6中第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归（在严格模式下），就不会发生栈溢出，相对节省内存 尾递归(tail recursion)非尾递归 因为最后一个操作并不是调用自己, 而是 乘法 1234function fact(n)&#123; if(n==0)return 1; return n*fact(n-1);&#125; 尾递归 当然是最后一个操作一定是调用自己. 1234function fact(n, acc)&#123; if(n==0)return acc; return fact(n-1, acc*n)&#125; 两个地方值得注意 看到 acc 了没有, 这就是典型的尾递归最常见的东西, 用来累计每次递归运算结果 fact函数的最后一个操作是fact本身 由于tail recur非常容易改写成循环, 编译器容易对其进行优化 12345678function fact(n)&#123; var acc=1,i=n while(i!=0)&#123; acc=acc*i; i-=1; &#125; return acc&#125; 有没有觉得尾递归和循环非常像, 唯一的区别是 尾递归用参数重新绑定递减的n 尾递归用参数重新绑定叠加值acc 循环直接改变变量i来进行递减 循环叠加变量acc 柯里化-实现add(1)(2)(3)=6定义 柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 实现一个简单柯里化 12345678910111213function add() &#123; let sum = 0; return function innerFn(num) &#123; if (num !== undefined) &#123; sum += num; return innerFn; &#125; else &#123; return sum; &#125; &#125;&#125;console.log(add()(1)(2)(3)()); // 输出 6 我们首先定义了一个 add 函数，它返回了一个内部函数 innerFn。在 innerFn 中，我们首先定义了一个变量 sum，用于保存累加的结果。当传入的参数不为 undefined 时，我们将其加到 sum 中，并返回 innerFn。这样就可以继续传递下一个参数了。当参数为 undefined 时，我们返回 sum，表示累加完毕 但是，这种简单的实现方式存在一个问题，那就是只能处理参数数量为 2 的函数，无法处理参数数量不确定的函数。因此我们需要更加通用的柯里化实现方式 这里是一个更加通用的函数柯里化的实现方式： 柯里化写法 1234567891011121314151617181920212223// es6写法const curry = (fn, ...args) =&gt; args.length &lt; fn.length // 参数长度不足时,重新柯里化函数,等待接受新参数 ? (...arguments) =&gt; curry(fn, ...args, ...arguments) // 函数长度满足时,执行函数 : fn(...args);// es5写法function curry(fn) &#123; return function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; return fn.apply(this, args); &#125; else &#123; return function(...args2) &#123; return curried.apply(this, args.concat(args2)); &#125; &#125; &#125; &#125;该函数的参数是一个函数 fn，它返回一个柯里化后的函数。在函数内部，我们定义了一个 curried 函数，它的作用是接受函数需要的所有参数。当传入的参数数量大于或等于原函数需要的参数数量时，就直接调用原函数并返回结果；否则，返回一个新函数，然后使用闭包将当前已经传入的参数保存下来。这个新函数再次接受一个参数，并将这个参数与之前已经保存的参数合并，然后递归调用 curried 函数const add = (a, b, c) =&gt; a + b + c;const curriedAdd = curry(add);console.log(curriedAdd(1)(2)(3)); currying 函数详解： 123456789101112131415161718function currying(fn, length) &#123; length = length || fn.length; // 注释 1 return function (...args) &#123; // 注释 2 return args.length &gt;= length // 注释 3 ? fn.apply(this, args) // 注释 4 : currying(fn.bind(this, ...args), length - args.length) // 注释 5 &#125;&#125;// Testconst fn = currying(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 柯里化应用场景 参数复用，如var curriedAdd = curry(add, 5) 延迟执行，sum(1)(2)(3)，传入参数个数没有满足原函数入参个数，都不会立即返回结果。 函数式编程中，作为compose, functor, monad 等实现的基础 注意事项 使用柯里化函数，离不开闭包， arguments， 递归。 闭包，函数中的变量都保存在内存中，内存消耗大，有可能导致内存泄漏。递归，效率非常差，arguments, 变量存取慢，访问性很差, 参考 JavaScript专题之函数柯里化 devDependencies 和 dependencies 的区别devDependencies 和 dependencies的区别核心体现在 npm包 中。 只要开发的项目是发npm包提供给外部、其他业务项目使用的，需要非常注意依赖的安装地方，因为搞不好很容易在业务使用中会出现bug。dependencies的依赖包会被打入到npm包中，慎用。 而如果只是自己项目用，不需要发npm包的话，把依赖安装到 devDependencies 或者 dependencies 中，实质上是没有任何区别的。 args剩余参数与arguments函数形参类数组args 定义：只包含那些没有对应形参的实参。将所有后面剩余的是实参个数包裹成一个数组。 展开运算符 用于解构赋值 类数组对象变成数组 var arr1=[‘a’,’b’,’c’]; var arr2=[‘d’,’e’];arr1.push(…arr2) let b=[…new Set([1,2])] arguments对象 1.定义：包含了传给函数的所有实参。在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。它是一个类数组，不是数组。 1234567891011function test(a, b, c) &#123; console.log(arguments) // Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ] console.log(test.length) // 3 console.log(arguments.callee.length) // 3 console.log(Array.apply(null, arguments))&#125;test(1,2,3,4)其中arguments 代表的是函数实参的个数其中fn.length 代表函数形参的个数其中arguments.callee 指向函数本身 2.提取参数 123456var args = Array.prototype.slice.call(arguments);var args = [].slice.call(arguments);// ES2015const args = Array.from(arguments);const args = [...arguments]; 警告： 对参数使用 slice 会阻止某些 JavaScript 引擎中的优化 (比如 V8 - 更多信息)。如果你关心性能，尝试通过遍历 arguments 对象来构造一个新的数组。另一种方法是使用被忽视的Array构造函数作为一个函数： 1var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)); 3.一般模式和严格模式下arguments 一般模式：如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的 严格模式：arguments和参数是双向绑定的 (1)一般模式 直接上代码，先来看调用时缺省参数的情况 1234567891011function a1(x) &#123; x = 2; console.log(x, arguments[0]);&#125;a1(); // 2 undefinedfunction a2(x) &#123; arguments[0] = 2; console.log(x, arguments[0]);&#125;a2(); // undefined 2 再来看调用时传入参数的情况 1234567891011function a3(x) &#123; x = 2; console.log(x, arguments[0]);&#125;a3(1); // 2 2function a4(x) &#123; arguments[0] = 2; console.log(x, arguments[0]);&#125;a4(1); // 2 2 可以看到如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的。 (2)严格模式 再来看看严格模式，直接上代码 123456789101112131415161718192021222324252627function b1(x) &#123; &#x27;use strict&#x27;; x = 2; console.log(x, arguments[0]);&#125;b1(); // 2 undefinedfunction b2(x) &#123; &#x27;use strict&#x27;; arguments[0] = 2; console.log(x, arguments[0]);&#125;b2(); // undefined 2function b3(x) &#123; &#x27;use strict&#x27;; x = 2; console.log(x, arguments[0]);&#125;b3(1); // 2 1function b4(x) &#123; &#x27;use strict&#x27;; arguments[0] = 2; console.log(x, arguments[0]);&#125;b4(1); // 1 2 在严格模式下，无论参数是否缺省，arguments和参数都是隔离开的。 常用函数字符串自动补全padStart()和padEnd()padStart可以在字符串的前面进行字符补全.padEnd是在字符串后面补全。 12let month = 8;month.padStart(2, 0);// 08 可以省掉 123if (month &lt; 10) &#123; month = &#x27;0&#x27; + month;&#125; 获取20~50随机数12345678function randomNum(min,max)&#123; const range = max -min; const xishu = Math.random();// [0,1] const res=min+math.round(xishu*range); return res;&#125;randomNum(20,50) 数组的交集，差集，并集，补集12345678910111213141516171819202122var a = [1,2,3,4,5]var b = [2,4,6,8,10] //交集var c = a.filter(function(v)&#123; return b.indexOf(v) &gt; -1 &#125;) //差集var d = a.filter(function(v)&#123; return b.indexOf(v) == -1 &#125;) //补集var e = a.filter(function(v)&#123; return !(b.indexOf(v) &gt; -1) &#125;) .concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;)) //并集var f = a.concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;)); console.log(&quot;数组a：&quot;, a);console.log(&quot;数组b：&quot;, b);console.log(&quot;a与b的交集：&quot;, c);console.log(&quot;a与b的差集：&quot;, d);console.log(&quot;a与b的补集：&quot;, e);console.log(&quot;a与b的并集：&quot;, f); 数组去重1const uniqueArr = (arr) =&gt; [...new Set(arr)]; 从url获取参数1234const getParameters = () =&gt; &#123; const url = window.location.href; return JSON.parse(`&#123;&quot;$&#123;decodeURI(url.split(&#x27;?&#x27;)[1]).replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;).replace(/=/g, &#x27;&quot;:&quot;&#x27;)&#125;&quot;&#125;`);&#125;; 检查对象是否为空1const isEmpty = obj =&gt; Reflect.ownKeys(obj).length === 0 &amp;&amp; obj.constructor === Object; 反转字符串1const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); 生成随机十六进制颜色1const randomHexColor = () =&gt; `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;)&#125;` 检查设备类型12const judgeDeviceType = () =&gt; /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? &#x27;Mobile&#x27; : &#x27;PC&#x27;; 文字复制到剪贴板1const copyText = async (text) =&gt; await navigator.clipboard.writeText(text) 添加水印123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export function paintWaterMark(msg=&#x27;仅测试用途&#x27;, className=&#x27;water&#x27;, transparency=&#x27;0.3&#x27;) &#123; // 在Vue中可改为ES6写法 var childNode = document.getElementsByClassName(&#x27;fixed-water-mark&#x27;); if (childNode &amp;&amp; childNode.length !== 0) &#123; document.getElementsByClassName(className)[0].removeChild(childNode[0]); &#125; var wrap = document.createElement(&#x27;div&#x27;); // 创建一个div wrap.className = &#x27;fixed-water-mark&#x27;; // 给div添加类名 var wm = document.createElement(&#x27;canvas&#x27;); // 单个水印画布 wm.id = &#x27;watermark&#x27;; // 给canvas标签添加id wm.width = 450; // 设置canvas宽 wm.height = 200; // 设置canvas高 wm.style.display = &#x27;none&#x27;; // 设置画布隐藏属性 wrap.appendChild(wm); // 在div中添加画布 var rwm = document.createElement(&#x27;canvas&#x27;); // 重复绘制水印画布，用于整个页面 rwm.id = &#x27;repeat-watermark&#x27;; wrap.appendChild(rwm); document.getElementsByClassName(className)[0].appendChild(wrap); // 绘制单个水印 var cw = document.getElementById(&#x27;watermark&#x27;); var ctx = cw.getContext(&#x27;2d&#x27;); // 清空矩形 ctx.clearRect(0, 0, 450, 200); // 设置字体 ctx.font = &#x27;16px Arial&#x27;; // 文字居中 ctx.textAlign = &#x27;center&#x27;; // 逆时针旋转20度 ctx.rotate((-30 * Math.PI) / 180); // 填充透明度为 transparency 的灰色 ctx.fillStyle = `rgba(255,128,64,$&#123;transparency&#125;)`; ctx.fillText(msg, 55, 95); // 填充内容为工号 var date = new Date(); var currentDateText = date.getFullYear() + &#x27;/&#x27; + (date.getMonth() + 1) + &#x27;/&#x27; + date.getDate(); // 填充内容为当前时间 ctx.fillText(currentDateText, 55, 115); // 在另一个画布上重复绘制单个水印 var crw = document.getElementById(&#x27;repeat-watermark&#x27;); crw.width = window.innerWidth; // 设置画布宽度等于窗口显示宽度 crw.height = window.innerHeight; // 设置画布高度等于窗口显示高度 var ctxr = crw.getContext(&#x27;2d&#x27;); ctxr.clearRect(0, 0, crw.width, crw.height); var pat = ctxr.createPattern(cw, &#x27;repeat&#x27;); // 在水平和垂直方向重复绘制单个水印 ctxr.fillStyle = pat; ctxr.fillRect(0, 0, crw.width, crw.height);&#125;","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"0基础_框架","slug":"D_框架_0基础","date":"2099-02-28T22:33:16.000Z","updated":"2023-03-25T03:23:04.135Z","comments":true,"path":"2099/03/01/D_框架_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2099/03/01/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"canvas和svg技术 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。 从渲染模式上来说，Canvas属于 即时模式，而SVG则是 保留模式 ,这两种模式的区别可以参见 cshao 的博文： http://www.lifelaf.com/blog/?p=354。 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。 从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的Javascript API对整个画布进行操作的，而SVG则是基于XML元素的。 从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。 关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。关于SVG和Canvas的运行场景可参考MSCN关于 **如何为您的网站在Canvas和SVG之间做出选择**： 从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索 DevOpsDevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化，它促进开发和运营团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中。 DevOps有助于提高组织提供应用程序和服务的速度。它使组织能够更好地为客户服务，并在市场中更有竞争力。 为什么需要DevOps？ 在DevOps之前： ● 开发和运营团队完全孤立。 ● 测试和部署是在设计构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。 ● 在不使用DevOps的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。 ● 手动代码部署会导致生产中出现人为错误 ● 开发和运营团队有各自的时间表，不同步导致进一步的延误。 在DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。 DevOps原则 12345678910111、以客户为中心的行动： DevOps团队必须采取以客户为中心的行动，因为他们应该不断投资于产品和服务。2、端到端的责任： DevOps团队需要提供性能支持，直到它们终止为止。这提高了产品的责任水平和质量。3、持续改进： DevOps文化专注于持续改进，以尽量减少浪费。它不断加快提供的产品或服务的改进。4、自动化一切：自动化是DevOps流程的重要原则。这不仅适用于软件开发，也适用于整个基础架构环境。5、作为一个团队工作：在DevOps文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。6、监控和测试所有内容： DevOps团队拥有强大的监控和测试程序非常重要。 Echartclear和disposeclear:清空绘画内容，清空后实例可用,不会删除实例 dispose：释放图表实例，释放后实例不再可用。 渲染百万数据全量渲染改增量虽然这并不能解决拖动时的卡顿(因为仍旧需要遍历所有点),但能将每秒渲染的全量数据从百万改成几百个的增量数据，至少能给CPU放个假。 官方API提供appendData方法。 研究了下Echarts的实现，其在填入数据时做了diff，而G每次填入的都是在原有数据基础上新增一秒数据，所以在diff算法的加持下，早就是增量渲染了。 懒加载走投无路之下，便想砍掉几张图表。 G支持的性能数据颇多，同时需要绘制很多张图表。 但实际上电脑屏幕并不足够大，展示给用户的可视范围并不大，我们可以只实时渲染用户所见的部分，其余部分通过监听滚轮，鼠标，键盘的操作，当其可视时，再进行渲染。 可以看到一帧的时间已经达到了100ms+，其中占据较多时间的是Echart.setOption这个函数。实际上，Echarts在渲染单张图表时表现还是不错的，一般能做到20ms内，但因为我们图表共有数十张，10*10=100。改成滚动时加载之后帧渲染便好了极多。 sampling降采样实际上，我们可以注意到，G上的一个折线图，一般占用的像素宽度大概只有700到1500，就算是百万个点，能展示出来的也不过寥寥，这里便大有文章可做。 ECharts 有 提供 sampling 降采样功能 ，其中有max，min，avg以及lttb等。使用G进行性能测试的同学很多时候，都是需要观测离群值的，所以max，min以及avg势必会丢弃很多细节，没法使用。 可以看出，使用了lttb算法之后，细节和趋势都保留的非常好，而且每帧渲染耗时更是从之前的成百上千降至50ms内，相当给力。","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"构建工具","slug":"D_框架_构建工具","date":"2024-05-11T23:33:16.000Z","updated":"2024-06-02T01:41:13.272Z","comments":true,"path":"2024/05/12/D_框架_构建工具/","link":"","permalink":"https://fuyunjinglong.github.io/2024/05/12/D_%E6%A1%86%E6%9E%B6_%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Rollup 使用Rollup打包JavaScript 手写Vue2-珠峰-待续 手写Vue2-珠峰-video Rollup搭建环境Rollup是什么 Rollup是一个JS模块打包器，可以将小块代码编译成大块复杂代码，rollup.js更专注JS类库打包(开发应用使用webpack，开发库使用Rollup) 环境搭建 1.初始化package.json 1npm init -y 2.安装rollup环境 @babel/core是es6转es5低级语法的核心包 @babel/preset-env是babel插件的集合 rollup-plugin-babel是rollup和babel的插件，是桥梁 1npm i rollup @babel/core @babel/preset-env rollup-plugin-babel -D 目录配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// rollup.config.jsimport babel from &#x27;rollup-plugin-babel&#x27;export default&#123; input:&#x27;./src/index.js&#x27;,// 打包项目的入口 output:&#123; file:&#x27;dist/vue.js&#x27;,// 打包输出的结果 format:&#x27;umd&#x27;, // 采用的模块化规范 name:&#x27;Vue&#x27;, // 指定的打包后全局变量 sourcemap:true &#125;, plugins:[ babel(&#123;// 自动读取babel配置文件 exclude:&quot;./node_module/**&quot; // 排除babel解析目录，**是glob写法 &#125;) ]&#125;//.babelrc配置文件&#123; &quot;presets&quot;: [ // presets叫预设，也是插件的集合，主要把高级语法转为低级语法，如e6-&gt;es5 &quot;@babel/preset-env&quot; ]&#125;// index.js入口文件export default&#123; a:1, b:2&#125;// package.json&#123; &quot;name&quot;: &quot;vue2-rollup&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;rollup -c -w&quot;// 执行打包，并读取默认config配置，watch动态监听文件变化 &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.21.3&quot;, &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;, &quot;rollup&quot;: &quot;^2.79.1&quot;, &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot; &#125;&#125;// 打包后的结果支持commonjs,amd,有全局Vue参数 响应式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// \\src\\index.js/** * Class方法扩展与构造函数方法扩展比较： * 1.Class用于扩展方法耦合的场景，但扩展方法都在class内部 * 2.构造函数用于外部方法的任意扩展，使用原型属性继承扩展方法，可以无限扩展，不受约束 */import initMixin from &#x27;./init&#x27;function Vue(options)&#123;this._init(options)&#125;initMixin(Vue) // 扩展方法通过传入Vue构造函数，通过原形添加方法，并分文件管理export default Vue// \\src\\init.jsimport &#123;initState&#125; from &#x27;./state&#x27;export default function initMixin(Vue)&#123;// 扩展Vue的方法Vue.prototype._init=function(options)&#123; // 绑定所有选项参数到实例上，后续所有的扩展方法都可以拿到这些选项 const vm = this // $表示Vue自己的属性参数 vm.$options= options // 初始化数据，如prop,data,methods,computed,watch initState(vm)&#125;&#125;//\\src\\state.jsimport &#123; observe &#125; from &quot;./observe/index.js&quot;;export function initState(vm)&#123; const options =vm.$options if(options.data)&#123; initData(vm) &#125;&#125;function initData(vm)&#123;let data = vm.$options.data;// 判断是否为函数，如果是则执行函数获取返回值。// 代理后，添加到vm实例上_datadata=vm._data = typeof data ===&#x27;function&#x27;?data.call(vm):data;// 观察数据,实现响应式observe(data)console.log(data);&#125;// \\src\\observe\\index.js// 高类聚，低耦合class Observer&#123; constructor(data)&#123; this.walk(data); &#125; walk(data)&#123; // 遍历一遍数据，添加响应式 Object.keys(data).forEach(key=&gt;&#123; defineReactive(data,key,data[key]) &#125;) &#125;&#125;function defineReactive(data,key,value)&#123; // 属性全部被重写 // 递归代理属性 observe(value); Object.defineProperty(data,key,&#123; get()&#123; return value &#125;, set(newV)&#123; observe(value); value = newV===value?value:newV; &#125; &#125;)&#125;export function observe(data)&#123; // 数据响应式 if(typeof data !== &#x27;object&#x27;||data===null)&#123; return;// 如果不是对象，就不处理 &#125; /** * Class方法扩展与构造函数方法扩展比较： * 1.Class用于扩展方法耦合的场景，但扩展方法都在class内部 * 2.构造函数用于外部方法的任意扩展，使用原型属性继承扩展方法，可以无限扩展，不受约束 */// 这里采用Class类 return new Observer(data)&#125; Monorepo vs Multirepo定义Monorepo 的全称是 monolithic repository，即单体式仓库，与之对应的是 Multirepo(multiple repository)，这里的“单”和“多”是指每个仓库中所管理的模块数量。 Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。例如：Rollup。 Monorep 是把所有相关的 package 都放在一个仓库里进行管理，每个 package 独立发布。例如：React, Angular, Babel, Jest, Umijs, Vue … LernaLerna是业界知名度最高的 Monorepo 管理工具，功能完整。 Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。 Lerna 现在已经被很多著名的项目组织使用。基于 Lerna 管理 packages 的 Monorepo 项目，如：Babel, React, Vue, Angular, Ember, Meteor, Jest 。","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"第三方库","slug":"D_框架_第三方库","date":"2024-02-28T23:33:16.000Z","updated":"2024-02-28T23:11:43.685Z","comments":true,"path":"2024/02/29/D_框架_第三方库/","link":"","permalink":"https://fuyunjinglong.github.io/2024/02/29/D_%E6%A1%86%E6%9E%B6_%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","excerpt":"","text":"vex-table123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336&lt;template&gt; &lt;el-button @click=&quot;loadColumnAndData(20, 20)&quot;&gt;20列20行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(50, 50)&quot;&gt;50列50行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(100, 100)&quot;&gt;100列100行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(500, 500)&quot;&gt;500列500行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(1000, 1000)&quot;&gt;1000列1000行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(2000, 2000)&quot;&gt;2000列2000行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(4500, 4500)&quot;&gt;4500列4500行&lt;/el-button&gt; &lt;!-- &lt;el-button @click=&quot;loadColumnAndData(5000, 5000)&quot;&gt;5000列5000行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(50000, 50000)&quot;&gt;5w列5w行&lt;/el-button&gt; &lt;el-button @click=&quot;loadColumnAndData(100000, 100000)&quot;&gt;10w列10w行&lt;/el-button&gt; --&gt; &lt;div class=&quot;VexTable&quot;&gt; &lt;vxe-grid ref=&quot;xGrid&quot; class=&quot;xGrid&quot; v-bind=&quot;gridOptions&quot; height=&quot;auto&quot; v-on=&quot;gridEvents&quot;&gt; &lt;template v-for=&quot;(col, cIndex) in columns&quot; #[`$&#123;col.slots.header&#125;`]=&quot;&#123; row, column &#125;&quot; :key=&quot;col.field&quot;&gt; &lt;div class=&quot;first-col-top&quot;&gt;&#123;&#123; column.title &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/vxe-grid&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;tsx&quot;&gt;// 功能：支持大容量自定义表头,自定义单元格，上限4500x4500import &#123; ref, reactive, toRefs, computed, watch, nextTick, onMounted, h &#125; from &#x27;vue&#x27;;import &#123; VXETable &#125; from &#x27;vxe-table&#x27;;import &#123; randomNum &#125; from &#x27;@/utils&#x27;;import FCalendar from &#x27;@/components/FCalendar.vue&#x27;;const props = defineProps([]);const emits = defineEmits([]);const xGrid = ref(null);const columnList: any[] = [];const dataList: any[] = [];const gridOptions = reactive(&#123; border: true, showOverflow: true, loading: false, height: 400, columnConfig: &#123; resizable: true, &#125;, editConfig: &#123; trigger: &#x27;click&#x27;, mode: &#x27;cell&#x27;, showIcon: false, &#125;,&#125;);const gridEvents = &#123; // headerCellClick(params) &#123; // const &#123; column &#125; = params; // console.log(`表头单元格点击$&#123;column.title&#125;`); // &#125;, // headerCellDblclick(params) &#123; // const &#123; column &#125; = params; // console.log(`表头单元格双击$&#123;column.title&#125;`); // &#125;, // headerCellMenu(params) &#123; // const &#123; column &#125; = params; // console.log(`表头右键单元格 $&#123;column.title&#125;`); // &#125;, // cellClick(params) &#123; // const &#123; column &#125; = params; // console.log(`单元格点击$&#123;column.title&#125;`); // &#125;, // cellDblclick(params) &#123; // const &#123; column &#125; = params; // console.log(`单元格双击$&#123;column.title&#125;`); // &#125;, // cellMenu(params) &#123; // const &#123; row &#125; = params; // console.log(`单元格右键行 $&#123;row.name&#125;`); // &#125;, // footerCellClick(params) &#123; // const &#123; column &#125; = params; // console.log(`表尾单元格点击$&#123;column.title&#125;`); // &#125;, // footerCellDblclick(params) &#123; // const &#123; column &#125; = params; // console.log(`表尾单元格双击$&#123;column.title&#125;`); // &#125;, // footerCellMenu(params) &#123; // const &#123; column &#125; = params; // console.log(`表尾右键单元格 $&#123;column.title&#125;`); // &#125;, // checkboxChange(params) &#123; // console.log(`复选框切换 $&#123;params.checked&#125;`); // &#125;, // checkboxAll(params) &#123; // console.log(`复选框全选切换 $&#123;params.checked&#125;`); // &#125;, // scroll(params) &#123; // console.log(`滚动事件scrollTop=$&#123;params.scrollTop&#125; scrollLeft=$&#123;params.scrollLeft&#125;`); // &#125;, // zoom(params) &#123; // console.log(`表格全屏 type=$&#123;params.type&#125;`); // &#125;, // custom(params) &#123; // console.log(`表格自定义列表 type=$&#123;params.type&#125;`); // &#125;,&#125;;const duble = reactive(&#123; row: &#123;&#125;, column: &#123;&#125;, val: &#x27;&#x27;,&#125;);function judgeSame(row, column, value) &#123; // if (row.rowId === duble.row.rowId &amp;&amp; column.field === duble.column.field &amp;&amp; value === duble.val) &#123; // return false; // &#125; duble.row = row; duble.column = column; duble.val = value; console.log(&#x27;column:&#x27; + duble.column.field + &#x27;;row:&#x27; + JSON.stringify(duble.row) + &#x27;;value:&#x27; + duble.val);&#125;function myRender(type, colT) &#123; // 内置渲染器 const t = &#123; input: () =&gt; inputRender(), select: () =&gt; selectRender(), date: () =&gt; dateRender(), slot: () =&gt; slotRender(), &#125;; let r = t[type] ? t[type]() : &#123;&#125;; r = &#123; editRender: colT === 0 ? r : &#123;&#125;, slots: colT === 0 ? &#123; header: `header_$&#123;randomNum()&#125;` &#125; : r, &#125;; return r;&#125;function inputRender() &#123; // 单元组件-输入框 return &#123; name: &#x27;input&#x27;, props: &#123; placeholder: &#x27;请输入名称&#x27; &#125;, events: &#123; change(&#123; row, column &#125;) &#123; judgeSame(row, column, column.model.value); &#125;, &#125;, &#125;;&#125;function selectRender() &#123; // 单元组件-下拉框 return &#123; name: &#x27;$select&#x27;, options: [ &#123; label: &#x27;男&#x27;, value: &#x27;男&#x27;, &#125;, &#123; label: &#x27;女&#x27;, value: &#x27;女&#x27;, &#125;, ], events: &#123; change(&#123; row, column &#125;, &#123; value &#125;) &#123; judgeSame(row, column, value); &#125;, &#125;, &#125;;&#125;function dateRender() &#123; // 单元组件-日期 return &#123; header: `header_$&#123;randomNum()&#125;`, edit(&#123; row, column &#125;) &#123; return h(FCalendar, &#123; row, column, onChange(&#123; row, column &#125;) &#123; judgeSame(row, column, row[column.property]); &#125;, &#125;); &#125;, &#125;;&#125;function slotRender() &#123; // 单元组件-自定义 return &#123; header: `header_$&#123;randomNum()&#125;`, default: (&#123; row, column: &#123; field &#125; &#125;) =&gt; &#123; return row[field]; &#125;, edit: (&#123; row, column &#125;) =&gt; &#123; return h(&#x27;div&#x27;, &#123;&#125;, [ h( &#x27;span&#x27;, &#123; class: &#x27;btn&#x27;, onClick(event) &#123; judgeSame(row, column, event); &#125;, &#125;, &#x27;点击&#x27; ), ]); &#125;, &#125;;&#125;function createColT(field, t, others = &#123;&#125;) &#123; // 模拟各种创建列 const ty = &#123; 0: &#x27;input&#x27;, 1: &#x27;select&#x27;, 2: &#x27;date&#x27;, 3: &#x27;slot&#x27;, &#125;; return createCol(&#123; field, type: ty[t], colT: t &gt; 1 ? 1 : 0, ...others &#125;);&#125;function createCol(&#123; colT = 0, title, field, type, ...others &#125;) &#123; // 创建列 const renders = myRender(type, colT); return &#123; title: title ? title : field, // 表头别名 field, // 表数据映射字段 ...renders, ...others, &#125;;&#125;const columns = ref([ createCol(&#123; field: &#x27;name&#x27;, type: &#x27;input&#x27; &#125;), createCol(&#123; field: &#x27;sex&#x27;, type: &#x27;select&#x27; &#125;), createCol(&#123; field: &#x27;time&#x27;, type: &#x27;date&#x27;, colT: 1 &#125;), createCol(&#123; field: &#x27;age&#x27;, type: &#x27;slot&#x27;, colT: 1 &#125;),]);// 双向数据绑定，一般不要轻易用，会一定程度上影响性能const datas = ref([ &#123; rowId: 0, name: `师傅`, sex: &#x27;男&#x27;, time: &#x27;2023-09-03&#x27;, age: 8 &#125;, &#123; rowId: 1, name: `大师兄`, sex: &#x27;女&#x27;, time: &#x27;2023-09-03&#x27;, age: 18 &#125;, &#123; rowId: 2, name: `大师兄1`, sex: &#x27;男&#x27;, time: &#x27;2023-09-03&#x27;, age: 181 &#125;,]);onMounted(() =&gt; &#123; nextTick(() =&gt; &#123; // gridOptions.loading = true; // const $grid = xGrid.value; // if ($grid) &#123; // gridOptions.columns = columns.value; // gridOptions.data = datas.value; // &#125; // gridOptions.loading = false; // 官方支持简单单元格10wX10w,实测自定义单元格4500X4500 loadColumnAndData(20, 20); &#125;);&#125;);const mockColumns = (colSize: number): Promise&lt;any[]&gt; =&gt; &#123; // 模拟创建列 return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; const currSize = 0; columnList.length = 0; if (currSize &lt; colSize) &#123; for (let i = currSize; i &lt; colSize; i++) &#123; columnList.push( createColT(&#x27;attr&#x27; + i, 1, &#123; width: i === 0 ? 60 : 140 &#125;) // &#123; // field: &#x27;attr&#x27; + i, // title: i === 0 ? &#x27;&#x27; : &#x27;Attr&#x27; + i, // width: i === 0 ? 60 : 140, // type: i === 0 ? &#x27;checkbox&#x27; : &#x27;FInput&#x27;, // fixed: i &lt; 1 ? &#x27;left&#x27; : null, // editRender: &#123; // //该处是列可编辑状态下的编辑框，这里是一个静态下拉框，下面有一个动态下拉框也是我踩雷的地方 // name: &#x27;$select&#x27;, // options: [ // &#123; label: &#x27;待处理&#x27;, value: &#x27;待处理&#x27; &#125;, // &#123; label: &#x27;处理中&#x27;, value: &#x27;处理中&#x27; &#125;, // &#123; label: &#x27;已计划&#x27;, value: &#x27;已计划&#x27; &#125;, // &#123; label: &#x27;已完成&#x27;, value: &#x27;已完成&#x27; &#125;, // &#123; label: &#x27;已关闭&#x27;, value: &#x27;已关闭&#x27; &#125;, // ], // props: &#123; placeholder: &#x27;请选择工单状态&#x27; &#125;, // &#125;, // &#125; ); &#125; &#125; resolve(columnList); &#125;, 100); &#125;);&#125;;const mockList = (rowSize: number): Promise&lt;any[]&gt; =&gt; &#123; // // 模拟创建行 return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; const d = &#123;&#125;; columns.value.forEach((c, ci) =&gt; &#123; d[&#x27;attr&#x27; + ci] = &#x27;attr_row_&#x27; + ci; &#125;); dataList.length = 0; for (let i = 0; i &lt; rowSize; i++) &#123; dataList.push(d); &#125; // 模拟数据 const result = JSON.parse(JSON.stringify(dataList.slice(0, rowSize))); resolve(result); &#125;, 100); &#125;);&#125;;const loadColumnAndData = async (colSize: number, rowSize: number) =&gt; &#123; // 核心:加载行列数据 gridOptions.loading = true; const res0 = await mockColumns(colSize); columns.value = res0; Promise.all([mockList(rowSize)]).then((rest) =&gt; &#123; const startTime = Date.now(); const $grid = xGrid.value; // 使用函数式加载 if ($grid) &#123; Promise.all([$grid.reloadColumn(columns.value), $grid.reloadData(rest[0])]).then(() =&gt; &#123; VXETable.modal.message(&#123; content: `渲染 $&#123;colSize&#125; 列 $&#123;rowSize&#125; 行，用时 $&#123;Date.now() - startTime&#125;毫秒`, status: &#x27;info&#x27; &#125;); gridOptions.loading = false; &#125;); &#125; else &#123; gridOptions.loading = false; &#125; &#125;);&#125;;&lt;/script&gt;&lt;style scoped&gt;.VexTable &#123; width: 100%; height: calc(100% - 50px);&#125;&lt;/style&gt;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"","slug":"Test copy","date":"2024-01-15T14:26:56.445Z","updated":"2024-01-15T15:08:12.314Z","comments":true,"path":"2024/01/15/Test copy/","link":"","permalink":"https://fuyunjinglong.github.io/2024/01/15/Test%20copy/","excerpt":"","text":"// 最经典的闭包 let getSingle = function(fn){ let result = null; return function(){ return result||(result = fn()); } } // 单一职责 let createLogin = function(){ let div = document.createElement('div'); div.innerHTML = '我是登录的弹窗'; div.style.display = 'none'; document.body.append(div); return div } // 还可以创建createIframe等等 const singleLogin = getSingle(createLogin); document.getElementById('login').onclick = function(){ let login = singleLogin(); login.style.display = 'block'; }","categories":[],"tags":[]},{"title":"Vue2和Vue3比较","slug":"D_框架_Vue2和Vue3比较","date":"2023-09-11T23:33:16.000Z","updated":"2024-02-28T22:52:10.817Z","comments":true,"path":"2023/09/12/D_框架_Vue2和Vue3比较/","link":"","permalink":"https://fuyunjinglong.github.io/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue2%E5%92%8CVue3%E6%AF%94%E8%BE%83/","excerpt":"","text":"Vue3和Vue2的区别生命周期 vue2.x vue3 beforeCreate – created – beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted Tips： setup是围绕beforeCreate和created生命周期钩子运行的，所以不需要显式地去定义 多根节点Vue3 支持了多根节点组件，也就是fragment。 异步组件Vue3 提供 Suspense组件，允许程序在等待异步组件时渲染兜底的内容，如 loading ，使用户体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default和fallback。Suspense确保加载完异步内容时显示默认插槽，并将fallback插槽用作加载状态。 123456789101112&lt;tempalte&gt; &lt;suspense&gt; &lt;template #default&gt; &lt;todo-list /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt; Loading... &lt;/div&gt; &lt;/template&gt; &lt;/suspense&gt;&lt;/template&gt; 真实的项目中踩过坑，若想在 setup 中调用异步请求，需在 setup 前加async关键字。这时，会受到警告async setup() is used without a suspense boundary。 解决方案：在父页面调用当前组件外包裹一层Suspense组件 TeleportVue3 提供Teleport组件可将部分DOM移动到 Vue app之外的位置。 12345&lt;button @click=dialogVisible = true&gt;点击&lt;/button&gt;&lt;teleport to=body&gt; &lt;div class=dialog v-if=dialogVisible&gt; &lt;/div&gt;&lt;/teleport&gt; 组合式API 更好的逻辑复用 更灵活的代码组织 更好的类型推导 更小的生产包体积 响应式原理Vue2 响应式原理基础是Object.defineProperty；Vue3 响应式原理基础是Proxy。 Object.defineProperty 基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。Tips： writable 和 value 与 getter 和 setter 不共存。 1234567891011121314let obj = &#123;&#125;let name = 瑾行 Object.defineProperty(obj, name , &#123; enumerable: true, // 可枚举（是否可通过for...in 或 Object.keys()进行访问） configurable: true, // 可配置（是否可使用delete删除，是否可再次设置属性） // value: , // 任意类型的值，默认undefined // writable: true, // 可重写 get: function() &#123; return name &#125;, set: function(value) &#123; name = value &#125;&#125;) 那 Vue3 为何会抛弃它呢？那肯定是有一些缺陷的。 主要原因：无法监听对象或数组新增、删除的元素。Vue2 方案：针对常用数组原型方法push、pop、shift、unshift、splice、sort、reverse进行了hack处理；提供Vue.set监听对象/数组新增属性。对象的新增/删除响应，还可以new个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。 Tips： Object.defineOProperty是可以监听数组已有元素，但 Vue2 没有提供的原因是性能问题。 Proxy Proxy是ES6新特性，通过第2个参数handler拦截目标对象的行为。相较于Object.defineProperty提供语言全范围的响应能力，消除了局限性。 消除局限性： 1.对象/数组的新增、删除。2.监测.length修改。3.Map、Set、WeakMap、WeakSet的支持。基本用法：创建对象的代理，从而实现基本操作的拦截和自定义操作 1234567891011function createReactiveObject(target, isReadOnly, baseHandlers, collectionHandlers, proxyMap) &#123; ... // collectionHandlers: 处理Map、Set、WeakMap、WeakSet // baseHandlers: 处理数组、对象 const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) proxyMap.set(target, proxy) return proxy&#125; 打包优化tree-shaking：模块打包webpack、rollup等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于import和export语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。 以nextTick为例子，在 Vue2 中，全局 API 暴露在 Vue 实例上，即使未使用，也无法通过tree-shaking进行消除。 Vue3 中针对全局 和内部的API进行了重构，并考虑到tree-shaking的支持。因此，全局 API 现在只能作为ES模块构建的命名导出进行访问。 12import &#123; nextTick &#125; from vuenextTick(() =&gt; &#123; // 一些和DOM有关的东西&#125;) TypeScript 支持Vue3 由TS重写，相对于 Vue2 有更好地TypeScript支持。 Vue2 Option API中 option 是个简单对象，而TS是一种类型系统，面向对象的语法，不是特别匹配。 Vue2 需要vue-class-component强化vue原生组件，也需要vue-property-decorator增加更多结合Vue特性的装饰器，写法比较繁琐。 入门体系架构比较Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 。它为后续做服务端渲染以及跨端框架 Weex 提供了基础。 Vue2.0很多需要解决的痛点,比如源码自身的维护性，数据量大后带来的渲染和更新的性能问题. Vue3.0从源码、性能和语法 API 三个大的方面优化框架，vue3是一个比较好符合开源标准的工程化解决方案。 源码优化，采用monorepo 方式，形成高内聚、低耦合的代码层次结构 性能优化，响应式系统、代码体积、编译阶段做了大幅优化 语法API，采用组合式API,更高效的代码逻辑组织和复用 1.源码优化 (1)代码管理方式 语法开销体积e.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码）、platforms（平台专有代码）、server（服务端渲染的相关代码）、sfc（.vue 单文件解析相关代码）、shared（共享工具代码）等目录。 Vue.js 3.0，整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到不同的目录中，每个模块有各自的API类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。 Vue.js 2.x 12345678源码托管在 src 目录src├── compiler # 编译相关├── core # 核心代码├── platforms # 不同平台的支持├── server # 服务端渲染├── sfc # .vue 文件解析├── shared # 共享代码 Vue.js 3.0 123456789101112@vue├── compiler-core│ ├── LICENSE│ ├── README.md│ ├── dist│ │ ├── compiler-core.cjs.js│ │ ├── compiler-core.cjs.prod.js│ │ ├── compiler-core.d.ts│ │ └── compiler-core.esm-bundler.js│ ├── index.js│ └── package.json├── compiler-dom (2)类型检查 Vue.js 2.x 选用 Flow 做类型检查，来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好。 Vue.js 3.0 抛弃了 Flow ，使用 TypeScript 重构了整个项目。 TypeScript 提供了更好的类型检查，能支持复杂的类型推导；由于源码就使用 TypeScript 编写，也省去了单独维护 d.ts 文件的麻烦。 2.性能优化 (1)响应式优化 vue2缺陷 它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法； 对于嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。如果我们定义的响应式数据过于复杂，这就会有相当大的性能损耗； vue3弥补上述缺陷 使用了 Proxy API 做数据劫持，它劫持的是整个对象，对于对象的属性的增加和删除都能检测到。 Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理 。 a.改用proxy api做数据劫持 Vue.js 2.x 内部是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter 来实现响应式的。这个 API 有一些缺陷，它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。 Vue.js 3.0 使用了 Proxy API 做数据劫持，它劫持的是整个对象，自然对于对象的属性的增加和删除都能检测到。 b.响应式是惰性的 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，就没有那么大的性能消耗。 (2)体积优化 a.引入tree-shaking的技术 tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。像我们在项目中没有引入 Transition、KeepAlive 等不常用的组件，那么它们对应的代码就不会打包进去。 b.移除了一些冷门的feature Vue.js 3.0 兼容了 Vue.js 2.x 绝大部分的api，但还是移除了一些比较冷门的feature：如 keyCode 支持作为 v-on 的修饰符、$on，$off 和 $once 实例方法、filter过滤、内联模板等。 (3)编译优化 a.生成block tree Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部需要遍历该组件的整个 vnode 树。 Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节点。 b.slot编译优化 Vue.js 2.x 中，如果有一个组件传入了slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费。 Vue.js 3.0 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新。动态slot指的是在slot上面使用v-if，v-for，动态slot名字等会导致slot产生运行时动态变化但是又无法被子组件track的操作。 c.diff算法优化 能力有限,可以看下这篇文章：https://blog.csdn.net/weixin_48726650/article/details/107019164 3.语法 API 优化 a.优化逻辑组织 使用 Vue.js 2.x 编写组件本质就是在编写一个“包含了描述组件选项的对象”，可以把它称为 Options API。我们按照 data、props、methods、computed 这些不同的选项来书写对应的代码。这种方式对于小型的组件可能代码还能一目了然，但对于大型组件要修改一个逻辑点，可能就需要在单个文件中不断上下切换和寻找逻辑代码。 Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样在修改一个逻辑时，只需要改那一块的代码了。 b.优化逻辑复用 在 Vue.js 2.x 中，我们一般会用 mixins 去复用逻辑。当抽离并引用了大量的mixins，你就会发现两个不可避免的问题：命名冲突和数据来源不清晰。 Vue.js 3.0 设计的 Composition API，在逻辑复用方面就会很有优势了。 进阶双向绑定所谓的双向绑定，其实就是将Model和View绑定在一起，任何一方改变的同时，改变另外一方。 vue2在组件中这样设置: 父组件 1&lt;ChildComponent v-model = &quot;title&quot;&gt; 子组件 12345678910111213141516171819export default &#123; model: &#123; prop: &#x27;title&#x27;, // v-model绑定的属性名称 event: &#x27;change&#x27; // v-model绑定的事件 &#125;, props: &#123; value: String, // value跟v-model无关 title: &#123; // title是跟v-model绑定的属性 type: String, default: &#x27;Default title&#x27; &#125; &#125;, methods: &#123; handle() &#123; // 这里的 change, 对应 event this.$emit(&#x27;change&#x27;, &#x27;xxx&#x27;) &#125; &#125;&#125; vue3在组件中这样设置 父组件 123&lt;!-- 两个方法等价 --&gt;&lt;Son v-model=&quot;message&quot; /&gt;&lt;!-- &lt;Son :modelValue=&quot;message&quot; @update:modelValue=&quot;message = $event&quot; /&gt; --&gt; 子组件 123456789101112131415161718192021export default defineComponent(&#123; props: &#123; modelValue: &#123; type: String &#125; &#125;, emits: [&#x27;update:modelValue&#x27;], setup(props, &#123; emit &#125;) &#123; const newValue = computed(&#123; get: () =&gt; props.modelValue, set: (nv) =&gt; &#123; console.log(nv) emit(&#x27;update:modelValue&#x27;, nv) &#125; &#125;) return &#123; newValue &#125; &#125;&#125;) 小结 vue2: v-model: 会把 value 用作 prop 且把 input 用作 event; 可以通过 .sync修饰符 指定传递名字 支持model: 可以指定v-model的 value属性名 和 event事件名字 组件v-model原理: 12&lt;Son v-model=&quot;age&quot; /&gt;&lt;Son :value=&quot;age&quot; @change=&quot;age = $event&quot; /&gt; vue3: v-model: 不在绑定 value 而是 modelValue, 接受方法也不再是 input 而是 update:modelValue 组件支持多个 v-model, 并且可以指定名字 v-model:名字 组件v-model原理: 12&lt;Son v-model=&quot;formData&quot; /&gt;&lt;Son :modelValue=&quot;formData&quot; @update:modelValue=&quot;formData = $event&quot; /&gt; Object.defineProperty和Porxy前言 Vue都是采用数据劫持代理+发布订阅模式方式实现，vue2到vue3的差别是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变。Proxy/Reflect是在ES2015规范中加入的，Proxy可以更好的拦截对象行为，Reflect可以更优雅的操纵对象。 并不是说Proxy的性能就比Object.defineProperty高多少 在Proxy里的处理方式比Vue2时期的好很多：Vue2的响应式是一上来就一顿遍历+递归把你定义的所有数据全都变成响应式的，这就会导致如果页面上有很多很复杂的数据结构时，用Vue2写的页面就会白屏一小段时间。毕竟遍历+递归还是相对很慢的一个操作嘛！ 对于vue3,当我们获取对象上的某个键对应的值时，会先判断这个值到底有没有对应的发布者对象，没有的话再创建发布者对象。而且当获取到的值是引用类型时再把这个值变成响应式对象，等你用到了响应式对象里的值时再去新建发布者对象。 总结成一句话就是：Vue3是用到哪部分的数据的时候，再把数据变成响应式的。而Vue2则是不管三七二十一，刚开局就全都给你变成响应式数据。 对比： Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法 defineProperty 不能监听到数组下标变化和对象新增属性，Proxy 可以 defineProperty 是劫持对象属性，Proxy 是代理整个对象 defineProperty 局限性大，只能针对单属性监听，所以在一开始就要全部递归监听。Proxy 对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能提升很大，且首次渲染更快 defineProperty 会污染原对象，修改时是修改原对象，Proxy 是对原对象进行代理并会返回一个新的代理对象，修改的是代理对象 defineProperty 不兼容 IE8，Proxy 不兼容 IE11 对比 Object.defineProperty Porxy 功能 监听对象的单个属性 监听整个对象 属性为对象时 需要递归监 不需要 对象新增一个属性时 需要手动监听 不需要手动监听 数组通过push、unshift方法增加的元素 无法监听 可以监听 一、Object.defineProperty 基本使用 核心： 对象: 通过 defineProperty 对对象的已有属性值的读取和修改进行劫持(监视/拦截) 数组: 通过重写数组原型方法实现元素修改的劫持 缺陷： 初始化时需要遍历对象所有 key，如果对象层次较深，性能不好 通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多 Object.defineProperty 无法监听到数组元素的变化，只能通过劫持重写方法 动态新增，删除对象属性无法拦截，只能用特定 set/delete API 代替 不支持 Map、Set 等数据结构 12345678910111213141516171819202122let obj = &#123;&#125;let input = document.getElementById(&#x27;input&#x27;)let span = document.getElementById(&#x27;span&#x27;)// 数据劫持Object.defineProperty(obj, &#x27;text&#x27;, &#123;// value:10, //初值// enumerable:true,//属性是否支持枚举,默认false// writable:true,//属性是否支持修改,默认false// configurable:true,//属性是否支持删除,默认false get() &#123; console.log(&#x27;获取数据了&#x27;) &#125;, set(newVal) &#123; console.log(&#x27;数据更新了&#x27;) input.value = newVal span.innerHTML = newVal &#125;&#125;)// 输入监听input.addEventListener(&#x27;keyup&#x27;, function(e) &#123; obj.text = e.target.value&#125;) 监听对象上的多个属性 12345678910111213141516Object.keys(person).forEach(function (key) &#123; Object.defineProperty(person, key, &#123; enumerable: true, configurable: true, // 默认会传入this get() &#123; return person[key] &#125;, set(val) &#123; console.log(`对person中的$&#123;key&#125;属性进行了修改`) person[key] = val // 修改之后可以执行渲染操作 &#125; &#125;)&#125;)console.log(person.age) 深度监听一个对象 12345678910111213141516171819202122232425262728293031323334function defineProperty(obj, key, val) &#123; //如果某对象的属性也是一个对象，递归进入该对象，进行监听 if(typeof val === &#x27;object&#x27;)&#123; observer(val) &#125; Object.defineProperty(obj, key, &#123; get() &#123; console.log(`访问了$&#123;key&#125;属性`) return val &#125;, set(newVal) &#123; // 如果原本的属性值是一个对象，递归进入该对象进行监听 if(typeof newVal === &#x27;object&#x27;)&#123; observer(key) &#125; // 如果原本的属性值是一个字符串 console.log(`$&#123;key&#125;属性被修改为$&#123;newVal&#125;了`) val = newVal &#125; &#125;)&#125;// 在observer里面加一个递归停止的条件function Observer(obj) &#123; //如果传入的不是一个对象，return if (typeof obj !== &quot;object&quot; || obj === null) &#123; return &#125; // for (key in obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; defineProperty(obj, key, obj[key]) &#125;) // &#125;&#125; 监听数组 如果还是按照基本用法，是无法监听数组变化，vue2采用重写Array原型上的方法实现监听。 Proxy 基本使用 Proxy 也就是代理，可以帮助我们完成很多事情，例如对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义，因此提供了一种机制，可以对外界的访问进行过滤和改写。 核心： 通过 Proxy(代理): 拦截对 data 任意属性的任意(13 种)操作, 包括属性值的读写, 属性的添加, 属性的删除等… 通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作 语法：const p = new Proxy(target, handler) 参数: target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 通过Proxy，我们可以对设置代理的对象上的一些操作进行拦截，外界对这个对象的各种操作，都要先通过这层拦截。 1234567891011121314151617181920let w3cjs = &#123; name: &quot;w3cjs&quot;, age: 99&#125;;w3cjs = new Proxy(w3cjs, &#123; get(target, key) &#123; let result = target[key]; //如果是获取 年龄 属性，则添加 岁字 if (key === &quot;age&quot;) result += &quot;岁&quot;; return result; &#125;, set(target, key, value) &#123; if (key === &quot;age&quot; &amp;&amp; typeof value !== &quot;number&quot;) &#123; throw Error(&quot;age字段必须为Number类型&quot;); &#125; return Reflect.set(target, key, value); &#125;&#125;);console.log(`我叫$&#123;w3cjs.name&#125; 我今年$&#123;w3cjs.age&#125;了`);w3cjs.age = 100; Proxy的表单验证 123456789101112131415161718192021222324252627282930313233343536373839404142// 验证规则 const validators = &#123; name: &#123; validate(value) &#123; return value.length &gt; 6; &#125;, message: &#x27;用户名长度不能小于六&#x27; &#125;, password: &#123; validate(value) &#123; return value.length &gt; 10; &#125;, message: &#x27;密码长度不能小于十&#x27; &#125;, moblie: &#123; validate(value) &#123; return /^1(3|5|7|8|9)[0-9]&#123;9&#125;$/.test(value); &#125;, message: &#x27;手机号格式错误&#x27; &#125; &#125; // 验证方法 function validator(obj, validators) &#123; return new Proxy(obj, &#123; set(target, key, value) &#123; const validator = validators[key] if (!validator) &#123; target[key] = value; &#125; else if (validator.validate(value)) &#123; target[key] = value; &#125; else &#123; alert(validator.message || &quot;&quot;); &#125; &#125; &#125;) &#125; let form = &#123;&#125;; form = validator(form, validators); form.name = &#x27;666&#x27;; // 用户名长度不能小于六 form.password = &#x27;113123123123123&#x27;; Proxy支持拦截的操作，一共有13种： get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和proxy[&#39;foo&#39;]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v 或 proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 Virtual-DOMVue3 相比于 Vue2 虚拟DOM 上增加patchFlag字段。我们借助Vue3 Template Explorer来看。 12345&lt;div id=app&gt; &lt;h1&gt;技术摸鱼&lt;/h1&gt; &lt;p&gt;今天天气真不错&lt;/p&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/div&gt; 渲染函数如下: 1234567891011121314import &#123; createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId &#125; from vueconst _withScopeId = n =&gt; (_pushScopeId(scope-id),n=n(),_popScopeId(),n)const _hoisted_1 = &#123; id: app &#125;const _hoisted_2 = /*#__PURE__*/ _withScopeId(() =&gt; /*#__PURE__*/_createElementVNode(h1, null, 技术摸鱼, -1 /* HOISTED */))const _hoisted_3 = /*#__PURE__*/ _withScopeId(() =&gt; /*#__PURE__*/_createElementVNode(p, null, 今天天气真不错, -1 /* HOISTED */))export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createElementBlock(div, _hoisted_1, [ _hoisted_2, _hoisted_3, _createElementVNode(div, null, _toDisplayString(_ctx.name), 1 /* TEXT */) ]))&#125; 注意第 3 个_createElementVNode的第 4 个参数即patchFlag字段类型，字段类型情况如下所示。1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style等。除此之外，发现所有的静态节点，都保存为一个变量进行静态提升，可在重新渲染时直接引用，无需重新创建。 123456789101112131415export const enum PatchFlags &#123; TEXT = 1, // 动态文本内容 CLASS = 1 &lt;&lt; 1, // 动态类名 STYLE = 1 &lt;&lt; 2, // 动态样式 PROPS = 1 &lt;&lt; 3, // 动态属性，不包含类名和样式 FULL_PROPS = 1 &lt;&lt; 4, // 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较 HYDRATE_EVENTS = 1 &lt;&lt; 5, // 带有监听事件的节点 STABLE_FRAGMENT = 1 &lt;&lt; 6, // 不会改变子节点顺序的 fragment KEYED_FRAGMENT = 1 &lt;&lt; 7, // 带有 key 属性的 fragment 或部分子节点 UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 子节点没有 key 的fragment NEED_PATCH = 1 &lt;&lt; 9, // 只会进行非 props 的比较 DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 动态的插槽 HOISTED = -1, // 静态节点，diff阶段忽略其子节点 BAIL = -2 // 代表 diff 应该结束&#125; Virtual-DOM-diff算法diff算法一般流程： 同级比较，再比较子节点 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除) 比较都有子节点的情况(核心diff) 递归比较子节点 正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -&gt; O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。 Vue2中diff 采用了双端比较的算法。 从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。 Vue3中diff 借鉴了 ivi算法和 inferno算法。 在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。 还运用了动态规划的思想求解最长递归子序列。 小结 编译阶段的优化： 事件缓存：将事件缓存(如: @click)，可以理解为变成静态的了 静态提升：第一次创建静态节点时保存，后续直接复用 添加静态标记：给节点添加静态标记，以优化 Diff 过程 由于编译阶段的优化，除了能更快的生成虚拟 DOM 以外，还使得 Diff 时可以跳过”永远不会变化的节点”，Diff 优化如下 Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff 使用最长递增子序列优化了对比流程 根据尤大公布的数据就是 Vue3 update 性能提升了 1.3~2 倍 参考 深入浅出虚拟 DOM 和 Diff 算法，及 Vue2 与 Vue3 中的区别 Option API和Composition APIvue2 Option API 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; car.name &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Person&quot;, data() &#123; return &#123; person: &#123; name: &quot;小明&quot;, sex: &quot;male&quot;, &#125;, car: &#123; name: &quot;宝马&quot;, price: &quot;40w&quot;, &#125; &#125;; &#125;, watch:&#123; &#x27;person.name&#x27;: (value) =&gt; &#123; console.log(`名字被修改了, 修改为 $&#123;value&#125;`) &#125;, &#x27;person.sex&#x27;: (value) =&gt; &#123; console.log(`性别被修改了, 修改为 $&#123;value&#125;`) &#125; &#125;, methods: &#123; changePersonName() &#123; this.person.name = &quot;小浪&quot;; &#125;, changeCarPrice() &#123; this.car.price = &quot;80w&quot;; &#125; &#125;,&#125;;&lt;/script&gt; vue3 Composition API 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; car.name &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; reactive, watch &#125; from &quot;vue&quot;;// person的逻辑const person = reactive&lt;&#123; name: string; sex: string &#125;&gt;(&#123; name: &quot;小明&quot;, sex: &quot;male&quot;,&#125;);watch( () =&gt; [person.name, person.sex], ([nameVal, sexVal]) =&gt; &#123; console.log(`名字被修改了, 修改为 $&#123;nameVal&#125;`); console.log(`名字被修改了, 修改为 $&#123;sexVal&#125;`); &#125;);function changePersonName() &#123; person.name = &quot;小浪&quot;;&#125;// car的逻辑const car = reactive&lt;&#123; name: string; price: string &#125;&gt;(&#123; name: &quot;宝马&quot;, price: &quot;40w&quot;,&#125;);function changeCarPrice() &#123; car.price = &quot;80w&quot;;&#125;&lt;/script&gt; 样式改动样式穿透 123456789101112// vue2&lt;style scoped&gt;.a /deep/ .b &#123; /* ... */&#125;&lt;/style&gt;// vue3&lt;style scoped&gt;.a :deep(.b) &#123; /* ... */&#125; 全局样式和局部样式 1234局部样式&lt;style scoped&gt;/* local styles */&lt;/style&gt; 123456789101112全局样式：不带scope&lt;style&gt;/* global styles */&lt;/style&gt;全局样式：使用:global伪类// 创建一个.red的全局类样式&lt;style scoped&gt;:global(.red) &#123; color: red;&#125;&lt;/style&gt; Vue2升级Vue3迁移指南 简介 新特性 Composition API Teleport Fragments Emits Component Option createRenderer API⽤于创建⾃定义渲染器 破坏性变化 Global API 改为应⽤程序实例调⽤ Global and internal APIs重构为可做摇树优化 model选项和v-bind的sync 修饰符被移除，统⼀为v-model参数形式 渲染函数API修改 函数式组件仅能通过简单函数⽅式创建 废弃在SFC的template上使⽤functional或者添加functional选项的⽅式声明函数式组件 异步组件要求使⽤defineAsyncComponent ⽅法创建 组件data选项应该总是声明为函数 ⾃定义组件⽩名单执⾏于编译时 is属性仅限于⽤在component标签上 $scopedSlots 属性被移除，都⽤$slots代替 特性强制策略变更 ⾃定义指令API和组件⼀致 ⼀些transition类名修改:v-enter -&gt; v-enter-fromv-leave -&gt; v-leave-from watch 选项 和$watch 不再⽀持点分隔符字符串路径, 使⽤计算函数作为其参数 Vue 2.x中应⽤程序根容器的 outerHTML 会被根组件的模板替换 (或被编译为template)。 Vue 3.x现在使⽤应⽤根容器的innerHTML取代. 移除 移除keyCode 作为 v-on 修饰符 on,off and $once 移除 Filters移除 Inline templates attributes移除 取消 v-on:keyup.keyCode修饰符按键数字 移除$ on、$off 和 $once 方法不应该是vue3提供的功能，vue3移除了EventBus总线通信，推荐mitt.js 123456import mitt from &quot;mitt&quot;&lt;script&gt;const emitter = mitt()emitter.emit(&#x27;foo&#x27;,1)emitter.on(&#x27;foo&#x27;,(e)=&gt;&#123;&#125;)&lt;/script&gt; 移除 Filter 过滤器推荐使用 computed 方案来代替 初始化 Vue 应用Vue 不再是一个构造函数，通过 createApp 方法初始化 12341 $ npm init vite-app &lt;project-name&gt;2 $ cd &lt;project-name&gt;3 $ npm install4 $ npm run dev 全局 API 调用方式1Vue.config.globalProperties.$echarts = echarts; 渲染 Render 方法修改vue2.0渲染函数里的 h 参数，便于tree shaking 12345export default&#123; render(h)&#123; return h(&#x27;div&#x27;) &#125;&#125; Vue 3.0 中 h 函数通过 vue 引入,不再传入h函数，拍平props结构，scopedslots删掉，统一为slots即this.$scopedSlots 替代为 this.$slots 123456import &#123;h&#125; from &#x27;vue&#x27;export default&#123; render()&#123; return h(div) &#125;&#125; 通过h函数进行render渲染 1234567891011121314151617181920212223242526272829Demo5.jsimport &#123; h, reactive &#125; from &quot;vue&quot;;export default &#123; setup(props, &#123; slots, attrs, emit &#125;) &#123; const state = reactive(&#123; count: 0, &#125;); function increment() &#123; state.count++; &#125; // 返回render函数 return () =&gt; h( &quot;div&quot;, &#123; onClick: increment, &#125;, [slots.default(), slots.content(&#123; data: &quot;jack&quot; &#125;), state.count, h(&quot;input&quot;, &#123; value: &quot;123456&quot; &#125;, [&quot;我是span&quot;])] ); &#125;,&#125;;其中，h为函数，不再是参数，格式：h(&#x27;标签名&#x27;,&#123;属性或事件&#125;,[子元素或h函数])&lt;Demo5&gt; 我是匿名插槽 &lt;template #default&gt;我是匿名插槽&lt;/template&gt; &lt;template #content=&quot;&#123; data &#125;&quot;&gt;我是具名插槽，取消了作用域插槽&#123;&#123; data &#125;&#125;&lt;/template&gt; &lt;/Demo5&gt; 异步组件defineAsyncComponent由于vue3引入函数式组件，为了区分函数式组件和异步组件，特地增加标记defineAsyncComponent。 必须明确使用defineAsyncComponent包裹 component选项重名为loader Loader 函数不在接收 resolve and reject 且必须返回⼀个Promise vue2.0 1const Home = () =&gt; import(&quot;./components/Home.vue&quot;) vue3.0 123456789101112components: &#123; // 无配置项异步组件 AsyncPage: defineAsyncComponent(() =&gt; import(&quot;./NextPage.vue&quot;)), // 有配置项异步组件 AsyncPageWithOptions: defineAsyncComponent(&#123; loader: () =&gt; import(&quot;.NextPage.vue&quot;), delay: 200, timeout: 3000, errorComponent: () =&gt; import(&quot;./ErrorComponent.vue&quot;), loadingComponent: () =&gt; import(&quot;./LoadingComponent.vue&quot;), &#125;) &#125;, defineAsyncComponent 也可以接受一个对象 动态组件 is 属性vue2.0会渲染成mybutton组件 1&lt;button is=&quot;mybutton&quot;&gt;&lt;/button&gt; vue3.0则当成普通属性，除非用v-is指令替代 is只能作用域component组件 1&lt;component is=&quot;comp&quot;&gt;&lt;/component&gt; dom内使用模板解析，使用v-is替代 123&lt;table&gt;&lt;tr v-is=&quot;&#x27;comp&#x27;&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 其他API1)shallowRef 这是一个浅层的 ref，与 shallowReactive 一样是拿来做性能优化的 2)toRaw toRaw 方法是用于获取 ref 或 reactive 对象的原始数据的 3)markRaw markRaw 方法可以将原始数据标记为非响应式的，即使用 ref 或 reactive 将其包装，仍无法实现数据响应式，其接收一个参数，即原始数据，并返回被标记后的数据 4)provide &amp;&amp; inject 这里简单说明一下这两个方法的作用： provide ：向子组件以及子孙组件传递数据。接收两个参数，第一个参数是 key，即数据的名称；第二个参数为 value，即数据的值 inject ：接收父组件或祖先组件传递过来的数据。接收一个参数 key，即父组件或祖先组件传递的数据名称 5)getCurrentInstance 獲取this實例 1let &#123; proxy &#125; = getCurrentInstance() 6)useStore 在Vue3的 getCurrentInstance().ctx 中也没有发现 $store 这个属性.这就要通过 vuex 中的一个方法了，即 useStore 7)vue3操作dom 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;el&quot;&gt;div元素&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; // 创建一个DOM引用，名称必须与元素的ref属性名相同 const el = ref(null) // 在挂载后才能通过 el 获取到目标元素 onMounted(() =&gt; &#123; el.value.innerHTML = &#x27;内容被修改&#x27; &#125;) // 把创建的引用 return 出去 return &#123;el&#125; &#125;&#125;&lt;/script&gt; TypeScript作用三个原因： 您可以避免经典的错误 &#39;undefined&#39; is not a function. 在不严重破坏代码的情况下，重构代码更容易。 使大型、复杂的应用程序源码更易阅读。 研究表明，静态类型检查的TypeScript可以检测到所有JavaScript错误的15％。 TypeScript更可靠 与JavaScript相比，TypeScript代码更可靠、更容易重构。这使开发人员可以更轻松地避免错误并进行重写。 类型的定义和编译器的引入，可使你避免掉代码中的大多数愚蠢错误。 TypeScript更清晰 显式类型使我们代码可读性更高，所以我们的注意力将会更集中在我们的系统究竟是如何构建的，以及系统的不同部分如何相互作用。在大型系统中，能够在记住上下文的同时抽象出系统的其余部分是很重要的。类型的定义使我们能够做到这一点。 TypeScript和JavaScript实际上是可以互换的，何乐而不为呢？ 由于JavaScript是TypeScript的子集，因此您可以在TypeScript代码中使用您想要的所有JavaScript库和代码。 github上pull request排名 反对Vue2升级Vue3最近一篇反对Vue2升级到Vue3的文章在vue官方社区引起了热议。（原文链接：Vue 3 was a mistake that we should not repeat） 原作者主要的问题，是从Vue3突破性的改变以及周边生态圈未能及时跟上的角度，重点强调了迁移升级成本+风险较大。 关于升级成本问题：尤大也承认了Vue3升级体验并没有想象中的那么流畅，Vue4会吸取经验，做好平稳迭代。 一、破坏性的api变更（Breaking changes） Events API的弃用让这个问题首当其冲。Vue实例再也不能作为事件总线做事件通信，$on，$off，$once的彻底移除意味着之前所有有关代码都必须重新推翻重写，虽然有很好的插件工具让这件事变得没那么复杂，但是仍然会带来不小的迁移成本。 代码构建问题。 你会经常遇到用Vue2写法写出来的代码在构建(build) 失败或抛出警告。因为这些api写法在Vue3中已经被废弃。这问题在已存在的大型项目中的尤为突出下图展示了一部分Breaking changes，可以看到破坏性的api变更数确实很多： 二、颠覆式的设计模式（composition-api） 颠覆式的composition-api慢慢向面向函数思想转变，导致很多原有习惯于options-api的开发者反感Vue正在像react靠拢，没有坚持住Vue特色。它提出了一种新的基于函数的 Vue 组件编写方式，引起了Vue社区大量的争议和分裂，甚至将社区分隔为两种观点阵营针锋相对，最终导致了Vue 最黑暗的一天事件。这很令人沮丧。 三、生态系统（The ecosystem） 生态系统和框架本身一样重要。因为没有责任机制，在有争议的决定和在弃用功能的时候，很多框架周边的生态系统的许多贡献者会被迫离开，并导致许多库被放弃或者延迟更新。很多时候，我们没有办法做版本兼容时，我们往往只能把责任归咎于，开源库缺乏同理心和对大局的理解。 四、文档系统（Documentation） 在我们的日常开发中，尤其是在使用框架时，我们会遇到各种各样的问题，这时我们时常需要google或者问答社区作为帮手，但是目前关于Vue搜索出来的结果几乎全是Vue2的结果 五、过往案例（The past） 过渡到 Vue 3 看起来很像从AngularJS过渡到Angular（版本 1⇒ 2）。大量的延迟和重大更改导致了挫败感，最终 Angular 失去了对 React 和 Vue 的吸引力。 尤大的回复： 1.当我们进行版本切换时，所有核心库和工具都与这两个版本兼容（或为 Vue 2/3 支持提供单独的版本）。 实际上阻碍升级的依赖都是第三方，主要是 Nuxt 和 Vuetify。 2.实际使用过 Composition API + &lt; script setup&gt; 的用户在真是开发中的反馈非常积极，证明这是一个有价值的补充，现在他们中的许多人更喜欢它而不是 Options API。 我们当然可以更好地处理新 API 的引入，但仅仅因为存在争议，并不意味着它是错误的或者不必要的。实际上，引入大的、新的想法的行为，势必会让那些喜欢呆在舒适区的人感到不安，但如果我们迎合这种心态，就永远不会取得真正的进展。 3、4.虽然我们确实创造了 Vue CLI、Vuex、Vetur 和 VuePress 的新替代品，但它们本身都有适用于 Vue 3 的版本。 5.关于和angular的过往对比： 没有可比性，不能拿Vue升级和angularjs -&gt; angular做对比。 Angular 和 AngularJS 是根本不同的框架。几乎没有共享交集，除了完全重写之外没有实际的迁移路径。 有许多生产 Vue 2 应用程序成功迁移到 Vue 3 的案例。很容易吗，确实不是，但是他们都迁移成功了。 6.我们同意，Vue3升级体验并没有想象中的那么流畅。Vue 将随着吸取的经验不断发展，我们绝对不打算在未来的Vue4中，进行这样的破坏性重大升级。 参考 Vue2升级到Vue3到底是不是一个正确的选择？(尤雨溪亲自回复解读) 对比Vue2总结Vue3新特性(2022年最全，2.5w字！) gogocode插件Vue2 到 Vue3 升级指南 Vue2升级3-问题汇总参考 keeko笔记汇总 Vue3 + Vite2 + ElementPlus + TS 项目常见问题 Vue2 + Webpack4 + TS 改造小记 vue-cli3 + vue2 项目转 vite 小记 vue2 老项目迁移vue3 记录 template v-for告警 12345报错：&lt;template v-for&gt; key should be placed on the &lt;template&gt; 告警解决原因：vue3要求template循环的key只能在template标签上修改： 1.key属性放到template标签上 2..eslintrc.js配置&#x27;vue/no-v-for-template-key-on-child&#x27;: &#x27;off&#x27; // vue3","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"Vue2.0_原理","slug":"D_框架_Vue2.0_原理","date":"2023-09-11T23:33:16.000Z","updated":"2023-07-16T03:26:18.811Z","comments":true,"path":"2023/09/12/D_框架_Vue2.0_原理/","link":"","permalink":"https://fuyunjinglong.github.io/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue2.0_%E5%8E%9F%E7%90%86/","excerpt":"","text":"入门生命周期vue生命周期详细全过程 beforeCreate():实例在内存中被创建出来，还没有初始化好data和methods属性。 create():实例已经在内存中创建，已经初始化好data和method，此时还没有开始编译模板。 beforeMount():已经完成了模板的编译，还没有挂载到页面中。 mounted()：将编译好的模板挂载到页面指定的容器中显示。 beforeUpdate():状态更新之前执行函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为还没有开始重新渲染DOM节点。 updated():此时data中的状态值和界面上显示的数据都已经完成了跟新，界面已经被重新渲染好了！ beforeDestroy():实例被销毁之前。 destroyed():实例销毁后调用，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除,所有的子实例也都会被销毁。组件已经被完全销毁，此时组建中所有data、methods、以及过滤器，指令等，都已经不可用了。 1.beforeCreate钩子函数 a.用户使用 new Vue()新建 Vue 实例 b.父实例实例化子实例，确认组件间的父子关系，将父组件的自定义事件传递给子组件 c.初始化将 render 函数转为虚拟 dom 的方法 2. created钩子函数: a.初始化事件，进行数据的观测 b.数据已经和data属性进行绑定（放在 data 中的属性当值发生改变的同时，视图也会改变） c.此时还是没有 el 选项 3. beforeMount钩子函数： a.el**选项。如果有的话就继续向下编译，如果没有el 选项，则停止编译，也就意味着停止了**生命周期。 b.如删掉 el: ‘#app’ c.template 参数 （1）如果 vue 实例对象中有 template 参数选项，则将其作为模板编译成 render 函数。（2）如果没有 template 选项，则将外部 HTML 作为模板编译。（3）可以看到 template 中的模板优先级要高于 outer HTML 的优先级。 4. mounted a.给 vue 实例对象添加$el 成员，beforeMount 之前 el 上还是 undefined b.mounted 之前 h1 中还是通过****进行占位的，因为此时还有挂载到页面上，还是 JavaScript 中的虚拟 DOM 形式存在的。在 mounted 之后可以看到 h1 中的内容发生了变化。 5. beforeUpdate a.vue 发现 data 中的数据发生了改变，则在下一次时间循环开始重新渲染组件 6. updated a.重新执行 render 函数生成 vnode。 b.将 vnode 转化为真实 Dom c.重新挂载到 HTML 中，并且覆盖掉上一次渲染的$el 7. beforeDestroy: a.调用 vm.$destroy()准备销毁 vue 实例 b.beforeDestroy 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。 8. destroyed: a.在 Vue 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 父子组件生命周期更新顺序父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。 1父beforeCreate-&gt; 父create -&gt; 子beforeCreate-&gt; 子created -&gt; 子mounted -&gt; 父mounted Vue2.x组件通信方式 父子组件通信 事件机制(**父-&gt;子props,子-&gt;父 $on、$emit) 获取父子组件实例 $parent、$children Ref 获取实例的方式调用组件的属性或者方法 Provide、inject (不推荐使用，组件库时很常用) 兄弟组件通信 eventBus ,也适用任意组件 跨级组件通信 Vuex $attrs、$listeners Provide、inject methods和watch、computed watch和computed都是依赖数据变化触发 watch:擅长一对多的关系处理，无缓存性，可以执行深监听 computed:擅长多对一的关系处理，有缓存性 methods通过实践驱动触发 v-for和v-if不能连用 因为v-for的优先级比v-if的优先级高，所以如果嵌套使用的话，每次v-for都会执行一次v-if，造成重复计算的问题，会影响性能，所以vue官方不推荐这样使用 建议使用 computed，对数据先过滤 在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。 在 vue 3.x 中，v-if 总是优先于 v-for 生效。 数组变异方法 变异方法：改变原数组的方法 非变异方法：不会改变原数组的方法 变异方法 push( ) pop( ) shift( ) unshift( ) splice( ) sort( ) reverse( ) 非变异方法 filter( ) concat( ) slice( ) Vue 变异方法源码 变异的本质就是重写原型链,在这些方法内部加上自定义的逻辑，其实就是想监听这些方法的调用。 Vue 中默认的做法就是在数组实例与它的原型之间，插入了一个新的原型对象，这个原型方法实现了这些变异方法，也就拦截了真正数组原型上的方法（因为原型链的机制，找到了就不会继续往上找了）。 变异方法中增加了自定义逻辑，也调用了真正数组原型上的方法，即实现了目的，也不会对正常使用造成影响。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;]/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;)const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change，关键关键关键 ob.dep.notify() 在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用。 建议在created中调用： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； vm.$set()如何解决对象属性新增问题原理： 如果目标是数组，使用 vue 实现的变异方法 splice 实现响应式 如果目标是对象,判断属性存在,同时也为响应式,直接赋值 如果 target 本身就不是响应式,直接赋值 如果属性不是响应式,则调用 defineReactive 方法进行响应式处理 组件中的data为什么是一个函数？ 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 如果data是对象的话，对象属于引用类型，会影响到所有的实例。而函数就不影响 如果是root根实例，可以使用对象，因为只有一个实例。 高阶MVC、MVP、MVVM与Vue关系这三个框架模式表示了web领域的发展进程，从最早的前后端.net,jsp到分离的ajax,再到完全的前后端分离，再到响应式。 这三者共同的目标都是为了职责划分，代码分层，解决维护问题，目标是为了解决Mode数据和View视图的耦合问题。 MVC MVC最早出现在服务端，如springmvc，在前端早期也有应用，如Backbone.js,优点是分层清晰，缺点是数据流混乱，灵活性带来了维护问题。 所有的通信流程都是单向的。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 MVP MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。解决MV的耦合性问题，但P层过于臃肿。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel MVVM广泛应用于前端领域，不仅解决MV耦合问题，还解决了两者映射关系复杂和DOM操作代码，提高开发效率、代码可读性。 Vue 是MVVM框架(基于mvc升级，弱化了controller层。但没有完全遵循mvvm，因为MVVM规定Model和View不能直接通信，传统mvvm是不能手动操作数据，而vue有ref操作dom数据) 数据响应式数据响应式图1 数据响应式图2 原理 通过数据劫持代理+发布订阅模式来实现 核心流程 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。劫持data中的每一个属性添加getter和setter即数据劫持 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：派发更新，Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：依赖收集，订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。Observer与Dep是1对1，Dep和Watcher是多对多。 双向绑定 vue的单向数据流 Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。 如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。 Vue是单向数据流，不是双向数据流 Vue的双向绑定不过是语法糖，v-bind数据绑定 与 v-on处理函数绑定 Object.definePropert是用来做响应式更新的 父组件 123&lt;AnalysisSub v-model=&quot;phoneInfo&quot; :zip-code.sync=&quot;zipCode&quot; /&gt;或 &lt;AnalysisSub :phone-info=&quot;phoneInfo&quot; @change=&quot;val =&gt; (phoneInfo = val)&quot; :zip-code=&quot;zipCode&quot; @update:zipCode=&quot;val =&gt; (zipCode = val)&quot;/&gt; 子组件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;input :value=&quot;phoneInfo.phone&quot; type=&quot;number&quot; placeholder=&quot;手机号&quot; @input=&quot;handlePhoneChange&quot; /&gt; &lt;input :value=&quot;zipCode&quot; type=&quot;number&quot; placeholder=&quot;邮编&quot; @input=&quot;handleZipCodeChange&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PersonalInfo&quot;, model: &#123; prop: &quot;phoneInfo&quot;, // 默认 value event: &quot;change&quot; // 默认 input &#125;, props: &#123; phoneInfo: Object, zipCode: String &#125;, methods: &#123; handlePhoneChange(e) &#123; this.$emit(&quot;change&quot;, &#123; ...this.phoneInfo, phone: e.target.value &#125;); &#125;, handleZipCodeChange(e) &#123; this.$emit(&quot;update:zipCode&quot;, e.target.value); &#125; &#125;&#125;;&lt;/script&gt; 123允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。v-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景。引入sync标记。这种双向的改变可以灵活控制，但是会带来维护上的复杂性 Object.defineProperty 与 Proxy 1.Object.defineProperty：只能对属性进行劫持，需要递归遍历对象的每个属性，执行Object.defineProperty把每一层对象数据都变成响应式的（如果定义的响应式数据过于复杂，会有很大的性能负担）不能检测对象属性的添加和删除（需要重新遍历）2.Proxy在getter中去递归响应式，真正访问到的内部对象才会变成响应式，而不是无脑递归，提升了性能劫持的是整个对象，能检测到对象属性的添加和删除 Observer/Dep/WatcherObserver Observer 的作用是对整个 Data 进行监听，在 initData 这个初始方法里使用observe(data),Observer 类内部通过 defineReactive 方法劫持 data 的每一个属性的 getter 和 setter。看一下源码： 123456789101112131415161718192021222324252627export function observe(value: any, asRootData: ?boolean): Observer | void &#123; /*判断Data是否是一个对象*/ if (!isObject(value)) &#123; return; &#125; let ob: Observer | void; /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/ if (hasOwn(value, &quot;__ob__&quot;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/ observerState.shouldConvert &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; // 创建一个Observer实例，绑定data进行监听 ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/ ob.vmCount++; &#125; return ob;&#125; Vue 的响应式数据都会有一个ob作为标记，里面存放了 Observer 实例，防止重复绑定。 再看一下 Observer 类的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Observer class that are attached to each observed * object. Once attached, the observer converts target * object&#x27;s property keys into getter/setters that * collect dependencies and dispatches updates. */export class &#123; value: any; dep: Dep; // 每一个Data的属性都会绑定一个dep，用于存放watcher arr vmCount: number; // number of vms that has this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 /* /vue-src/core/util/lang.js: function def (obj: Object, key: string, val: any, enumerable?: boolean) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;) &#125; */ def(value, &#x27;__ob__&#x27;, this) // 这个def的意思就是把Observer实例绑定到Data的__ob__属性上去 if (Array.isArray(value)) &#123; /* 如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。 */ const augment = hasProto ? protoAugment /*直接覆盖原型的方法来修改目标对象*/ : copyAugment /*定义（覆盖）目标对象或数组的某一个方法*/ augment(value, arrayMethods, arrayKeys) /*Github:https://github.com/answershuto*/ /*如果是数组则需要遍历数组的每一个成员进行observe*/ this.observeArray(value) &#125; else &#123; /*如果是对象则直接walk进行绑定*/ this.walk(value) &#125; &#125; /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) /* walk方法会遍历对象的每一个属性进行defineReactive绑定 defineReactive: 劫持data的getter和setter */ for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i], obj[keys[i]]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; /* 数组需要遍历每一个成员进行observe */ for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到，Observer 类主要干了以下几件事： 给 data 绑定一个ob属性，用来存放 Observer 实例，避免重复绑定 如果 data 是 Object, 遍历对象的每一个属性进行 defineReactive 绑定 如果 data 是 Array, 则需要对每一个成员进行 observe。vue.js 会重写 Array 的 push、pop、shift、unshift、splice、sort、reverse 这 7 个方法，保证之后 pop/push 等操作进去的对象也有进行双向绑定. (具体代码参见 observer/array.js) defineReactive() 如上述源码所示，Observer 类主要是靠遍历 data 的每一个属性，使用 defineReactive()方法劫持 getter 和 setter 方法, 下面来具体看一下 defineReactive: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export function defineReactive( obj: Object, key: string, val: any, customSetter?: Function) &#123; /*在闭包中定义一个dep对象*/ const dep = new Dep(); const property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return; &#125; /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/ // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get; const setter = property &amp;&amp; property.set; /*对象的子对象也会进行observe*/ let childOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; /*如果原本对象拥有getter方法则执行*/ const value = getter ? getter.call(obj) : val; // Dep.target：全局属性，用于指向某一个watcher，用完即丢 if (Dep.target) &#123; /* 进行依赖收集 dep.depend()内部实现addDep，往dep中添加watcher实例 (具体参考Dep.prototype.depend的代码) depend的时候会根据id判断watcher有没有添加过，避免重复添加依赖 */ dep.depend(); if (childOb) &#123; /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/ childOb.dep.depend(); &#125; if (Array.isArray(value)) &#123; /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/ dependArray(value); &#125; &#125; return value; &#125;, set: function reactiveSetter(newVal) &#123; /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/ const value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return; &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; customSetter) &#123; customSetter(); &#125; if (setter) &#123; /*如果原本对象拥有setter方法则执行setter*/ setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; /*新的值需要重新进行observe，保证数据响应式*/ childOb = observe(newVal); /*dep对象通知所有的观察者*/ dep.notify(); &#125;, &#125;);&#125; defineReactive()方法主要通过 Object.defineProperty()做了以下几件事: 在闭包里定义一个 Dep 实例； getter 用来收集依赖，Dep.target 是一个全局的属性，指向的那个 watcher 收集到 dep 里来（如果之前添加过就不会重复添加）； setter 是在更新 value 的时候通知所有 getter 时候通知所有收集的依赖进行更新（dep.notify）。这边会做一个判断，如果 newVal 和 oldVal 一样，就不会有操作。 Dep 在上面的 defineReactive 中提到了 Dep，于是接下来看一下 Dep 的源码, dep 主要是用来在数据更新的时候通知 watchers 进行更新： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * A dep is an observable that can have multiple * directives subscribing to it. */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ // subs: Array&lt;Watcher&gt; this.subs = [] &#125; /*添加一个观察者对象*/ addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; /*移除一个观察者对象*/ removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; /*依赖收集，当存在Dep.target的时候添加观察者对象*/// 在defineReactive的getter中会用到dep.depend() depend () &#123; if (Dep.target) &#123; // Dep.target指向的是一个watcher Dep.target.addDep(this) &#125; &#125; /*通知所有订阅者*/ notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; // 调用每一个watcher的update subs[i].update() &#125; &#125;&#125;// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.Dep.target = null/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/ Dep 是一个发布者，可以订阅多个观察者，依赖收集之后 Dep 中会有一个 subs 存放一个或多个观察者，在数据变更的时候通知所有的 watcher。 再复习一下，Dep 和 Observer 的关系就是 Observer 监听整个 data，遍历 data 的每个属性给每个属性绑定 defineReactive 方法劫持 getter 和 setter, 在 getter 的时候往 Dep 类里塞依赖（dep.depend），在 setter 的时候通知所有 watcher 进行 update(dep.notify) Watcher watcher 接受到通知之后，会通过回调函数进行更新。 接下来我们要仔细看一下 watcher 的源码。由之前的 Dep 代码可知的是，watcher 需要实现以下两个作用： dep.depend()的时候往 dep 里添加自己； dep.notify()的时候调用 watcher.update()方法，对视图进行更新； 同时要注意的是，watcher 有三种：render watcher/ computed watcher/ user watcher(就是 vue 方法中的那个 watch) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255export default class Watcher &#123; vm: Component; expression: string; // 每一个DOM attr对应的string cb: Function; // update的时候的回调函数 id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: ISet; newDepIds: ISet; getter: Function; value: any; constructor( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm; /*_watchers存放订阅者实例*/ vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new Set(); this.newDepIds = new Set(); this.expression = process.env.NODE_ENV !== &quot;production&quot; ? expOrFn.toString() : &quot;&quot;; // parse expression for getter /*把表达式expOrFn解析成getter*/ if (typeof expOrFn === &quot;function&quot;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = function () &#123;&#125;; process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; warn( `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` + &quot;Watcher only accepts simple dot-delimited paths. &quot; + &quot;For full control, use a function instead.&quot;, vm ); &#125; &#125; this.value = this.lazy ? undefined : this.get(); &#125; /** * Evaluate the getter, and re-collect dependencies. */ /*获得getter的值并且重新进行依赖收集*/ get() &#123; /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/ pushTarget(this); let value; const vm = this.vm; /* 执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。 在将Dep.target设置为自身观察者实例以后，执行getter操作。 譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c， 那么在执行getter的时候就会触发a跟c两个数据的getter函数， 在getter函数中即可判断Dep.target是否存在然后完成依赖收集， 将该观察者对象放入闭包中的Dep的subs中去。 */ if (this.user) &#123; // this.user: 判断是不是vue中那个watch方法绑定的watcher try &#123; value = this.getter.call(vm, vm); &#125; catch (e) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`); &#125; &#125; else &#123; value = this.getter.call(vm, vm); &#125; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/ if (this.deep) &#123; /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/ traverse(value); &#125; /*将观察者实例从target栈中取出并设置给Dep.target*/ popTarget(); this.cleanupDeps(); return value; &#125; /** * Add a dependency to this directive. */ /*添加一个依赖关系到Deps集合中*/ // 在dep.depend()中调用的是Dep.target.addDep() addDep(dep: Dep) &#123; const id = dep.id; if (!this.newDepIds.has(id)) &#123; // newDepIds和newDeps记录watcher实例所用到的dep，比如某个computed watcher其实用到了data里的a/b/c三个属性，那就需要记录3个dep this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; // 作用是往dep的subs里添加自己（Watcher实例） // 但是会先判断一下id，如果subs里有相同的id就不会重复添加 dep.addSub(this); &#125; &#125; &#125; /** * Clean up for dependency collection. */ /*清理依赖收集*/ cleanupDeps() &#123; /*移除所有观察者对象*/ let i = this.deps.length; while (i--) &#123; const dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; let tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0; &#125; /** * Subscriber interface. * Will be called when a dependency changes. */ // dep.notify的时候会逐个调用watcher的update方法 update() &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ // 基本不会用到sync this.run(); &#125; else &#123; /*异步推送到观察者队列中，由调度者调用。*/ queueWatcher(this); &#125; &#125; /** * Scheduler job interface. * Will be called by the scheduler. */ /* 调度者工作接口，将被调度者回调。 */ run() &#123; if (this.active) &#123; const value = this.get(); if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. /* 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */ isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value; /*设置新的值*/ this.value = value; /*触发回调渲染视图*/ if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError( e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;` ); &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125; &#125; /** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ /*获取观察者的值*/ evaluate() &#123; this.value = this.get(); this.dirty = false; &#125; /** * Depend on all deps collected by this watcher. */ /*收集该watcher的所有deps依赖*/ depend() &#123; let i = this.deps.length; while (i--) &#123; this.deps[i].depend(); &#125; &#125; /** * Remove self from all dependencies&#x27; subscriber list. */ /*将自身从所有依赖收集订阅列表删除*/ teardown() &#123; if (this.active) &#123; // remove self from vm&#x27;s watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/ if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this); &#125; let i = this.deps.length; while (i--) &#123; this.deps[i].removeSub(this); &#125; this.active = false; &#125; &#125;&#125; Virtual DOMVirtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。 虚拟DOM就是一个普通的JavaScript对象，包含了tag、props、children三个属性。 Virtual DOM做了两件事: 1、用 JS对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中； 2、当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异； 3、把两棵树差异应用到真实DOM上 属性key的作用： key的作用是尽可能的复用 DOM 元素 Virtual DOM-diff算法算法实现的三个核心函数：element,diff,patch。 算法大致流程: 12345678910111213141516171819// 1. 构建虚拟 DOMvar tree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [ el(&#x27;h1&#x27;, &#123;style: &#x27;color: blue&#x27;&#125;, [&#x27;simple virtal dom&#x27;]), el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]), el(&#x27;ul&#x27;, [el(&#x27;li&#x27;)])])// 2. 通过虚拟 DOM 构建真正的 DOMvar root = tree.render()document.body.appendChild(root)// 3. 生成新的虚拟 DOMvar newTree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [ el(&#x27;h1&#x27;, &#123;style: &#x27;color: red&#x27;&#125;, [&#x27;simple virtal dom&#x27;]), el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]), el(&#x27;ul&#x27;, [el(&#x27;li&#x27;), el(&#x27;li&#x27;)])])// 4. 比较两棵虚拟 DOM 树的不同var patches = diff(tree, newTree)// 5. 在真正的 DOM 元素上应用变更patch(root, patches) diff算法参考了snabbdom(https://github.com/snabbdom/snabbdom)是著名的虚拟DOM库，diff算法的鼻祖。 1.patch中的sameVnode方法：判断是否为相同节点：依据key和tag标签名 是：继续执行patchVnode方法进行深层比对 否：没必要比对了，直接整个节点替换成新虚拟节点 key值是否一样；标签名是否一样；否都为注释节点；是否都定义了data 2.patchVnode：更新节点 判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都是文本节点并且不相等，那么将el的文本节点设置为newVnode的文本节点。 如果oldVnode有子节点而newVnode没有，则删除el的子节点 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 3.updateChildren：首尾指针法 「双端比较的算法」过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较. oldNode头尾指针标记，newNode头尾指针标记。 oldNode与newNode指针逐个比较，如果判定相同节点，则执行patchVnode更新节点。 否则以newNode的key去oldNode中寻找等key值，如果找到key相等的，再比较sameVnode，如果相同，则patchVnode更新节点，否则插入节点。如果没有找到key相等的，则插入节点。 如果结束后，oldNodeStart&gt;=oldNodeEnd，那么就需要删除旧节点中部分节点。newNodeStart&gt;=newNodeEnd，那么需要新增新节点中的部分节点。 inject/provide的响应式问题官方说法： provide/inject 的 直接绑定数据 才不支持响应式，但又因为 没有对数据的进行深层次处理，所以原有的响应式数据才会继续触发整个响应式系统的改变。 说人话：直接修改对象，inject监听不到改动；修改对象的某个属性，就能监听到改动。加一句，即使修改属性，computed也监听不到变化。 123456789101112131415161718192021222324// 祖先组件provide()&#123; return &#123; // keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型 keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()] // keyName: &#x27;test&#x27; value 如果是基本类型，就无法实现响应式 &#125; &#125;,data()&#123; return &#123; name:&#x27;张三&#x27;&#125; &#125;, methods: &#123; changeValue()&#123; this.name = &#x27;改变后的名字-李四&#x27; &#125; &#125; // 后代组件 inject:[&#x27;keyName&#x27;] create()&#123; console.log(this.keyName) // 改变后的名字-李四&#125; 看源码:关闭了依赖数据的 响应式依赖收集;但对inject注入对象的深层处理，没有屏蔽响应式 12345678910111213141516171819202122232425262728293031323334353637export function initInjections(vm: Component) &#123; // 对inject注入对象深层处理，没有屏蔽响应式 const result = resolveInject(vm.$options.inject, vm) if (result) &#123; // 关闭了依赖数据的 响应式依赖收集 toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; if (__DEV__) &#123; defineReactive(vm, key, result[key], () =&gt; warn(&#x27;&#x27;)) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125;export function resolveInject(inject: any, vm: Component): Record&lt;string, any&gt; | undefined | null &#123; if (inject) &#123; const result = Object.create(null) const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] if (key === &#x27;__ob__&#x27;) continue const provideKey = inject[key].from if (provideKey in vm._provided) &#123; result[key] = vm._provided[provideKey] &#125; else if (&#x27;default&#x27; in inject[key]) &#123; const provideDefault = inject[key].default result[key] = isFunction(provideDefault) ? provideDefault.call(vm) : provideDefault &#125; else if (__DEV__) &#123; warn(&#x27;&#x27;) &#125; &#125; return result &#125;&#125; 参考 Vue 2 阅读理解（十四）之 Provide/Inject 依赖注入 Vue模板编译流程Vue | 模板是如何编译的 Vue提供两个不同构建版本： vue.js： 完整版本，包含了模板编译的能力；对应runtime-compiler vue.runtime.js： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。对应runtime-only 所以 如果通过 script 标签引入 Vue，需要使用 vue.min.js 如果使用了vue-loader,就可以只用 vue.runtime.js 编译核心流程： parse解析器：将模板解析成 AST抽象语法树 optimize优化器：标记静态节点 generate代码生成器：将 AST 转换成“代码字符串” 编译渲染完整流程： template =&gt; ast =&gt; render函数 =&gt; VDOM =&gt; 真实DOM 先将template解析成抽象语法树（ast） 将ast编译成（complier）成render函数 将render函数渲染（render）成虚拟DOM 最后将虚拟DOM渲染成真实DOM keep-alive原理1.定义 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 一般结合路由和动态组件一起使用，用于缓存组件； 常用的两个属性include/exclude，允许组件有条件的进行缓存。其中 exclude 的优先级比 include 高 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。 keep-alive的中还运用了LRU(Least Recently Used)算法。 2.功能 include定义缓存白名单，keep-alive会缓存命中的组件；exclude定义缓存黑名单，被命中的组件将不会被缓存；max定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。include优先级比exclude更高。 3.源码分析 (1.1)初始化过程： 获取keep-alive包裹的组件及组件名。 根据设置的黑白名单，判断缓存是否命中，命中则使用缓存，否则直接创建或销毁组件。核心函数pruneCacheEntry 根据组件ID和tag生成缓存Key，value为componentInstance组件实例的键值对。 键值对超过max长度，使用LRU最近最少使用策略删除。 设置keepAlive为true即标记为激活状态,patch期间渲染组件，mounted等生命周期过滤 123456789101112131415161718192021222324252627282930313233343536373839// src/core/components/keep-alive.jsexport default &#123; name: &#x27;keep-alive&#x27;, abstract: true, // 判断当前组件虚拟dom是否渲染成真实dom的关键 props: &#123; include: patternTypes, // 缓存白名单 exclude: patternTypes, // 缓存黑名单 max: [String, Number] // 缓存的组件实例数量上限，使用LRU最近最少使用的组件删除 &#125;,//核心是cache和keys，keys里默认值是tagname。//这两个属性没有声明到可视化的data中,静态属性声明可以减少数据监听的开销 created () &#123; this.cache = Object.create(null) // 缓存虚拟dom的key和实例的映射 this.keys = [] // 缓存的虚拟dom的key键集合 &#125;, destroyed () &#123; //销毁时，更新cache for (const key in this.cache) &#123; // 删除所有的缓存 pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted () &#123; // 实时监听黑白名单的变动 this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;) &#125;, render () &#123; // 先省略... &#125;&#125; 核心render函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// src/core/components/keep-alive.jsrender () &#123; const slot = this.$slots.default const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象 const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; // 存在组件参数 // check pattern const name: ?string = getComponentName(componentOptions) // 组件名,name:&#x27;VBase&#x27; const &#123; include, exclude &#125; = this if ( // 条件匹配 // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; //没有匹配到，则直接返回节点 return vnode &#125; const &#123; cache, keys &#125; = this const key: ?string = vnode.key == null // 定义组件的缓存key // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key if (cache[key]) &#123; // 已经缓存过该组件 //将缓存的组件，赋值给你要渲染的新的组件 vnode.componentInstance = cache[key].componentInstance // make current key freshest //删除并添加key remove(keys, key) keys.push(key) // 调整key排序 &#125; else &#123; cache[key] = vnode // 缓存组件对象 keys.push(key) // prune oldest entry //如果超过max最大缓存组件的长度，使用LRU策略，删除第一个 if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; // 超过缓存数限制，将第一个删除 pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; vnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到 &#125; return vnode || (slot &amp;&amp; slot[0])&#125; (1.2)actived生命周期流程： patch阶段调用invokeInsertHook，执行activateChildComponent递归调用自组建的active生命周期。所以先执行子组件的active，然后是父组件的active. deactivated也是类似。标记为失活状态。 4.使用场景 123456789101112131415&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 动态判断 --&gt;&lt;keep-alive :include=&quot;includedComponents&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 首页是A页面 B页面跳转到A，A页面需要缓存 C页面跳转到A，A页面不需要被缓存 12345678910111213141516171819202122232425262728293031323334&#123; path: &#x27;/&#x27;, name: &#x27;A&#x27;, component: A, meta: &#123; keepAlive: true // 需要被缓存 &#125;&#125;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;, beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta to.meta.keepAlive = true; // B 跳转到 A 时，让 A 缓存，即不刷新 next(); &#125;&#125;;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;, beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新 next(); &#125;&#125;; 4.vue的渲染过程 Vue在渲染的时候先调用原型上的_render函数将组件对象转化为一个VNode实例；而_render是通过调用createElement和createEmptyVNode两个函数进行转化。 完成VNode实例化后，Vue调用原型上的_update函数把VNode渲染为真实DOM，这个过程又是通过调用__patch__函数完成的。 keep-alive刚好就发生在patch期间。abstract: true也导致了vue渲染时，不会生成真正的实例。 nextTick的实现原理 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 2.源码分析 nextTick源码主要分为两块： 1.能力检测 2.根据能力检测以不同方式执行回调队列 (2.1)能力检测 Event Loop分为宏任务（macro task）以及微任务（ micro task），不管执行宏任务还是微任务，完成后都会进入下一个tick，并在两个tick之间执行UI渲染。 宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务。 nextTick在能力检测这一块，就是遵循的这种思想。 1234567891011121314151617181920212223242526//首先，检测浏览器是否支持setImmediate，不支持就使用MessageChannel，再不支持只能使用效率最差但是兼容性最好的setTimeout了。//之后，检测浏览器是否支持Promise，如果支持，则使用Promise来执行回调函数队列，毕竟微任务速度大于宏任务。如果不支持的话，就只能使用宏任务来执行回调函数队列。if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // 如果支持，宏任务（ macro task）使用setImmediate macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125; // 同上&#125; else if (typeof MessageChannel !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === &#x27;[object MessageChannelConstructor]&#x27;)) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; /* istanbul ignore next */ // 都不支持的情况下，使用setTimeout macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; (2.2)执行回调函数队列 总体流程是:接收回调函数，将回调函数推入回调函数队列中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 回调函数队列const callbacks = []// 异步锁let pending = false// 执行回调函数function flushCallbacks () &#123; // 重置异步锁 pending = false // 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份，清空回调函数队列 const copies = callbacks.slice(0) callbacks.length = 0 // 执行回调函数队列 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;...// 我们调用的nextTick函数export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 将回调函数推入回调队列 callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列 if (!pending) &#123; pending = true if (useMacroTask) &#123; macroTimerFunc() &#125; else &#123; microTimerFunc() &#125; &#125; // $flow-disable-line // 2.1.0新增，如果没有提供回调，并且支持Promise，返回一个Promise if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 有2个关键点： 如何保证只在接收第一个回调函数时执行异步方法？ nextTick源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。 当然执行flushCallbacks函数时有个难以理解的点，即：为什么需要备份回调函数队列？执行的也是备份的回调函数队列？ 因为，会出现这么一种情况：nextTick套用nextTick。如果flushCallbacks不做特殊处理，直接循环执行回调函数，会导致里面nextTick中的回调函数会进入回调队列。这就相当于，下一个班车的旅客上了上一个班车。 3.自己实现简易的nextTick 在简易版的nextTick中，通过nextTick接收回调函数，通过setTimeout来异步执行回调函数。通过这种方式，可以实现在下一个tick中执行回调函数，即在UI重新渲染后执行回调函数。 123456789101112131415161718192021let callbacks = []let pending = falsefunction nextTick (cb) &#123; callbacks.push(cb) if (!pending) &#123; pending = true setTimeout(flushCallback, 0) &#125;&#125;function flushCallback () &#123; pending = false let copies = callbacks.slice() callbacks.length = 0 copies.forEach(copy =&gt; &#123; copy() &#125;)&#125; Vue-router路由-hash和history hash模式：通过#号后面的内容的更改，触发hashchange事件，实现路由切换 history模式：通过pushState和replaceState切换url，触发popstate事件，实现路由切换，需要后端配合 区别 url 展示上，hash 模式有“#”，history 模式没有 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由 兼容性，hash 可以支持低版本浏览器和 IE。 Vue-router路由-懒加载三种实现方式： vue异步组件 es提案的import() webpack的require,ensure() 1.vue异步组件 12345&#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: resolve =&gt; **require**([&#x27;@/components/home&#x27;],resolve) &#125;, 2.es提案的import() 1const Home = () =&gt; import(&#x27;@/components/home&#x27;) 3.webpack的require,ensure() 12345&#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/home&#x27;)), &#x27;demo&#x27;) &#125;, Vue-router导航守卫有哪些 全局前置/钩子：beforeEach、beforeResolve、afterEach 路由独享的守卫：beforeEnter 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave 完整的导航解析流程： 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫(2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 1.全局守卫 具体分为：全局前置守卫、全局解析守卫、全局后置钩子 1.1 全局前置守卫-beforeEach 12345// GOODrouter.beforeEach((to, from, next) =&gt; &#123; if (to.name !== &#x27;Login&#x27; &amp;&amp; !isAuthenticated) next(&#123; name: &#x27;Login&#x27; &#125;) else next()&#125;) 1.2 全局解析守卫-beforeResolve 在 每次导航时都会触发，但是确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用 123456789101112131415router.beforeResolve(async to =&gt; &#123; if (to.meta.requiresCamera) &#123; try &#123; await askForCameraPermission() &#125; catch (error) &#123; if (error instanceof NotAllowedError) &#123; // ... 处理错误，然后取消导航 return false &#125; else &#123; // 意料之外的错误，取消导航并把错误传给全局处理器 throw error &#125; &#125; &#125;&#125;) 1.3 全局后置钩子 不会接受 next 函数也不会改变导航本身，对于分析、更改页面标题、声明页面等辅助功能 123router.afterEach((to, from, failure) =&gt; &#123; if (!failure) sendToAnalytics(to.fullPath)&#125;) 2.路由独享的守卫-beforeEnter beforeEnter 守卫 只在进入路由时触发，不会在 params、query 或 hash 改变时触发 12345678910const routes = [ &#123; path: &#x27;/users/:id&#x27;, component: UserDetails, beforeEnter: (to, from) =&gt; &#123; // reject the navigation return false &#125;, &#125;,] 3.组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 123456789101112131415161718const UserDetails = &#123; template: `...`, beforeRouteEnter(to, from) &#123; // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ &#125;, beforeRouteUpdate(to, from) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` &#125;, beforeRouteLeave(to, from) &#123; // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` &#125;,&#125; $route和$router的区别 $route 是路由信息对象，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。 而$router 是路由实例对象包括了路由的跳转方法，钩子函数等。 vue 性能优化编码阶段 不要在模板里面写过多表达式 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 如果需要使用v-for给每项元素绑定事件时使用事件代理 SPA 页面采用keep-alive缓存组件 频繁切换的使用 v-show，不频繁切换的使用 v-if 循环调用子组件时添加 key，key保证唯一 使用路由懒加载、异步组件 防抖、节流 第三方模块按需导入 长列表滚动到可视区域动态加载 图片懒加载 **** SEO 优化 预渲染 服务端渲染SSR，nuxt.js 打包优化 压缩代码 Tree Shaking/Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化 用户体验 骨架屏 PWA渐进式 Web 应用，使用多种技术来增强 web app 的功能，让网页应用呈现和原生应用相似的体验。 SFC平时写的 .vue 文件称为 SFC(Single File Components)。vue 会先对 .vue 文件进行解析，分成 template、script、styles、customBlocks 四个部分，称为 descriptor。之后，再对这四个部分分别进行编译最终得到可以在浏览器中执行的 .js 文件.最终编译成.js 文件是交给 vue-loader 等库来做的。 SFCDescriptor，是表示 .vue 各个代码块的对象，为以下数据格式： 1234567// an object format describing a single-file component.declare type SFCDescriptor = &#123; template: ?SFCBlock; script: ?SFCBlock; styles: Array&lt;SFCBlock&gt;; customBlocks: Array&lt;SFCBlock&gt;;&#125;; vue 提供了一个 [compiler.parseComponent(file, [options\\])方法]，来将 .vue 文件解析成一个 SFCDescriptor。 1.文件入口 解析 sfc 文件的源码入口在 src/sfc/parser.js 中，编译后的产出在 /packages/vue-template-compiler 和 /packages/vue-server-renderer 下的 build.js 中。 build.js 文件中直接 export 出了parseComponent方法。 首先我们来看看parseComponent方法都做了哪些事情。 2.parseComponent方法 parseComponent方法中主要定义了start和end两个函数，之后调用了parseHTML方法来对 .vue 文件内容践行编译。start和end两个函数作为参数传给了parseHTML，我们等下再看。 先看下这个parseHTML方法是做啥的呢？ 3.parseHTML方法 该方法看名字可以猜到是一个 html-parser。 parseHTML 的代码细节较多，我们可以简单理解为：遍历解析查找文件中的各个标签，解析到每个起始标签时，调用 option 中的 start 方法进行处理；解析到每个结束标签时，调用 option 中的 end 方法进行处理。 对应到这里，就是分别调用parseComponent方法中定义的 start 和 end 函数进行处理。 由于我们这里只是想要找到第一层标签，也就是 template、script 这些。因此可以在parseComponent中维护一个 depth 变量，在start中将depth++，在end中depth--。那么，每个depth === 1的标签就是我们需要获取的信息，包含 template、script、style 以及一些自定义标签。 接下来我们来看start和end中进行了哪些处理。 4.start 每当遇到一个起始标签时，执行start函数。 1、记录下 currentBlock。每个 currentBlock 包含以下内容： 2、根据 tag 名称，将 currentBlock 对象保存在在返回结果对象中。 返回结果对象定义为 sfc，如果 tag 不是 script,style,template 中的任一个，就放在 sfc.customBlocks 中。如果是 style，就放在 sfc.styles 中。script 和 template 则直接放在 sfc 下。 5.end 每当遇到一个结束标签时，执行end函数。 如果当前是第一层标签(depth === 1)，并且 currentBlock 变量存在，那么取出这部分 text，放在 currentBlock.content 中。 在将 .vue 整个遍历一遍后，得到的 sfc 对象即为我们需要的 SFCDescriptor。 6.生成 .js compiler.parseComponent(file, [options])得到的只是一个组件的 SFCDescriptor，最终编译成.js 文件是交给 vue-loader 等库来做的。 Flow静态类型检测器 Flow官网 Flow中文网 Flow中文攻略 安装编译器首先，你需要一个编译器来剔除Flow的类型注解。你可以选择Babel或flow-remove-types. Babel Babel是一个支持Flow的Javascript编译器。Babel我们通俗的理解就是把现在浏览器不支持的新特性（比如：ES6）转换为可以支持的ES5语法，从而使我们能在项目中体测新标准带来的福利。Babel使用我们Flow代码，并剔除所有的类型注解。 首先得安装 babel-cli 或 babel-preset-flow npm环境 1npm install --save-dev babel-cli babel-preset-flow 新建一个 .babelrc文件，并在 presets属性里设置 flow 123&#123; &quot;presets&quot;: [&quot;flow&quot;]&#125; 如果你的源代码在 src 目录里，你可以将这些代码编译到另一个目录中 npm环境 1./node_modules/.bin/babel src/ -d lib/ 当然，在 package.json配置运行 1234567&#123; &quot;name&quot;: &quot;my-project&quot;, &quot;main&quot;: &quot;lib/index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/ -d lib/&quot; &#125;&#125; flow-remove-types flow-remove-types是一个简单去掉类型注释的命令行工具，他是一个不需要 Babel 支持的轻量级代替 Babel的工具。 首行安装 flow-remove-types 1npm install --save-dev flow-remove-types 如果你的源代码在 src 目录里，你可以将这些代码编译到另一个目录中 1./node_modules/.bin/flow-remove-types src/ -d lib/ 在 package.json配置运行 1234567&#123; &quot;name&quot;: &quot;my-project&quot;, &quot;main&quot;: &quot;lib/index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;flow-remove-types src/ -d lib/&quot; &#125;&#125; 安装 Flow把npm包安装到devDependency上 1npm install --save-dev flow-bin 在 package.json 的 scripts 里添加 &quot;flow&quot; 12345678910&#123; &quot;name&quot;: &quot;my-flow-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;devDependencies&quot;: &#123; &quot;flow-bin&quot;: &quot;^0.86.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;flow&quot;: &quot;flow&quot; &#125;&#125; 首先运行 1npm run flow init 在第一次运行了 init 后，运行 1npm run flow /src/index.js 12345678// @flowfunction square(n: number): number &#123; return n * n;&#125;square(2);","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"Vue3.0_原理","slug":"D_框架_Vue3.0_原理","date":"2023-09-11T23:33:16.000Z","updated":"2024-02-28T23:03:21.894Z","comments":true,"path":"2023/09/12/D_框架_Vue3.0_原理/","link":"","permalink":"https://fuyunjinglong.github.io/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue3.0_%E5%8E%9F%E7%90%86/","excerpt":"","text":"入门生命周期 setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和methodonBeforeMount() : 组件挂载到节点上之前执行的函数。onMounted() : 组件挂载完成后执行的函数。onBeforeUpdate(): 组件更新之前执行的函数。onUpdated(): 组件更新完成之后执行的函数。onBeforeUnmount(): 组件卸载之前执行的函数。onUnmounted(): 组件卸载完成后执行的函数onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。 Vue2 Vue3 beforeCreate ❌setup(替代) created ❌setup(替代) beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted errorCaptured onErrorCaptured 🎉onRenderTracked 🎉onRenderTriggered 新增的钩子函数onRenderTracked()和 onRenderTriggered() onRenderTracked() 直译过来就是状态跟踪，它会跟踪页面上所有响应式变量和方法的状态。只要页面有update的情况，他就会跟踪，然后生成一个event对象。 onRenderTriggered() 直译过来是状态触发，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。 与watch相似。 event 对象属性的详细介绍： key 那边变量发生了变化 newValue 更新后变量的值 oldValue 更新前变量的值 target 目前页面中的响应变量和函数 实际开发中如何使用 beforecreate : 可以在这函数中初始化加载动画 created ：做一些数据初始化，实现函数自执行 mounted： 调用后台接口进行网络请求，拿回数据，配合路由钩子做一些事情 destoryed ：当前组件已被删除，清空相关内容 mounted中做网络请求和重新赋值，在destoryed中清空页面数据。 单组件 页面首次加载 1setup -&gt; onBeforeMount -&gt; onRenderTracked -&gt; onMounted 页面更新 1onRenderTriggered -&gt; onBeforeUpdate -&gt; onUpdated 页面卸载 1onBeforeUnmount -&gt; onUnmounted 父子组件生命周期更新顺序 页面首次加载 1父组件setup -&gt; 父组件onBeforeMount -&gt; 父组件onRenderTracked -&gt; 子组件setup -&gt; 子组件onBeforeMount -&gt; 子组件onRenderTracked -&gt; 子组件onMounted -&gt; 父组件onMounted 页面更新 纯父组件属性更新 onRenderTriggered -&gt; onBeforeUpdate -&gt; onUpdated 纯子组件属性更新 onRenderTriggered -&gt; onBeforeUpdate -&gt; onUpdated 父组件属性更新，该属性在子组件中有被使用 父组件onRenderTriggered -&gt; 父组件onBeforeUpdate -&gt; 子组件onBeforeUpdate -&gt; 子组件onUpdated -&gt; 父组件onUpdated 子组件属性更新，该属性在父组件中有被使用 子组件onRenderTriggered -&gt; 父组件onRenderTriggered -&gt; 父组件onBeforeUpdate -&gt; 子组件onBeforeUpdate -&gt; 子组件onUpdated -&gt; 父组件onUpdated 页面卸载 1父组件onBeforeUnmount -&gt; 子组件onBeforeUnmount -&gt; 子组件onUnmounted -&gt; 父组件onUnmounted 生命周期 Proxy是代理，Reflect是干嘛用的？准确讲应该是这样的，Reflect更像是一种语法变体，其挂在的所有方法都能找到对应的原始语法，也就是Reflect的替代性非常强。 比较常用的两个方法就是get()和set()方法： 12Reflect.get(target, propertyKey)Reflect.set(target, propertyKey, value) 等效于 12target[propertyKey]target[propertyKey] = value; Reflect对象经常和Proxy代理一起使用，原因有三点： Reflect提供的所有静态方法和Proxy第2个handle参数方法是一模一样的。 Proxy get/set()方法需要的返回值正是Reflect的get/set方法的返回值，可以天然配合使用，比直接对象赋值/获取值要更方便和准确(通过返回值知道是否赋值成功，并不会因为报错而中断正常代码执行)。 receiver参数具有不可替代性。 关于receiver参数 receiver是接受者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver参数是无需使用的，但是如果发生了继承，为了明确调用主体，receiver参数就需要出马了。 12345678910111213141516171819let miaoMiao = &#123; _name: &#x27;疫苗&#x27;, get name () &#123; return this._name; &#125;&#125;let miaoXy = new Proxy(miaoMiao, &#123; get (target, prop, receiver) &#123; return target[prop]; &#125;&#125;);let kexingMiao = &#123; __proto__: miaoXy, _name: &#x27;科兴疫苗&#x27;&#125;;// 结果是疫苗console.log(kexingMiao.name); 实际上，这里预期显示应该是“科兴疫苗”，而不是“疫苗”。 这个时候，就需要使用receiver参数了，代码变化部分参见下面标红的那一行： 12return Reflect.get(target, prop, receiver);// 也可以简写为 Reflect.get(...arguments) 进阶Vue3存在的问题参考 Vue3的漏洞 丢失响应性 Vue3的TypeScript对类型的支持十分孱弱 一、丢失响应性 vue3还存在着很多问题 例如对ts支持不够友好 ref.value的混乱 解构丢失响应性（不知道有啥好的实践,目前是使用计算属性） 从体验上远不如vue2 目前个人认为最完善的库是solidjs 可惜生态没跟上来 可能对大家而言react vue并不是最好的解 react一个useeffct官网花6篇文章来描述这个api 我真是笑了 总而言之react vue3写起来不是很润。 你没有发现吗?Vue团队是为了补坑而补坑,Vue2的ref仅仅是引用组件而已,而在Vue3变成了定义响应式变量,这一点我估计是参考了react,但react的运行机制与vue不同,react的ref是定义一个引用,避免组件重新渲染值被重置。 vue3对ts的支持挺不错了，毕竟本身就是用ts写的，模板对ts的支持可能比较弱。解构这个绕不过去，不是vue3的问题，原生js就是那样，除非魔改，但是魔改的好几版提案都没落地。只能说各有取舍吧。 二、Vue3的TypeScript对类型的支持十分孱弱 参考：为什么我感觉 Vue 3 TypeScript 还是不行？ 几个问题： option props define 的方式定义非常不灵活，这种值定义的思想意味着你必须要用值来定义类型，而不是利用类型来指导值应该长什么样，因此 vue 3 整体的类型设计不得不遭受了这个思想的严重毒害，不得不设计的很复杂（具体详见其 d.ts 实现） 值指导类型下不得不引入 ExtractPropTypes 来将 props 值定义转为类型定义，但 vue 没有提供 ExtractPropTypes 的逆运算，导致在定义共有 props 组件 (props 继承) 的时候十分难受 defineComponent 不支持泛型；有个 hack 手段是包一层函数 wrapper来引入泛型，不过这样有运行时开销 应我看就应该取缔 SFC .vue 组件，这东西太反类型了，而且容易造成一个 vue 文件几千行的问题，有悖 VCA 所声称的组合优于继承的设计目标；或者说社区可以考虑去推动 ts 支持自定义文件后缀的 type loader （这样也可以解决 .pb 文件的类型问题） 写惯了 React 的来看 vue tsx 会感觉 slots 的设计很奇怪 … 直接将 props 下的字段作为 slots 使用不是更符合直觉？感觉 vue props 整体的设计完全是 react prop 的子集 … emit、onXxx、vModel 等框架基础概念的类型做得很差, 用过的都懂, 太难受了 Vue 3 还是不够激进（真要激进了我感觉 Vue 就成 React With Reactive Object 了） 尤大的回答： Props 值定义确实是一个兼容性导致的包袱。但是在 下已经支持直接用 defineProps 类型声明 props 了（自动编译为对应的值声明）。tsx 下也有方案在讨论。 sfc 的 TS IDE 支持请用 + vscode + volar。volar 最近几个月很多改进，我个人用已经跟 tsx 感觉没太大差别了。配套的有 vue-tsc 可以做命令行检查。 有了 VCA 还能写几千行的 SFC 组件那就纯粹是人的问题了，VCA 抽取逻辑跟纯 JS/TS 文件没什么区别，一个 TS 文件也能写几千行（几万行的 checker.ts 不也有么 tsx 本质上是 ts 团队给开了后门直接把 tsx 的推导做进了 ts 本身。ts 如果愿意开档更加完整的 plugin 机制，所有基于模板的框架的类型支持也不至于需要绕那么多弯子，然而 ts 团队怕增加维护成本不肯开。不管怎么说 vue 和 svelte 现在通过各种 hack 也算是做出来了基本完整的模板 ts 支持。 模板在性能这块吊打 tsx，在 IDE 支持抹平了的前提下用 tsx 本质上是在为了开发者的偏好牺牲用户体验的性能（性能没遇到瓶颈就无所谓） 这边自己不维护框架的人吐槽吐槽我也能理解，毕竟作为使用者只需要考虑自己爽不爽。作为维护者，Vue 的已有的用户习惯、生态和历史包袱摆在那里，能激进的程度是有限的，Vue 3 的大部分设计都是戴着镣铐跳舞，需要做很多折衷。如果真要激进还不如开个新项目，或者没人用的玩票项目，想怎么设计都可以。 组件泛型的问题也有不少人提出了，这个目前确实不行，但不表示以后不会有。 最后实话实说，所有前端里面像这个问题下面的类型体操运动员们毕竟是少数，绝大部分有 intellisense + 类型校验就满足需求了。真的对类型特别特别较真的用 React 也没什么不好，无非就是性能差点。 松若章的回答： 我觉得 props 的问题很大程度上是兼容性包袱导致的，在 Vue 组件的 prop resolve 的过程里，如果没有大量编写经验其实很难记清楚每种配置会 resolve 什么值。同时这些动态 resolve prop 的过程也对类型的编写造成了很多麻烦，即使在现在的版本，setup 函数中 props 的静态类型和 runtime 的实际表现都有不小的偏差。如果未来这些不一致可以全部修复的话倒也不算什么大问题了 定义共有 props 组件我觉得问题不是很大，只是相比于 React 在 interface 的层面就能共享，Vue 目前必须通过展开运算符才能解决。 我想提一下的是 ExtractPropTypes 的另一个问题，这个工具类型提取出来的其实是用于 setup 函数的 props 而不是外界传入的 props，这实际上对于类型的使用造成了一些阻碍。在 prop 没有 required 的情况下需要使用 Partial&lt;ExtractPropTypes&lt;typeof xxxProps&gt;&gt; 才能给出实际外部的 props 的类型。 针对于组件 props 的泛型，目前似乎没啥好办法，我也很头大，只能采取比泛型更松的类型约束。泛型类型对于业务组件的编写可能不算特别常用，但是对于底层组件的编写其实非常重要。详见： 取缔 SFC 组件有点过于激进了，有点因噎废食的感觉。如果工具链能成熟多数场景下是可以使用 SFC 来编写的，既维持模板的优点也带有类型检查。当然前提是工具链能成熟，包含 vscode 的插件、类似 tsc –noEmit 的命令行类型检查，正确的 dts 文件生成。在年初的时候我尝试过 vuedx、volar，vuedx 会让我的 vscode 卡死，volar 总有类型提示存在问题，发现不太能适应我的开发场景。但是 ts 不能不上，最后我把一个 .vue 的组件库用 .tsx 重写了 slots 的位置确实有放到 props 的可能，毕竟它的机制和 [render props](https://www.zhihu.com/search?q=render props&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={“sourceType”%3A”answer”%2C”sourceId”%3A1835420993}) 非常像，但是我个人觉得放到 prop 里面会导致 tsx 更加难看，因为 vue3 的组件全量使用了函数 slot，不允许数组作为组件 children，在嵌套组件时候和别的 prop 会混起来，这两种风格可能大家各有喜好。 我在 vue3 从没使用过 emits，实际上也非常建议不要允许 emits 属性在生产环境的使用，我相信这个选项留着更多的还是为了兼容性的问题。vModel 本身是个语法糖，类型支持如何完全取决于对 props 的类型支持，只能等着插件逐步完善了。至于对 onXxx 的支持，确实比 React 要弱一些，我觉得目前只能说达到基本可用的状态，由于 Vue 采取了原生事件，原生事件的类型没有对于 target 的泛型，对于事件的支持不如 React 一整套重写的事件类型也是情理之中。 总的来说 Vue3 的 typescript 支持在 TSX 的情境下其实是可以有不错的体验的（但是离 React 还有不小的差距）。但是模板之下，就看工具链是否给力了，还是希望 Vue 在 SFC 情况下的类型体验能早日达到 TSX 的程度。 vue3代码实践建议Typescript TS严格模式：使用TS时，要开启tsconfig中的严格模式，如果关闭严格模式，类型检查的效果将大打折扣 避免AnyScript：使用TS时要进行严格的类型声明，避免过多的any，因为使用any将失去类型检查，如果实在难以描述类型，则可以考虑使用unknow。TS项目中如果存在很多的any，不如抛弃TypeScript 不要保留报错：各类报错通常是用来处理边界情况的，这正是此类报错存在的意义，需要重视并解决。有时候开发者会比TS更清楚数据的类型，此时一些不必要的类型报错可以通过类型断言解决。重视并解决所有报错可以为代码提供更好的健壮性 代码建议 规范、明确的命名： 在命名变量或函数时，名称应该尽可能的明确它的作用/功能，不要使用缩写特别是拼音缩写，这将导致代码可读性严重下降，复杂变量/方法使用注释进行注解 积极使用新的ES语法：包括可选链操作符(?.)、解构、剩余参数语法、空值合并运算符(??)等，合理地使用它们将有效地提高代码可读性 合理的代码组织：单个函数中，一些相关的函数内容写在一起可以有效的规范代码结构，在某个代码块比较复杂时，还可以提取为一个函数置于函数后部，前半部分仅保留核心逻辑，可以有效提升代码可读性。在VUE组件中也是类似的逻辑 语义化代码：在编写代码时，调用各类JSAPI时，应该注重语义化，比如要对数组进行某种批处理，就使用Array.map而不是使用Array.forEach或其他循环方式然后配合外部创建的另一个空数组进行处理。要实现什么效果就使用什么API，这样既可以让代码精简，也可以增强可读性，让代码自己描述自己，这是增强代码可读性的关键 基础功能使用工具类：在进行一些基础判断等操作时，尽量使用一些封装好的工具类，这样可以避免判断时的疏漏而产生错误；使用某功能时也先查询是否已有相关工具，同一类功能使用同一个封装好的工具将更方便管理，但要注意的是此类工具不能过于复杂，否则大范围应用后将会导致难以维护、牵一发而动全身 Vapor ModeVapor Mode是一种替代编译策略，受到Solid的启发，我们一直在进行实验。使用相同的Vue SFC，Vapor Mode将其编译为JavaScript输出，与当前基于Virtual DOM的输出相比，它更具有性能、内存占用和运行时支持代码方面的优势。尽管它仍处于早期阶段，拥有以下优点： 1、Vapor模式旨在用于性能是主要关注点的用例。它是选择性的，不会影响现有的代码库。 2、您将能够将Vapor组件子树嵌入到任何现有的Vue 3应用程序中。理想情况下，我们希望在组件级别实现细粒度选择，这意味着可以在同一个应用程序中自由混合Vapor和非Vapor组件。 3、仅使用Vapor组件构建应用程序允许您从构建包中删除虚拟DOM运行时，从而显着减少基线运行时大小。 4、为了实现最佳性能，Vapor模式将仅支持Vue功能的子集。特别地，Vapor模式组件将仅支持Composition API和。然而，这个受支持的子集在Vapor和非Vapor组件之间将完全相同。 不同框架的编译策略对比： 🚀 React编译之后是Jsx函数返回的虚拟DOM 🚀 Vue编译之后是render函数返回的虚拟DOM 🚀 SolidJS编译之后返回的真实DOM字符串 🚀 Svelte编译之后返回的是真实DOM片段 粗颗粒度：React由于架构机制决定了每当状态发生改变，从当前组件开始一直到叶子组件重新加载。 中颗粒度：Vue由于给每个组件建立了watchEffect监听机制，每当组件依赖的状态发生改变，当前组件重新加载。 细颗粒度：SolidJS和Svelte由于在编译之后就确定了当状态发生改变UI随之变化的关系，所以仅仅是具体DOM的重新加载。 对于组件更新时： React在当前组件状态发生变化时，从当前组件开始，包括子组件都被重新加载了。 Vue仅仅是当前组件重新加载。 SolidJS、Svelte仅仅是重新加载对应的DOM！ 在项目比较小时，SolidJS、Svelte的优势不会很明显， 但是当面对大型项目时，React和Vue的性能短板就显露出来了。 Vapor mode可以在给定相同的Vue SFC前提下，与当前基于虚拟DOM的输出相比，Vapor Mode将其编译成性能更高、使用更少内存且需要更少运行时支持代码的JavaScript输出。 手写Vue3-珠峰(pnpm的workspace来实现monorepo包管理) 从零手写Vue3响应式模块 - 珠峰培训-video pnpm是什么pnpm是快速、节省磁盘空间的包管理器，主要采用符号链接的方式管理模块。 搭建monorepo环境初始化 1npm init -y 安装基本的依赖包 typescript：做类型检查 rollup：打包 rollup-plugin-typescript2：打包时解析ts @rollup/plugin-json:打包时解析json @rollup/plugin-node-resolve:按照node的方式解析模块 @rollup/plugin-commonjs：解析低版本模块 minimist：解析用户提供的参数 execa@4：启动多个进程打包程序，指定版本4 1pnpm install typescript rollup rollup-plugin-typescript2 @rollup/plugin-json @rollup/plugin-node-resolve @rollup/plugin-commonjs minimist execa@4 -D -w 创建packages目录，在根目录下pnpm-workspace.yaml配置文件，指定打包目录 12packages: - &quot;packages/*&quot; 安装tsc即tsconfig配置文件 1234567891011121314151617181920pnpm tsc --init tsconfig.json配置&#123; &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;dist&quot;, // 输出目录 &quot;sourceMap&quot;: true, // 采用source &quot;target&quot;: &quot;ES2016&quot;, // 目标语法 &quot;module&quot;: &quot;ESNext&quot;, // 模块格式 &quot;moduleResolution&quot;: &quot;Node&quot;, // 模块解析方式 &quot;strict&quot;: true, // 严格模式 &quot;resolveJsonModule&quot;: true, //解析json &quot;esModuleInterop&quot;: true, // 允许es6语法引入commonjs模块 &quot;jsx&quot;: &quot;preserve&quot;, // jsx不转义 &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], // 支持的类库esnext和dom &quot;baseUrl&quot;: &quot;.&quot;, //以当前路径为基准进行查找 &quot;paths&quot;: &#123; &quot;@vue/*&quot;: [&quot;packages/*/src&quot;] // 别名前缀 &#125; &#125;&#125; 创建reactivity模块和shared模块 其中reactivity会依赖shared 1234567891011121314151617创建packages/reactivity/src/index.js创建packages/reactivity/package.json&#123; &quot;name&quot;: &quot;@vue/reactivity&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;module&quot;: &quot;dist/reactivity.esm-bundler.js&quot;, &quot;unpkg&quot;: &quot;dist/reactivity.global.js&quot;, &quot;buildOptions&quot;: &#123; &quot;name&quot;: &quot;VueReactivity&quot;, &quot;formats&quot;: [ &quot;esm-bundler&quot;, &quot;cjs&quot;, &quot;global&quot; ] &#125;&#125; 1234567891011121314创建packages/shared/src/index.js创建packages/shared/package.json&#123; &quot;name&quot;: &quot;@vue/shared&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;module&quot;: &quot;dist/shared.esm-bundler.js&quot;, &quot;buildOptions&quot;: &#123; &quot;formats&quot;: [ &quot;esm-bundler&quot;, &quot;cjs&quot; ] &#125;&#125; 给reactivity指定安装shared的依赖，让它找得到它 1pnpm i @vue/shared@workspace --filter @vue/reactivity 12345678packages/reactivity/src/index.jsimport &#123; isObject &#125; from &quot;@vue/shared&quot;;packages/shared/src/index.jsexport function isObject(value: unknown): value is Record&lt;any, any&gt; &#123; return typeof value === &quot;object&quot; &amp;&amp; value !== null;&#125; 创建打包脚本 1234package.json&quot;scripts&quot;: &#123; &quot;dev&quot;:&quot;node scripts/dev.js reactivity -f global -s&quot; //表示打包响应式模块，使用global方式打包，输出sourcemap &#125;, 123456789101112131415161718192021222324252627282930scripts/dev.jsconst minimist = require(&quot;minimist&quot;);const execa = require(&quot;execa&quot;);// import minimist from &quot;minimist&quot;;// import execa from &quot;execa&quot;;const args = minimist(process.argv.slice(2)); //获取打包命令的执行参数// 获取执行命名时，打包的参数const target = args._.length ? args._[0] : &quot;reactivity&quot;; //目标模块const formats = args.f || &quot;global&quot;; // 打包的方式es6还是global全局等等const sourcemap = args.s || false; // 是否生产源码模式console.log(target, formats, sourcemap);// 读取参数后，执行子进程命令execa( &quot;rollup&quot;, [ &quot;-wc&quot;, // --watch --config监视文件变化和读取配置文件 &quot;--environment&quot;, // 配置环境 [ `TARGET:$&#123;target&#125;`, `FORMATS:$&#123;formats&#125;`, sourcemap ? `SOURCE_MAP:true` : &quot;&quot;, ] .filter(Boolean) .join(&quot;,&quot;), //过滤掉空值或false的值 ], &#123; stdio: &quot;inherit&quot;, // 子进程命令在当前命令进程下继续执行 &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364rollup.config.jsimport path from &quot;path&quot;;import ts from &quot;rollup-plugin-typescript2&quot;;import json from &quot;@rollup/plugin-json&quot;;import &#123; nodeResolve &#125; from &quot;@rollup/plugin-node-resolve&quot;;import commonjs from &quot;@rollup/plugin-commonjs&quot;;// 命令参数获取-打包格式const packageFormats = process.env.FORMATS &amp;&amp; process.env.FORMATS.split(&quot;,&quot;);// 命令参数获取-源码const sourcemap = process.env.SOURCE_MAP;const target = process.env.TARGET;console.log(packageFormats, sourcemap, target);// 根据target找到要打包的目录const packagesDir = path.resolve(__dirname, &quot;packages&quot;);// 要打包的入口const packageDir = path.resolve(packagesDir, process.env.TARGET);// 以打包的目录解析文件const resolve = (p) =&gt; path.resolve(packageDir, p);// 获取打包的名字const name = path.basename(packageDir);const pkg = require(resolve(&quot;package.json&quot;));// 输出配置const outputConfig = &#123; &quot;esm-bundler&quot;: &#123; file: resolve(`dist/$&#123;name&#125;.esm-bundler.js`), format: &quot;es&quot;, &#125;, cjs: &#123; file: resolve(`dist/$&#123;name&#125;.cjs.js`), format: &quot;cjs&quot;, &#125;, global: &#123; file: resolve(`dist/$&#123;name&#125;.global.js`), format: &quot;iife&quot;, &#125;,&#125;;// 稍后打包的所有文件，可能命令中不含packageFormats值const packageConfigs = packageFormats || pkg.buildOptions.formats;function createConfig(format, output) &#123; output.sourcemap = sourcemap; output.export = &quot;named&quot;; // 外部模块，哪些模块不需要打包 let external = []; if (format === &quot;global&quot;) &#123; // 填充全局名称 output.name = pkg.buildOptions.name; &#125; else &#123; // 哪些内部依赖不需要打包 external = [...Object.keys(pkg.dependencies)]; &#125; return &#123; input: resolve(`src/index.ts`), output, external, plugins: [json(), ts(), commonjs(), nodeResolve()], &#125;;&#125;// 返回数组，会依次进行打包export default packageConfigs.map((format) =&gt; createConfig(format, outputConfig[format]));","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"源码_Vue2.0","slug":"D_框架_源码_Vue2.0","date":"2023-09-11T23:33:16.000Z","updated":"2024-10-11T13:50:16.279Z","comments":true,"path":"2023/09/12/D_框架_源码_Vue2.0/","link":"","permalink":"https://fuyunjinglong.github.io/2023/09/12/D_%E6%A1%86%E6%9E%B6_%E6%BA%90%E7%A0%81_Vue2.0/","excerpt":"","text":"前言关于源码 为了面试 为了在简历上写自己会源码 了解底层原理 学习高手思路 通过源码来学习一些小技巧(骚操作) 对框架如何实现的各种功能感到好奇 内卷严重 不看不行 逆水行舟 不进则退 自己也想造轮子 先看看别人都是怎么做的 各种公众号和卖课的都在贩卖焦虑 被洗脑洗的 怎样学习源码才是最科学的方式呢？ 我们来看一个例子：有一些听起来非常高大上的高科技产品，如电磁轨道炮。那么当我们拆解一个电磁轨道炮的时候，大概率你是看不懂它的。 但用了一些磁铁、若干钢珠、以及几个我们日常生活中能够搞到的材料来制作了一个简易版的电磁轨道炮。这样我们一下子就能够搞懂电磁轨道炮的真正原理。 虽然这样的轨道炮并不能真正的用于实战，但只要我们明白了最基础的那部分，我们就可以在此基础上一步步进行扩展，慢慢弄懂整个能够用于实战的复杂轨道炮。 Vue源码调试1.下载源码 vue-v2.6.14版本下载 2.安装依赖 1npm i 安装依赖报错&#45;&#112;&#104;&#97;&#110;&#116;&#x6f;&#109;&#106;&#x73;&#x2d;&#x70;&#x72;&#101;&#98;&#117;&#105;&#108;&#116;&#64;&#50;&#46;&#x31;&#x2e;&#x31;&#x34; install: node install.js 1解决方案：npm install phantomjs-prebuilt@2.1.14 --ignore-scripts 安装依赖报错-(plugin Rollup Core) Error: Could not load 1手动下载依赖包https://github.com/ideayuye/rollup-plugin-alias，并覆盖掉本地文件夹 \\node_modules\\rollup-plugin-alias。进入rollup-plugin-alias文件夹，依次执行npm i 安装依赖报错-idealTree:vue: sill idealTree buildDeps 12清除npm缓存npm cache clean --force设置新的淘宝镜像源npm config set registry https://registry.npmmirror.com 3.开启打包源文件 12// package.json&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev --sourcemap&quot;, 4.开始调试源码 在源码目录中添加断点调试即可，比如\\vue-2.6.14\\src\\core\\instance\\init.js 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; #demo &#123; font-family: &quot;Helvetica&quot;, Arial, sans-serif; text-align: center; &#125; &lt;/style&gt; &lt;script src=&quot;./dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;button @click=&quot;num++&quot;&gt;Object类型自增加：&#123;&#123;num&#125;&#125;&lt;/button&gt; &lt;button @click=&quot;add&quot;&gt;Array类型自增加：&#123;&#123;arr&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#demo&quot;, data: &#123; num: 0, arr: [1, 2, 3], &#125;, methods: &#123; add() &#123; this.arr.push(this.arr[this.arr.length - 1] + 1); // this.$set(this.arr, 0, this.arr[0] + 1); &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue源码目录12345678910111213141516171819202122232425262728293031323334├── benchmarks 性能、基准测试├── dist 构建打包的输出目录├── examples 案例目录├── flow 因为Vue使用了Flow来进行静态类型检查，这里定义了声明了一些静态类型├── packages 一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的 vue-template-compiler，还有 weex 相关的 ├── vue-server-renderer ├── vue-template-compiler ├── weex-template-compiler └── weex-vue-framework├── scripts 所有的配置文件的存放位置，比如 rollup 的配置文件├── src vue 源码目录│ ├── compiler 编译器 |—codegen 根据ast生成render函数 |—directives 通用生成render函数之前需要处理的指令 |—parser 模板解析│ ├── core 运行时的核心包│ │ ├── components 全局组件，比如 keep-alive│ │ ├── config.js 一些默认配置项│ │ ├── global-api 全局方法，也就是添加在Vue对象上的方法，比如Vue.use,Vue.extend,,Vue.mixin等│ │ ├── instance 实例相关内容，包括实例方法，生命周期，事件等│ │ ├── observer 响应式原理│ │ ├── util 工具方法│ │ └── vdom 虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿│ ├── platforms 平台相关的编译器代码│ │ ├── web │ │ ├── weex 类似react native跨端平台 |— web web端独有文件 |— compiler 编译阶段需要处理的指令和模块 |— runtime 运行阶段需要处理的组件、指令和模块 |— server 服务端渲染相关 |— util 工具库│ ├── server 服务端渲染相关├── test 测试目录├── types TS 类型声明 Vue从实例化到渲染的完整流程参考：vue源码分析 new Vue-&gt;init-&gt;mount-&gt;compile-&gt;render-&gt;vnode-&gt;patch-&gt;dom 1. 定义Vue构造函数 12345initMixin(Vue); // 定义 _initstateMixin(Vue); // 定义 $set $get $delete $watch 等eventsMixin(Vue); // 定义事件 $on $once $off $emitlifecycleMixin(Vue); // 定义 _update $forceUpdate $destroyrenderMixin(Vue); // 定义 _render 返回虚拟dom 2. initMixin 实例化Vue时，执行 _init, _init 定义在 initMixin 中 123456789101112131415161718192021222324Vue.prototype._init = function (options) &#123; // 合并 options if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options); // 组件合并 &#125; else &#123; // 非组件合并 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; initLifecycle(vm); // 定义 vm.$parent vm.$root vm.$children vm.$refs 等 initEvents(vm); // 定义 vm._events vm._hasHookEvent 等 initRender(vm); // 定义 $createElement $c callHook(vm, &#x27;beforeCreate&#x27;); // 挂载 beforeCreate 钩子函数 initInjections(vm); // resolve injections before data/props initState(vm); // 初始化 props methods data computed watch 等方法 initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); // 挂载 created 钩子函数 if (vm.$options.el) &#123; vm.$mount(vm.$options.el); // 实例挂载渲染dom &#125;&#125;; 3. $mount vue最终都是通过render函数将dom编译为虚拟dom 12345678// 构建render函数if (!options.render) &#123; // 如果没有render属性，那么将template模版编译转为render&#125;// 最后调用 mountreturn mount.call(this, el, hydrating)// mount 调用 mountComponentreturn mountComponent(this, el, hydrating) 4. mountComponent 通过 new Watcher 调用执行 updateComponent, vm._render获取虚拟dom, vm._update将虚拟dom转为真实的dom并挂载到页面。 1234// hydrating 代表服务端渲染 hydrating =&gt; falseupdateComponent = function () &#123; vm._update(vm._render(), hydrating); // 关键点&#125;; 5. _render _render执行render函数 返回vnode。 1234Vue.prototype._render = function () &#123; // 此处的 vm._renderProxy 等价于 vm vnode = render.call(vm._renderProxy, vm.$createElement);&#125; $createElement 主要是参数重载，整合为统一格式后调用 _createElement函数。 6. _update _update 主要实现 vnode 转化为实际的dom， 注入到页面的同时并销毁页面模版。 Vue源码深度解析参考 Vue.js源码全方位深入解析-黄轶-video Vue.js源码全方位深入解析-黄轶 李永宁Vue源码解读-video 珠峰公开课-vue2.0源码实现-video vue核心四大模块 Vue源码系列-Vue中文社区 李永宁Vue源码解读 汪道南源码解析 推荐 7 个 Vue2、Vue3 源码解密分析的开源项目 Vue核心四大模块 生命周期过程 变化监测原理 模板编译原理 虚拟DOM原理 生命周期过程-待续变化监测原理-待续模板编译原理-待续虚拟DOM原理-待续Vue.js源码全方位深入解析-黄轶 2.x版本笔记 准备工作认识FlowFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查。 为什么用 Flow JavaScript 是动态类型语言，但是它过于灵活的副作用是很容易写出非常隐蔽的隐患代码，在编译期不会报错，但在运行阶段就可能出现各种奇怪的bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 Vue.js 在做 2.0 重构的时候，引入了 Flow 做静态类型检查,之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法,非常小成本的改动就可以拥有静态类型检查的能力。 Flow 的工作方式 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。 12345678910111213类型推断/*@flow*/function split(str) &#123; return str.split(&#x27; &#x27;)&#125;split(11)类型注释/*@flow*/function add(x: number, y: number): number &#123; return x + y&#125;add(&#x27;Hello&#x27;, 11) 类型注释 更多请移步 Flow 的官方文档。 数组 123/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push(&#x27;Hello&#x27;) 类和对象 12345678910111213141516171819/*@flow*/class Bar &#123; x: string; // x 是字符串 y: string | number | void; // y 可以是字符串或者数字，void表示为空即可不传 z: boolean; constructor(x: string, y: string | number| void) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar(&#x27;hello&#x27;, 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: &#x27;hello&#x27;, b: 11, c: [&#x27;hello&#x27;, &#x27;world&#x27;], d: new Bar(&#x27;hello&#x27;, 3)&#125; Null 若想任意类型 T 可以为 null 或者 undefined，只需类似如下写成 ?T 的格式即可。 12/*@flow*/var foo: ?string = null // 此时，foo 可以为字符串，也可以为 null。 Flow 在 Vue.js 源码中的应用 对于引用的第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型。 在 Vue.js 的主目录下有 .flowconfig 文件， [libs] 部分用来描述包含指定库定义的目录，这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。 12345678flow├── compiler.js # 编译相关├── component.js # 组件数据结构├── global-api.js # Global API 结构├── modules.js # 第三方库定义├── options.js # 选项相关├── ssr.js # 服务端渲染相关├── vnode.js # 虚拟 node 相关 Vue.js 源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 构建脚本 总共有 3 条命令，Vue.js 源码构建的脚本如下： 1234567&#123; &quot;script&quot;: &#123; &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;, &quot;build:weex&quot;: &quot;npm run build -- weex&quot; &#125;&#125; 构建过程 scripts/build.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 1.读取配置文件let builds = require(&#x27;./config&#x27;).getAllBuilds()// 2.根据package.json中脚本的配置参数，得到需要打包的平台，然后过滤配置if (process.argv[2]) &#123; const filters = process.argv[2].split(&#x27;,&#x27;) builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf(&#x27;weex&#x27;) === -1 &#125;)&#125;// 3.开始构建build(builds)function build (builds) &#123; let built = 0 const total = builds.length const next = () =&gt; &#123; // 根据配置逐个构建对应平台的js文件 buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;function buildEntry (config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /(min|prod)\\.js$/.test(file) return rollup.rollup(config)// 生成bundle .then(bundle =&gt; bundle.generate(output))// 生成输出文件 .then((&#123; output: [&#123; code &#125;] &#125;) =&gt; &#123; if (isProd) &#123;// 如果是生产环境，是否需要压缩代码 const minified = (banner ? banner + &#x27;\\n&#x27; : &#x27;&#x27;) + terser.minify(code, &#123; toplevel: true, output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: [&#x27;makeMap&#x27;] &#125; &#125;).code // 最后生成打包文件 return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125; scripts/config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if (process.env.TARGET) &#123; module.exports = genConfig(process.env.TARGET)&#125; else &#123; exports.getBuild = genConfig // 根据package.json的脚本配置，生成rollup所需要的配置文件格式数组，genConfig是最终格式 exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)&#125;// 所有平台需要配的配置const builds = &#123; // Runtime+compiler development build (Browser) &#x27;web-full-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.js&#x27;),// 后面分析的入口 dest: resolve(&#x27;dist/vue.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;development&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, &#x27;web-runtime-cjs-prod&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime.js&#x27;), dest: resolve(&#x27;dist/vue.runtime.common.prod.js&#x27;), format: &#x27;cjs&#x27;, env: &#x27;production&#x27;, banner &#125;, .... &#125; // 转换为rollup最终需要的配置数据格式，并添加其他配置function genConfig (name) &#123; const opts = builds[name] const config = &#123; input: opts.entry, external: opts.external, plugins: [ flow(), alias(Object.assign(&#123;&#125;, aliases, opts.alias)) ].concat(opts.plugins || []), output: &#123; file: opts.dest, format: opts.format, banner: opts.banner, name: opts.moduleName || &#x27;Vue&#x27; &#125;, onwarn: (msg, warn) =&gt; &#123; if (!/Circular/.test(msg)) &#123; warn(msg) &#125; &#125; &#125; ... return config&#125; Runtime Only VS Runtime + Compiler通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本。 Runtime Only 我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。 Runtime + Compiler 我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板 从入口开始核心 本质上是一个Vue函数，通过src\\core\\instance\\index.js重写原型方法和src\\core\\global-api\\index.js挂载静态全局方法，扩展功能方法。 我们之前提到过 Vue.js 构建过程，在 web 应用下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 src/platforms/web/entry-runtime-with-compiler.js： 12345import Vue from &#x27;./runtime/index&#x27;Vue.prototype.$mount = function ()&#123;...// luwen重写了原型mount方法&#125;export default Vue // luwen来自另外一个地方 src\\platforms\\web\\runtime\\index.js： 1234567import Vue from &#x27;core/index&#x27;// luwen定义一些静态方法Vue.config.mustUseProp = mustUsePropVue.prototype.$mount = function ( ...// luwen重写了原型mount方法 &#125;export default Vue // luwen来自另外一个地方 src\\core\\index.js： 1234import Vue from &#x27;./instance/index&#x27;// luwen定义全局方法initGlobalAPI(Vue)export default Vue // luwen来自另外一个地方 src\\core\\instance\\index.js 1234567891011121314151617// luwen最后发现Vue本质是一个函数function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;// luwen-通过重写原型，扩展Vue函数的方法initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue src\\core\\global-api\\index.js 12345678910111213141516171819202122232425export function initGlobalAPI (Vue: GlobalAPI) &#123; // luwen定义了一些工具函数吗，但有可能会变化，所以有使用风险 Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125;// luwen定义了全局的set,delete,delete Vue.set = set Vue.delete = del Vue.delete = nextTick// luwen定义了全局的方法component、directive、filter,合并到options上 ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &#x27;s&#x27;] = Object.create(null) &#125;) // luwen定义了全局内置组件KeepAlive extend(Vue.options.components, builtInComponents) // luwen-通过重写原型，扩展全局静态方法 initUse(Vue)// luwen定义了全局use方法 initMixin(Vue)// luwen定义了全局mixin方法 initExtend(Vue)// luwen定义了全局extend方法 initAssetRegisters(Vue)// luwen定义了全局component、directive、filter方法处理&#125; 数据驱动new Vue 发生了什么我们看下Vue的构造函数 src\\core\\instance\\index.js 123456789101112// luwen最后发现Vue本质是一个函数function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; // luwen-最初的初始化方法，_init是在initMixin函数中实现的原形重写定义 this._init(options)&#125;// luwen-通过重写原型，扩展Vue函数的方法initMixin(Vue)// luwen-来自另外一个地方 src\\core\\instance\\init.js 12345678910111213141516171819202122export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; // luwen-最终将options合并并挂载到$options上,方便后续调用。这里的options就是Vue函数的入参 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) initLifecycle(vm)// luwen-初始化生命周期 initEvents(vm)// luwen-初始化事件中心 initRender(vm)// luwen-初始化渲染函数 callHook(vm, &#x27;beforeCreate&#x27;) initInjections(vm) // resolve injections before data/props initState(vm)// luwen-初始化用户数据 initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) // luwen-最后判断是否存在el,存在则挂载dom if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125; &#125; 为什么this.num就能访问data定义中的num？ this.num本质就是访问this._data.num src\\core\\instance\\state.js 12345678910111213141516171819202122function initData (vm: Component) &#123; let data = vm.$options.data // luwen-data赋值到_data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; // luwen-比较data和props有没有重复定义 while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm ) &#125; &#125; // luwen-就是访问this.num本质就是访问this._data.num。 // luwen-将vm的数据通过代理访问到_data上 proxy(vm, `_data`, key) &#125;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"源码_Vue3.0","slug":"D_框架_源码_Vue3.0","date":"2023-09-11T23:33:16.000Z","updated":"2024-06-02T01:38:00.231Z","comments":true,"path":"2023/09/12/D_框架_源码_Vue3.0/","link":"","permalink":"https://fuyunjinglong.github.io/2023/09/12/D_%E6%A1%86%E6%9E%B6_%E6%BA%90%E7%A0%81_Vue3.0/","excerpt":"","text":"库和框架的区别库和框架的区别是什么？库是你主动使用的工具，而框架是你被动适应的环境。 Vue源码调试1.下载源码 源码地址：https://github.com/vuejs/core 2.安装依赖 前提：安装node&gt;16和pnpm&gt;7。 依赖安装，最好移除puppeteer依赖，下载很慢 pnpm install 3.添加打包源码 “dev”: “node scripts/dev.js –sourcemap”, 4.调试源码 在目录下可以断点调试，如\\core-main\\packages\\runtime-dom\\src\\index.ts 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; #demo &#123; font-family: &#x27;Helvetica&#x27;, Arial, sans-serif; text-align: center; &#125; &lt;/style&gt; &lt;script src=&quot;./packages/vue//dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;button @click=&quot;num++&quot;&gt;Object类型自增加：&#123;&#123;num&#125;&#125;&lt;/button&gt; &lt;button @click=&quot;add&quot;&gt;Array类型自增加：&#123;&#123;arr&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.createApp(&#123; data: () =&gt; (&#123; num: 0, arr: [1, 2, 3] &#125;), methods: &#123; add() &#123; this.arr.push(this.arr[this.arr.length - 1] + 1) // this.$set(this.arr, 0, this.arr[0] + 1); &#125; &#125; &#125;).mount(&#x27;#demo&#x27;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 也可以使用 源码内部自带的调试案例 启动服务npm run dev打开链接http://localhost:5000/packages/vue/examples/composition/todomvc打断点 Vue源码目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 目录结构分析├── .github // github 工作流，issue 模版，代码贡献指南├── .vscode // vscode 编辑器的配置├── packages // vue 源码核心包，使用 pnpm workspace 工作区管理│ ├── compiler-core // 编译器（平台无关），例如基础的 baseCompile 编译模版文件, baseParse生成AST│ ├── compiler-dom // 基于compiler-core，专为浏览器的编译模块，可以看到它基于baseCompile，baseParse，重写了complie、parse│ ├── compiler-sfc // 编译vue单文件组件│ ├── compiler-ssr // 服务端渲染编译│ ├── reactivity // vue独立的响应式模块，可以与任何框架配合,使用proxy│ ├── reactivity-transform // 响应式实验功能，目前仅用于测试│ ├── runtime-core // 与平台无关的运行时。有虚拟DOM渲染器，vue组件和各种API。可针对某个具体平台实现高阶runtime，比如自定义渲染器│ ├── runtime-dom // 针对浏览器的runtime。包含处理原生DOM API │ ├── runtime-test // 一个专门为了测试而写的轻量级 runtime。由于这个 rumtime 「渲染」出的 DOM 树其实是一个 JS 对象，所以这个 runtime 可以用在所有 JS 环境里。你可以用它来测试渲染是否正确。│ ├── server-renderer // 服务端渲染│ ├── sfc-playground│ ├── shared // 内部工具库,不暴露API│ ├── size-check // 简单应用，用来测试代码体积│ ├── template-explorer // 用于调试编译器输出的开发工具│ └── vue // 面向公众的完整版本, 包含运行时和编译器│ └── vue-compat // 用于兼容 vue2│ ├── global.d.ts // 声明文件├── scripts // vue3脚本文件，包含配置文件，进行编译和打包等│ ├── bootstrap.js│ ├── build.js│ ├── checkYarn.js│ ├── dev.js│ ├── release.js│ ├── setupJestEnv.ts│ ├── utils.js│ └── verifyCommit.js├── test-dts // 测试文件│ ├── README.md│ ├── component.test-d.ts│ ├── componentTypeExtensions.test-d.tsx│ ├── defineComponent.test-d.tsx│ ├── functionalComponent.test-d.tsx│ ├── h.test-d.ts│ ├── index.d.ts│ ├── inject.test-d.ts│ ├── reactivity.test-d.ts│ ├── ref.test-d.ts│ ├── setupHelpers.test-d.ts│ ├── tsconfig.build.json│ ├── tsconfig.json│ ├── tsx.test-d.tsx│ └── watch.test-d.ts├── CHANGELOG.md // 多个版本提交记录、时间和内容├── LICENSE // MIT协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。├── README.md // 项目说明├── api-extractor.json // 这是所有包的共享基本配置文件├── jest.config.js // 测试配置文件├── package.json // 项目依赖├── rollup.config.js // rollup打包配置文件├── tsconfig.json // 定了用来编译这个项目的根文件和编译选项├── pnpm-lock.yaml // 锁定依赖版本└── pnpm-workspace.yaml // pnpm 工作区 Vue3可构建的版本 1234567891011121314151617181920212223// 常见的2个版本vue.global.js：是包含编译器和运行时的“完整”构建版本，因此它支持动态编译模板。vue.runtime.global.js：只包含运行时，并且需要在构建步骤期间预编译模板。// cjs（用于服务端渲染）vue.cjs.jsvue.cjs.prod.js（生产版，代码进行了压缩）// global（用于浏览器&lt;script src=&quot;&quot; /&gt;标签导入，导入之后会增加一个全局的Vue对象）vue.global.jsvue.global.prod.js（生产版，代码进行了压缩）vue.runtime.global.jsvue.runtime.global.prod.js（生产版，代码进行了压缩）// browser（用于支持ES6 Modules浏览器&lt;script type=&quot;module&quot; src=&quot;&quot;/&gt;标签导入）vue.esm-browser.jsvue.esm-browser.prod.js（生产版，代码进行了压缩）vue.runtime.esm-browser.jsvue.runtime.esm-browser.prod.js（生产版，代码进行了压缩）// bundler（这两个版本没有打包所有的代码，只会打包使用的代码，需要配合打包工具来使用，会让Vue体积更小）vue.esm-bundler.jsbue.runtime.esm-bundler.js Vue从实例化到渲染的完整流程Vue源码深度解析参考 催学社-Vue3 源码实战课-video Vue.js 3.0 核心源码-黄轶-video Vue3源码解析，打造自己的Vue3框架-video 珠峰公开课-vue3源码视频-video vue 源码 全宇宙 vue3js源码 Vue核心四大模块 生命周期过程 变化监测原理 模板编译原理 虚拟DOM原理 尤大手写mini-vue链接 整体流程 数据响应式模块：初始化为响应式对象 编译模块：编译为渲染函数，编译过程一般在两个时刻执行,即浏览器运行时(runtime)和Vue打包编译时(compile time) 渲染模块： RenderPhase ： 渲染模块使用渲染函数根据初始化数据生成虚拟Dom MountPhase ： 利用虚拟Dom创建视图页面Html PatchPhase：数据模型一旦变化渲染函数将再次被调用生成新的虚拟Dom，然后做Dom Diff更新视图Html 编译模块 Parase解析：模板字符串 -&gt; AST(Abstract Syntax Treee)抽象语法树，本质是一连串的正则匹配 Transform转换：譬如 v-bind v-if v-for的转换 Generate生成渲染器： AST -&gt; 渲染函数 defineProperty版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;// reactivity ---响应式let activeEffectclass Dep &#123; subscribers = new Set() depend() &#123; if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; effect()) &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect effect() activeEffect = null&#125;function reactive(raw) &#123; // 使用 Object.defineProperty // 1. 遍历对象上存在的 key Object.keys(raw).forEach(key =&gt; &#123; // 2. 为每个 key 都创建一个依赖对象 const dep = new Dep() // 3. 用 getter 和 setter 重写原对象的属性 let realValue = raw[key] Object.defineProperty(raw, key, &#123; get() &#123; // 4. 在 getter 和 setter 里调用依赖对象的对应方法 dep.depend() return realValue &#125;, set(newValue) &#123; realValue = newValue dep.notify() &#125; &#125;) &#125;) return raw&#125;// vdom ---虚拟domfunction h(tag, props, children) &#123; return &#123; tag, props, children &#125;; &#125;function mount(vnode, container, anchor) &#123; const el = document.createElement(vnode.tag); vnode.el = el; // props if (vnode.props) &#123; for (const key in vnode.props) &#123; if (key.startsWith(&#x27;on&#x27;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]) &#125; else &#123; el.setAttribute(key, vnode.props[key]); &#125; &#125; &#125; if (vnode.children) &#123; if (typeof vnode.children === &quot;string&quot;) &#123; el.textContent = vnode.children; &#125; else &#123; vnode.children.forEach(child =&gt; &#123; mount(child, el); &#125;); &#125; &#125; if (anchor) &#123; container.insertBefore(el, anchor) &#125; else &#123; container.appendChild(el); &#125; &#125;function patch(n1, n2) &#123; // Implement this // 1. check if n1 and n2 are of the same type if (n1.tag !== n2.tag) &#123; // 2. if not, replace const parent = n1.el.parentNode const anchor = n1.el.nextSibling parent.removeChild(n1.el) mount(n2, parent, anchor) return &#125; const el = n2.el = n1.el // 3. if yes // 3.1 diff props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; for (const key in newProps) &#123; const newValue = newProps[key] const oldValue = oldProps[key] if (newValue !== oldValue) &#123; if (newValue != null) &#123; el.setAttribute(key, newValue) &#125; else &#123; el.removeAttribute(key) &#125; &#125; &#125; for (const key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.2 diff children const oc = n1.children const nc = n2.children if (typeof nc === &#x27;string&#x27;) &#123; if (nc !== oc) &#123; el.textContent = nc &#125; &#125; else if (Array.isArray(nc)) &#123; if (Array.isArray(oc)) &#123; // array diff const commonLength = Math.min(oc.length, nc.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oc[i], nc[i]) &#125; if (nc.length &gt; oc.length) &#123; nc.slice(oc.length).forEach(c =&gt; mount(c, el)) &#125; else if (oc.length &gt; nc.length) &#123; oc.slice(nc.length).forEach(c =&gt; &#123; el.removeChild(c.el) &#125;) &#125; &#125; else &#123; el.innerHTML = &#x27;&#x27; nc.forEach(c =&gt; mount(c, el)) &#125; &#125; &#125;// paste all previous code from Codepenconst app = &#123; data: reactive(&#123; count: 0 &#125;), render() &#123; return h(&#x27;div&#x27;, &#123; onClick: () =&gt; &#123; app.data.count++ &#125; &#125;, String(app.data.count)) &#125;&#125;function mountApp(component, selector) &#123; let isMounted = false let oldTree watchEffect(() =&gt; &#123; if (!isMounted) &#123; mount(oldTree = component.render(), document.querySelector(selector)) isMounted = true &#125; else &#123; const newTree = component.render() patch(oldTree, newTree) oldTree = newTree &#125; &#125;)&#125;mountApp(app, &#x27;#app&#x27;)&lt;/script&gt; Proxy版本(可断点调试)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;// 定义一个暂时存放 watchEffect 传进来的参数的变量let activeEffect// 定义一个 Dep 类，该类将会为每一个响应式对象的每一个键生成一个发布者实例class Dep &#123; // 用 Set 做缓存列表以防止列表中添加多个完全相同的函数 subscribers = new Set() // 构造函数接受一个初始化的值放在私有变量内 constructor(value) &#123; this._value = value &#125; // 当使用 xxx.value 获取对象上的 value 值时 get value() &#123; // 代理模式 当获取对象上的value属性的值时将会触发 depend 方法 this.depend() // 然后返回私有变量内的值 return this._value &#125; // 当使用 xxx.value = xxx 修改对象上的 value 值时 set value(value) &#123; // 先改值再触发 这样保证触发的时候用到的都是已经修改后的新值 this._value = value // 代理模式 当修改对象上的value属性的值时将会触发 notify 方法 this.notify() &#125; // 这就是我们常说的依赖收集方法 depend() &#123; // 如果 activeEffect 这个变量为空 就证明不是在 watchEffect 这个函数里面触发的 get 操作 if (activeEffect) &#123; // 但如果 activeEffect 不为空就证明是在 watchEffect 里触发的 get 操作 // 那就把 activeEffect 这个存着 watchEffect 参数的变量添加进缓存列表中 this.subscribers.add(activeEffect) &#125; &#125; // 更新操作 通常会在值被修改后调用 notify() &#123; // 遍历缓存列表里存放的函数 并依次触发执行 this.subscribers.forEach((effect) =&gt; &#123; effect() &#125;) &#125;&#125;// 模仿 Vue3 的 watchEffect 函数/**这个函数就被赋值给了activeEffect这个变量上面去，然后立刻执行这个函数，一般来说这个函数里面都会有一些响应式对象的对吧？既然有，那就会触发getter去进行依赖收集操作，而依赖收集则是判断了activeEffect这个变量有没有值，如果有，那就把它添加进缓存列表里。等到执行完这个函数后，就立即将activeEffect这个变量置为空值，防止不在watchEffect这个函数中触发getter的时候也执行依赖收集操作。**/function watchEffect(effect) &#123;// 先把传进来的函数放入到 activeEffect 这个变量中 activeEffect = effect // 然后执行 watchEffect 里面的函数 effect() // 最后把 activeEffect 置为空值 activeEffect = null&#125;// proxy versionconst reactiveHandlers = &#123;// 当触发 get 操作时 get(target, key) &#123; // 先调用 getDep 函数取到里面存放的 value 值 const value = getDep(target, key).value // 如果 value 是对象的话 if (value &amp;&amp; typeof value === &#x27;object&#x27;) &#123; // 那就把 value 也变成一个响应式对象 return reactive(value) &#125; else &#123; // 如果 value 只是基本数据类型的话就直接将值返回 return value &#125; &#125;, // 当触发 set 操作时 set(target, key, value) &#123; // 调用 getDep 函数并将里面存放的 value 值重新赋值成 set 操作的值 getDep(target, key).value = value &#125;&#125;// 定义一个 WeakMap 数据类型 用于存放 reactive 定义的对象以及他们的发布者对象集const targetToHashMap = new WeakMap()// 定义 getDep 函数 用于获取 reactive 定义的对象所对应的发布者对象集里的某一个键对应的发布者对象function getDep(target, key) &#123; // 获取 reactive 定义的对象所对应的发布者对象集 let depMap = targetToHashMap.get(target) // 如果没获取到的话 if (!depMap) &#123; // 就新建一个空的发布者对象集 depMap = new Map() // 然后再把这个发布者对象集存进 WeakMap 里 targetToHashMap.set(target, depMap) &#125;// 再获取到这个发布者对象集里的某一个键所对应的发布者对象 let dep = depMap.get(key) // 如果没获取到的话 if (!dep) &#123; // 就新建一个发布者对象并初始化赋值 dep = new Dep(target[key]) // 然后将这个发布者对象放入到发布者对象集里 depMap.set(key, dep) &#125; // 最后返回这个发布者对象 return dep&#125;function reactive(obj) &#123; return new Proxy(obj, reactiveHandlers)&#125;function h(tag, props, children) &#123; return &#123; tag, props, children &#125;&#125;// 根组件挂载function mount(vnode, container, anchor) &#123; const el = document.createElement(vnode.tag) vnode.el = el // props if (vnode.props) &#123; for (const key in vnode.props) &#123; if (key.startsWith(&#x27;on&#x27;)) &#123; el.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]) &#125; else &#123; el.setAttribute(key, vnode.props[key]) &#125; &#125; &#125; if (vnode.children) &#123; if (typeof vnode.children === &#x27;string&#x27;) &#123; el.textContent = vnode.children &#125; else &#123; vnode.children.forEach((child) =&gt; &#123; mount(child, el) &#125;) &#125; &#125; if (anchor) &#123; container.insertBefore(el, anchor) &#125; else &#123; container.appendChild(el) &#125;&#125;// diff算法function patch(n1, n2) &#123; // Implement this // 1. check if n1 and n2 are of the same type if (n1.tag !== n2.tag) &#123; // 2. if not, replace const parent = n1.el.parentNode const anchor = n1.el.nextSibling parent.removeChild(n1.el) mount(n2, parent, anchor) return &#125; const el = (n2.el = n1.el) // 3. if yes // 3.1 diff props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; for (const key in newProps) &#123; const newValue = newProps[key] const oldValue = oldProps[key] if (newValue !== oldValue) &#123; if (newValue != null) &#123; el.setAttribute(key, newValue) &#125; else &#123; el.removeAttribute(key) &#125; &#125; &#125; for (const key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.2 diff children const oc = n1.children const nc = n2.children if (typeof nc === &#x27;string&#x27;) &#123; if (nc !== oc) &#123; el.textContent = nc &#125; &#125; else if (Array.isArray(nc)) &#123; if (Array.isArray(oc)) &#123; // array diff const commonLength = Math.min(oc.length, nc.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oc[i], nc[i]) &#125; if (nc.length &gt; oc.length) &#123; nc.slice(oc.length).forEach((c) =&gt; mount(c, el)) &#125; else if (oc.length &gt; nc.length) &#123; oc.slice(nc.length).forEach((c) =&gt; &#123; el.removeChild(c.el) &#125;) &#125; &#125; else &#123; el.innerHTML = &#x27;&#x27; nc.forEach((c) =&gt; mount(c, el)) &#125; &#125;&#125;function patch(n1, n2) &#123; // Implement this // 1. check if n1 and n2 are of the same type if (n1.tag !== n2.tag) &#123; // 2. if not, replace const parent = n1.el.parentNode const anchor = n1.el.nextSibling parent.removeChild(n1.el) mount(n2, parent, anchor) return &#125; const el = (n2.el = n1.el) // 3. if yes // 3.1 diff props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; for (const key in newProps) &#123; const newValue = newProps[key] const oldValue = oldProps[key] if (newValue !== oldValue) &#123; if (newValue != null) &#123; el.setAttribute(key, newValue) &#125; else &#123; el.removeAttribute(key) &#125; &#125; &#125; for (const key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.2 diff children const oc = n1.children const nc = n2.children if (typeof nc === &#x27;string&#x27;) &#123; if (nc !== oc) &#123; el.textContent = nc &#125; &#125; else if (Array.isArray(nc)) &#123; if (Array.isArray(oc)) &#123; // array diff const commonLength = Math.min(oc.length, nc.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oc[i], nc[i]) &#125; if (nc.length &gt; oc.length) &#123; nc.slice(oc.length).forEach((c) =&gt; mount(c, el)) &#125; else if (oc.length &gt; nc.length) &#123; oc.slice(nc.length).forEach((c) =&gt; &#123; el.removeChild(c.el) &#125;) &#125; &#125; else &#123; el.innerHTML = &#x27;&#x27; nc.forEach((c) =&gt; mount(c, el)) &#125; &#125;&#125;const Component = &#123; data() &#123; return &#123; count: 0 &#125; &#125;, render() &#123; return h( &#x27;div&#x27;, &#123; onClick: () =&gt; &#123; this.count++ &#125; &#125;, String(this.count) ) &#125;&#125;function createApp(Component, container) &#123; // implement this const state = reactive(Component.data()) let isMount = true let prevTree watchEffect(() =&gt; &#123; const tree = Component.render.call(state) if (isMount) &#123; mount(tree, container) isMount = false &#125; else &#123; patch(prevTree, tree) &#125; prevTree = tree &#125;)&#125;// calling this should actually mount the component.createApp(Component, document.getElementById(&#x27;app&#x27;))&lt;/script&gt; Vue3源码中学到了什么性能 缓存 Diff算法：贪心+二分 位运算 缓存 缓存的本质是用空间换时间。 Vue 里使用了 WeakMap 这个内置对象缓存响应式数据。使用 WeakMap 而不是 Map 的目的，是让 JS 引擎在垃圾回收时释放已经没有引用的内存对象，提升查询速度和避免内存溢出。 Diff算法：贪心+二分 Diff 算法应该说是 Vue 源码里难度最高的算法。即便是整个源码中最难的算法，在 Leetcode 上也只是中等难度的题目。 一个流行的框架最伟大、最核心的地方，不是他用了多难的算法，而是他从某一类别应用的传统的开发方式中，抽象出一套公式。将固化的、重复的、复杂的事情留给框架自己，让使用者可以更关注自己的需求如何实现，同时又提供了一定的灵活性。 算法只是锦上添花。引入算法以优化框架的性能，能让框架更有竞争力，但框架主张的开发模式、带来的设计思想，才是核心。 根据二八定律，一件事情的核心工作只占20%，在安全漏洞、性能瓶颈方面也一样。识别出软件的性能瓶颈，储备一定的算法知识，再加以实际应用，做好这20%，也就离100%不远了。 Diff算法解析：http://hcysun.me/vue-design/zh/renderer-diff.html#减小dom操作的性能开销 LeetCode.300：https://leetcode-cn.com/problems/longest-increasing-subsequence/ 位运算 位运算大量用于底层软件开发,在计算资源和内存资源寸土寸金的板子上，用一个bit的高低电平来判断是或否，位运算精准而优雅。 位运算在 框架/平台 类核心模块编码时可以借鉴，而以CRUD为主的业务类需求，则尽量使用人类（开发者）易于理解的表述方式。 一是因为业务逻辑变化频繁，使用标志位和位运算往往需要事先对所有枚举值做全面的规划，如 Linux 文件系统的权限标志位； 二是方便自己和其他开发者阅读代码，好的代码应该是写一次而经得起读百次的。 可扩展性 Vue3 的源码采用 Monorepo 来管理各个包，repo 的组织结构非常完整而合理，各模块各司其职，充分解耦并且提供了极大的可扩展性，每一个 package 都独立提供了足够通用和抽象的API。 Composition API：组合 &gt; 继承Vue3 提供了 Composition API，借鉴了 React Hooks。 从 Vue 的 Options API、React 的 Class Component，两大框架殊途同归，最终都拥抱了 Function Component，说明函数式编程十分适应前端（UI）的开发。 计算机底层知识：编译模板或JSX为用户提供了足够简单、直观的编码方式（而不是让你自己去写渲染函数），把复杂的事情留给了框架自己。 在Vue2.x版本之前，Vue 没有将编译器与核心模块分离，在运行时引入编译器会使 Vue 整个包的体积变大，在Vue2.x之后，如果使用 webpack + SFC，webpack 会在打包编译阶段将 template 转成渲染函数（render function），并且提供了选项，使得运行时 Vue 可以剥离其编译器，减少体积，在 webpack 打包阶段完成 template 编译，也能提升运行时性能。 工具Typescript 人总是会犯错，任何事情的成功都不能依赖人的自觉性。Typescript 的编译时类型检查能让大部分常见的错误在开发阶段消除，让代码更加健壮和易于维护。 Rollup Rollup是一款小巧的 Javascript 模块打包工具，更适合于库应用的构建工具；可以将小块代码编译成大块复杂的代码，基于ES6 modules，它可以让你的 bundle 最小化，有效减少文件请求大小。 Monorepo &amp; Lerna 越来越多的主流框架/库采用monorepo方式来组织自己的代码仓。 lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。 lerna 现在已经被很多著名的项目组织使用，如：Babel, React, Vue, Angular, Ember, Meteor, Jest 。","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"JavaScript中的设计模式","slug":"J_设计模式_JavaScript","date":"2023-03-14T22:33:16.000Z","updated":"2024-03-13T23:02:32.570Z","comments":true,"path":"2023/03/15/J_设计模式_JavaScript/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/15/J_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_JavaScript/","excerpt":"","text":"大纲 快速掌握前端必会的 7 种设计模式-video-mk 设计模式的源码应用单例模式(闭包的应用) 点击登录，弹出登录弹窗 1234567891011121314151617181920212223242526272829303132333435363738394041// 基础版let createLogin = (function()&#123; let div = null; return function()&#123; if(!div)&#123; div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录的弹窗&#x27;; div.style.display = &#x27;none&#x27;; document.body.append(div); &#125; return div &#125;&#125;)()document.getElementById(&#x27;login&#x27;).onclick = function()&#123; let login = createLogin(); login.style.display = &#x27;block&#x27;;&#125;改进：单一职责的闭包// 最经典的闭包let getSingle = function(fn)&#123; let result = null; return function()&#123; return result||(result = fn()); &#125;&#125;// 单一职责let createLogin = function()&#123; let div = document.createElement(&#x27;div&#x27;); div.innerHTML = &#x27;我是登录的弹窗&#x27;; div.style.display = &#x27;none&#x27;; document.body.append(div); return div&#125;// 还可以创建createIframe等等const singleLogin = getSingle(createLogin);document.getElementById(&#x27;login&#x27;).onclick = function()&#123; let login = singleLogin(); login.style.display = &#x27;block&#x27;;&#125; ES6-Promise观察者模式 通过 Promise.prototype.then 和 Promise.prototype.catch 方法将观察者方法注册到被观察者 Promise 对象中，同时返回一个新的 Promise 对象，以便可以链式调用。 被观察者管理内部 pending、fulfilled 和 rejected 的状态转变，同时通过构造函数中传递的 resolve 和 reject 方法以主动触发状态转变和通知观察者。 Vue3-Proxy策略模式+代理模式 Proxy的表单验证，使用各种策略校验数据类型 Proxy代理原始数据，进行数据劫持和代理 参考 探索两种优雅的表单验证 场景：前端表单校验 所有选项不能为空 用户名长度不能少于6位 密码长度不能少于6位 手机号码必须符合格式 邮箱地址必须符合格式 常规校验 123456789101112131415161718192021222324252627282930313233343536let registerForm = document.querySelector(&#x27;#registerForm&#x27;)registerForm.addEventListener(&#x27;submit&#x27;, function() &#123; if (registerForm.userName.value === &#x27;&#x27;) &#123; alert(&#x27;用户名不能为空！&#x27;) return false &#125; if (registerForm.userName.length &lt; 6) &#123; alert(&#x27;用户名长度不能少于6位！&#x27;) return false &#125; if (registerForm.passWord.value === &#x27;&#x27;) &#123; alert(&#x27;密码不能为空！&#x27;) return false &#125; if (registerForm.passWord.value.length &lt; 6) &#123; alert(&#x27;密码长度不能少于6位！&#x27;) return false &#125; if (registerForm.phoneNumber.value === &#x27;&#x27;) &#123; alert(&#x27;手机号码不能为空！&#x27;) return false &#125; if (!/^1(3|5|7|8|9)[0-9]&#123;9&#125;$/.test(registerForm.phoneNumber.value)) &#123; alert(&#x27;手机号码格式不正确！&#x27;) return false &#125; if (registerForm.emailAddress.value === &#x27;&#x27;) &#123; alert(&#x27;邮箱地址不能为空！&#x27;) return false &#125; if (!/^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* $/.test(registerForm.emailAddress.value)) &#123; alert(&#x27;邮箱地址格式不正确！&#x27;) return false &#125;&#125;, false) 但存在很多问题，比如： registerForm.addEventListener绑定的函数比较庞大，包含了很多的if-else语句，看着都恶心，这些语句需要覆盖所有的校验规则。 registerForm.addEventListener绑定的函数缺乏弹性，如果增加了一种新的校验规则，或者想要把密码的长度校验从6改成8，我们都必须深入registerForm.addEventListener绑定的函数的内部实现，这是违反了开放-封闭原则的。 算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野。 用策略模式重构表单校验 思路：一键验证，使用策略模式，核心思想:将做什么和谁去做相分离 策略模式的组成 抽象策略角色：策略类，通常由一个接口或者抽象类实现。 具体策略角色：包装了相关的算法和行为。 环境角色：持有一个策略类的引用，最终给客户端用的。 具体策略角色——编写策略类 12345678910111213141516171819/*策略对象*/const strategies = &#123; isNonEmpty(value, errorMsg) &#123; return value === &#x27;&#x27; ? errorMsg : false &#125;, minLength(value, length, errorMsg) &#123; return value.length &lt; length ? errorMsg : false &#125;, isMoblie(value, errorMsg) &#123; return !/^1(3|5|7|8|9)[0-9]&#123;9&#125;$/.test(value) ? errorMsg : false &#125;, isEmail(value, errorMsg) &#123; return !/^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/.test(value) ? errorMsg : false &#125; &#125; 抽象策略角色——编写Validator类 1234567891011121314151617/*Validator类*/class Validator &#123; constructor() &#123; this.cache = [] //保存校验规则 &#125; add(value,name,...other) &#123; this.cache.push(strategies[name]) &#125; start() &#123; for (let validatorFunc of this.cache) &#123; let errorMsg = validatorFunc()//开始校验，并取得校验后的返回信息 if (errorMsg) &#123;//r如果有确切返回值，说明校验没有通过 return errorMsg &#125; &#125; &#125;&#125; 环境角色——客户端调用代码 1234567891011121314151617// 获取表单form元素let registerForm = document.querySelector(&#x27;#registerForm&#x27;)function validatorFunc()&#123; // 创建表单校验实例 let validator = new Validator(); // 编写校验配置 validator.add(registerForm.userName, &#x27;isNonEmpty&#x27;, &#x27;用户名不能为空&#x27;) validator.add(registerForm.userName, &#x27;minLength&#x27;, &#x27;用户名长度不能小于6&#x27;) // 开始校验，并接收错误信息 let errorMsg = validator.start() // 如果有错误信息输出，说明校验未通过 if(errorMsg)&#123; alert(errorMsg) return false//阻止表单提交 &#125;&#125;validatorFunc() 策略模式的优缺点 策略模式利用组合、委托和多态等技术思想，可以有效的避免多种条件选择语句； 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于拓展； 策略模式中的算法也可以复用在系统的其它地方，从而避免了许多重复的复制黏贴的工作； 在策略模式利用组合和委托来让Context拥有执行算法的能力，这也是继承一种更轻便的替代方案。 当然，策略模式也有一些缺点，但掌握了策略模式，这些缺点并不严重。 编写难度加大，代码量变多了，这是最直观的一个缺点，也算不上缺点，毕竟不能完全以代码多少来衡量优劣。 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。 其次，要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时strategy要向客户暴露它的所有实现，这是违反最少知识原则的。 参考 16种JavaScript设计模式（中）","categories":[{"name":"J_设计模式","slug":"J-设计模式","permalink":"https://fuyunjinglong.github.io/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"性能优化_0基础","slug":"H_工程热点_性能优化_0基础","date":"2023-03-12T08:33:16.000Z","updated":"2024-03-30T03:53:35.179Z","comments":true,"path":"2023/03/12/H_工程热点_性能优化_0基础/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96_0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"性能优化总策略总策略由两大策略层面和三大优化指标构成 使用浏览器DevTools分析性能 使用Chrome Performance进行性能调优 两大层面策略 网络层面 渲染层面 网络层面(4大策略) 构建策略：基于构建工具(Webpack/Rollup/Parcel/Esbuild/Vite/Gulp) 图像策略：基于图像类型(JPG/PNG/SVG/WebP/Base64) 分发策略：基于内容分发网络(CDN) 缓存策略：基于浏览器和Http缓存(强缓存/协商缓存) 一、构建策略 减少打包时间：缩减范围、缓存副本、定向搜索、提前构建、并行构建、可视结构 减少打包体积：分割代码、摇树优化、动态垫片、按需加载、作用提升、压缩资源 措施： 配置include/exclude缩小Loader对文件的搜索范围 配置cache缓存Loader对文件的编译副本 配置resolve提高文件的搜索速度 配置DllPlugin将第三方依赖提前打包 配置Thread将Loader单进程转换为多进程 配置BundleAnalyzer分析打包文件结构 分割各个模块代码，提取相同部分代码 删除项目中未被引用代码 通过垫片服务根据UA返回当前浏览器代码垫片 将路由页面/触发性功能单独打包为一个文件，使用时才加载 分析模块间依赖关系，把打包好的模块合并到一个函数中 压缩HTML/CSS/JS代码，压缩字体/图像/音频/视频 二、图像策略 图像选型：了解所有图像类型的特点及其何种应用场景最合适 图像压缩：在部署到生产环境前使用工具或脚本对其压缩处理 图像选型一定要知道每种图像类型的体积/质量/兼容/请求/压缩/透明/场景等参数相对值，这样才能迅速做出判断在何种场景使用何种类型的图像。 类型 体积 质量 兼容 请求 压缩 场景 JPG 小 中 高 是 有损 背景图、轮播图、色彩丰富图 PNG 大 高 高 是 无损 图标、透明图 SVG 小 高 高 是 无损 图标、矢量图 WebP 小 中 低 是 兼备 看兼容情况 Base64 看情况 中 高 否 无损 图标 工具 开源 收费 API 免费体验 QuickPicture ✖️ ✔️ ✖️ 可压缩类型较多，压缩质感较好，有体积限制，有数量限制 ShrinkMe ✖️ ✖️ ✖️ 可压缩类型较多，压缩质感一般，无数量限制，有体积限制 Squoosh ✔️ ✖️ ✔️ 可压缩类型较少，压缩质感一般，无数量限制，有体积限制 TinyJpg ✖️ ✔️ ✔️ 可压缩类型较少，压缩质感很好，有数量限制，有体积限制 TinyPng ✖️ ✔️ ✔️ 可压缩类型较少，压缩质感很好，有数量限制，有体积限制 Zhitu ✖️ ✖️ ✖️ 可压缩类型一般，压缩质感一般，有数量限制，有体积限制 三、分发策略 所有静态资源走CDN：开发阶段确定哪些文件属于静态资源 把静态资源与主页面置于不同域名下：避免请求带上Cookie 四、缓存策略 考虑拒绝一切缓存策略：Cache-Control:no-store 考虑资源是否每次向服务器请求：Cache-Control:no-cache 考虑资源是否被代理服务器缓存：Cache-Control:public/private 考虑资源过期时间：Expires:t/Cache-Control:max-age=t,s-maxage=t 考虑协商缓存：Last-Modified/Etag] http缓存机制： 先走强缓存，若命中失败才走协商缓存。 若命中强缓存，直接使用强缓存； 若未命中强缓存，发送请求到服务器检查是否命中协商缓存； 若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。 http缓存应用场景: 频繁变动资源：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效 不常变化资源：设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件 渲染层面(4大策略) CSS策略：基于CSS规则 DOM策略：基于DOM操作 JS策略：基于脚本加载 异步更新策略：基于异步更新 一、CSS策略 避免出现超过三层的嵌套规则 避免为ID选择器添加多余选择器 避免使用标签选择器代替类选择器 避免使用通配选择器，只对目标节点声明规则 避免重复匹配重复定义，关注可继承属性 二、DOM策略 缓存DOM计算属性 避免过多DOM操作 使用DOMFragment缓存批量化DOM操作 缓存DOM计算属性 使用类合并样式，避免逐条改变样式 使用display控制DOM显隐，将DOM离线化 三、JS策略 脚本与DOM/其它脚本的依赖关系很强：对&lt;script&gt;设置defer 脚本与DOM/其它脚本的依赖关系不强：对&lt;script&gt;设置async 五、异步更新策略 在异步任务中修改DOM时把其包装成微任务 三大优化指标 三大指标 FCP(首次内容渲染)：是否在加载？用户请求url到页面出现第一个元素，页面首次绘制文本、图片、非空白 Canvas 或 SVG ，即白屏时间。 FMP(首次有效渲染)：是否内容有用？用户请求url到主要有意义内容渲染,没有严格定义，目前采用LCP。即首屏时间 TTI(可交互时间):用户请求url到用户可输入交互吗?对应的用户关注点是 可以使用吗 其他指标如，google三大指标LCP(加载),FID(交互),CLS(视觉稳定性)，或者雅虎35军规 123Largest Contentful Paint (LCP): 测量加载性能。为了能提供较好的用户体验，LCP指标建议页面首次加载要在2.5s内完成。First Input Delay (FID): 测量交互性能。为了提供较好用户体验，交互时间建议在100ms或以内。Cumulative Layout Shift (CLS): 测量视觉稳定性。为了提供较好用户体验，页面应该维持CLS在0.1或以内。 优化标准 单位(S) FCP FMP TTI A类-极致 1 2 3 B类-通用 2 3 5 C类-较差 3 5 8 D类-不可接受 &gt;3 &gt;5 &gt;8 优化结果 FCP:从2降到1.2，性能提升40% FMP:从3降到2.2，性能提升26% TTI:从4降到3.2，性能提升20% 指标详解 FCP 首次内容绘制，标记的是浏览器渲染第一帧内容 DOM 的时间点，浏览器首次渲染任何文本，图像（包括背景图像），SVG 或者 &lt;canvas&gt; 等元素。 FMP 近似等于LCP，首次有效绘制，标记主角元素渲染完成的时间点，主角元素可以是视频网站的视频控件，内容网站的页面框架也可以是资源网站的头图等。 TTI Time to Interactive (TTI)，从页面加载到可视化呈现、页面初始化脚本已经加载，并且可以可靠地快速响应用户的时间 LCP 最大内容绘制，LCP（Largest Contentful Paint），用于记录视窗内最大的元素绘制的时间(页面开始加载到最大文本块内容或图片显示在页面中的时间)。表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点 FID 首次输入延迟，FID（First Input Delay），记录由于主线程繁忙导致用户首次输入的延迟时间。 Google 推荐响应用户交互在 100ms 以内(用户首次与网站进行交互(例如点击一个链接、按钮、js自定义控件)到浏览器真正进行响应的时间)。 CLS 累计位移偏移，CLS（Cumulative Layout Shift），它能衡量页面是否排版稳定。记录了页面上非预期的位移波动(从页面开始加载到状态变为隐藏过程中，发生不可预期的layout shifts的累积分数)。页面移动会经常发生在资源异步加载、或者DOM元素动态添加到已存在的页面元素上面。这些元素有可能是图片、视频、第三方广告或小图标等。 FP 页面第一次绘制像素的时间(页面开始加载到某一块内容显示在页面上的时间) TBT 阻塞总时间，TBT（Total Blocking Time），记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。 秒开率 低于1s内的数据占比即是秒开率，例如手淘的页面秒开率基本都达到80%以上。 TTFB 浏览器从请求页面开始到接收第一字节的时间，这个时间段包括 DNS 查找、TCP 连接和 SSL 连接 DCL 当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片（譬如如果有 async 加载的脚本就不一定完成）。 参考 写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践 前端性能优化 24 条建议（2020） 从输入url到渲染完成整个过程浏览器输入urlpc-&gt;正向代理(电信、VPN)-&gt;CDN(100%使用到)-反向代理(阿里云，源站的代理人)-&gt;源站 url地址解析，补全域名。 搜索本地DNS缓存记录，Chrome1分钟 缓存1000条DNS解析结果。否则域名解析为ip(DNS是基于UDP,查找域名，不需要建立3次握手，快)。 通过ip路由寻址，三次握手建立tcp连接。 负载均衡器 发送http请求。 服务器处理请求，浏览器接收HTTP响应。 渲染页面，构建dom树。 关闭TCP连接（四次挥手）。 1.首先url解析，url本质是统一资源定位符 默认补齐协议http，或默认补齐www. protocol，协议头，譬如有http，加密的https，ftp等host，主机域名或IP地址port，端口号（通常端口号不常见是因为大部分的都是使用默认的端口所以隐藏，如HTTP默认端口80，HTTPS默认端口443。）path，目录路径query，即查询参数fragment，即#后的hash值，一般用来定位到某个位置 2.DNS域名解析域名解析的过程实际是将域名还原为IP地址的过程。先检查本地host文件，再找本地dns，再向上查找。按根域服务器 -&gt;顶级域,.com-&gt;第二层域，baidu.com-&gt;子域，ww.baidu.com的顺序找到IP地址。 3.TCP连接通过三次握手协议进行连接 3.5负载均衡器 Nginx是一款高性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。 负载均衡的方法很多，Nginx负载均衡、LVS-NAT、LVS-DR等。 以Nginx负载均衡为例，Nginx有4种类型的模块：core、handlers、filters、load-balancers。 这里讲述下负责负载均衡的模块load-balancers和负责执行一系列过滤操作的filters模块。 Nginx默认支持 RR轮转法 和 ip_hash法 这2种分配算法。前者会从头到尾一个个轮询所有Web服务器，而后者则对源IP使用hash函数确定应该转发到哪个Web服务器上。还有其他的分配算法，如fair：这种算法会选择相应时间最短的Web服务器。url_hash：这种算法会使得相同的url发送到同一个Web服务器 而Filter的功能可以理解成先把前一步生成的结果处理一遍，再返回给浏览器。比如可以将前面没有压缩的网页用gzip压缩后再返回给浏览器。 4.发送http请求 排队等待，一个域名下最多6个连接。HTTP请求包含请求行、请求头、请求体三部分。默认不会断开，keep-alive保持下次传输时，复用上次创建的链接 123456789101112131415Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收Content-Type：客户端发送出去实体内容的类型Cache-Control: 指定请求和响应遵循的缓存机制，如no-cacheIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中Cookie: 有cookie并且同域访问时会自动带上Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-aliveHost：请求的服务器URLOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)User-Agent：用户客户端的一些必要信息，如UA头部等 5.服务端响应 123451xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 常用的响应头部（部分）： 12345678910111213Access-Control-Allow-Headers: 服务器端允许的请求HeadersAccess-Control-Allow-Methods: 服务器端允许的请求方法Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）Content-Type：服务端返回的实体内容的类型Date：数据从服务器发送的时间Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档Last-Modified：请求资源的最后修改时间Expires：应该在什么时候认为文档已经过期,从而不再缓存它Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag：请求变量的实体标签的当前值Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）Server：服务器的一些相关信息 html渲染流程 解析HTML标签，构建DOM树 解析CSS标签，并构建CSSOM样式规则树 调用js引擎处理script标记、绑定事件、修改DOM树/CSS树 将DOM和CSSOM合并成一个Render dom渲染树; 根据渲染树来布局（Layout回流/reflow重绘），来计算每个节点的几何信息 调用渲染引擎绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite） GUI渲染线程,JS引擎线程,事件触发线程,定时器触发线程,异步http请求线程 Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。 Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。 名词解释 123456Parse Stylesheet：解析样式表，构建出 CSSOMRecalculate Style：重新计算样式，确定样式规则Layout：根据计算结果进行布局，确定元素的大小和位置Update Layer Tree：更新渲染层树Paint：根据 Layer Tree 绘制页面（位置、大小、颜色、边框、阴影等）Composite Layers：组合层，浏览器将图层合并后输出到屏幕 性能监控原生Performance API 左边部分代表的是网络传输层面的过程，右边部分代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析、DOM 树构建、布局、绘制等。 查找域名：开始查找域名到查找结束，计算公式为（domainLookupEnd - domainLookupStart） 建立连接：开始发出连接请求到连接成功，计算公式为（connectEnd - connectStart） 请求文档：开始请求文档到开始接收文档，计算公式为（responseStart - requestStart） 接收文档：开始接收文档到文档接收完成，计算公式为（responseEnd - responseStart） domready：开始解析文档到 DOMContentLoaded 事件被触发,计算公式为（domContentLoadedEventStart - domLoading） load 事件持续：load 事件被触发到 load 事件完成，计算公式为（loadEventEnd - loadEventStart） 完全加载：开始解析文档到文档完全加载，计算公式为（domComplete - domLoading） 首屏加载：开始解析文档到首屏加载完毕，计算公式为（firstscreenready - domLoading） 完全加载【全过程】：此次浏览最开始时刻到完全加载完毕,计算公式为（domComplete - navigationStart） 首屏加载【全过程】：此次浏览最开始时刻到首屏加载完毕,计算公式为（firstscreenready - navigationStart） 123456789cosnt &#123; fetchStart,//开始访问 requestStart,//请求开始 responseStart,//响应开始 responseEnd,//响应结束 domInteractive,//dom可交互时间点，即dom的event事件可绑定时间点 domContentLoadedEventEnd,//dom加载完毕 loadEventEnd//所有资源加载完毕，包括js，css,图片加载&#125; = performance.timing 指标计算 123456789101112131415161718192021222324252627282930const paint=performance.getEntriesByType(&#x27;paint&#x27;)//FCP，原生js的performance指标FCP =paint[1].startTime//FMP，原生js的PerformanceObserver的APInew PerformanceObserver((entryList,observer)=&gt;&#123;指标FMP =entryList.getEntries()[0]; observer.disconnect();//断开监视&#125;).observe(&#123;entryTypes:[&#x27;element&#x27;]&#125;)//TTI指标TTI =domInteractive-fetchStart //整一个可交互时间指标ttfb(白屏时间) = responseStart - navigationStart ||0指标DCL(dom加载时间) =domContentLoadedEventEnd-fetchStart指标Load(页面加载时间) =loadEventEnd-fetchStart指标tcp(连接时间) = connectEnd - connectStart || 0,指标FP(第一次绘制像素时间) =paint[0].startTime//LCP，mutationObserver微任务new PerformanceObserver((entryList,observer)=&gt;&#123; entryList=entryList.getEntries() LCP=entryList[entryList.length-1]//取队列的最后一个元素 observer.disconnect();//断开监视&#125;).observe(&#123;entryTypes:[&#x27;largest-contentful-paint&#x27;]&#125;)//FIDnew PerformanceObserver((entryList,observer)=&gt;&#123; firstInput=entryList.getEntries()[0]//取队列的第一个元素 if(!firstInput) return; FID=firstInput.processingStart-firstInput.startTime; observer.disconnect();//断开监视&#125;).observe(&#123;type:[&#x27;first-input&#x27;],buffered:true&#125;) 事前预警-埋点上报(1)埋点方式 代码埋点、可视化埋点、无痕埋点三种 代码埋点也叫手动埋点属于侵入式埋点，由开发手动在代码内植入预埋点，完全由开发控制埋点的位置时间和触发机制。 可视化埋点即以业务代码为输入，通过可视化系统配置埋点，最后以耦合的形式输出业务代码和埋点代码。 无痕埋点即无差别地对全局所有事件和页面加载生命周期等进行拦截全埋点。 (1.1)代码埋点 如百度统计、友盟、TalkingData、Google Analytics、Sensors Analytics等都提供了这一方案。 (1.2)可视化埋点 方案有Mixpanel、TalkingData、诸葛IO、腾讯MTA，Sensors AnalyticsV1.3+等 (1.3)无埋点 Heap、百度（点击猴子）、GrowingIO等与可视化埋点又类似，二者的区别就是可视化埋点先通过界面配置哪些控件的操作数据需要收集；“无埋点”则是先尽可能收集所有的控件的操作数据，然后再通过界面配置哪些数据需要在系统里面进行分析。 (2)具体操作 123456789101112131415161718(2.1)利用&lt;script&gt;标签的 src 属性上报工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 &lt;script&gt; 节点，将指标信息拼接成 url param 的形式，通过 &lt;script&gt; 标签的 src 属性发起请求，将数据上报到服务器。(2.2)利用&lt;img&gt;标签的 src 属性上报- 跨域友好- 执行过程无阻塞- 使用image时，部分浏览器内页面关闭不会影响数据上报- gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节(2.3)利用 HTML5 Beacon API 进行数据上报Beacon API 允许开发者发送少量错误分析和上报的信息,优点：- 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行- 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页- 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理 事后分析ChromeDevToolsPerformance 一、Personmance面板简介三大区域：网页性能(总览图);网络面板(瀑布图)，主线程(火焰图)等。熟语：总览在瀑布下用火焰烤饼 总览图：蓝色：解析htmlLoading；黄色：js相关；紫色：渲染相关；绿色：绘制相关； 瀑布图：蓝色：html加载；黄色：js脚本资源加载；紫色：css资源加载；绿色：img等资源加载；灰色：api接口请求 火焰图：红色标记的为长任务 瀑布图 12345一个请求分为4段：浅色线段：请求建立连接时间，从客户端发送请求到建立tcp连接，比如网络问题，nginx转发问题浅色柱子TTFB：客户端请求第一个字节到客户端收到第一个字节的时间，比如：后台处理任务时间过长深色柱子：客户端下载第一个字节到最后一个字节的时间浅色线段：等待主线程处理时间即浏览器拿到所有资源到交给主线程处理的等待时间，比如：主线程有很多任务，某些js脚本执行时间过长 火焰图 123456脚本执行、样式计算、布局计算、绘制等等。任务队列，每个任务又分为若然子任务，有红色箭头标记长任务，run time。找到最长的长任务，可能就是存在性能瓶颈的地方。这个Task还不是Event Loop，表示当前主线程忙碌，无法响应用户交互。Run Microtasks 则确实是在一次任务的末尾执行的微任务。Task之间的白色就是Idle空闲时间,可能是资源加载时间过长引起的。当我们点开调用栈观察时，可以看到源码中的回调函数以及对应的源码位置。比如：LongTask里有一个二维码绘制的函数drawQrCode。耗时比较久，但是其实只需要鼠标移入才需要显示的，没必要做到首页加载。 二、面板详解 区域1：网页性能总览图总览图包含 FPS（每秒帧数情况，越大越好）、CPU（CPU占用情况）、NET（网络资源情况）、HEAP（JS占用情况）一共四项指标。 区域2：各项指标的区块图 12345678910111Network：表示每个服务器资源的加载情况，**瀑布图**。main:表示每个task执行的时间，以及子任务的执行时间，**火焰图**，x轴表示时间轴，每个条形代表一个事件，越宽代表花费时间越长。y轴表示调用堆栈，高的事件调用低的事件。2Frames：表示每幅帧的运行情况。3Timings：上图中有 4 条虚线，分别表示如下。（1）DCL（DOMContentLoaded）表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发。（2）FP（First Paint）首屏绘制，页面刚开始渲染的时间。（3）FCP（First Contentful Paint）首屏内容绘制，首次绘制任何文本，图像，非空白canvas 或 SVG 的时间点。（4）FMP（First Meaningful Paint）首屏有意义的内容绘制，这个“有意义”没有权威的规定，本质上是通过一种算法来猜测某个时间点可能是 FMP。有的理解为是最大元素绘制的时间，即同LCP（Largest Contentful Paint ）。其中 FP、FCP、FMP 是同一条虚线，三者时间不一致。比如首次渲染过后，有可能出现 JS 阻塞，这种情况下 FCP 就会大于 FP。（5）L（Onload）页面所有资源加载完成事件。（6）LCP（Largest Contentful Paint ）最大内容绘制，页面上尺寸最大的元素绘制时间。 区域3：数据统计与汇总 bottom-up 执行的事件，可以看到各活动占用的时间。Self Time 表示直接花费的时间，Total Time表示在该活动和其所有子活动花费的时间。可以看到该事件是执行的微任务，包含了重新计算样式+布局+调用方法+请求状态改变+解析html。 Call Tree 调用树，查看根活动（根活动是那些导致浏览器做一些工作的活动。例如，当单击一个页面时，浏览器会触发一个Event作为根 Activity 的 Activity。这Event可能会导致处理程序执行，等等。其在Main,call Tree 、Event Log都是最高级）。 Event log 浏览器在每一帧里，都会执行： 1Schedule Style Recalculation` -&gt; `Recalculate Style` -&gt; `Update Layer Tree` -&gt; `Paint` -&gt; `Composite Layers 12345- JavaScipt：JavaScript 实现动画效果，DOM 元素操作等。（Demo 3没有 js ，故这一步没有）- Style（Schedule Style Recalculation、Recalculate Style）：确定每个 DOM 元素应该应用什么 CSS 规则，重新计算样式。- Layout（Update Layer Tree）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow，即回流- Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。这个过程会触发对元素的绘制，rePaint，即重绘- Composite（渲染层合并，Composite Layers）：按照合理的顺序合并图层然后显示到屏幕上。 案例分析 google官方推出的性能案例 a.打开性能面板，进行录制 b.开始分析 根据调用时间，推断代码入口 根据具体某个阶段，推断代码入口 Memory案例分析 主要查看程序是否存在内存泄漏情况 1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;内存泄漏案例分析&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; &lt;button id=&quot;run&quot;&gt;运行&lt;/button&gt; &lt;button id=&quot;stop&quot;&gt;停止&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script &gt; const arr =[] for(let i=0;i&lt;200000;i++)&#123; arr.push(i) &#125;// let arr = new Array(20000).fill(1) let newArr=[] function run()&#123; newArr = newArr.concat(arr) &#125; let clearRun document.querySelector(&#x27;#run&#x27;).onclick=function()&#123; clearRun=setInterval(()=&gt;&#123; run() &#125;,1000) &#125; document.querySelector(&#x27;#stop&#x27;).onclick=function()&#123; clearInterval(clearRun) &#125; &lt;/script&gt;&lt;/html&gt; a.打开内存面板，进行录制 b.分析面板 Lighthouseweb-vitals 库Google官方提供了一个web-vitals库,可以测量google性能三大指标LCP,FID,CLS。 12345678910111213import &#123;getCLS, getFID, getLCP&#125; from &#x27;web-vitals&#x27;;function sendToAnalytics(metric) &#123; const body = JSON.stringify(metric); // Use `navigator.sendBeacon()` if available, falling back to `fetch()`. (navigator.sendBeacon &amp;&amp; navigator.sendBeacon(&#x27;/analytics&#x27;, body)) || fetch(&#x27;/analytics&#x27;, &#123;body, method: &#x27;POST&#x27;, keepalive: true&#125;);&#125;getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics); web-report-sdkweb-monitoring性能优化提高网站的性能，很多的手段，比如，浏览器访问优化，CDN加速，反向代理，分布式缓存，使用集群，代码和数据结构的优化，存储性能的优化等 渲染-HTML 最精简的dom深度，减少DOM元素的数量（否则会加重页面layout的压力）; 批量修改dom使用DocumentFragment；在循环结束时，一次性写入； 尽量少用iframe，优点：引入缓慢的第三方内容，安全沙箱，并行下载脚本。缺点:代价高，白屏，阻塞页面加载，非语义。 渲染-CSS 最小化回流layout和重绘paint，如将没用的元素设为不可见visibility: hidden。利用GPU进行完成动画transform属性； 最精简的css层级(不超过3层);合并内嵌css（不然计算量会很大）; 优先id或class选择器，减少匹配次数; 选择link标签，舍弃@import 渲染-图像 图片在渲染前指定大小：img在加载图片后会改变宽高，导致重排 使用CSS Sprite雪碧图加载，横向排列一般都比纵向排列的最终文件小。 使用webp格式文件 渲染-JS 合理使用script 标签的defer和async，与dom耦合的使用defer，否则使用async preload和prefetch：preload主要用于预加载当前页面需要的资源；而prefetch主要用于加载将来页面可能需要的资源； 属性读写分离，先读后写； 网络-构建Webpack 体积更小 使用摇树技术Tree-Shaking 使用作用域提升scope-hositing 缩小打包范围 压缩h5图片样式文件 splitChunks 代码分割，抽取公共代码 速度更快 使用多线程打包 使用中间缓存优化 网络-构建Vue加载时性能优化 服务端渲染（SSR）和预渲染（Prerender） 组件路由懒加载 运行时性能优化 扁平化store数据结构 提取公共css和公共组件 第三方库按需引入 使用非相应式数据 Object.freeze() v-show和v-if，computed和watch，v-for的keyv-for 遍历必须为 item 添加 key，且避免同时使用 v-if事件的销毁图片懒加载、路由懒加载、异步组件第三方插件的按需引入服务端渲染 SSR or 预渲染SPA 页面采用keep-alive缓存组件key保证唯一防抖、节流第三方模块按需导入长列表性能优化 SEO优化 预渲染 服务端渲染SSR 打包优化 压缩代码 Tree Shaking/Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化 用户体验 骨架屏 PWA 网络-分发CDN 内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速 淘宝的图片访问，有98%的流量都走了CDN缓存。只有2%会回源到源站，节省了大量的服务器资源。 借用阿里云官网的例子，来简单介绍CDN的工作原理。 12345678910假设通过CDN加速的域名为www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：1. 当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。2. LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。3. 当授权DNS解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。4. 域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。5. LDNS获取DNS返回的解析IP地址。6. 用户获取解析IP地址。7. 用户向获取的IP地址发起对该资源的访问请求。 如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。 如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。 从这个例子可以了解到：（1）CDN的加速资源是跟域名绑定的。（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。 减少http请求数 因为浏览器有6个并发的限制;合并文件、CSS Sprites、行内图片（Base64编码） 传输优化 开启Gzip压缩，有时候压缩率高达90%； 123456789101112131415nginx 配置gzip段如下：gzip on;//该指令用于开启或关闭gzip模块(on/off)gzip_min_length 1k;//设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。gzip_buffers 4 16k;//设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。gzip_http_version 1.1;//识别http的协议版本(1.0/1.1)gzip_comp_level 2;//gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)gzip_types text/plain application/x-javascript text/css application/xml//匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。gzip_vary on;//和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩 网络-缓存浏览器缓存和Http缓存","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"性能优化_webpack","slug":"H_工程热点_性能优化_webpack","date":"2023-03-12T02:33:16.000Z","updated":"2023-07-16T03:53:27.403Z","comments":true,"path":"2023/03/12/H_工程热点_性能优化_webpack/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96_webpack/","excerpt":"","text":"入门前言module，chunk 和 bundle是什么 同一份逻辑代码在不同转换场景下的取了三个名字， module是源码，module经过webpack处理成chunk，webpack最后输出bundle。 module：源码文件，包括 ESM或commonJS 或是UMD chunk：webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作 bundle：webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行 打包后文件目录 app.js:就是app.vue文件 mainfest.js:一些异步加载的实现方法 vender.js:vue核心功能被打包到这里 chunk.js:主要的页面路由被打包编译在此 webpack是什么定义 webpack 是一个模块打包机，将根据文件间的依赖关系对其进行静态分析，然后按指定规则递归地构建一个依赖关系图，最终打包成一个或多个 bundle。 核心模块 entry: 入口 output: 输出 loader: 模块转换器，用于把模块原内容按照需求转换成新内容 插件(plugins): 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情 特点 支持多种模块化标准方案，包括ES Module,CommonJS,UMD 支持code splitting代码分割和文件分块 支持loader静态文件串联处理，强大的plugin插件扩展功能 打包工具 gulp/grunt是自动化任务构建工具。 gulp/grunt：是一种能够优化前端开发的工作流程的工具，比如css/js的压缩混淆，预处理语言的编译、图片体积优化等等。与webpack有部分重合，比如打包、压缩混淆、图片转 base64 等等。但它们的目的跟要解决的问题是不一样的。 webapck/browserify/seajs/requirejs是模块化解决方案，强调模块化开发，而那些文件压缩合并、预处理等功能，不过是附带的功能。 seajs/requirejs： 是一种在线”编译” 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module 这些东西。也就实现了模块化。 webpack/browserify： 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先，它是预编译的，不需要在浏览器中加载解释器。另外，你在本地直接写JS，不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。 webpack打包原理打包概况： 从入口文件开始，分析整个个应用的依赖树 将每个依赖模块包装起来，放到一个数组中，等待被调用 执行模块加载方法，确定模块之间以互相调用 把执行入口文件的逻辑放在一个立即执行函数汇总，参数就是模块数组 详细流程: （1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。 （2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 （3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。 （4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 （5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。 （6）输出完成：输出所有的chunk到文件系统。 打包流程： 打包核心源码： 123456789101112131415161718192021222324252627282930313233343536373839404142431)首先是一个自执行函数2)参数通过对象形式传递，key是文件路径，value是函数，eval()表示执行字符串代码。eval执行vaule函数字符串。3)如果有多个依赖文件，最终会打包成一个文件4)__webpack_require__最重要，模拟了require方法，将所有的引入合并成一个文件5)通过递归的方式不断调用自己__webpack_require__，检查自己的依赖关系(function(modules)&#123; //module缓存对象 var installedModules = &#123;&#125;; //require函数精髓 function __webpack_require__(moduleId)&#123; //检查module是否在cache中 if(installedModules[moduleId])&#123; return installedModules[moduleId].exports; &#125; //若不在cache中则新建module并放入cache中 var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; //执行module函数 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); //标记module已经加载 module.loaded = true; //返回module的导出模块 return module.exports; &#125; //暴露modules对象（__webpack_modules__） __webpack_require__.m = modules; //暴露modules缓存 __webpack_require__.c = installedModules; //设置webpack公共路径__webpack_public_path__ __webpack_require__.p = &quot;&quot;; //读取入口模块并且返回exports导出 return __webpack_require__(0);&#125;)([function(module, exports, __webpack_require__)&#123; /*模块Id为0*/ var text = __webpack_require__(1); console.log(text);&#125;,function(module, exports)&#123; /*模块Id为1*/ module.exports = &#x27;Hello world&#x27;;&#125;]); webpack优化策略分析工具 webpack-bundle-analyzer打包分析神器 speed-measure-webpack-plugin分析整个打包时长，涉及所有 loader 和 plugins 优化指标 体积更小 使用摇树技术Tree-Shaking 使用作用域提升scope-hositing 缩小打包范围 压缩h5图片样式文件 splitChunks 代码分割，抽取公共代码 速度更快 使用多线程打包 使用中间缓存优化 一、体积更小 使用摇树技术Tree-Shaking DCE（Dead Code Elimination）消除无用js代码。Tree-Shaking 目前只适用于 ESModule模块化的代码，不适用commonjs。通过静态分析将无用代码打上标记，然后删除标记的无用代码。配置usedExports: true,配置mode：production生产环境。或者配置terser-webpack-plugin 使用作用域提升scope-hositing 把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码 缩小打包范围 压缩html,如html-webpack-plugin cacheDirectory开启babel缓存，提高二次构建速度，缓存loader执行结果； 优化 module.noParse,不解析依赖打包，externals编译后不打包 优化 resolve.modules，默认值为 [‘node_modules’]，会逐层查找第三方模块，直接指定绝对路径，更快速查找； 优化 resolve.extensions ,默认值为 [‘.wasm’, ‘.mjs’, ‘.js’, ‘.json’],修改为js,ts，更快速匹配文件； 排除对于语言包的打包,比如moment，排除多余语言，new webpack.IgnorePlugin(/./locale/,/moment/) 压缩h5图片样式文件 HtmlWebpackPlugin优化压缩html UglifyjsWebpackPlugin升级后的minimize压缩 压缩图片，使用 url-loader 减少 http 请求,图片转为内置base64URI 使用 optimize-css-assets-plugin 压缩 CSS splitChunks 代码分割，抽取公共代码 entry 配置多入口 动态路由载入 splitChunks 配置 splitChunks 规则和配置 拆分合并规则：a.命名规则：vendorab.js。vendor前缀表示命中缓存，a-b表示a和b有相同模块合并。cacheGroups表示缓存组，被命中的缓存组模块，会以vendor为前缀。b.如果都是异步代码，都会被默认拆分出来打包成独立文件。相同模块会自动合并，命名后缀均为a_lodash.js。c.如果都是同步代码，在”async”模式下，不拆分不合并;在“initial或all”模式下，会拆分且合并；vendors_a-b_lodash.js。d.如果是一同步一异步代码，在”async”模式下，同步代码不拆分不合并;在”initial”模式下，会拆分同步代码，但是同步代码与异步代码相同模块不会合并；在”all”模式下，会拆分且合并。 1234567891011121314151617181920212223242526module.exports = &#123; // ... optimization: &#123; splitChunks: &#123; chunks: &#x27;async&#x27;, // 三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认) minSize: 30000, // 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk 的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了 maxSize: 0, // 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize minChunks: 1, // 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小 maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了 maxInitialRequests: 3, // 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了 automaticNameDelimiter: &#x27;~&#x27;, // 打包文件名分隔符 name: true, // 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个 cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // 正则规则，如果符合就提取 chunk priority: -10 // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级 &#125;, default: &#123; minChunks: 2, priority: -20, // 优先级 reuseExistingChunk: true // 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个 &#125; &#125; &#125; &#125;&#125;; 二、速度更快 使用多线程打包happypack-loader 原理：每次 webapck 解析一个模块，HappyPack 会将它及它的依赖分配给 worker 线程中。处理完成之后，再将处理好的资源返回给 HappyPack 的主进程，从而加快打包速度。 使用中间缓存优化HardSourceWebpackPlugin 进阶webpack-loader机制 【万字长文｜趣味图解】彻底弄懂Webpack中的Loader机制 loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，如编译、压缩等、语法分析及转换，然后交由下一环节进行处理，所有载入的模块最终都会经过moduleFactory处理，转成javascript可以识别和运行的代码，从而完成模块的集成。 Loader本质 Loader 本质上是导出为函数的 JavaScript 模块。它接收资源文件或者上一个 Loader 产生的结果作为入参，也可以用多个 Loader 函数组成 loader chain（链），最终输出转换后的结果。 Loader的四种类型 分为：前置(pre)、普通(normal)、行内(inline)、后置(post)。 12345678910111213module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &quot;style-loader&quot;, //将css内容变成style标签插入到html中去 &quot;css-loader&quot;, //解析css文件的路径等 &quot;less-loader&quot;, //将less=&gt;css ], enforce: &quot;pre&quot;, //这里也可以是post，默认不写就是normal &#125;, ],&#125;, Loader执行顺序 简单说：Loader 的执行顺序是由右向左，或者由下到上执行。 官方说法：Pitching 阶段和Normal 阶段 所有一个接一个地进入的 Loader，都有两个阶段： Pitching 阶段: Loader 上的 pitch 方法，按照 后置(post)、行内(inline)、普通(normal)、前置(pre) 的顺序调用。 Normal 阶段: Loader 上的 常规方法，按照 前置(pre)、普通(normal)、行内(inline)、后置(post) 的顺序调用。模块源码的转换， 发生在这个阶段。 同等类型下的 Loader 执行顺序才是由右向左，或者由下到上执行。 以处理SCSS文件为例： SCSS源代码会先交给sass-loader把SCSS转换成CSS； 把sass-loader输出的CSS交给css-loader处理，找出CSS中依赖的资源、压缩CSS等； 把css-loader输出的CSS交给style-loader处理，转换成通过脚本加载的JavaScript代码； 先sass-loader再css-loader再style-loader，每个Loader会链式的顺序执行， 第一个Loader将会拿到需处理的原内容，上一个Loader处理后的结果会传给下一个接着处理。 babel文件编译器 bebel-loader中核心的是，@babel-core核心包、@babel-preset-env预设。babel是javascript语法的编译器。比如class，let,for…of promise等等这样的，低版本浏览器不支持，babel编译器将es6代码转换成浏览器能识别的代码。默认情况下对新的语法和API中的，新的语法进行转换。在Babel执行编译的过程中，会从项目的根目录下的 .babelrc文件中读取配置。.babelrc是一个json格式的文件。在.babelrc配置文件中，主要是对预设(presets) 和 插件(plugins) 进行配置。 webpack-plugin机制原理 plugin是一个扩展器，它丰富了 webpack 本身，针对是loader` 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack 打包过程中的某些节点，执行广泛的任务。 Plugin 的作用： 能够 hook 到在每个编译(compilation)中触发的所有关键事件。 在插件实例的 apply 方法中，可以通过 compiler.options 获取 Webpack 配置，并进行修改。 webpack-vueloader机制完整流程 .vue 单文件文件组件类型的文件（下文简称 SFC）。Webpack 需要增加 vue-loader 和 vueLoaderPlugin 对 SFC 进行支持。入参 source 是 SFC 源码，经过处理逻辑后，输出 export default 的代码字符串。 1.SFC 的输入和输出 2.template、script、style 代码块切分 template、script、style 代码块在输出结果中已经转化为对应的 import 逻辑。这一步是 vue-loader 调用了 @vue/component-compiler-utils 的 parse 函数进行解析后，分别生成了对应的 import 逻辑. 3.VueLoaderPlugin 的作用 vue&amp;type=template 的作用是什么? VueLoaderPlugin 通过plugin的第2作用，对 module.rules 进行动态修改。 VueLoaderPlugin 的处理流程中，修改了 module.rules，在原来的基础上加入了 pitcher 和 cloneRules 。这一步的作用是：新增的 rule ，能识别形如 ?vue&amp;type=template 的 querystring，让不同语言的代码块匹配到对应的 rule。 4.SFC 转化流程 每个代码块都导出了对应逻辑，我们以 script 块为例，结合第二节的 PitcherLoader 再次进行转化. 5.再次执行 VueLoader 在 PitchLoader 的转化结果中，还是会以 vue-loader 作为第一个处理的 loader，但 vue-loader 不是一开始就转化过了吗 ？与第一次不同的是，这次 vue-loader 的作用，仅仅是把 SFC 中语法块的源码提取出来，并交给后面的 loader 进行处理。 webpack-手写loader自定义loader分为:同步loader和异步loader 1234567891011121314151617181920212223242526272829303132333435363738394041webpack.config.jsconst path = require(&#x27;path&#x27;);module:&#123; rules:[ &#123; test:/.js$/, use:[ path.resolve(__dirname,&#x27;./loaders/replace.js&#x27;) ] &#125; ]&#125;index.jsconsole.log(&#x27;luwentest&#x27;)//同步loader,修改打包内容replace.jsmodule.export = function(context)&#123;//没有使用箭头函数，可能需要修改this指向return context.replace(/luwentest/g,&#x27;luwenProduction&#x27;)&#125;asyncReplace.js//异步loaderconst sleep = num =&gt;new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(); &#125;,num)&#125;);module.export = function(content)&#123;//获取loader的异步回调函数 cosnt callback= this.async(); ;(async()=&gt;&#123; //立即执行函数 await sleep(3000); content = context.replace(/luwentest/g,&#x27;luwenProduction&#x27;) //执行回调函数，传入4个参数，第1个是error信息，2是内容，3，4未知 callback(null,content); &#125;)();&#125; webpack-手写plugin必须条件： 必须是一个class类； 必须重写apply方法； 必须调用complier API来影响打包结果； 1.webpack 读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。 2.初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。 3.插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin (事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack 123456789101112131415161718192021222324252627282930//在项目打包时，动态创建license证书license-webpack-plugin.jsclass LicenseWebpackPlugins&#123; constructor(parmas)&#123; console.log(parmas); &#125; apply(complier)&#123; // 在emit阶段插入钩子函数，用于特定时机处理额外的逻辑； compiler.hooks.emit.tap(&#x27;HelloPlugin&#x27;, (compilation) =&gt; &#123; // 在功能流程完成后可以调用 webpack 提供的回调函数； &#125;) // 如果事件是异步的，会带两个参数，第二个参数为回调函数， compiler.plugin(&#x27;emit&#x27;, function (compilation, callback) &#123; // 处理完毕后执行 callback 以通知 Webpack // 如果不执行 callback，运行流程将会一直卡在这不往下执行 callback() &#125;) //Compiler 代表了整个 Webpack 从启动到关闭的生命周期 //Compilation 只是代表了一次新的编译，只要文件有改动，compilation 就会被重新创建。 //tapAsync表示异步处理，接收2个参数，第1个参数是类名，第2个是函数， //第2个是函数,包括2个参数，第1个参数是compliation类似可编译对象实例，第2个是cb回调函数 complier.hook.emit.tapAsync(&#x27;LicenseWebpackPlugins&#x27;,(compliation,cb)=&gt;&#123; compliation.assets[&#x27;LICENSE&#x27;]=&#123; source:function()&#123; return &#x27;xxxxx我的证书信息&#x27; &#125; &#125; &#125;) &#125;&#125; webpack3、4、5比较webpack4比3的优化： v8 引擎带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf） 默认使用更快的 md4 hash 算法 webpack AST 可以直接从 loader 传递给 AST，减少解析时间 增加了mode配置，development | production，production配置默认启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。 splitChunks替代了CommonChunksPlugin MiniCssExtractPlugin取代ExtractTextWebpackPlugin 代码分割，支持动态import，而不是用system.import或者require.ensure vue-loader，使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader UglifyJsPlugin，使用optimization.minimize为true就行 webpack5比4的优化： 内置 terser-webpack-plugin,mode=“production” 配置自动开启js压缩，自动开启 tree-shaking。而webpack4需要安装 terser-webpack-plugin。 内置 cache 缓存机制，cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。wepback4需要npm install hard-source-webpack-plugin -D 5需要webpack serve 启动服务。日志不好。4可以webpack-dev-server 启动服务 raw-loader 将文件导入为字符串，asset/source 替换 raw-loader（导出源代码） url-loader 将文件作为 data url 内联到 bundle文件中，asset/inline 替换 url-loader （导出 url） file-loader 将文件发送到输出目录中，asset/resource 替换 file-loader(发送单独文件) 5.2版本以后提供npx webpack全局命令，支持全局操作,原理：当前目录下查找node_module,如果没有用，则下载webpack ESbuild就比webpack快 我的主基准测试会将 three.js 库复制 10 次并从头开始构建单个包，过程中没有任何缓存，从而模拟一个大型代码库。在这个基准测试中，esbuild 比我测试的其他 JavaScript 打包器（Webpack、Rollup、Parcel 和 FuseBox）快 10-100 倍。这个基准测试可以使用’make bench-three’来运行。 目前支持： CommonJS 模块 ES6 模块 使用’–bundle’与 ES6 模块的静态绑定打包 使用’–minify’完全压缩（空格、标识符和修饰符） 启用’–sourcemap’时，完全支持源映射 .jsx 文件的 JSX 到 JavaScript 转换 通过’–define’进行编译时标识符替换 使用 package.json 中的’browser’字段进行路径替换 自动检测 tsconfig.json 中的’baseUrl’ 为什么这么快： 它是用 Go 语言编写的，该语言可以编译为原生代码； 解析，打印和源映射生成全部完全并行化； 无需昂贵的数据转换，只需很少的几步即可完成所有操作； 编写代码时处处注意速度表现，并尽量避免不必要的配置。 webpack性能瓶颈 代码构建 浏览器的很多包分析工具是用C/C++写的, 显然是要比 webpack 使用 js 去分析整个依赖图谱更具优势，速度上也是要快很多的。 代码压缩 webpack 使用的 terser, 是用 js 写的，不如go语言编写的esbuild 高级webpack-code splitting代码分割详解webpack code splitting 代码分割需要做的事情： 为 Vendor 单独打包（Vendor 指第三方的库或者公共的基础组件，因为 Vendor 的变化比较少，单独打包利于缓存） 为 Manifest （Webpack 的 Runtime 代码）单独打包 为不同入口的业务代码打包，也就是代码分割异步加载（同理，也是为了缓存和加载速度） 为异步公共加载的代码打一个的包 分割的两种方式： require.ensure代码分割：通过require.ensure定义分割点，将代码进行分割打包，异步加载 dynamic import代码分割：在动态代码拆分方面，webpack支持符合ECMAScript提议的import()语法进行代码分割和异步加载。 1.require.ensure代码分割 webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中，这个新的 chunk 会被 webpack 通过 jsonp 来异步加载，其他包则会同步加载。 2.dynamic import 代码分割 requre.ensure好像已被webpack4废弃。es6提供了一种更好的代码分割方案也就是dynamic import（动态加载）的方式，webpack打包时会根据import()自动代码分割； webpack分包策略 基础类库 chunk-libs UI 组件库 chunk-elementUI 自定义共用组件/函数 chunk-commons 低频组件 chunk-eachrts/chunk-xlsx等 业务代码 lazy-loading xxxx.js 类型 共用率 使用频率 更新频率 例子 基础类库 高 高 低 vue/react、vuex/mobx、xx-router、axios 等 UI 组件库 高 高 中 Element-UI/Ant Design 等 必要组件/函数 高 高 中 Nav/Header/Footer 组件、路由定义、权限验证、全局 State 、全局配置等 非必要组件/函数 高 高 中 封装的 Select/Radio 组件、utils 函数 等 (必要和非必要组件可合并) 低频组件 低 低 低 富文本、Mardown-Editor、Echarts、Dropzone 等 业务代码 低 高 高 业务组件、业务模块、业务页面 等 基础类库 chunk-libs 它是构成我们项目必不可少的一些基础类库，比如 vue+vue-router+vuex+axios 这种标准的全家桶，它们的升级频率都不高，但每个页面都需要它们。（一些全局被共用的，体积不大的第三方库也可以放在其中：比如 nprogress、js-cookie、clipboard 等） UI 组件库 理论上 UI 组件库也可以放入 libs 中，但这里单独拿出来的原因是： 它实在是比较大，不管是 Element-UI还是Ant Design gizp 压缩完都可能要 200kb 左右，它可能比 libs 里面所有的库加起来还要大不少，而且 UI 组件库的更新频率也相对的比 libs 要更高一点。我们不时的会升级 UI 组件库来解决一些现有的 bugs 或使用它的一些新功能。所以建议将 UI 组件库也单独拆成一个包。 自定义组件/函数 chunk-commons 这里的 commons 主要分为 必要和非必要。 必要组件是指那些项目里必须加载它们才能正常运行的组件或者函数。比如你的路由表、全局 state、全局侧边栏/Header/Footer 等组件、自定义 Svg 图标等等。这些其实就是你在入口文件中依赖的东西，它们都会默认打包到app.js中。 非必要组件是指被大部分页面使用，但在入口文件 entry 中未被引入的模块。比如：一个管理后台，你封装了很多 select 或者 table 组件，由于它们的体积不会很大，它们都会被默认打包到到每一个懒加载页面的 chunk 中，这样会造成不少的浪费。你有十个页面引用了它，就会包重复打包十次。所以应该将那些被大量共用的组件单独打包成chunk-commons。 不过还是要结合具体情况来看。一般情况下，你也可以将那些非必要组件\\函数也在入口文件 entry 中引入，和必要组件\\函数一同打包到app.js之中也是没什么问题的。 低频组件 低频组件和上面的共用组件 chunk-commons 最大的区别是，它们只会在一些特定业务场景下使用，比如富文本编辑器、js-xlsx前端 excel 处理库等。一般这些库都是第三方的且大于 30kb，所以 webpack 4 会默认打包成一个独立的 bundle。也无需特别处理。小于 30kb 的情况下会被打包到具体使用它的页面 bundle 中。 业务代码 这部分就是我们平时经常写的业务代码。一般都是按照页面的划分来打包，比如在 vue 中，使用路由懒加载的方式加载页面 component: () =&gt; import(&#39;./Foo.vue&#39;) webpack 默认会将它打包成一个独立的 bundle。 完整配置代码： 1234567891011121314151617181920212223splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; libs: &#123; name: &quot;chunk-libs&quot;, test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: &quot;initial&quot; // 只打包初始时依赖的第三方 &#125;, elementUI: &#123; name: &quot;chunk-elementUI&quot;, // 单独将 elementUI 拆包 priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/ &#125;, commons: &#123; name: &quot;chunk-comomns&quot;, test: resolve(&quot;src/components&quot;), // 可自定义拓展你的规则 minChunks: 2, // 最小共用次数 priority: 5, reuseExistingChunk: true &#125; &#125;&#125;; 参考webpack 优秀中文文章 掘金站内 webpack 优秀文章汇总 [万字总结] 一文吃透 Webpack 核心原理 webpack三部曲-带你深度解锁Webpack系列(基础篇) webpack三部曲带-你深度解锁Webpack系列(进阶篇) webpack三部曲-带你深度解锁Webpack系列(优化篇) 浅谈webpack性能优化 记一次真实的Webpack优化经历 17项关于webpack的性能优化 Webpack之SplitChunks插件用法详解 webpack 4 Code Splitting 的 splitChunks 配置探索 webpack优化之玩转代码分割和公共代码提取","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"React入门","slug":"D_框架_React入门","date":"2023-03-10T23:33:16.000Z","updated":"2024-03-17T23:08:57.416Z","comments":true,"path":"2023/03/11/D_框架_React入门/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/11/D_%E6%A1%86%E6%9E%B6_React%E5%85%A5%E9%97%A8/","excerpt":"","text":"大纲 尚硅谷React教程 React18+TS 通用后台管理系统解决方案落地实战-video-mk React16.4 开发简书项目 从零基础入门到实战(欢乐购旧版)-video-mk 2023 React18 系统入门 进阶实战《欢乐购》-video-mk 全栈萧晨 scrimba 的互动式 React 教程 React入门12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // OH的右边的内容就是JSX的语法：类似XML的js的扩展语法 // 需要这么写，不然就会报错，需要告诉babel需要转哪些，只需要在script标签写type=&quot;text/babel&quot;就可以了） let oH = &lt;div id=&#x27;xx&#x27;&gt;hello react!&lt;/div&gt;; // ReactDOM.render(要渲染什么内容，渲染到哪里) // 只有用了这个才会创建虚拟DOM，先创建再更新 ReactDOM.render(oH, document.querySelector(&quot;#app&quot;));&lt;/script&gt; 基本语法规则 遇到&lt;&gt;开头的代码，以标签的语法解析 遇到{}开头的代码，以js的语法解析 渲染虚拟dom 使用纯JS方式创建 使用JSX方式创建 1234// 使用纯JS方式创建let oH = React.createElement(&#x27;h1&#x27;,&#123;id:&#x27;xx&#x27;&#125;,&#x27;hello react!&#x27;)// 使用JSX方式创建&#x27;let oH = &lt;div id=&#x27;xx&#x27;&gt;hello react!&lt;/div&gt;; 声明组件的两种方式 类组件-&gt;函数组件就好像vue2-&gt;vue3进化过程一样 类组件 函数组件及react-hooks 123456789101112131415161718192021222324252627282930313233343536373839// 类组件 class App extends React.Component&#123; // 方式1：需要使用到props传值继承时 constructor(props)&#123; super(props) console.log(props) this.state=&#123; flag:false &#125; &#125; // 方式2：不需要props传值 // state=&#123; // flag:false // &#125; handleClick=()=&gt; &#123; debugger const &#123;flag&#125; =this.state this.setState(&#123; flag:!flag &#125;) &#125; render()&#123; const &#123;flag&#125; = this.state const msg = flag?&#x27;a&#x27;:&#x27;b&#x27; return( &lt;div&gt; &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&lt;/h1&gt; &#123;msg&#125; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;App name=&quot;test&quot;/&gt;, document.querySelector(&quot;#app&quot;)); // 函数组件及react-hooks，要求：函数名首字母大写，div根节点只能有一个。function App()&#123; return (&lt;div&gt;这是函数组件&lt;/div&gt;) &#125;ReactDOM.render(&lt;App/&gt;, document.querySelector(&quot;#app&quot;)); 用了Vue-两天学会React(实战)组件传值vue 1234567891011// 父组件&lt;GoodsList v-if=&quot;!isGoodsIdShow&quot; :goodsList=&quot;goodsList&quot;/&gt;// 子组件 -- 通过props获取即可props: &#123; goodsList:&#123; type:Array, default:function()&#123; return [] &#125; &#125; &#125; react 1234567891011121314151617181920212223242526272829303132// 父组件export default function tab(props:any) &#123; const [serverUrl, setServerUrl] = useState&lt;string | undefined&gt;(&#x27;https://&#x27;); console.log(props); // 父组件接收子组件的值并修改 const changeMsg = (msg?:string) =&gt; &#123; setServerUrl(msg); &#125;; return( &lt;View className=&#x27;tab&#x27;&gt; &lt;View className=&#x27;box&#x27;&gt; &lt;TabName msg=&#123;serverUrl&#125; changeMsg=&#123;changeMsg&#125; /&gt; &lt;/View&gt; &lt;/View&gt; )&#125;// 子组件function TabName(props)&#123; console.log(&#x27;props&#x27;,props); // 子传父 const handleClick = (msg:string) =&gt; &#123; props.changeMsg(msg); &#125;; return ( &lt;View&gt; &lt;Text&gt;&#123;props.msg&#125;&lt;/Text&gt; &lt;Button onClick=&#123;()=&gt;&#123;handleClick(&#x27;77777&#x27;)&#125;&#125;&gt;测试&lt;/Button&gt; &lt;/View&gt; );&#125;; 获取DOMvue 1this.$refs[&#x27;ref&#x27;] react 12345678910111213141516// 声明ref const domRef = useRef&lt;HTMLInputElement&gt;(null);// 通过点击事件选择input框const handleBtnClick = ()=&gt; &#123; domRef.current?.focus(); console.log(domRef,&#x27;domRef&#x27;)&#125;return( &lt;View className=&#x27;home&#x27;&gt; &lt;View className=&#x27;box&#x27;&gt; &lt;Input ref=&#123;domRef&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;handleBtnClick&#125;&gt;增加&lt;/button&gt; &lt;/View&gt; &lt;/View&gt; ) 列表渲染vue 123&lt;div v-for=&quot;(item, index) in mealList&quot; :key=&quot;index&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/div&gt; react 123456789101112131415161718192021222324//声明对象类型 type Coordinates = &#123; name:string, age:number &#125;; // 对象 let [userState, setUserState] = useState&lt;Coordinates&gt;(&#123; name: &#x27;John&#x27;, age: 30 &#125;); // 数组 let [list, setList] = useState&lt;Coordinates[]&gt;([&#123; name: &#x27;李四&#x27;, age: 30 &#125;]);// 如果你的 =&gt; 后面跟了一对花括号 &#123; ，那你必须使用 return 来指定返回值！const listItem = list.map((oi)=&gt;&#123; return &lt;View key=&#123;oi.age&#125;&gt;&#123;oi.name&#125;&lt;/View&gt; &#125;);return ( &#123; list.map((oi)=&gt;&#123; return &lt;Text className=&#x27;main-list-title&#x27; key=&#123;oi.age&#125;&gt;&#123;oi.name&#125;&lt;/Text&gt; &#125;) &#125; &lt;View&gt;&#123; listItem &#125;&lt;/View&gt; &lt;/View&gt; ) 条件渲染react 1234567891011render() &#123; const &#123; showBgView, bgType, lang, showView, industryList &#125; = this.state return ( &lt;div className=&#x27;change-product-pop&#x27;&gt; &#123; showView ? ( &lt;div className=&#x27;change-product-pop-list&#x27;&gt; ):[] &#125; &lt;/div&gt; ) 计算属性vue 12345computed: &#123; userinfo() &#123; return this.$store.state.userinfo; &#125;, &#125;, react 1234567const [serverUrl, setServerUrl] = useState(&#x27;https://localhost:1234&#x27;);let [age, setAge] = useState(2);const name = useMemo(() =&gt; &#123; return serverUrl + &quot; &quot; + age;&#125;, [serverUrl]);console.log(name) // https://localhost:1234 2 监听器vue 123456watch: &#123; // 保证自定义菜单始终显示在页面中 customContextmenuTop(top) &#123; ...相关操作 &#125; &#125;, react 123456789101112131415161718192021222324import &#123; useEffect, useState &#125; from &#x27;react&#x27;;export default function home() &#123; const [serverUrl, setServerUrl] = useState(&#x27;https://localhost:1234&#x27;); const [age, setAge] = useState(2); /** * useEffect第二个参数中所传递的值才会进行根据值的变化而出发; * 如果没有穿值的话,就不会监听数据变化 */ useEffect(()=&gt;&#123; if (age !== 5) &#123; setAge(++age) &#125; &#125;,[age]) useEffect(()=&gt;&#123; if(serverUrl !== &#x27;w3c&#x27;) &#123; setServerUrl(&#x27;w3c&#x27;); &#125; &#125;,[serverUrl]) return(78)&#125;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"大话数据结构","slug":"E_数据结构_大话数据结构","date":"2023-03-10T23:33:16.000Z","updated":"2023-03-11T11:10:54.360Z","comments":true,"path":"2023/03/11/E_数据结构_大话数据结构/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/11/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"基本概念和术语 数据：描述客观事物，能被计算机识别的符号合集 数据元素：组成数据的基本单位 数据项：数据的分割的最小基本单位 数据对象：性质相同的数据元素的集合 数据结构：相互之间存在一种或多种关系的数据元素的集合 数据结构分为逻辑结构和物理结构 逻辑结构：数据元素之间的关系(集合结构、线性结构、树形结构、图形结构) 物理结构：数据元素在计算机中存储形式(顺序存储、链式存储) 算法算法是描述解决问题的方法 算法的五个基本特性： 输入 输出 有穷性：有限的步骤 确定性：相同的输入对应唯一输出结果 可行性：每一步都可以通过有限次步骤完成 算法设计的要求： 正确性 可读性：便于阅读、理解、交流 健壮性：对于非法输入，也能处理 时间短存储低 常见时间复杂度 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 通常，默认运行时间都是按照最坏情况执行。 线性表定义：零个或多个数据元素的有限序列。 线性表的顺序存储 优点：快速查询，元素之间的逻辑关系无需额外空间 缺点：插入和删除需要移动元素，扩容问题 线性表的链式存储-单链表","categories":[{"name":"E_数据结构","slug":"E-数据结构","permalink":"https://fuyunjinglong.github.io/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"金三银四突击","slug":"AA_面试_金三银四突击","date":"2023-03-06T22:33:16.000Z","updated":"2024-10-11T13:50:49.781Z","comments":true,"path":"2023/03/07/AA_面试_金三银四突击/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/07/AA_%E9%9D%A2%E8%AF%95_%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%E7%AA%81%E5%87%BB/","excerpt":"","text":"interview 2024年前端简历（node.js，ts,react，Flutter、Rn，微前端，低代码，小程序，移动端） 2022前端面试题，p7/35 项目实战汇总-小程序 JavaScript专项-还在头疼 vue2源码:PC本地-Vue2.js源码全方位深入解析-黄轶-第1章 准备工作(2-6) vue3源码:PC本地-催学社-Vue3源码实战课 JS数据结构与算法-video-p38_19 Java数据结构与算法-video或PC本地-03-算法数据结构体系学习班-p0 react入门 移动端 小程序 1.项目经历 1.1企业格局之策略制定 项目亮点：打飞机-UI和业务逻辑分离大崔哥 video 1.2需求力竞争PMT 项目亮点：手写vue3源码之pnpm实现monorepo包管理 video 项目亮点：手写vue2源码之rollup打包 video 1.3客户关注 项目亮点：定制化修改elementui源码适配场景 2.环境搭建-vue3+vite+ts(大崔哥) video web前端导航 印记中文 前站导航 程序员盒子 前端工程化 前端工程化 H5 为什么利用多个域名来存储网站资源会更有效 ？ iframe 内嵌框架缺点 html语义化是什么 CSS 对 reflow 和 repaint 的理解 盒子模型 页面样式导入link 和 @import 区别 常见兼容性问题？ 清除浮动 如何保持水平垂直居中 ？ position 、float 和 display 的取值意思 CSS 常用3种引入方式 CSS 选择符有哪些 ？哪些属性可以继承 ？优先级？ CSS3 有哪些新特性 ? 对BFC规范的理解 canvas 与 svg 的区别 ？ rem、em、px、vh 与 vw 的区别 ？ 伪类与伪元素 flex=1代表什么 JS 彻底搞懂this(看题给结果) 消息队列和事件循环(看题给结果) 闭包(看题给结果) 原型、原型链、继承(看题给结果) 浏览器内核的理解 null 和 undefined JS的8种继承方案 实现 add(1)(2)(3) = 6 垃圾回收 内存泄露 JS 判断变量是对象还是数组 JS类型判断—typeof, constructor, instanceof, toString 常见六大Web安全攻防解析 async和defer的作用是什么？有什么区别 模块化规范 事件冒泡和事件捕获 JS异步编程六大方案 函数式编程 必会20道JS-手写数据双向绑定 必会20道JS-手写call/apply/bind 必会20道JS-手写instanceof 必会20道JS-手写Object.create 必会20道JS-手写new操作符 必会20道JS-手写Promise 必会20道JS-手写深浅拷贝 必会20道JS-手写setTimeout模拟setInterval 必会20道JS-手写一种原型式继承和构造函数继承 必会20道JS-手写-EventBus发布订阅 必会20道JS-手写简单路由 必会20道JS-手写rem实现原理 必会20道JS-手写实现拖拽 必会20道JS-手写防抖和节流 ES6 for 循环中的 var 、let 与 const 区别(看题给结果) ES5和ES6之默认值的区别？ ES5和ES6之继承的区别？ Promise是什么 Generator函数是什么 async函数是什么 axios取消请求 for in、for of、forEach的比较 框架-基础 权限认证 权限控制 框架-vue2 如何理解双向绑定 如何理解数据响应式 computed和watch区别 父子组件生命周期钩子函数执行顺序 在哪个生命周期内调用异步请求？ 谈谈对keep-alive的理解 谈谈对vuex的理解 Vue模板编译流程(编译器原理) router路由hash和history原理 router路由-懒加载 Vue-router导航守卫有哪些 vm.$set()如何解决对象属性新增问题 vue2.x中如何监测数组变化 nextTick实现原理 性能优化-Vue Vue2.x组件通信方式 v-for和v-if为什么不能连用 组件中的data为什么是一个函数？ 如何理解vue的单向数据流 Virtual-DOM虚拟DOM Virtual-DOM-diff算法 框架-vue3 Vue2和Vue3的diff算法对比 计算机网络 HTTP-常见的状态码 一文读懂 HTTP/1、HTTP/2、HTTP/3 彻底搞懂Https RPC是什么？ webSocket是什么？ TCP是什么？ TCP为什么是三次握手？四次挥手？ TCP 与 UDP 的区别 Http缓存原理 cookies，sessionStorage 和 localStorage 的区别 Cookie的实现原理 应用缓存-manifest即HTML5的离线缓存 工程热点 性能优化-webpack-loader机制 数据结构与算法 数据结构_左神 数据结构_JavaScript 性能优化 性能优化总策略 从输入url到渲染完成整个过程 React 必须要会的 50 道 React 面试题","categories":[{"name":"AA_面试","slug":"AA-面试","permalink":"https://fuyunjinglong.github.io/categories/AA-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"前端学习大纲","slug":"AA_面试_前端学习大纲","date":"2023-03-06T22:33:16.000Z","updated":"2024-03-31T03:26:25.626Z","comments":true,"path":"2023/03/07/AA_面试_前端学习大纲/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/07/AA_%E9%9D%A2%E8%AF%95_%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"不懂就问 印记中文 前站导航 程序员盒子 编码规范华为云前端编码规范 Airbnb JavaScript 风格指南 第一阶段：HTML+CSS学习前要求：基本的计算机操作能力，比如浏览网页、查资料等，以及坚持学习的决心和恒心。学习后将掌握：可以使用HTML和CSS制作静态网页。 HTML 大纲 HTML5与CSS3基础教程（第8版）.pdf CSS 大纲 CSS世界.pdf CSS揭秘.pdf ES6-10语法 大纲 ECMAScript6入门-阮一峰.pdf 深入理解ES6 第二阶段：JavaScript学习前要求：熟练应用HTML和CSS。学习后将掌握：前端开发最核心的技能JavaScript，以及jQuery和Ajax。 JavaScript 大纲 《JavaScript Dom编程艺术》 《JavaScript权威指南》- (犀牛书) JavaScript高级程序设计（第3版）.pdf- (红宝书) 你不知道的JavaScript（上中下卷）.pdf 现代javascript教程（在线） 《JavaScript函数式编程》 《JavaScript面向对象编程》 jQuery 《jQuery实战（第2版）》 随着 JavaScript 语言的不断发展，也出现了许多新的 JavaScript 框架，如 React、Angular 和 Vue。这些框架在功能和性能方面都有了一定的优势，正在逐渐取代 jQuery。 那么，2023年 jQuery 还有必要学吗？答案是肯定的。 对于初学者来说，jQuery 是一个很好的入门工具。jQuery 的语法简单易懂，可以帮助初学者快速掌握 JavaScript 的基础知识。 对于大型项目来说，jQuery 仍然是一个不错的选择。jQuery 的 API 简单易用，可以帮助开发者快速开发出复杂的功能。 对于老旧项目来说，jQuery 仍然是一个必不可少的工具。jQuery 可以帮助开发者维护和升级老旧的 jQuery 项目。 以下是一些建议： 如果是初学者，可以先从 jQuery 入手，掌握 JavaScript 的基础知识。 如果是经验丰富的开发者，可以了解一下 React、Angular 和 Vue 等新框架。 对于大型项目或老旧项目，可以使用 jQuery 来开发新功能，并使用新框架来重构旧代码。 第三阶段：开发工具学习前要求：能够熟练应用HTML、CSS、JavaScript开发具有交互效果的网页。学习后将掌握：前端开发团队协作常用的版本控制工具SVN、Git，以及项目构建工具Webpack的使用方法。 Git快速上手 大纲 Git教程 《Pro Git中文版》 《GitHub入门与实践》 Git教程 - 廖雪峰 自动化构建工具 Webpack 大纲 《webpack指南》 《深入浅出Webpack》 未来构件化工具vite 大纲 Vite官网 Vite介绍及实现原理&lt;超详细、纯干货！&gt; 第四阶段：前端框架学习前要求：能够熟练应用HTML、CSS、JavaScript开发具有交互效果的网页。学习后将掌握：Vue.js、React、AngularJS三大神器，以及响应式框架Bootstrap，让你的前端开发工作如有神助！ Vue.js 大纲-D_框架_Vue2.0_入门 大纲-D_框架_Vue3.0_入门 Vue2官网 Vue3官网 《Vue.js 实战》 《Vue.js项目实战》 《Vue.js 3实战入门》 《Vue.js 3权威指南》 《Vue.js 3实战开发》 《Vue.js 3应用开发与核心源码解析》 React.js 大纲 React 入门实例教程-阮一峰 一看就懂的ReactJs入门教程（精华版 Angular.jsTypeScript 大纲 第五阶段：移动及服务端开发学习前要求：PC端的前端开发技能已经炉火纯青。学习后将掌握：基于移动设备的Web前端开发技能，以及Node.js服务器端开发技能。 Node.js 大纲 《深入浅出node.js》 《Node.js实战》 《Node学习指南》 跨端APPFlutter、React Native、UniApp 大纲 小程序WXML原生、UniApp、taro支持vue 大纲 微信公众号 大纲 低代码Microsoft Power Apps、Mendix、OutSystems、Bubble、Appian 大纲 微前端single-spa、qiankun、Piral、Mosaic、 大纲 第六阶段：融会贯通源码解读 源码_Vue2.0 源码_Vue3.0 Vue.js源码全方位深入解析-video-黄轶 Vue.js 3.0 核心源码-video-黄轶 ElementUI源码解析-樱满空-video Element-UI 源码简析-崇序员 性能优化 大纲 Web性能权威指南.pdf 数据结构与算法 数据结构_左神 数据结构_JavaScript 设计模式 大纲 [Head First JavaScript程序设计.pdf](https://github.com/fuyunjinglong/awesome-books/blob/master/前端/Head First JavaScript程序设计.pdf) JavaScript设计模式与开发实践.pdf","categories":[{"name":"AA_面试","slug":"AA-面试","permalink":"https://fuyunjinglong.github.io/categories/AA-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"华为技术","slug":"Z_业务和面经_华为技术","date":"2023-03-04T23:33:16.000Z","updated":"2023-06-04T13:42:19.540Z","comments":true,"path":"2023/03/05/Z_业务和面经_华为技术/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/05/Z_%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F_%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF/","excerpt":"","text":"华为术语版本生命周期策略GA到EOS,一般GA-&gt;EOM-&gt;EOP-&gt;EOFS-&gt;EOS过程。 1，GA：发布，通用可获得性； 2，EOM：停止销售即停止接单，End of Marketing； 单板/部件EOM：停止接受单板、部件订单（包括新建订单、扩容和备件订单）；产品EOM：停止接受该产品的订单（包括新建订单和扩容订单）；版本EOM：停止接受该软件版本的订单（包括新建订单和扩容订单）； 3，EOP：停止生产，End of Production； 4，EOFS：停止全面支持，End of Full Support,对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复。 单板/部件EOFS: 该点之后对客户提供单板/部件服务标准降低，在EOFS日之后，备件维修服务不为客户提供修复保证，只解决Critical 和 Major 级别的问题；版本EOFS：对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复； 5，EOS：停止服务和支持，End of Service and Support，不再提供针对该软件版本的服务支持，只能通过升级新版本来解决问题。 单板/部件EOS：指从该日起可不再提供该单板/部件任何服务；产品EOS：从该日起不再提供该产品任何服务，包括电话支持；版本EOS：不再提供任何技术服务支持，包含新问题的定位和缺陷修复； 在EOFS、EOS阶段出补丁需要通过例外备案、审批。 通信技术1-5G的发展历程1G上世纪80年代，电话开始普及使用，人们仅仅使用的是模拟、仅限语音的蜂窝电话标准，被称为“第一代移动通讯技术”，也叫“1G”，代表设备是大哥大，只能打电话。 2GGSM和CDMA 人们在传输数据的过程中发现，太大的数据信息很难在传播过程中消耗的时间太多了，欧洲人聪明，把时间分割成了周期性的帧（Frame），每个帧再分割成若干个时隙向基站发送信号，这种技术叫做时分多址（TDMA），基于这个技术，欧洲人研制出了第二代通讯技术，也叫“GSM（Global System For Mobile Communications）”，俗称2G 到了20世纪中期，当时二代通讯技术已经使用一段时间了，一位美国女子名叫海蒂·拉玛（她还是著名的影视演员）基于时分多址发明了新的通讯技术：码分多址（CDMA），和时分多址有区别的是，它是靠信息的编码序列来分割成若干个码隙向基站发送信号，被称为2.5代移动通讯技术。 来到中国，移动及当时的网通选择了主流的GSM网络制程，而电信则成为唯一一家支持CDMA制程的通讯公司。一个是分割时间，一个是分割编码 3GPP组织网络制程的全球普及，使人们越来越依赖于“无线上网”，理念是：为了定义完整的端到端系统规范，确保符合行业需求，不同厂商之间实现无缝互操作以及为移动提供其所必需的全球规模，并且也为了实现GSM由2G网络到3G网络的平滑过渡的需求，从而产生了一个组织，如果将全球无线通讯比作一个村的话，那么这个组织绝对是这个村里的村长，它让你“耕什么地”你就得耕什么地，它让你的“庄稼”长多高你的庄稼必须长那么高，否则对不起，你不属于这代通讯技术的标准，这个组织就是3GPP。（注意，3GPP是实现GSM演进成立的。） 3GPP建立时，各国都在讨论谁当“老大”合适，当老大爽啊，有话语权，但是，每一代移动通讯技术的革新并不是某个体公司能完成的，它要设计到基站的建设、匹配制程的芯片制造、从中的技术研发、采用怎样的频率，运用多少的波段等等，毕竟关乎全球用户无线上网的问题，最后商量了下，全球各国几个在通讯领域有重要地位或作用的运营商，来做3GPP的成员，先后足足请了七个大佬 日本无线工业及商贸联合会（ARIB） 中国通信标准化协会（CCSA） 美国电信行业解决方案联盟（ATIS） 日本电信技术委员会（TTC） 欧洲电信标准协会（ETSI） 印度电信标准开发协会（TSDSI） 韩国电信技术协会（TTA） 3G在3GPP的带动下实现了第三代移动通讯技术（3G）的W-CDMA技术、TD-CDMA技术的普及化。 4G3GPP是为了实现欧洲人创造的GSM的演化，那个美国美女演员创造的CDMA能善罢甘休？不行，我们北美也要创立一个！第二年1999年，北美公司联合芯片巨头高通等创立了个3GPP2，和3GPP有一定的竞争关系，只不过后来高通又放弃了CDMA向4G演进的路线，3GPP2也逐渐边缘化. 到了LTE（Long Term Evolution，长期演进），也就是4G，各大运营商开发出了TD-LTE和FDD-LTE两种制程，“村长”3GPP出来了，说你们这个制程不满足我的标准，LTE只有3.9G，你们不叫4G，这让运营商很尴尬，最后四舍五入，3.9G就叫4G吧！就一直按4G叫了，其实未被3GPP认可，国内的4G网只是3GPP的3.9G的标准。 后来运营商无奈，按照3GPP对于4G的标准推出了升级版的LTE Advanced，这才满足国际电信联盟对4G的要求，直到后来的LTE-A才叫做4G。 5G对于未来的第五代通讯技术（俗称5G），3GPP提前好打预防针，告诉底下和无线网络相关的公司，说你们必须按照我的要求制定5G，要不然我还是不承认。底下公司齐声说“啥要求啊？”3GPP说，5G必须要提高速率和降低时延，并规定，5G网络传输速率至少需符合100Mbps下载速度、50Mbps上传速度，网路延迟时间不得超过4毫秒，并且在时速500公里的高速列车上也能维持稳定网络连接。 定义了三大场景：eMBB、mMTC和URLLC，对应了想要涉及的领域。 3GPP将“5G”视为是一个重大的改革，要具备五大创新！ 第一大创新：mmWave 提到网络速率，必定和频率、波长、以及光速三者有关，它们的关系是这样的： 5G的第一个创新技术就来了，率先使用目前波段较小的mmWave（毫米波），就目前的动态来看，毫米波段中28GHz频段和60GHz频段比较有希望使用在5G的两个频段中，使用毫米波频段，频谱带宽比较前代要宽了10倍，传输速率自然也得到大幅度提升。 第二大创新：Massive MIMO MIMO的英文全称是Multiple-Input Multiple-Output，意为“多进多出”，说白了就是基站的天线变多了，并且手机的接受能力也变强了，源头上多根天线发送，接收对象****多根天线接受。 第三大创新：Beam Management Beam Management意为波束赋形，也是第五代移动通讯技术的一大创新，它主要是改变了信号的发射形式进行的改变。说到基站发射信号的形式，有些类似于灯泡发光，它是360度向四面八方发射的，对于光而言，要想照亮某个区域或某处物体，大部分散发出去的光都浪费了。 而波束赋形就比较厉害了，它是一种基于天线阵列的信号预处理技术，通过调整天线阵列中的每个阵元的加权系数产生具有指向性的波束，通俗的将，它可以改变信号的发射轨迹，实现“点对点”有针对的信号传播。 第四大创新：LDPC/Polar 前面说过，3GPP对应想要涉及的领域，定义了5G的三大场景：eMBB、mMTC和URLLC。 2017年11月下旬，华为公司主推的Polar Code（极化码）方案拿下5G，作为控制信道的编码方案，这个方案便是3PGG制定的三个场景之一的eMBB场景，而高通主导的LDPC码作为数据信道的编码方案。 根据华为的实际测试来看，Polar码可以同时满足超高速率、低时延、大连接场景的需求，并且能够使蜂窝网络的频谱提升10%左右，与毫米波结合可以达到27Gbps的速率 第五大创新：AS Layer AS Layer是相比较4G网络的一种新型的架构模式，主要是以正交频分多任务（OFDM）为基础的弹性参数物理层（PHY，Layer 1），它可以最多包含5个次载波。该架构可以同时回应更快速的数据与响应速度。 5G标准无线三次发展浪潮 2G:语音 3G、4G:无线宽带 5G:超级全连接世界(eMBB大宽带 + uRLLC低时延 + mMTC海量连接) 5G标准进展 R15基础版本：201712NSA和201806SA独立组网 R16基础版本：IMT-2020这才是5G官方名称即冻结最终版 产业链进展 2018CPE设备-&gt;2019手机终端 应用场景 uRLLC超高可靠性低时延连接业务：无人机、远程医疗、紧急服务、自动驾驶 mMTC大物联业务：智慧城市、智慧农业、工业控制、物流 eMBB增强移动贷款业务：VR、移动办公、家庭宽带、游戏 5G关键技术切片即服务 频谱 无线通信关键是频谱，有个规定：频率越低，覆盖距离越远。频率越高，容量越大。 所以采用C-band作为5G全球协同频谱，兼顾了容量和覆盖。 组网结构 NSA非独立组网：4G的eNB和5G的gNB共同组网 SA独立组网：全部gNB组网 NR上下行通道解耦 采用上行3.5G,下行1.8G低频段，增强上行覆盖，降低建网成本 CloudRAN 架构 即无线云化，包括中心化、云化、协同化，就像阿里云，设备上云，降低成本，以后只需要一个射频就可以，其他都在云服务 产品型态演进 本质就是云化 4G:EPC核心网+BBU(基带板、主控板)+RRU 5G:NGC核心网+CU(云化的bbu)+DU(本地bbu)+AAU 空口技术 空口技术-空分复用 以前是时分复用GSM、码分复用WCDMA、时频LTE、再到现在的空分NR即空间上复用 空口技术 - Beamforming原理 即波束原理，强+强=强，弱+弱=弱，强+弱=弱，使用BF后，根据手机等设备的相位，动态调整天线的发射频率和相位，使信号增强。 Qosflow支持差异化应用 支持同级自动检测Qos 5G语音解决方案 目前还是采用4G的VoLTE方案(IMS),将来可能基于IMS+SA，这也是5G的弱项。 5G组网技术5G网络整体架构演进 现阶段-小规模NR部署：LTE+NR双连接。Option3，Option3x,Option3a(逐渐被淘汰，因为是核心网控制4geNB和5gNB)，都属于NSA Option3:EPC核心网-&gt;LTE eNB-&gt;gNB Option3x:EPC核心网-&gt;gNB-&gt;LTE eNB Option3a:EPC核心网-&gt;gNB和EPC核心网-&gt;LTE eNB 未来-NGC部署：eLTE+NB双连接。NSA的Option7和Option7a。SA的Option4和Option4a。 Option7:新NC核心网-&gt;升级后的eLTE eNB-&gt;gNB Option4:新NC核心网-&gt;gNB-&gt;升级后的eLTE eNB 终极目标-NR连续覆盖，直连NGC：SA的Option2 NC-&gt;gNB-&gt;端，路途非常长，因为运营商需要将4g设备全部替换成5g 5G产品介绍产品组网方案 终端:CPE(3.5g)设备或TUE终端(4g+5g设备),例如手机 天线：新的方案是AAU+RRU即天线和射频放一起，如64T64R，64个发送通道64个接收通道，设备分开连线非常复杂。老方案是分开的。 射频：RRU和CPRI BBU:机框，包括主控板基带板 传输和时钟：传输带宽 核心网：新增核心网PLMN 网管：新RAN网管，后续将核心网和网管统一云化，到云端部署使用 产品版本 一、原型机polestar，原型机CPE峰值速率1.4G，只能做单点演示 二、商用版本18B：1、使用TUE终端，峰值速率2.8G2、使用商用CPE，峰值速率750M 三、商用版本19A：使用商用CPE，峰值速率1G（850M 5G+150M LTE） 华为产品路标 2018以前 2018 2019 2020 站点形态 64T64R，45kg 32T32R 16TR 网络演进 NSA 上下行解耦 SA SA 频段 C-Band 高频毫米波 室分 VoNR 场景 FWA固定网络 VR/AR uRLLC/mMTC 5G交付关键点 站点准备 规划优化 自动化集成 站点准备 主要涉及三大困境：天面受限、电源紧张、空间不足。 天面受限：站点承重不足，安装位置不够。方案：新增抱杆，合并抱杆，更换全新A+P天线 电源紧张：5g供电是4g设备的3倍。方案：存量站点5G电源叠加包，PowerCube电源搬迁，智能锂电BoostLi 空间不足：电源柜空间不足等。方案： 规划优化 挑战一5GMM网规网优复杂：Massive MIMO，由4g的单双流传输到5g的8流波束传输。 挑战二5G缺少手持路测终端：现在测试设备是整车小面包车，如5g的TUE终端设备 自动化集成 无线、承载网、核心网都缺乏测试工具，截止2018年 5G is On5G的三大问题一是澄清关于5G的一些技术事实； 二是回答5G到底能干啥，运营商怎么把钱赚回来； 三是回答5G网络到底怎么建设，用谁的设备去建设。 5G的七大误区 误区一：5G的功耗比4G大幅增加 误区二：部署5G需要大幅度改造现网电源 误区三：5G Massive MIMO AAU相比传统天线+RRU重量大幅增加 误区四：部署5G一定要部署切片，没有切片就不是真正的5G 误区五：5G当前就能使能各垂直行业的数字化，能解决所有问题 误区六：5G是不安全的 误区七：O/xRAN也能做5G。 真相一：5G基站功耗和4G典型站点功耗相当,大约2000w，5G每Mbps能耗成本更低为1.7w/Mbps，相当于4G的10%。 真相二：可通过对现网电源扩容PSU或增加刀片电源来满足5G需求。供电系统一般为：交流配电部分+AC/DC电源柜+DCDU直流配电(RRU/AAU+BBU)。 真相三：5G的AAU与传统天线+RRU重量基本相当，甚至更轻。 真相四：标准和商用版本短时间内不能支持uRLLC和mMTC切片；中短期来看，FWA和eMBB应用是运营商最现实的选择。 真相五：当前聚焦eMBB在行业的应用，按节奏和产业进度逐步使能行业。 真相六：5G架构基于4G，全球4G网络近十年的运行经验证明4G安全可靠，同时5G进一步加强了用户信息保护机制。 真相七：小厂商标准节奏落后，现网白盒化难度高，短期来看，小厂商较活跃，但路标靠后，规模供货困难。 5G的应用发展细分为3个阶段：一是更好的体验（20192020）；二是更好的生活（20212022）；三是更公平高效安全的社会(2022~)。 长期来看，5G可以在数字沟通、数字天空、数字娱乐、智能制造等发挥价值。但目前主要聚焦在eMBB和FWA可以使能的业务上，其中VR为主要场景。 目前华为是业界唯一一个可以提供5G端到端设备的厂家。面向5G的端到端解决方案，我们有业界最强的芯片、设备和极简网络架构，所以面向运营商的网络部署，我们可以做到最快、性能最好、网络可靠性最高。 韩国三大运营商：SKT，KT,LGU+ 日本三大运营商：Decomo,KDDI,SoftBank 欧洲主要运营商：DT.Germany,EE.UK,3UK,Vodafone,Orange","categories":[{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"TypeScript入门","slug":"D_框架_TypeScript入门","date":"2023-03-01T23:33:16.000Z","updated":"2024-06-02T01:43:37.632Z","comments":true,"path":"2023/03/02/D_框架_TypeScript入门/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/02/D_%E6%A1%86%E6%9E%B6_TypeScript%E5%85%A5%E9%97%A8/","excerpt":"","text":"大纲 TS 学习指南1.8w字/轻松学 TypeScript-Video/20 道 TS 练习题–阿宝哥 TypeScript 全面进阶指南-video 专为小白设计的TypeScript入门课-video-mk TS从入门到深度掌握，晋级TypeScript高手-video TypeScript 类型体操通关秘籍-video ts类型体操 为什么你非常不适应 TypeScript前言在群里看到一些问题和言论：为什么你们这么喜欢“类型体操”？为什么我根本学不下去 TypeScript？我最讨厌那些做类型体操的了；为什么我学了没过多久马上又忘了？ 有感于这些问题，我想从最简单的一个角度来切入介绍一下 TypeScript，并向大家介绍并不是只要是个类型运算就是体操。并在文中介绍一种基本思想作为你使用类型系统的基本指引。 引子我将从一个相对简单的 API 的设计过程中阐述关于类型的故事。在这里我们可以假设我们现在是一个工具的开发者，然后我们需要设计一个 API 用于从对象中拿取指定的一些 key 作为一个新的对象返回给外面使用。 垃圾 TypeScript一个人说：我才不用什么破类型，我写代码就是要没有类型，我就是要随心所欲的写。然后写下了这段代码。 123typescriptdeclare function pick(target: any, ...keys: any): any 他的用户默默的写下了这段代码： 123typescriptpick(undefined, &#x27;a&#x27;, 1).b 写完运行，发现问题大条了，控制台一堆报错，接口数据也提交不上去了，怎么办呢？ 刚学 TypeScript一个人说：稍微检查一下传入类型就好了，别让人给我乱传参数就行。 123typescriptdeclare function pick(target: Record&lt;string, unknown&gt;, ...keys: string[]): unknown 很好，上面的问题便不复存在了，API 也是基本可用的了。但是！当对象复杂的时候，以及字段并不是短单词长度的时候就会发现了一个没解决的问题。 123typescriptpick(&#123; abcdefghijkl: &#x27;123&#x27; &#125;, &#x27;abcdefghikjl&#x27;) 从肉眼角度上，我们很难发现这前后的不一致，所以我们为什么要让调用方的用户自己去 check 自己的字段有没有写对呢？ 不就 TypeScript一个人说：这还不简单，用个泛型加 keyof 不就行了。 123typescriptdeclare function pick&lt; T extends Record&lt;string, unknown&gt;&gt;(target: T, ...keys: (keyof T)[]): unknown 我们又进一步解决的上面的问题，但是！还是有着相似的问题，虽然我们不用检查 keys 是不是传入的是一个正确的值了，但是我们实际上对返回的值也存在一个类似的问题。 123typescriptpick(&#123; abcdefghijkl: &#x27;123&#x27; &#125;, &#x27;abcdefghijkl&#x27;).abcdefghikjl 一点小小的拓展 在这里我们看起来似乎是一个很简单的功能，但实际上蕴含着一个比较重要的信息。 为什么我们之前的方式都拿不到用户传入进来的类型信息呢？是有原因的，当我们设计的 API 的时候，前面的角度是从，如何校验类型方向进行的思考。 而这里是尝试去通过约定好的一种规则，通过 TypeScript 的隐式类型推断获得到传入的类型，再通过约定的规则转化出一种新的类型约束来对用户的输入进行限制。 算算 TypeScript一个人说：好办，算出来一个新的类型就好了。 123456typescriptdeclare function pick&lt; T extends Record&lt;string, unknown&gt;, Keys extends keyof T&gt;(target: T, ...keys: Keys[]): &#123; [K in Keys]: T[K]&#125; 到这里已经是对类型的作用有了基础的了解了，能写出来符合开发者所能接受的类型相对友好的代码了。我们可以再来思考一些更特殊的情况： 12typescript// 输入了重复的 keypick(&#123; a: &#x27;&#x27; &#125;, &#x27;a&#x27;, &#x27;a&#x27;) 完美 TypeScript到这里，我们便是初步开始了类型“体操”。但是在本篇里，我们不去分析它。 12345678910111213141516171819202122typescriptexport type L2T&lt;L, LAlias = L, LAlias2 = L&gt; = [L] extends [never] ? [] : L extends infer LItem ? [LItem?, ...L2T&lt;Exclude&lt;LAlias2, LItem&gt;, LAlias&gt;] : neverdeclare function pick&lt; T extends Record&lt;string, unknown&gt;, Keys extends L2T&lt;keyof T&gt;&gt;(target: T, ...keys: Keys): Pick&lt;T, Keys[number] &amp; keyof T&gt;const x0 = pick(&#123; a: &#x27;1&#x27;, b: &#x27;2&#x27; &#125;, &#x27;a&#x27;)console.log(x0.a)// @ts-expect-errorconsole.log(x0.b)const x1 = pick(&#123; a: &#x27;1&#x27;, b: &#x27;2&#x27; &#125;, &#x27;a&#x27;, &#x27;a&#x27;)// ^^^^^^^^// TS2345: Argument of type &#x27;[&quot;a&quot;, &quot;a&quot;]&#x27; is not assignable to parameter of type &#x27;[&quot;a&quot;?, &quot;b&quot;?] | [&quot;b&quot;?, &quot;a&quot;?]&#x27;.// Type &#x27;[&quot;a&quot;, &quot;a&quot;]&#x27; is not assignable to type &#x27;[&quot;a&quot;?, &quot;b&quot;?]&#x27;.// Type at position 1 in source is not compatible with type at position 1 in target.// Type &#x27;&quot;a&quot;&#x27; is not assignable to type &#x27;&quot;b&quot;&#x27;. 一个相对来说比较完美的 pick 函数便完成了。 总结我们再来回到我们的标题吧，从我对大多数人的观察来说，很多的人开始来使用 TypeScript 有几种原因： 看到大佬们都在玩，所以自己也想来“玩”，然后为了过类型校验而去写 看到一些成熟的项目在使用 TypeScript ，想参与贡献，参与过程中为了让类型通过而想办法去解决类型报错 公司整体技术栈采用的是 TypeScript ，要用 TypeScript 进行业务编写，从而为了过类型检查和 review 而去解决类型问题 诸如此类的问题还有很多，我将这种都划分为「为了解决类型检查的问题」而进行的类型编程，这也是大多数人为什么非常不适应 TypeScript，甚至不喜欢他的一个原因。这其实对学习 TypeScript 并不是一个很好的思路，在这里我觉得我们需要站在设计者的角度去对类型系统进行思考。我觉得有以下几个角度： 类型检查到位 类型提示友好 类型检查严格 扩展性十足 我们如果站在这几个角度对我们的 API 进行设计，我们可以发现，开发者能够很轻松的将他们需要的代码编写出来，而尽量不用去翻阅文档，查找 example。 希望通过我的这篇分享，大家能对 TypeScript 多一些理解，并参与到生态中来，守护我们的 JavaScript。 入门初识 TypeScript TypeScript 的介绍 TypeScript 是一种由微软开发的开源、跨平台的编程语言。它是 JavaScript 的超集，最终会被编译为 JavaScript 代码。 2012 年 10 月，微软发布了首个公开版本的 TypeScript，2013 年 6 月 19 日，在经历了一个预览版之后微软正式发布了正式版 TypeScript TypeScript 的作者是安德斯·海尔斯伯格，C#的首席架构师。它是开源和跨平台的编程语言。 TypeScript 扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以运行在 TypeScript 环境中。 TypeScript 是为大型应用的开发而设计，并且可以编译为 JavaScript。 TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6+ 的支持**，它由 Microsoft 开发，代码开源于 GitHub 上 TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6+ 的支持，它由 Microsoft 开发，代码开源于 GitHub 上 TypeScript 的特点 TypeScript 主要有 3 大特点： 始于 JavaScript，归于 JavaScript TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的 JavaScript 引擎中。 强大的类型系统 类型系统允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。 先进的 JavaScript TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。 总结 TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。 安装 TypeScript命令行运行如下命令，全局安装 TypeScript： 1npm install -g typescript 安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)： 1tsc -V 第一个 TypeScript 程序编写 TS 程序 src/helloworld.ts 1234567function greeter(person) &#123; return &#x27;Hello, &#x27; + person&#125;let user = &#x27;Yee&#x27;console.log(greeter(user)) 手动编译代码 我们使用了 .ts 扩展名，但是这段代码仅仅是 JavaScript 而已。 在命令行上，运行 TypeScript 编译器： 1tsc helloworld.ts 输出结果为一个 helloworld.js 文件，它包含了和输入文件中相同的 JavsScript 代码。 在命令行上，通过 Node.js 运行这段代码： 1node helloworld.js 控制台输出： 1Hello, Yee vscode 自动编译 1). 生成配置文件tsconfig.json tsc --init 2). 修改tsconfig.json配置 &quot;outDir&quot;: &quot;./js&quot;, &quot;strict&quot;: false, 3). 启动监视任务: 终端 -&gt; 运行任务 -&gt; 监视tsconfig.json 类型注解 接下来让我们看看 TypeScript 工具带来的高级功能。 给 person 函数的参数添加 : string 类型注解，如下： 1234567function greeter(person: string) &#123; return &#x27;Hello, &#x27; + person&#125;let user = &#x27;Yee&#x27;console.log(greeter(user)) TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组： 1234567function greeter(person: string) &#123; return &#x27;Hello, &#x27; + person&#125;let user = [0, 1, 2]console.log(greeter(user)) 重新编译，你会看到产生了一个错误： 1error TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;. 类似地，尝试删除 greeter 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript 提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。 接口 让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 firstName 和 lastName 字段的对象。 在 TypeScript 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。 123456789101112131415interface Person &#123; firstName: string lastName: string&#125;function greeter(person: Person) &#123; return &#x27;Hello, &#x27; + person.firstName + &#x27; &#x27; + person.lastName&#125;let user = &#123; firstName: &#x27;Yee&#x27;, lastName: &#x27;Huang&#x27;&#125;console.log(greeter(user)) 类 最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。 让我们创建一个 User 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。 还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。 123456789101112131415161718192021222324class User &#123; fullName: string firstName: string lastName: string constructor(firstName: string, lastName: string) &#123; this.firstName = firstName this.lastName = lastName this.fullName = firstName + &#x27; &#x27; + lastName &#125;&#125;interface Person &#123; firstName: string lastName: string&#125;function greeter(person: Person) &#123; return &#x27;Hello, &#x27; + person.firstName + &#x27; &#x27; + person.lastName&#125;let user = new User(&#x27;Yee&#x27;, &#x27;Huang&#x27;)console.log(greeter(user)) 重新运行 tsc greeter.ts，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 JavaScript 函数的实现。 使用 webpack 打包 TS下载依赖 12345678# 2021年2月8日yarn add -D typescriptyarn add -D webpack webpack-cliyarn add -D webpack-dev-serveryarn add -D html-webpack-plugin clean-webpack-pluginyarn add -D ts-loaderyarn add -D cross-env 入口 JS: src/main.ts 123// import &#x27;./01_helloworld&#x27;document.write(&#x27;Hello Webpack TS!&#x27;) index 页面: public/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;webpack &amp; TS&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; build/webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const path = require(&#x27;path&#x27;)const isProd = process.env.NODE_ENV === &#x27;production&#x27; // 是否生产环境function resolve(dir) &#123; return path.resolve(__dirname, &#x27;..&#x27;, dir)&#125;module.exports = &#123; mode: isProd ? &#x27;production&#x27; : &#x27;development&#x27;, entry: &#123; app: &#x27;./src/main.ts&#x27; &#125;, output: &#123; path: resolve(&#x27;dist&#x27;), filename: &#x27;[name].[contenthash:8].js&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, use: &#x27;ts-loader&#x27;, include: [resolve(&#x27;src&#x27;)] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(&#123;&#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; &#125;) ], resolve: &#123; extensions: [&#x27;.ts&#x27;, &#x27;.tsx&#x27;, &#x27;.js&#x27;] &#125;, devtool: isProd ? &#x27;cheap-module-source-map&#x27; : &#x27;eval-cheap-source-map&#x27;, devServer: &#123; host: &#x27;localhost&#x27;, // 主机名 stats: &#x27;errors-only&#x27;, // 打包日志输出输出错误信息 port: 8081, open: true &#125;&#125; 配置打包命令 12&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack serve --config build/webpack.config.js&quot;,&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot; 运行与打包 12yarn devyarn build TypeScript 常用语法基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值 最基本的数据类型就是简单的 true/false 值，在 JavaScript 和 TypeScript 里叫做 boolean（其它语言中也一样）。 123let isDone: boolean = falseisDone = true// isDone = 2 // error 数字 和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 1234let a1: number = 10 // 十进制let a2: number = 0b1010 // 二进制let a3: number = 0o12 // 八进制let a4: number = 0xa // 十六进制 字符串 JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（&quot;）或单引号（&#39;）表示字符串。 12345let name: string = &#x27;tom&#x27;name = &#x27;jack&#x27;// name = 12 // errorlet age: number = 12const info = `My name is $&#123;name&#125;, I am $&#123;age&#125; years old!` undefined 和 null TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 它们的本身的类型用处不是很大： 12let u: undefined = undefinedlet n: null = null 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 数组 TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： 1let list1: number[] = [1, 2, 3] 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： 1let list2: Array&lt;number&gt; = [1, 2, 3] 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 123let t1: [string, number]t1 = [&#x27;hello&#x27;, 10] // OKt1 = [10, &#x27;hello&#x27;] // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(t1[0].substring(1)) // OKconsole.log(t1[1].substring(1)) // Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法 枚举 enum 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。 12345678910enum Color &#123; Red, Green, Blue&#125;// 枚举数值默认从0开始依次递增// 根据特定的名称得到对应的枚举数值let myColor: Color = Color.Green // 0console.log(myColor, Color.Red, Color.Blue) 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： 123456enum Color &#123; Red = 1, Green, Blue&#125;let c: Color = Color.Green 或者，全部都采用手动赋值： 123456enum Color &#123; Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字： 12345678enum Color &#123; Red = 1, Green, Blue&#125;let colorName: string = Color[2]console.log(colorName) // &#x27;Green&#x27; any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： 123let notSure: any = 4notSure = &#x27;maybe a string&#x27;notSure = false // 也可以是个 boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let list: any[] = [1, true, &#x27;free&#x27;]list[1] = 100 void 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1234567/* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */function fn(): void &#123; console.log(&#x27;fn()&#x27;) // return undefined // return null // return 1 // error&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null： 1let unusable: void = undefined object object 表示非原始类型，也就是除 number，string，boolean之外的类型。 使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如： 123456789function fn2(obj: object): object &#123; console.log(&#x27;fn2()&#x27;, obj) return &#123;&#125; // return undefined // return null&#125;console.log(fn2(new String(&#x27;abc&#x27;)))// console.log(fn2(&#x27;abc&#x27;) // errorconsole.log(fn2(String)) 联合类型 联合类型（Union Types）表示取值可以为多种类型中的一种需求 1: 定义一个一个函数得到一个数字或字符串值的字符串形式值 123function toString2(x: number | string): string &#123; return x.toString()&#125; 需求 2: 定义一个一个函数得到一个数字或字符串值的长度 12345678910function getLength(x: number | string) &#123; // return x.length // error if (x.length) &#123; // error return x.length &#125; else &#123; return x.toString().length &#125;&#125; 类型断言 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法 12345678910111213141516/*类型断言(Type Assertion): 可以用来手动指定一个值的类型语法: 方式一: &lt;类型&gt;值 方式二: 值 as 类型 tsx中只能用这种方式*//* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */function getLength(x: number | string) &#123; if ((&lt;string&gt;x).length) &#123; return (x as string).length &#125; else &#123; return x.toString().length &#125;&#125;console.log(getLength(&#x27;abcd&#x27;), getLength(1234)) 类型推断 类型推断: TS 会在没有明确的指定类型的时候推测出一个类型有下面 2 种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为 any 类型 12345678/* 定义变量时赋值了, 推断为对应的类型 */let b9 = 123 // number// b9 = &#x27;abc&#x27; // error/* 定义变量时没有赋值, 推断为any类型 */let b10 // any类型b10 = 123b10 = &#x27;abc&#x27; 接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述) 接口初探 需求: 创建人的对象, 需要对人的属性进行一定的约束 1234id是number类型, 必须有, 只读的name是string类型, 必须有age是number类型, 必须有sex是string类型, 可以没有 下面通过一个简单示例来观察接口是如何工作的： 12345678910111213141516171819202122232425262728293031/*在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型接口: 是对象的状态(属性)和行为(方法)的抽象(描述)接口类型的对象 多了或者少了属性是不允许的 可选属性: ? 只读属性: readonly*//*需求: 创建人的对象, 需要对人的属性进行一定的约束 id是number类型, 必须有, 只读的 name是string类型, 必须有 age是number类型, 必须有 sex是string类型, 可以没有*/// 定义人的接口interface IPerson &#123; id: number name: string age: number sex: string&#125;const person1: IPerson = &#123; id: 1, name: &#x27;tom&#x27;, age: 20, sex: &#x27;男&#x27;&#125; 类型检查器会查看对象内部的属性是否与 IPerson 接口描述一致, 如果不一致就会提示类型错误。 可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 123456interface IPerson &#123; id: number name: string age: number sex?: string&#125; 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 123456const person2: IPerson = &#123; id: 1, name: &#x27;tom&#x27;, age: 20 // sex: &#x27;男&#x27; // 可以没有&#125; 只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性: 123456interface IPerson &#123; readonly id: number name: string age: number sex?: string&#125; 一旦赋值后再也不能被改变了。 12345678const person2: IPerson = &#123; id: 2, name: &#x27;tom&#x27;, age: 20 // sex: &#x27;男&#x27; // 可以没有 // xxx: 12 // error 没有在接口中定义, 不能有&#125;person2.id = 2 // error readonly vs const 最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。 函数类型 接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 1234567/*接口可以描述函数类型(参数的类型与返回的类型)*/interface SearchFunc &#123; (source: string, subString: string): boolean&#125; 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345const mySearch: SearchFunc = function(source: string, sub: string): boolean &#123; return source.search(sub) &gt; -1&#125;console.log(mySearch(&#x27;abcd&#x27;, &#x27;bc&#x27;)) 类类型 类实现接口 与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。 1234567891011121314151617181920/*类类型: 实现接口1. 一个类可以实现多个接口2. 一个接口可以继承多个接口*/interface Alarm &#123; alert(): any&#125;interface Light &#123; lightOn(): void lightOff(): void&#125;class Car implements Alarm &#123; alert() &#123; console.log(&#x27;Car alert&#x27;) &#125;&#125; 一个类可以实现多个接口 1234567891011class Car2 implements Alarm, Light &#123; alert() &#123; console.log(&#x27;Car alert&#x27;) &#125; lightOn() &#123; console.log(&#x27;Car light on&#x27;) &#125; lightOff() &#123; console.log(&#x27;Car light off&#x27;) &#125;&#125; 接口继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1interface LightableAlarm extends Alarm, Light &#123;&#125; 类对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。 基本示例 下面看一个使用类的例子： 1234567891011121314151617181920212223/*类的基本定义与使用*/class Greeter &#123; // 声明属性 message: string // 构造方法 constructor(message: string) &#123; this.message = message &#125; // 一般方法 greet(): string &#123; return &#x27;Hello &#x27; + this.message &#125;&#125;// 创建类的实例const greeter = new Greeter(&#x27;world&#x27;)// 调用实例的方法console.log(greeter.greet()) 如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 Greeter 类。这个类有 3 个成员：一个叫做 message 的属性，一个构造函数和一个 greet 方法。 你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。 后面一行，我们使用 new 构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。 最后一行通过 greeter 对象调用其 greet 方法 继承 在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 看下面的例子： 12345678910111213141516171819/*类的继承*/class Animal &#123; run(distance: number) &#123; console.log(`Animal run $&#123;distance&#125;m`) &#125;&#125;class Dog extends Animal &#123; cry() &#123; console.log(&#x27;wang! wang!&#x27;) &#125;&#125;const dog = new Dog()dog.cry()dog.run(100) // 可以调用从父中继承得到的方法 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Dog 是一个 派生类，它派生自 Animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。 因为 Dog 继承了 Animal 的功能，因此我们可以创建一个 Dog 的实例，它能够 cry() 和 run()。 下面我们来看个更加复杂的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Animal &#123; name: string constructor(name: string) &#123; this.name = name &#125; run(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; // 调用父类型构造方法 super(name) &#125; // 重写父类型的方法 run(distance: number = 5) &#123; console.log(&#x27;sliding...&#x27;) super.run(distance) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; // 调用父类型构造方法 super(name) &#125; // 重写父类型的方法 run(distance: number = 50) &#123; console.log(&#x27;dashing...&#x27;) // 调用父类型的一般方法 super.run(distance) &#125; xxx() &#123; console.log(&#x27;xxx()&#x27;) &#125;&#125;const snake = new Snake(&#x27;sn&#x27;)snake.run()const horse = new Horse(&#x27;ho&#x27;)horse.run()// 父类型引用指向子类型的实例 ==&gt; 多态const tom: Animal = new Horse(&#x27;ho22&#x27;)tom.run()/* 如果子类型没有扩展的方法, 可以让子类型引用指向父类型的实例 */const tom3: Snake = new Animal(&#x27;tom3&#x27;)tom3.run()/* 如果子类型有扩展的方法, 不能让子类型引用指向父类型的实例 */// const tom2: Horse = new Animal(&#x27;tom2&#x27;)// tom2.run() 这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal 的两个子类：Horse 和 Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 run 方法，它们重写了从 Animal 继承来的 run 方法，使得 run 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.run(34) 时，它会调用 Horse 里重写的方法。 1234sliding...sn run 5mdashing...ho run 50m 公共，私有与受保护的修饰符 默认为 public 在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，C# 要求必须明确地使用 public 指定成员是可见的。 在 TypeScript 里，成员都默认为 public。 你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal 类： 理解 private 当成员被标记成 private 时，它就不能在声明它的类的外部访问。 理解 protected protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*访问修饰符: 用来描述类内部的属性/方法的可访问性 public: 默认值, 公开的外部也可以访问 private: 只能类内部可以访问 protected: 类内部和子类可以访问*/class Animal &#123; public name: string public constructor(name: string) &#123; this.name = name &#125; public run(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`) &#125;&#125;class Person extends Animal &#123; private age: number = 18 protected sex: string = &#x27;男&#x27; run(distance: number = 5) &#123; console.log(&#x27;Person jumping...&#x27;) super.run(distance) &#125;&#125;class Student extends Person &#123; run(distance: number = 6) &#123; console.log(&#x27;Student jumping...&#x27;) console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // 子类看不到父类中私有的成员 super.run(distance) &#125;&#125;console.log(new Person(&#x27;abc&#x27;).name) // 公开的可见// console.log(new Person(&#x27;abc&#x27;).sex) // 受保护的不可见// console.log(new Person(&#x27;abc&#x27;).age) // 私有的不可见 readonly 修饰符 你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 123456789class Person &#123; readonly name: string = &#x27;abc&#x27; constructor(name: string) &#123; this.name = name &#125;&#125;let john = new Person(&#x27;John&#x27;)// john.name = &#x27;peter&#x27; // error 参数属性 在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性： 123456class Person2 &#123; constructor(readonly name: string) &#123;&#125;&#125;const p = new Person2(&#x27;jack&#x27;)console.log(p.name) 注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。 存取器 TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。 12345678910111213141516171819202122class Person &#123; firstName: string = &#x27;A&#x27; lastName: string = &#x27;B&#x27; get fullName() &#123; return this.firstName + &#x27;-&#x27; + this.lastName &#125; set fullName(value) &#123; const names = value.split(&#x27;-&#x27;) this.firstName = names[0] this.lastName = names[1] &#125;&#125;const p = new Person()console.log(p.fullName)p.firstName = &#x27;C&#x27;p.lastName = &#x27;D&#x27;console.log(p.fullName)p.fullName = &#x27;E-F&#x27;console.log(p.firstName, p.lastName) 静态属性 到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 Grid.xxx 来访问静态属性。 123456789101112/*静态属性, 是类对象的属性非静态属性, 是类的实例对象的属性*/class Person &#123; name1: string = &#x27;A&#x27; static name2: string = &#x27;B&#x27;&#125;console.log(Person.name2)console.log(new Person().name1) 抽象类 抽象类做为其它派生类的基类使用。 它们不能被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。 1234567891011121314151617181920212223/*抽象类 不能创建实例对象, 只有实现类才能创建实例 可以包含未实现的抽象方法*/abstract class Animal &#123; abstract cry() run() &#123; console.log(&#x27;run()&#x27;) &#125;&#125;class Dog extends Animal &#123; cry() &#123; console.log(&#x27; Dog cry()&#x27;) &#125;&#125;const dog = new Dog()dog.cry()dog.run() 函数函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。 基本示例 和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。 通过下面的例子可以迅速回想起这两种 JavaScript 中的函数： 123456789// 命名函数function add(x, y) &#123; return x + y&#125;// 匿名函数let myAdd = function(x, y) &#123; return x + y&#125; 函数类型 为函数定义类型 让我们为上面那个函数添加类型： 1234567function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function(x: number, y: number): number &#123; return x + y&#125; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。 书写完整函数类型 现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。 123let myAdd2: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y&#125; 可选参数和默认参数 TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。 JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的： 在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把firstName 的默认值设置为 &quot;A&quot;。 1234567891011function buildName(firstName: string = &#x27;A&#x27;, lastName?: string): string &#123; if (lastName) &#123; return firstName + &#x27;-&#x27; + lastName &#125; else &#123; return firstName &#125;&#125;console.log(buildName(&#x27;C&#x27;, &#x27;D&#x27;))console.log(buildName(&#x27;C&#x27;))console.log(buildName()) 剩余参数 必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。 在 TypeScript 里，你可以把所有参数收集到一个变量里：剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。 1234function info(x: string, ...args: string[]) &#123; console.log(x, args)&#125;info(&#x27;abc&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) 函数重载 函数重载: 函数名相同, 而形参不同的多个函数在 JS 中, 由于弱类型的特点和形参与实参可以不匹配, 是没有函数重载这一说的但在 TS 中, 与其它面向对象的语言(如 Java)就存在此语法 12345678910111213141516171819202122/*函数重载: 函数名相同, 而形参不同的多个函数需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加*/// 重载函数声明function add(x: string, y: string): stringfunction add(x: number, y: number): number// 定义函数实现function add(x: string | number, y: string | number): string | number &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y if (typeof x === &#x27;string&#x27; &amp;&amp; typeof y === &#x27;string&#x27;) &#123; return x + y &#125; else if (typeof x === &#x27;number&#x27; &amp;&amp; typeof y === &#x27;number&#x27;) &#123; return x + y &#125;&#125;console.log(add(1, 2))console.log(add(&#x27;a&#x27;, &#x27;b&#x27;))// console.log(add(1, &#x27;a&#x27;)) // error 泛型指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。 引入 下面创建一个函数, 实现功能: 根据指定的数量 count 和数据 value , 创建一个包含 count 个 value 的数组不用泛型的话，这个函数可能是下面这样： 1234567891011function createArray(value: any, count: number): any[] &#123; const arr: any[] = [] for (let index = 0; index &lt; count; index++) &#123; arr.push(value) &#125; return arr&#125;const arr1 = createArray(11, 3)const arr2 = createArray(&#x27;aa&#x27;, 3)console.log(arr1[0].toFixed(), arr2[0].split(&#x27;&#x27;)) 使用函数泛型 12345678910111213function createArray2&lt;T&gt;(value: T, count: number) &#123; const arr: Array&lt;T&gt; = [] for (let index = 0; index &lt; count; index++) &#123; arr.push(value) &#125; return arr&#125;const arr3 = createArray2&lt;number&gt;(11, 3)console.log(arr3[0].toFixed())// console.log(arr3[0].split(&#x27;&#x27;)) // errorconst arr4 = createArray2&lt;string&gt;(&#x27;aa&#x27;, 3)console.log(arr4[0].split(&#x27;&#x27;))// console.log(arr4[0].toFixed()) // error 多个泛型参数的函数 一个函数可以定义多个泛型参数 12345function swap&lt;K, V&gt;(a: K, b: V): [K, V] &#123; return [a, b]&#125;const result = swap&lt;string, number&gt;(&#x27;abc&#x27;, 123)console.log(result[0].length, result[1].toFixed()) 泛型接口 在定义接口时, 为接口中的属性或方法定义泛型类型在使用接口时, 再指定具体的泛型类型 1234567891011121314151617181920212223242526272829303132333435interface IbaseCRUD&lt;T&gt; &#123; data: T[] add: (t: T) =&gt; void getById: (id: number) =&gt; T&#125;class User &#123; id?: number //id主键自增 name: string //姓名 age: number //年龄 constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;class UserCRUD implements IbaseCRUD&lt;User&gt; &#123; data: User[] = [] add(user: User): void &#123; user = &#123; ...user, id: Date.now() &#125; this.data.push(user) console.log(&#x27;保存user&#x27;, user.id) &#125; getById(id: number): User &#123; return this.data.find(item =&gt; item.id === id) &#125;&#125;const userCRUD = new UserCRUD()userCRUD.add(new User(&#x27;tom&#x27;, 12))userCRUD.add(new User(&#x27;tom2&#x27;, 13))console.log(userCRUD.data) 泛型类 在定义类时, 为类中的属性或方法定义泛型类型在创建类的实例时, 再指定特定的泛型类型 12345678910111213141516171819class GenericNumber&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;()myGenericNumber.zeroValue = 0myGenericNumber.add = function(x, y) &#123; return x + y&#125;let myGenericString = new GenericNumber&lt;string&gt;()myGenericString.zeroValue = &#x27;abc&#x27;myGenericString.add = function(x, y) &#123; return x + y&#125;console.log(myGenericString.add(myGenericString.zeroValue, &#x27;test&#x27;))console.log(myGenericNumber.add(myGenericNumber.zeroValue, 12)) 泛型约束 如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性 1234// 没有泛型约束function fn&lt;T&gt;(x: T): void &#123; // console.log(x.length) // error&#125; 我们可以使用泛型约束来实现 12345678interface Lengthwise &#123; length: number&#125;// 指定泛型约束function fn2&lt;T extends Lengthwise&gt;(x: T): void &#123; console.log(x.length)&#125; 我们需要传入符合约束类型的值，必须包含必须 length 属性： 12fn2(&#x27;abc&#x27;)// fn2(123) // error number没有length属性 其它声明文件 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能 什么是声明语句 假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 &lt;script&gt; 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。 但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西 12345678910/*当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。声明语句: 如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码 declare var jQuery: (selector: string) =&gt; any;声明文件: 把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件下载声明文件: npm install @types/jquery --save-dev*/jQuery(&#x27;#foo&#x27;)// ERROR: Cannot find name &#x27;jQuery&#x27;. 这时，我们需要使用 declare var 来定义它的类型 123declare var jQuery: (selector: string) =&gt; anyjQuery(&#x27;#foo&#x27;) declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是： 1jQuery(&#x27;#foo&#x27;) 一般声明文件都会单独写成一个 xxx.d.ts 文件 创建 01_jQuery.d.ts, 将声明语句定义其中, TS 编译器会扫描并加载项目中所有的 TS 声明文件 1declare var jQuery: (selector: string) =&gt; any 很多的第三方库都定义了对应的声明文件库, 库文件名一般为 @types/xxx, 可以在 https://www.npmjs.com/package/package 进行搜索 有的第三库在下载时就会自动下载对应的声明文件库(比如: webpack),有的可能需要单独下载(比如 jQuery/react) 内置对象 JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 ECMAScript 的内置对象 BooleanNumberStringDateRegExpError 123456789/* 1. ECMAScript 的内置对象 */let b: Boolean = new Boolean(1)let n: Number = new Number(true)let s: String = new String(&#x27;abc&#x27;)let d: Date = new Date()let r: RegExp = /^1/let e: Error = new Error(&#x27;error message&#x27;)b = true// let bb: boolean = new Boolean(2) // error BOM 和 DOM 的内置对象 WindowDocumentHTMLElementDocumentFragmentEventNodeList 123456const div: HTMLElement = document.getElementById(&#x27;test&#x27;)const divs: NodeList = document.querySelectorAll(&#x27;div&#x27;)document.addEventListener(&#x27;click&#x27;, (event: MouseEvent) =&gt; &#123; console.dir(event.target)&#125;)const fragment: DocumentFragment = document.createDocumentFragment() TS类型体操 TS类型体操1 TS类型体操2 进阶interface和type什么区别一句话：能用 interface 实现，就用 interface , 如果不能就用 type 。 相同点： 都可以描述一个对象或者函数 都允许拓展（extends） 1.描述对象或函数 123456789101112131415interface User &#123; name: string age: number&#125; interface SetUser &#123; (name: string, age: number): void;&#125;type User = &#123; name: string age: number&#125;; type SetUser = (name: string, age: number): void; 2.都允许拓展（extends） interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。 1234567891011121314151617181920212223242526272829// interface extends interfaceinterface Name &#123; name: string; &#125;interface User extends Name &#123; age: number; &#125;// type extends typetype Name = &#123; name: string; &#125;type User = Name &amp; &#123; age: number &#125;;// interface extends typetype Name = &#123; name: string; &#125;interface User extends Name &#123; age: number; &#125;// type extends interfaceinterface Name &#123; name: string; &#125;type User = Name &amp; &#123; age: number; &#125; 不同点： type 可以而 interface 不行 type 可以声明基本类型别名，联合类型，元组等类型 type 语句中还可以使用 typeof 获取实例的 类型进行赋值 interface 可以而type 不行 interface 能够声明合并 1.type 可以而 interface 不行 1234567891011121314151617// 基本类型别名type Name = string // 联合类型interface Dog &#123; wong();&#125;interface Cat &#123; miao();&#125;type Pet = Dog | Cat// 具体定义数组每个位置的类型type PetList = [Dog, Pet] // 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement(&#x27;div&#x27;);type B = typeof div 2.interface 可以而type 不行 12345678910111213141516interface User &#123; name: string age: number&#125; interface User &#123; sex: string&#125; /*User 接口为 &#123; name: string age: number sex: string &#125;*/ 参考TypeScript 入门教程 深入理解 TypeScript","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"VueReactAngular比较","slug":"D_框架_VueReactAngular比较","date":"2023-02-28T23:33:16.000Z","updated":"2023-07-16T09:39:52.649Z","comments":true,"path":"2023/03/01/D_框架_VueReactAngular比较/","link":"","permalink":"https://fuyunjinglong.github.io/2023/03/01/D_%E6%A1%86%E6%9E%B6_VueReactAngular%E6%AF%94%E8%BE%83/","excerpt":"","text":"框架原理不用去在意 Vue 和 React 哪个好，这种比较没什么意义，重要的是哪个适合自己/团队，能为自己/团队实现价值。 卡颂大佬在《React 设计原理》中，提出了一个观点：现代前端框架的实现原理都可以用以下公式进行概括： UI = f(state) 其中： state —— 当前的视图的状态 f —— 框架内部的运行机制 UI —— 宿主环境的视图 如何描述 UI 前端领域经过长期发展，形成了两种主流的 UI 描述方案： JSX template JSX 是 Meta（原 Facebook）提出的一种 ECMAScript 的语法糖，增强了代码的可读性，但其实最终 JSX 在运行时会被转换成浏览器能够识别的标准 ECMAScript 语法。 template 模板的历史更加久远，它是前后端未分离的时代，已经有的产物，它扩充的是 HTML 语法。 数据驱动 框架内部运行机制的实现，可以概括为以下两个步骤： 根据 state 计算出 UI 变化，如， Vue 和 React 通过对比变化前后的 VNode，知道需要更新哪些元素 根据 UI 变化，执行具体宿主（如浏览器）的 API。 为什么需要分离成两个步骤？ 前端框架通常会抽离出一套抽象的元素操作的 API，例如：新增/删除/移动元素、修改元素属性等原子操作。不会直接操作浏览器 DOM。这样为了做到平台无关 按 state 变化后，引起框架的 UI 变更的抽象层级，作为分类依据，可以将框架分为三类： 应用级框架：数据变化 &gt; 应用变化 &gt; 比对应用 &gt; 更新元素 组件级框架：数据变化 &gt; 组件变化 &gt; 比对组件 &gt; 更新元素 元素级框架：数据变化 &gt; 元素变化 &gt; 更新元素 无论哪种路径，都是从最开始的数据变化，到最终的更新元素。只是不同框架，能够监听的变化层级不同，从而有了不同的处理 框架能够监听的层级越抽象，就需要花费更多的时间用于比对变化。例如应用级框架，需要比对整个应用前后的变化。 在我们常见的框架中： React 属于应用级框架 Vue 属于组件级框架 Svelte 属于元素级框架 前端框架用到的技术 响应式：实现了细粒度的更新，是组件级应用的一种实现 Virtual DOM：最终目的是快速找出一组 UI 元素中变化的部分，应用级和组件级框架需要使用。元素级框架由于直接指导变化的元素，因此不需要 AOT 预编译优化：使用模板的框架，能从 AOT 预编译优化中受益，因为模板的结构固定，容易分析。JSX 则难以优化，除非约束 JSX 的灵活性 响应式 这是一种自动追踪依赖的技术，它用于自动追踪依赖的状态，当状态改变时进行更新。 Virtual DOM VDOM 有以下优点： 相对于 DOM 有体积优势 多平台渲染能力 VDOM 可以多平台渲染能力，但反过来，多平台渲染能力，不一定需要 VDOM VDOM 的最终目的，其实是用于 Diff，计算出 UI 中变化的部分。但刚好又可以用于多平台渲染。 AOT 预编译优化 现在前端框架一般都有编译这一步骤，用于： 代码转换，如：ts 编译为 js，Vue 将 vue 文件转换成 js 编译优化 代码压缩、打包 编译有两个执行时机： 构建时编译（AOT，预编译） 运行时编译（JIT，即时编译） 它们的区别如下： AOT 可以提前进行编译，用户直接运行编译后的代码，可以减少首屏时间。而 JIT 则会消耗更多时间用于编译 JIT 的应用代码体积会更大，因为需要包含编译的相关逻辑 因此，在大多数情况下，我们使用 AOT 更多。不过有些框架（例如 Vue）会同时提供了 AOT 和 JIT 两种使用方式，以应对一些特殊的情况。 三大框架解析11三大框架介绍 1)angular 历史:2012开始1.0版本，16年升级2.0版本。新版本支持es6和ts。 基本特点： 双向绑定； 依赖注入； 基于ts的组件； 良好的应用架构； 工具生态完整，angular-cli用于创建、开发、测试等。有整套的解决方案，适合大型项目。 缺点：中文文档较少，框架较重，学习成本高。 2)react 历史：2013年facebook发布版本。2015年版本稳定，同年发布reacr-native。 基本特点： 虚拟dom，跨浏览器兼容，性能较好； 组件化，代码复用; JSX,js语法的扩展，模板简单、直接、语义化。 单项数据流：数据流清晰，组件状态更可控。 缺点： 本身只是view，大型项目需要加上React Router和Redux。 3)VUE 历史： 2015年1.0版本发布，同年vue-router、vuex、vue-cli出现，标志从一个视图层发展成一个渐进式框架。 2016年vue2.0发布，引入虚拟dom，性能大幅提升。 2019年vue2.0公布源码。 基本特点： 渐进式、轻量级框架; 简单易用; 双向数据绑定; 组件化; 轻量高效(使用虚拟dom，压缩后只有20kb) 缺点： vue不支持IE8，生态比较差(语法提示不友好，插件数量比较少) 2.vue和react比较 工程实践上，由于耦合性、代码组织灵活性、平滑升级、测试、重构让我们最终放弃了 Vue。在 Vue 中你操作的是定义好的对象，React 中你操作的是一个函数。所谓前端开发，本质就是在编写下面几个函数。显然，React 对此的抽象更为彻底。 123S = async(A1)S = sync(A2)UI = f(S) 相同点： (1)都使用Virtural DOM (2)都使用组件化思想，流程基本一致 (3)都是响应式，推崇单向数据流 (4)都有成熟的社区，都支持服务端渲染 Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法.不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数, Vue和React通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode diff -&gt; diff算法对比，并真正去更新真实DOM。 差异点： (1)核心思想不同 Vue早期定位是尽可能的降低前端开发的门槛，Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集和派发更新）。 React早期口号是Rethinking Best Practices。想要做的是用更好的方式去颠覆前端开发方式，推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其稳定性（无副作用即对主函数（调用者）没有附加影响）和可测试性（输入相同，输出一定相同）。 (1.1)核心思想不同导致写法差异 Vue推崇template。React推崇JSX、HOC、all in js (1.2)api差异 Vue定位简单易上手，基于template模板 + options API。比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api。 React本质上核心只有一个Virtual DOM + Diff算法，所以API非常少，知道setState就可以开发。 (1.3)社区差异 由于Vue定义简单易上手，能快速解决问题，所以很多常见的解决方案，是Vue官方主导开发和维护。比如状态管理库Vuex、路由库Vue-Router、脚手架Vue-CLI、Vutur工具等。属于那种大包大揽，遇到某类通用问题，只需要使用官方给出的解决方案即可。 React只关注底层，上层应用解决方案基本不插手。连最基础的状态管理早期也只是给出flow单向数据流思想，大部分都丢给社区去解决。比如状态管理库方面，有redux、mobx、redux-sage、dva等一大堆（选择困难症犯了），所以这也造就了React社区非常繁荣。 (1.4)未来升级方向不同 Vue依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。Vue3核心更新内容可以看到：template语法基本不变、options api只增加了setup选项（composition api）、基于依赖收集（Proxy）的数据可变。 React的函数式编程这个基本盘不会变。React核心思想，是把UI作为Basic Type，比如String、Array类型，然后经过render处理，转换为另外一个value（纯函数）。从React Hooks可以看出，React团队致力于组件函数式编程，（纯组件，无class组件），尽量减少副作用（减少this，this会引起副作用）。 (2)组件实现不同 Vue源码实现是把options挂载到Vue核心类上，然后再new Vue(&#123;options&#125;)拿到实例（vue组件的script导出的是一个挂满options的纯对象而已）。所以options api中的this指向内部Vue实例，对用户是不透明的，所以需要文档去说明this.$slot、this.$xxx这些api。 React内部实现比较简单，直接定义render函数以生成VNode，而React内部使用了四大组件类包装VNode，不同类型的VNode使用相应的组件类处理，职责划分清晰明了,用户透明。 (3)响应式原理不同 Vue2和Vue3响应式原理基本一致，都是基于依赖收集，不同的是Vue3使用Proxy. 123456Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。当数据改变时，以组件为根目录，默认全部重新渲染 (4)diff算法不同 Vue基于snabbdom库，它有较好的速度以及模块机制。Vue Diff使用双向链表，边对比，边更新DOM。 React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。 (5)事件机制不同 123456Vue原生事件使用标准Web事件Vue组件自定义事件机制，是父子组件通信基础Vue合理利用了snabbdom库的模块插件React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。React组件上无事件，父子组件通信使用props Vue与React的区别小结 vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用； props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图； 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制； 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现； vue使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板； vue多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法； Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现； react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。 react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些，比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。 react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin 三大框架解析2一、简介 angular 诞生于2009年的Angular可以算得上Web前端三大主流框架中最完整的框架，它包含模板、数据双向绑定、路由、模块化、服务、过滤器、依赖注入等所有功能。虽然出现较早，但是因为其强大的功能，至今使用热度不减。对于刚开始前端初学者来讲，AngularJS完全基于HTML和JavaScript，因此无需学习其他语法或语言。使用TypeScript能够提高代码可维护性，有利于后期重构。当然，Angular框架也不是完全没有缺点的。虽然双向数据流很方便，但是等业务复杂之后，你可能就搞不清楚数据流了。还有令人不开心的脏值检查，以及directive的封装并没有解决视图与数据关系完全分离的问题，有时候还要用$digist强制触发检测，当然，因为其由Google主导，小伙伴们还是不要选择了，毕竟Angular能搞定的，Vue也是完全能够胜任的。 React React是一个开源的JavaScript库，由Facebook和一个大型开发者社区共同维护。广泛用于开发web应用程序的用户界面。React框架的主要功能是对DOM操作，声明式设计，更快的开发出Web应用系统。使用React框架，可以非常轻松地创建用户交互界面，为应用的每一个状态设计简洁的视图。甚至在数据改变时，React也可以高效地更新渲染界面。虽然React框架本身比较容易理解，结构很清晰，就是由十几个API组成，然后异步渲染。但是很多人反映上手还是有一定的的难度的。React是单向数据流，代码写起来会较双向数据流的多一些，但是同样的排查问题时思路清晰很多。 Vue Vue框架的最大优势就是简单易上手，同时它也是目前Web前端开发的最常使用的主流框架。Vue.js是用于构建交互式的Web 界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。从技术上讲， Vue.js集中在MVVM模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的DOM操作和输出格式被抽象出来成指令和过滤器。所以相比其它的MVVM框架，Vue.js更容易上手。而且它能够开发单页面应用程序，还可以用作Web应用程序框架。Vue框架最大的优势就是能够在没有任何动作的情况下重新渲染，而且允许我们在需要时随时添加组件。 二、React详解 概述 React（有时叫React.js或ReactJS），是一个为数据提供渲染为HTML视图的开源JavaScript 库。React视图通常采用包含以自定义HTML标记规定的其他组件的组件渲染。React为程序员提供了一种子组件不能直接影响外层组件（”data flows down”）的模型，数据改变时对HTML文档的有效更新，和现代单页应用中组件之间干净的分离。它由Facebook、Instagram和一个由个人开发者和企业组成的社群维护。 Fiber架构 Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的”虚拟 DOM”。一个 fiber 就是一个 JavaScript 对象，Fiber 的数据结构如下： Fiber 如何解决问题的 Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个”执行单元”，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。 Fiber 实现原理 实现的方式是requestIdleCallback这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。React 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性 Fiber 架构核心 Fiber 架构可以分为三层： Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler Reconciler 协调器 —— 负责找出变化的组件 Renderer 渲染器 —— 负责将变化的组件渲染到页面上在新的架构模式下，工作流如下： 每个更新任务都会被赋予一个优先级。 当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层； 此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。 当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。Fiber 架构的核心即是”可中断”、”可恢复”、”优先级”。 Scheduler 调度器这个需要上面提到的requestIdleCallback，React 团队实现了功能更完备的 requestIdleCallback polyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。 Reconciler 协调器在 React 15 中是递归处理虚拟 DOM 的，React 16 则是变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间 React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？在 React 16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上的标记。 整个Scheduler与Reconciler的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。 三、Vue详解 1.Vue生命周期 Vue 主要实现了以下几个阶段： 组件初始化，包括事件初始化、数据初始化、依赖注入初始化等； 模板编译，即把 HTML 模板转化为可以被 Vue 利用的渲染函数，其中包括了虚拟 DOM 的概念； DOM 挂载与更新，即把渲染函数的返回值映射为真实的 DOM ，复用或创建新的 DOM 节点； 组件销毁，包括为了实现响应式而挂载的监听器、事件监听器等。 2.响应式原理 为了实现无侵入的响应式数据，Vue 使用了设计模式中的代理模式，在 2.x 系列借助 ES 5 对象方法 Object.defineProperty 对原始数据进行代理，在 3.x 系列中则使用 ES 6 Proxy 对象进行代理。ES 5 对象方法要求 ES 5 支持，因此 Vue 2.x 不支持 IE 8 以下的版本。ES 6 Proxy 要求 ES 6 支持，因此 Vue 3.x 无法支持 IE 11 。下文我们以目前广泛使用的 Vue 2.x 版本为例讲解数据响应式原理。其中 Object.defineProperty 只能代理属性的 set/get 方法，而 ES 6 Proxy 可以代理 defineProperty/deleteProperty 等方法，能够更全面地代理数据的增删改查，规避了原来使用 Object.defineProperty 无法捕捉的情况。这也是为什么 Vue 3 使用 ES 6 Proxy 的原因。 对象 Vue无法检测对象属性的添加或移除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。 对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。 1Vue.set(vm.someObject, &#x27;b&#x27;, 2) 这行语句的原理是虽然修改的是 b 属性的值，但是触发 someObject 的更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 1this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 数组 在 JS 中，数组可以看作是一类特殊的对象，因此，对于数组而言 Vue 2.x不能检测以下数组的变动：当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue；当你修改数组的长度时，例如：vm.items.length = newLength； 但是数组新增元素的情况要比对象新增属性常用得多，因此有必要解决数组无法响应新增属性的问题。为此，Vue 把数组的方法都代理了，调用数组方法相当于 *Vue.set(…)*。因此，用数组的方法也可以使数组保持响应的。例如： 1vm.items.splice(newLength) 依赖收集 依赖收集主要依赖两个数据结构实现，分别是 Dep 和 Watcher ，Watcher 封装观察者的信息，而 Dep 封装了依赖队列。每个响应式属性都有一个 Dep 维护其 Watcher 队列，当数据变化时逐个调用 Dep 队列中封装的 Watcher 实现视图更新。其过程大致是渲染函数初始化 Watcher ，把重新渲染作为 Watcher 的回调，触发具体渲染，如果获取了响应式数据，则在 getter 里把 Watcher 收集到对应的 Dep 中。当事件触发了响应式数据更新，则在其 setter 里通知 Dep 中的 Watcher 触发视图更新。读者在此处可能会对如何收集 Watcher 有疑问，毕竟 Watcher 和 getter 分别在两个过程中定义的，两者如何关联起来？答案是用了全局变量 Dep.target 在模块内形成了一个闭包。因此，如果页面上引用了两个 Vue （最常见的情况是创建库的时候把 Vue 打包进去了），响应式属性是无法在两个 Vue 中共享的，可能会造成难以定位的问题。 响应时机 由于 JS 是一个单线程的执行环境，也就是说每次只能执行一件事，意味着执行 JS 和更新 DOM 只能选一样执行。每次响应式属性变更时，如果都直接触发界面更新，那么在一个函数里对响应式数据进行大量更新时，就会出现“DOM 更新 - JS 执行 - DOM 更新…”的循环，如果 JS 执行较慢，就会出现卡顿，这显然不是我们想要的。因此，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的，在下一章虚拟 DOM 的时候会详细讲述。然后，在下一个的事件循环（在 JS 的术语里称为“tick”）中，Vue 刷新队列并执行实际（已去重的）工作。值得注意的是，Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替，本质上是希望利用事件队列中的微任务在逻辑后进行视图更新。 3.模板编译 渲染函数 一般在使用 Vue 的时候都会使用 Vue 单文件组件里的 HTML 模板或者直接使用挂载元素的 HTML 模板，HTML 模板为视图提供了一种比 JS 代码更友好的表达形式。但是 Vue 的模板并不是完全是 HTML ，因为 HTML 本身不支持定义自定义组件，缺少这种扩展的机制，Vue 设计了一个编译器，输入通过类似的 HTML 的语法，输出为一个输出到虚拟 DOM 的函数，这个过程称为渲染，这个函数就是渲染函数。 渲染函数采用了构造器的设计模式，通过传入一个构建 VNode 的构造函数，开发者可以层次化地构建出虚拟 DOM 树。例如： 123456789101112131415&#123; render: function (createElement) &#123; return createElement(&#x27;div&#x27;, [ createElement(&#x27;child&#x27;, &#123; // 在数据对象中传递 `scopedSlots` // 格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement(&#x27;span&#x27;, props.text) &#125; &#125; &#125;) ]) &#125;&#125; 以上函数对应为 HTML 模板： 12345&lt;div&gt; &lt;child v-slot=&quot;props&quot;&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/child&gt;&lt;/div&gt; 可以看到渲染函数实际上比 HTML 模板复杂而且不直观，但是它是驱动 Vue 模板优化的基本原理。 虚拟DOM 实际上，虚拟 DOM 是 React 社区提出来的一个概念。在 Vue 早期（大约 2.0 以前），Vue 也是没有使用虚拟 DOM 的。使用虚拟 DOM 的原因主要是直接操作 DOM 会带来重大的性能影响。主要体现在两方面： DOM 节点的属性多，空间开销较大，频繁操作必定会带来性能问题： JS 是单线程语言，每次操作 DOM 都是阻塞操作，将会阻塞 JS 的执行，操作 DOM 的时候无法同时执行 JS ，执行 JS 的时候无法更新 DOM ，频繁地切换将会导致动画不能及时响应。更为重要的是，即使 DOM 没有属性值没有更新，但是设置 DOM 的属性值也将阻塞 JS 的执行。 Diff 算法 在介绍 Diff 算法前，需要了解一个关于浏览器渲染的概念： 回流（reflow）：当 DOM 的布局变化时，例如改变元素大小、位置或者增减元素，浏览器需要清楚当前 DOM 子树并应用重新计算的结果。 重绘（redraw）：当 DOM 的属性修改时，例如改变字体颜色，浏览器并不需要重新计算元素的布局，而只要重新绘制新样式。 很显然回流比重绘更加耗费性能，因此我们在设计 Diff 算法时必须尽可能复用已有元素，避免频繁增减元素造成布局回流。 算法实现 虚拟 DOM 应用的核心算法就是 Diff 算法，其目标就是找出两个虚拟 DOM 树之间的最小化差异，好确定要更新的元素。Vue 2.x 的虚拟 DOM 实现主要参考 SnabbDOM ，其 Diff 算法主要有两个特点： 同级比较：对于给定两棵树，只比较同一级节点，如果节点类型不同则直接抛弃，重新构建。 就近复用：当两个节点类型相同，则复用节点，只修改节点的实例属性。 可以看到该算法主要是在实现简单的基础上尽可能复用节点，避免布局回流。 对于子节点集的比较则是希望找到没有同类型的最小集，为此，Diff 算法用了两个优化策略： 双指针比较：对列表的两端分别进行寻找，当两端的值不一致后，按新的前后两端和旧的前后两端比较（尽可能复用已知的索引） 按组件 key 寻找：当所有已知索引都无法匹配时，按 key 的散列表寻找，如果还找不到，只能遍历了。在实际应用中，新旧 DOM 树往往是比较接近的，因此双指针比较就可以很快地找出差异，剩下的部分再根据 key 或遍历寻找即可。 4.插件原理 Vue提供了几种扩展的方式，即： 添加全局方法或者property。如vue-custom-element； 添加全局资源：指令/过滤器/过渡等。如vue-touch； 通过全局混入来添加一些组件选项。如vue-router； 添加Vue实例方法，通过把它们添加到Vue.prototype上实现； 开发插件 Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123MyPlugin.install = function (Vue, options) &#123; // 插件逻辑&#125; 当 Vue 使用时，将会被回调： 1Vue.use(MyPlugin, options); 这个策略也可以认为是一种依赖反转，也就是被调用方不需要知道调用方以何种方式引入。因为 Vue 出现的年代里，Webpack 方兴未艾，全局变量引入模块的方式还大行其道，而全局变量名往往会因为冲突而改变，因此使用这种依赖注入的方式能够很好地规避此类情况。 但在现今倡导 ES 模块和 tree-shaking 优化的视角下，实际上 Vue 这么设计是不够优雅的，因为插件将会被全局共享，难以去掉不必要的依赖。在 Vue 3.x 对此已经进行了整改。 技术选型建议大小开发框架的大小对未来应用的性能至关重要。框架和应用程序必须在应用程序开始正常工作之前加载。在这方面，Angular 最复杂，有143KB。React 次之，有43KB，而 Vue.js只有23KB。除非你的应用特别大，并且包含了大量的组件，否则最好使用更小的结构。 性能在 Web 项目中，性能与 DOM 密切相关：DOM 在浏览器/代码中表示 Web 页面。在发生更新时，你可以通过 DOM 控制 Web页面。Vue、React和Angular的性能会因为任务的不同而有所差异，但在大多数情况下，它们都非常高效和快速。React和Vue都实现了 DOM。得益于其精心设计的结构，Vue提供了出色的性能和内存分配。这就是 React 和 Vue.js 优于Angular的地方：它们利用了虚拟 DOM。 社区React 是世界上最流行的框架，这已不是什么秘密。它越来越受欢迎，因为它提供了真正的 Promise。React 的 Mental Model 看起来很可靠，其组件让创建用户界面变得更容易，API 灵活且富有表现力，整个项目给人的感觉是就应该那样。对 API 库的描述也友好，更容易给人留下良好的印象。从那时起，React 库在基本概念和 API 方面就基本保持不变，但已经形成并发展出了一整套的知识和最佳实践，越来越多的人在使用它。Angular 因其优点而备受赞誉，并拥有大量的社区支持。遗憾的是，尽管 Vue.js 有很多好处，但它并没有像它的竞争对手那样被开发者所接受。下面让我们从流行度和相关性两个方面比较下这三个框架： GitHub：目前，Vue.js 是最流行的框架，尽管它是最年轻的，这意味着越来越多的项目将使用它。 谷歌搜索：在谷歌搜索中，React 查询请求最多，紧随其后的是 Vue.js。目前最不受欢迎的是 Angular.js。Angular.js 的人气在下降，而 Vue.js 的人气却在上升。 Vue、React 和 Angular：该选哪个？ 为了选出最合适的库，你应该首先仔细分析这些框架并理解自己的需求。无论是有许多依赖项的现有项目，还是你想使用熟悉的库进行开发的新应用程序，Vue 都不会给你带来任何麻烦。你可以继续使用 Bootstrap 或 Bulma 这样的 CSS 框架，保留为јQuery 或 Backbone 编写的组件，集成你最喜欢的库执行 HTTP 请求，或使用 Promise 对象。 要开始使用 Vue 进行编程，你所要做的就是将 Vue.js 库连接到 Web 页面。不需要复杂的组装工具！从头到尾开发一个原型只需要 1 到 2 周的时间，这让你能够尽早并经常地收集用户反馈。Vue 2 引入了服务器端渲染（SSR）支持。这让你可以最小化初期的数据加载，并根据需要请求新的视图和资源。与高效的组件缓存相结合，可以进一步减少流量消耗。 React 库能够做一些令人惊叹的事情。因为整个用户界面都是用 JavaScript 定义的，所以你可以使用 JavaScript 的丰富功能在模板中执行各种操作。你只会受到 JavaScript 特性的限制，而不会受到模板框架特性的限制。当你想到完全用 JavaScript 定义的视觉效果时，你可能会想到很多引号、转义字符和 createElement 调用。别担心，React 库允许你（选择性地）使用可以与 JavaScript 代码共存的 HTML-like JSX 语法定义可视元素。 React 与其他两个框架在以下理念上有所不同： 与其说它是一个框架，不如说它是一个库（最初是为了处理 UI 而创建的），因为它不受框架的限制，所以它的功能更多——更适合专业人士，而不是初学者；在 Angular 中许多可以“开箱即用”的主要特性，在这里必须单独连接（这种方法有优点，也有缺点，对于初学者来说是缺点，因为需要做不必要的动作）；更多地面向 JavaScript 而不是 TypeScript（尽管每个版本对 TS 的支持都在增加）；更便于创建原生 Android 和 iOS 移动应用程序，拥有大量适用于各种场合的第三方库（多于 Angular）。 Angular 已经被用在了许多规模最大、最复杂的 Web 应用程序中。 Hooks 浅谈：为啥vue和react都选择了Hooks 定义 “hooks” 直译是 “钩子”，它并不仅是 react，甚至不仅是前端界的专用术语，而是整个行业所熟知的用语。通常指： 系统运行到某一时期时，会调用被注册到该时机的回调函数。 以 react 为例，hooks 是： 一系列以 “use” 作为开头的方法，它们提供了让你可以完全避开 class式写法，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。 而在 vue 中， hooks 的定义可能更模糊，姑且总结一下： 在 vue 组合式API里，以 “use” 作为开头的，一系列提供了组件复用、状态管理等开发能力的方法。 命名规范和指导思想 在 react 官方文档里，对 hooks 的定义和使用提出了 “一个假设、两个只在” 核心指导思想。 一个假设： 假设任何以 「use」 开头并紧跟着一个大写字母的函数就是一个 Hook。 第一个只在： 只在 React 函数组件中调用 Hook，而不在普通函数中调用 Hook。（Eslint 通过判断一个方法是不是大坨峰命名来判断它是否是 React 函数） 第二个只在： 只在最顶层使用 Hook，而不要在循环，条件或嵌套函数中调用 Hook。 因为是约定，因而 useXxx 的命名并非强制，你依然可以将你自定义的 hook 命名为 byXxx 或其他方式，但不推荐。 为什么我们需要 hooks ? 更好的代码组织 更好的逻辑复用 如何开始玩 hooks react 的 Hooks 写法，因为 react Hooks 仅支持“函数式”组件，因此需要创建一个函数式组件 my-component.js 12345678910111213141516171819// my-component.jsimport &#123; useState, useEffect &#125; from &#x27;React&#x27;export default () =&gt; &#123; // 通过 useState 可以创建一个 状态属性 和一个赋值方法 const [ name, setName ] = useState(&#x27;&#x27;) // 通过 useEffect 可以对副作用进行处理 useEffect(() =&gt; &#123; console.log(name) &#125;, [ name ]) // 通过 useMemo 能生成一个依赖 name 的变量 message const message = useMemo(() =&gt; &#123; return `hello, my name is $&#123;name&#125;` &#125;, [name]) return &lt;div&gt;&#123; message &#125;&lt;/div&gt;&#125; vue 的 Hooks 写法，vue 的 Hooks 写法依赖于 组合式API，因此本例采用 &lt;script setup&gt; 来写： 1234567891011121314&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; computed, ref &#125; from &#x27;vue&#x27;// 定义了一个 ref 对象const name = ref(&#x27;&#x27;)// 定义了一个依赖 name.value 的计算属性const message = computed(() =&gt; &#123; return `hello, my name is $&#123;name.value&#125;`&#125;)&lt;/script&gt; 自定义Hooks react写法： 123456789101112import React from &#x27;react&#x27;;export const useName = () =&gt; &#123; // 这个 useMemo 很关键 const randomName = React.useMemo(() =&gt; genRandomName(), []); const [ name, setName ] = React.useState(randomName) return &#123; name, setName &#125;&#125; vue写法： 123456789101112import &#123; ref &#125; from &#x27;vue&#x27;;export const useName = () =&gt; &#123; const name = ref(genRandomName()) const setName = (v) =&gt; &#123; name.value = v &#125; return &#123; name, setName &#125;&#125; Mixin-HOC-Hook参考 【React深入】从Mixin到HOC再到Hook 前言 Mixin-HOC的缺点： 渲染上下文中公开的属性的来源不清楚。 例如，当使用多个 mixin 读取组件的模板时，可能很难确定从哪个 mixin 注入了特定的属性。 命名空间冲突。 Mixins 可能会在属性和方法名称上发生冲突，而 HOC 可能会在预期的 prop 名称上发生冲突。 性能问题，HOC 和无渲染组件需要额外的有状态组件实例，这会降低性能。 Hook的优点： 暴露给模板的属性具有明确的来源，因为它们是从 Hook 函数返回的值。 Hook 函数返回的值可以任意命名，因此不会发生名称空间冲突。 没有创建仅用于逻辑重用的不必要的组件实例。 Hook的缺点：比如 ref 带来的心智负担 Mixin广义的mixin方法，就是用赋值的方式将mixin对象中的方法都挂载到原对象上，来实现对象的混入，类似ES6中的Object.assign()的作用。原理如下： 123456789101112const mixin = function(obj, mixins)&#123; const newObj = obj; newObj.prototype = Object.create(obj.prototype); for(let prop in mixins)&#123; // 遍历mixins的属性 if(mixins.hasOwnPrototype(prop))&#123; // 判断是否为mixin的自身属性 newObj.prototype[prop] = mixins[prop]; // 赋值 &#125; &#125; return newObj;&#125; React.createClass的mixins的危害 Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的 Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 React.createClass现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且HOC是纯净的JavaScript，不用担心他们会被废弃。 React现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且React全面推荐使用高阶组件来替代它。 HOC(High-Order-Components高阶组件)高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个纯函数，且该函数接受一个组件作为参数，并返回一个新的组件。 高阶组件实现的方法有两种： 属性代理：通过被包裹组件的props来进行相关操作。主要进行组件的复用。 反向继承：继承被包裹的组件。主要进行渲染的劫持。 高阶组件可以实现什么功能: 双向绑定 组合渲染: 可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 条件渲染: 根据特定的属性决定原组件是否渲染 操作props: 可以对传入组件的props进行增加、修改、删除或者根据特定的 props进行特殊的操作。 获取refs: 高阶组件中可获取原组件的 ref，通过 ref获取组件实例, 从而可以实现对组件中的方法进行调用 状态管理: 将原组件的状态提取到 HOC中进行管理 操作state: 通过反向继承，我们可以直接操作原组件的 state 渲染劫持: 高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种 渲染劫持。 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持 props，在不遵守约定的情况下也可能造成冲突。 为什么在 Vue 中实现高阶组件比较难 主要是二者的设计思想和设计目标不同，在 React 中写组件就是在写函数，函数拥有的功能组件都有。而 Vue 更像是高度封装的函数，在更高的层面 Vue 能够让你轻松的完成一些事情，但与高度的封装相对的就是损失一定的灵活，你需要按照一定规则才能使系统更好地运行。 Hook使用 Hooks，你可以在将含有 state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。 Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。 123456789101112131415&lt;template&gt; &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; car.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; animal.name &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; usePerson, useCar, useAnimal &#125; from &quot;./hooks&quot;;const &#123; person, changePersonName &#125; = usePerson();const &#123; car &#125; = useCar();&lt;/script&gt; 1234567891011121314151617181920212223// usePerson.tsimport &#123; reactive, watch &#125; from &quot;vue&quot;;export default function usePerson() &#123; const person = reactive&lt;&#123; name: string; sex: string &#125;&gt;(&#123; name: &quot;小明&quot;, sex: &quot;male&quot;, &#125;); watch( () =&gt; [person.name, person.sex], ([nameVal, sexVal]) =&gt; &#123; console.log(`名字被修改了, 修改为 $&#123;nameVal&#125;`); console.log(`名字被修改了, 修改为 $&#123;sexVal&#125;`); &#125; ); function changePersonName() &#123; person.name = &quot;小浪&quot;; &#125; return &#123; person, changePersonName, &#125;;&#125; 使用Hooks的动机 减少状态逻辑复用的风险: Hook和 Mixin在用法上有一定的相似之处，但是 Mixin引入的逻辑和状态是可以相互覆盖的，而多个 Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。 避免地狱式嵌套 让组件更容易理解 使用函数代替class React Hook 和 Vue Hook 对比 React Hook 的缺点(限制非常多)： 不要在循环，条件或嵌套函数中调用 Hook 确保总是在你的 React 函数的最顶层调用他们。 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。 Vue Hook的优点： 与 React Hooks 相同级别的逻辑组合功能，但有一些重要的区别。 与 React Hook 不同，setup 函数仅被调用一次，这在性能上比较占优。 对调用顺序没什么要求，每次渲染中不会反复调用 Hook 函数，产生的的 GC 压力较小。 不必考虑几乎总是需要 useCallback 的问题，以防止传递函数prop给子组件的引用变化，导致无必要的重新渲染。 React Hook 有臭名昭著的闭包陷阱问题（甚至成了一道热门面试题，omg），如果用户忘记传递正确的依赖项数组，useEffect 和 useMemo 可能会捕获过时的变量，这不受此问题的影响。 Vue 的自动依赖关系跟踪确保观察者和计算值始终正确无误。 不得不提一句，React Hook 里的「依赖」是需要你去手动声明的，而且官方提供了一个 eslint 插件，这个插件虽然大部分时候挺有用的，但是有时候也特别烦人，需要你手动加一行丑陋的注释去关闭它。 黄子毅大大眼中的Vue Hook的优点： setup 仅执行一遍，而 React Function Component 每次渲染都会执行 Vue 的代码使用更符合 JS 直觉。JS 并非是针对 Immutable 设计的语言，所以 Mutable 写法非常自然，而 Immutable 的写法就比较别扭。 当 Hooks 要更新值时，Vue 只要用等于号赋值即可，而 React Hooks 需要调用赋值函数，当对象类型复杂时，还需借助第三方库才能保证进行了正确的 Immutable 更新。 对 Hooks 使用顺序无要求，而且可以放在条件语句里。 对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。 而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 setup 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。 不会再每次渲染重复调用，减少 GC 压力 React的Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。 Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 setup 的执行，所以确实不会造成 GC 压力。 React 必须要总包裹 useCallback 函数确保不让子元素频繁重渲染 Vue 3.0，由于 setup 仅执行一次，因此函数本身只会创建一次，不存在多实例问题，不需要 useCallback 的概念，更不需要使用 lint 插件 保证依赖书写正确. Vue不需要使用 useEffect useMemo 等进行性能优化，所有性能优化都是自动的。 React Hook + TS 购物车实战（性能优化、闭包陷阱、自定义 hook） 参考 Vue3 究竟好在哪里？（和 React Hook 的详细对比） 精读《Vue3.0 Function API》 React 和 Vue逻辑结构对比 Vue：Mutable + Template React：Immutable + JSX JSX 与 Template 的根本区别： jsx:JSX 使模版与 JS 可以写在一起，因此数据层与渲染层可以耦合在一起写（也可以拆分） template:Vue 采取的 Template 思路使数据层强制分离了，这也使代码分层更清晰 不建议在 JSX 中再实现类似 Mutable + JSX 心智负担React的心智负担 不能在条件语句中使用，useMemo 和 useCallback 需要显式指定依赖，解决子组件重新渲染可能还需要配合 React.memo 使用等等。虽然有对应的 eslint-plugin 可以帮助填充依赖，但是依赖项一旦很多，代码的可能读会非常差。现在普遍的观点是计算量大的再用 useMemo, 而 useCallback 能不用就不用。因为这点优化对性能的影响是微乎其微的，99% 的情况下都不会出现问题，等到出现问题的时候再进行优化也不迟。 Vue的心智负担 定义状态 ref定义的变量使用时，需要.value。虽然有了 $ref 语法糖，但最新已经废弃了。解构 props 也会出现响应丢失的问题，还要使用 toRefs 来解决。 插槽 因为在 react 中万物皆 props。Vue中需要具名插槽和作用于插槽等。 props 和 emits 的定义 属性 和 事件 还需要分成 defineProps 和 defineEmits 两个 api。反观 react，还是万物皆 props 。 侦听 watch watch监听对象里的某个属性时，第一个参数还需要是一个函数。还分为好多种，watch、watchPostEffect、watchSyncEffect、watchEffect。watch 的第三个参数又有很多属性。 渲染函数 vue3 提供了一个 h 函数，但还是很难用,还不如tsx。 typescript 支持 存在语法限制。给 defineProps 定义的 ts 类型，不能从其它文件导入，只能写在这个文件里。想分开写到别的文件，只能不使用 ts 来定义类型，要使用 defineProps 的第一个参数来指定类型，这样才能从别的文件导入了。这就是为什么大多数组件库没有使用 ts 来定义类型的原因，这样定义的类型要用 ExtractPropTypes 来提取 ts 类型。 breaking change vue2 升级到 vue3 是不兼容的，旧项目升级是很麻烦的。反观 react，几乎是没什么影响。 SolidJSSolidJS是什么号称支持现代前端特性：JSX、Fragments、Context、Portals、Suspense、Streaming SSR、Error Boundaries、并发渲染等现代功能。 又一个摒弃 虚拟DOM，跟 Svelte 一样走编译型路线的框架，没了虚拟DOM 运行时，又通过优秀的响应式系统保证更新颗粒度非常小，性能爆表。和 Svelte 不同的是 Solid 直接借用了 React 社区的 JSX 来编写模板，没有像 Vue Svelte 那样去自定义模板语法。总体来讲 React 有的 API 大部分都能在它里面找到，甚至包括 React 18 的 useTransition，SuspenseList. 另外不提供 Class 组件玩法，所有的组件都是函数组件，且该组件函数只会执行一次。内置了 For 组件来替代 map 来优化性能。支持自定指令等 使用123456789101112131415161718import &#123; render &#125; from &#x27;solid-js/web&#x27;;import &#123; createSignal, createEffect &#125; from &#x27;solid-js&#x27;;const Counter = () =&gt; &#123; const [getCount, setCount] = createSignal(0); const add = () =&gt; setCount(getCount() + 1); createEffect(() =&gt; &#123; console.log(&#x27;count is change:&#x27;, getCount()); &#125;); return ( &lt;button type=&#x27;button&#x27; onClick=&#123;add&#125;&gt; &#123;getCount()&#125; &lt;/button&gt; );&#125;;render(() =&gt; &lt;Counter /&gt;, document.getElementById(&#x27;root&#x27;)); SolidJS不仅打包体积小，性能也是 Number 1 参照js-framework-benchmark 跑分结果 特点平衡了 jsx 与 template 的利弊jsx 和 template 的优缺点： jsx 优点：作为js的语法糖拥有高度灵活性，可以随意编写 缺点：因为过于灵活在 编译阶段 很难分析操作意图 template 优点：因为语法有限制，大部分带有 操作意图（v-if、v-for） 的代码都可以在 编译阶段被识别以做优化 缺点：写法受限，大部分情况下不如jsx灵活 Vue3 对比 Vue2 性能之所以实现了一个质的飞跃，这其中就离不开 编译阶段优化。 1、 比如在编译阶段标记出template中永远不会变化的节点作为静态节点存储，将来更新时直接绕过他们； 2、提前对v-if、v-for这一类区块做区分，将来diff时绕过不必要的判断； 3、绑定props时记录哪些属性可能会变，将来 diff 时只对比“可能会变化的动态节点和属性”，跳过“永远不会变化的节点和属性”。 除此之外还有缓存事件处理程序等等 但JSX就不能识别操作意图，主要是写法太灵活。如果每种情况都去判断一遍，那么 编译阶段 将会非常复杂且耗时，另外显得也非常麻瓜。 1234567891011121314151617v-if的写法就有三种：// 写法1return status === 1 ? &lt;span&gt;通过&lt;/span&gt; : status === 2 ? &lt;span&gt;拒绝&lt;/span&gt; : null;// 写法2return ( &lt;&gt; &#123;status === 1 &amp;&amp; &lt;span&gt;通过&lt;/span&gt;&#125; &#123;status === 2 &amp;&amp; &lt;span&gt;拒绝&lt;/span&gt;&#125; &lt;/&gt;);// 写法3switch (status) &#123; case 1: return &lt;span&gt;通过&lt;/span&gt;; case 2: return &lt;span&gt;拒绝&lt;/span&gt;;&#125; SolidJS 采用的方案是：在 JSX 的基础上做了一层规范，中文译名为 控制流。写法上类似某种预设的组件，用于编译阶段优化。这样在编译阶段就可以做意图分析，提前知道这是在做按条件渲染，然后编译成对应的dom操作即可。 SolidJS小结： 即借鉴了 template 更容易做编译阶段优化的优势 又保留了 JSX 的灵活性 No Dom DiffNo Dom Diff 是说 SolidJS在更新粒度方面，摒弃了虚拟dom，采用节点级更新。 目前前端主流的几种方案： 应用级更新：状态更新会引起整个应用render，具体渲染哪些内容取决于协调的结果。代表作有 React(因为 React 每次更新都会重新走一遍更新流程，做这些限制是为了获取到完整的VDom树/Fiber树，通过 diff新旧两棵树来决定真正更新哪些组件，所以 React 并不是组件级更新) 组件级更新：状态更新时只会引起绑定了该状态的组件渲染，具体渲染哪些内容同样取决于协调的结果。代表作有vue2.x 节点级更新：状态更新时直接触法绑定该状态的节点更新，也就是指向型更新。代表作有vue1.x、Svelte、SolidJS 而SolidJS对于三大对象均采用简单对象存储，另外不需要递归观察，所以占用内存非常少。对于如何更新dom，具体的做法是：在编译阶段提前生成类似 insert、update、delete的dom操作方法，将来更新时直接调用。 重·编译时 提前生成节点渲染方法 刚才说到 SolidJS 在 jsx 中借鉴了部分 template 的规范写法，在编译阶段 分析意图，提前生成对应的dom操作方法 按需打包，缩小体积 这一步也就是 tree-shaking，只打包用到的模块，近一步缩小打包资源体积。 轻·运行时由于没有了diff这一大规模计算，使得运行时代码更轻量，所以SolidJS在更新时也更简洁。 SolidJS 在更新时的js调用栈如图： React v16 在更新时的js调用栈如图： 不被顺序限制的 hook说到前端框架中的 Hook，最先将这个方案落地的是React，但由于React一直推崇 immutable 思想，每次更新必须重新走一遍整个树的更新流程，使得 React Hook 不可以在条件循环中使用，否则可能使渲染结果受到影响。 后来尤大发布了Vue3.0，伴随而来的一大特性是Composition API，俗称Vue3 hook，由于Vue2以后都采用组件级的更新粒度，再加上响应式原理采用的是自动收集依赖，所以Vue3 hook不会有顺序/条件的限制，另外还可以嵌套使用。 SolidJS的响应式原理主要借鉴了React Hook的思想，同时也保留了Vue3的依赖收集模型，所以用起来非常丝滑。 其他 脚手架：degit，内部集成了 vite。 支持TS且类型友好 现代前端框架大部分特性：Fragments、Portals、Context、Suspense、事件委托、SSR等等 参考 比React还Vue3的框架SolidJS","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"插件","slug":"H_工程热点_插件","date":"2023-01-11T23:33:16.000Z","updated":"2023-03-25T09:45:27.143Z","comments":true,"path":"2023/01/12/H_工程热点_插件/","link":"","permalink":"https://fuyunjinglong.github.io/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/","excerpt":"","text":"VSCode主题注意要下载主题插件 12345678&quot;workbench.colorTheme&quot;: &quot;Monokai Dark Soda&quot;, //让函数(名)和后面的括号之间加个空格&quot;editor.tokenColorCustomizations&quot;: &#123; &quot;comments&quot;: &quot;#C17F39&quot; //春天绿&#125;,&quot;workbench.colorCustomizations&quot;: &#123; // &quot;tab.inactiveBackground&quot;: &quot;#a8a8a6&quot;, //非活动选项卡的背景色 &quot;tab.activeBackground&quot;: &quot;#C17F39&quot; //活动选项卡的背景色。&#125; 配置模板片段执行命令 1Ctrl + Shift + P 输入snippets, 点击 代码片段：配置用户代码片段 1234567891011121314151617181920&#123;&quot;vue3 template&quot;: &#123;&quot;prefix&quot;: &quot;vue3-template&quot;,&quot;body&quot;: [&quot;&lt;template&gt;&quot;,&quot; &lt;div&gt;&quot;,&quot;$1&quot;,&quot; &lt;/div&gt;&quot;,&quot;&lt;/template&gt;\\n&quot;,&quot;&lt;script lang=\\&quot;ts\\&quot; setup&gt;&quot;,&quot;import &#123; ref &#125; from \\&quot;vue\\&quot; &quot;,&quot;$2&quot;,&quot;&lt;/script&gt;\\n&quot;,&quot;&lt;style lang=\\&quot;scss\\&quot; scoped&gt;&quot;,&quot;$3&quot;,&quot;&lt;/style&gt;&quot;],&quot;description&quot;: &quot;vue3 template&quot;&#125;&#125;","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"E_左神","slug":"E_数据结构_左神","date":"2022-11-12T23:33:16.000Z","updated":"2024-04-21T02:59:21.370Z","comments":true,"path":"2022/11/13/E_数据结构_左神/","link":"","permalink":"https://fuyunjinglong.github.io/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/","excerpt":"","text":"大纲 左神-先读先读先读 算法与数据结构全阶班-左神video 00-算法和数据结构新手班【完结】 01-左神-算法与数据结构基础班【完结】 左神部分笔记 数据结构-浙江大学(opens new window)-video 清华大学-邓俊辉MOOC数据结构与算法全套-video 算法通关手册 大话数据结构 算法图解 数据结构与算法本质数据结构就是2种结构： 连续结构：连续空间(数组)，寻址容易，增删难 跳转结构：不连续，指针跳转，增删容易，寻址难 算法第一句话：分析算法复杂度，必须对算法流程足够清楚才能大致推算出来 算法不挑语言，因为算法很少用到语言的特性，只要会伪代码就行。其次，你在JS中也能找到Java对应的数据结构，增加实际codeing能力。 生活的意思不是一出生就会，是吃过苦会有的。算法也是，练过了，思维自然就有了。 有具体的问题-问题 有设计解决这个问题的具体流程-程序 有评价处理流程的可量化指标-复杂度 分类 明确知道怎么算的流程，如加减乘除 明确知道怎么尝试的流程，如质数。所以图灵是计算机算法的祖师爷。图灵在二战利用无数分支尝试破解德军密码。 什么是常数操作算法的执行时间与样本量无关，是一个固定值,表示为O(1) 什么是时间复杂度比如冒泡排序的时间复杂度：n平方。只取最高阶，去掉系数，去掉低阶。时间复杂度一定是最差的情况。 二分法的复杂度是O(logN) 常见时间复杂度排序：O(1)&lt;O(logN)&lt;O(N)&lt;O(N*logN)&lt;O(N2)&lt;O(2N)&lt;O(3N)&lt;… 评估算法优劣的核心指标 时间复杂度(流程决定) 额外空间复杂度(流程决定) 常数项时间(实现细节决定) 时间复杂度(流程决定)常数时间的操作 如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定值，这样的操作为常数时间操作。 比如： 常见的算术运算(+-*/) 常见的位运算(&gt;&gt;,&lt;&lt;,|,&amp;,^) 赋值、比较、自增、自减 数组寻址操作 算法的总操作流程与样本数量的关系确定 想象算法流程所处理的数据状况，按照最差情况来。比如时间复杂度，通常说的就是最差时间复杂度 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作 如果数据量为N,看看基本动作的数量和N是什么关系 如何确定算法流程的时间复杂度 当完成表达式建立后，只保留最高阶项，低阶项去掉，高阶项系数也去掉，记为O(忽略掉系数的高阶项) 问题的最优解 一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低指标后，使用最少空间复杂度，叫这个问题的最优解。最优解可以忽略常数项因素。 常见时间复杂度从好到差 O(1) O(logN) O(N) O(N*logN) O(N^2) O(N^3)…O(N^K) O(2^N) O(3^N)…O(K^N) O(N!) 算法学习脉络 知道算法的严格流程 知道算法的尝试流程(递归) 额外空间复杂度(流程决定)在实现算法流程中，你需要开辟一些空间来支持你的算法流程。这部分空间就是额外空间。 如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1) 常数项时间(实现细节决定)放弃理论分析，利用随机样本实际测试常数项时间差异性。 位运算符题目：打印int类型数据的32位信息 12345678public static void code_print(int num)&#123; // 打印int类型数据的32位信息 for(int i = 31; i &gt;=0;i--)&#123; // 1左移31位，即1000000...0可以取出第31位信息 // &lt;&lt;带符号左移，&lt;&lt;&lt;不带符号左移 System.out.print((num&amp;(1&lt;&lt;i))==0?0:1); &#125; &#125; 原码，反码，补码 原码：是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。 反码：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。 补码：正数的补码等于它的原码；负数的补码等于反码+1 int类型的无符号和有符号数的数 无符号：0—2的32次方即共有2的32次方个数 有符号：-2的31次方—2的31次方-1即共有2的32次方个数，相当于把无符号中的一半分给了负数。 123456// 最小值，10000000000000000000000000000000int a = Integer.MIN_VALUE;// 最大值，01111111111111111111111111111111int a = Integer.MAX_VALUE;//一个数的相反数int c = -a或 ~a+1即取反加1 对于有符号的二进制转十进制 非负数：最高位为0，不看最高位，其他位正常转十进制 负数：最高位为，不看最高位，其他位取反+1，再转十进制 多一句：为什么这么设计？方便底层对+2,-2统一做一套加减乘除的底层运算逻辑，提高计算机的运算性能。 N的阶层和题目：给定一个参数N,返回1!+2!+3!…N!的结果 解法二明显优于解法一。 解法一：先计算当前阶层值，然后求和 123456789101112131415//两层for循环public static long code_f1(int num)&#123; int ans = 0; for(int i=1;i&lt;=num;i++)&#123; ans+=code_factorial(i); &#125; return ans; &#125; public static long code_factorial(int N)&#123; int ans = 1; for(int i =1;i&lt;=N;i++)&#123; ans*=i; &#125; return ans; &#125; 解法二：每一个阶层值可以看成前一个阶层*当前N 1234567891011//一层for循环public static long code_f2(int num)&#123; int ans = 0;//求和 int cur =1;//cur记录前一个阶层值 // 一边计算阶层，一边同时求值 for(int i=1;i&lt;=num;i++)&#123; cur*=i; ans+=cur; &#125; return ans; &#125; 对数器找到一个实现算法流程的最简单的算法，与最终的算法，进行比较。 有一个你想要测的方法a； 实现一个绝对正确但是复杂度不好的方法b； 实现一个随机样本产生器； 实现对比算法a和b的方法； 把方法a和方法b比对多次来验证方法a是否正确； 如果有一个样本使得比对出错，打印样本分析是哪个方法出错； 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 定义：用于生成随机样本给自己做比对的机器。 利用随机性，生成任意数组，即对数器便于调试验证. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* package codechef; // don&#x27;t place package name! */import java.util.*;import java.lang.*;import java.io.*;/* Name of the class has to be &quot;Main&quot; only if the class is public. */class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; // 利用随机数特性，可以生成一个任意长度任意值的样本数组，便于验证。 // 和后续的对数器一起使用，方便调试排查问题 int testTimes = 10000000; for (int i = 0; i &lt; testTimes; i++) &#123; int[] arr = lengthRadomValueRadom(10,19); code_InsertSort1(arr); if(!isSortAsc(arr))&#123; System.out.println(&quot;插入排序算法不正确&quot;); &#125; &#125; &#125; public static int[] lengthRadomValueRadom(int maxLength,int maxvalue)&#123; // 随机生成最大长度，最大值的随机数组 int N = (int)(Math.random()*maxLength); int [] arr = new int[N]; for(int i =0;i&lt;N;i++)&#123; arr[i] = (int)(Math.random()*maxvalue); &#125; return arr; &#125; public static boolean isSortAsc(int[] arr)&#123; // 判断数组是否为升序，本质是对数器 int N = arr.length; if(N&lt;2)&#123; // 注意边界条件 return true; &#125; int maxV = arr[0]; for(int i = 1;i&lt;N;i++)&#123; if(maxV &gt;arr[i])&#123; return false; &#125; maxV = arr[i]; &#125; return true; &#125; public static void code_InsertSort1(int[] arr)&#123; // 插入排序 if(arr == null||arr.length&lt;2)&#123; //所有算法优先考虑边界问题 return; &#125; int N = arr.length; for(int end=1;end&lt;N;end++)&#123; // 1.遍历0-1，0-2... // 2.索引值不越界且左边小于后边相邻的，才停止。否则，一直交换下去，保证左边小右边大 for(int pre = end;pre-1&gt;=0&amp;&amp;arr[pre-1]&gt;arr[pre];pre--)&#123; swap(arr,pre-1,pre); &#125; &#125; &#125; public static void swap(int[]arr,int i,int j)&#123; // 常规交换 int tem = arr[i]; arr[i] = arr[j]; arr[j] = tem; &#125;&#125; 二分法经常看到在有序数组上，开展二分搜索。但有序是所有问题使用二分的必要条件吗？不是，只要能正确构建左右两侧的淘汰逻辑，就可以用二分。 题目1:在一个有序数组中，找某个数是否存在 题目2:在一个有序数组中，找&gt;=某个数最左侧的位置 题目3:在一个有序数组中，找&lt;=某个数最右侧的位置 题目4:局部最小值问题，无序数组，任意两个相邻的数不相等，返回一个局部最小值。注意：这个局部最小值可能有多个，只要找到一个就可以。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 题目1:在一个有序数组中，找某个数是否存在public static boolean exist(int[] sortedArr, int num) &#123; // 默认sortedArr是升序的 if (sortedArr == null || sortedArr.length == 0) &#123; return false; &#125; int L = 0; int R = sortedArr.length - 1; int mid = 0; // L..R while (L &lt; R) &#123; // L..R 至少两个数的时候 mid = L + ((R - L) &gt;&gt; 1); if (sortedArr[mid] == num) &#123; return true; &#125; else if (sortedArr[mid] &gt; num) &#123; // 因为数组是升序的，中间&gt;num,去左半边查询 R = mid - 1; &#125; else &#123; // 去右半边查询 L = mid + 1; &#125; &#125; return sortedArr[L] == num;&#125;// 题目2:在一个有序数组中，找&gt;=某个数最左侧的位置public static int nearestIndex(int[] arr, int value) &#123; int L = 0; int R = arr.length - 1; int index = -1; // 记录最左的对号 // 相当于，在大于等于value区域，一直往左收缩，直到index左边没有数为止 while (L &lt;= R) &#123; // 至少一个数的时候 int mid = L + ((R - L) &gt;&gt; 1); if (arr[mid] &gt;= value) &#123; // 记录mid,往左收缩 index = mid; R = mid - 1; &#125; else &#123; // 往右收缩 L = mid + 1; &#125; &#125; return index;&#125;// 题目3:在一个有序数组中，找&lt;=某个数最右侧的位置public static int nearestIndex(int[] arr, int value) &#123; int L = 0; int R = arr.length - 1; int index = -1; // 记录最右的对号 // 相当于，在小于等于value区域，一直往右收缩，直到index右边没有数为止 while (L &lt;= R) &#123; int mid = L + ((R - L) &gt;&gt; 1); if (arr[mid] &lt;= value) &#123; // 记录mid,往右收缩 index = mid; L = mid + 1; &#125; else &#123; // 往左收缩 R = mid - 1; &#125; &#125; return index;&#125;// 题目4:局部最小值问题public static int getLessIndex(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return -1; &#125; // 情况1：如果一个数组(0~1)(0 1)是升序排列，则局部最小值是 0 位置 if (arr.length == 1 || arr[0] &lt; arr[1]) &#123; return 0; &#125; // 情况2：如果一个数组(n-2, n-1)(n−2,n−1)是降序排列，则局部最小值是 n - 1n−1 位置 if (arr[arr.length - 1] &lt; arr[arr.length - 2]) &#123; return arr.length - 1; &#125; int left = 1; int right = arr.length - 2; int mid = 0; // 情况3：数组开头向下，结尾向上，那这个局部最小位置一定在中间 while (left &lt; right) &#123; mid = (left + right) / 2; if (arr[mid] &gt; arr[mid - 1]) &#123; right = mid - 1; &#125; else if (arr[mid] &gt; arr[mid + 1]) &#123; left = mid + 1; &#125; else &#123; return mid; &#125; &#125; return left;&#125; 异或运算异或运算：相同为0，不同为1 同或运算：相同为1，不同为0 能长时间记住的概率为0%，所以记住异或运算是无进位相加即可。 异或运算的性质 0^N=N N^N=0 异或运算满足交换律和结合律 如何不用额外变量交换两个数 12345利用交换律和结合律：注意a,b的内存地址一定要不同，值相同是可以的。之所以能这么来回倒，是因为有2个空间操作，如果变成一个空间，就挂了。int a=甲;int b=乙;a = a^b;b = a^b;//a^b^b a^0 aa = a^b;//a^b^a 0^b b 怎么把一个int类型的数N，提取出最右侧的1来 12int rightOne = N &amp; ((~N) + 1)其中(~N) + 1也等于-N 经典题目 题目1：一个数组中，只有一种数出现了奇数次，其余数出现了偶数次，怎么找到该数？ 题目2：一个数组中，有两种数出现了奇数次，其余数出现了偶数次，怎么找到这两个数？ 题目3：提取出一个int类型数N的出现1的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 题目1：一个数组中，只有一种数出现了奇数次，其余数出现了偶数次，怎么找到该数？public static void printOddTimesNum1(int[] arr) &#123; /* * 因为偶数的数异或结果为0,0^N=N,这就提取出来了 */ int eor = 0; for (int i = 0; i &lt; arr.length; i++) &#123; eor ^= arr[i]; &#125; System.out.println(eor);&#125;// 题目2：一个数组中，有两种数出现了奇数次，其余数出现了偶数次，怎么找到这两个数？public static void printOddTimesNum2(int[] arr) &#123; int eor = 0; for (int i = 0; i &lt; arr.length; i++) &#123; eor ^= arr[i]; &#125; // eor=a^b, a 和 b是两种数 // eor != 0 // eor最右侧的1，提取出来 // eor : 00110010110111000 // rightOne :00000000000001000 int rightOne = eor &amp; (-eor); // 提取出最右的1 int onlyOne = 0; // eor&#x27;只异或最右为1的数，提取出a for (int i = 0 ; i &lt; arr.length;i++) &#123; // arr[1] = 111100011110000 // rightOne= 000000000010000 if ((arr[i] &amp; rightOne) != 0) &#123; onlyOne ^= arr[i]; &#125; &#125; // b=a^b^a System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));&#125;// 题目3：提取出一个int类型数N的出现1的次数public static int bit1counts(int N) &#123; int count = 0; // 011011010000 // 000000010000 1 // 011011000000 while(N != 0) &#123; int rightOne = N &amp; ((~N) + 1); count++; N ^= rightOne; // N -= rightOne &#125; return count;&#125; 排序排序算法总结术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 时间复杂度 空间复杂度 稳定性 选择排序 O(N^2) O(1) 无 冒泡排序 O(N^2) O(1) 有 插入排序 O(N^2) O(1) 有 归并排序 O(N*logN) O(N) 有 随机快排 O(N*logN) O(logN) 无 堆排序 O(N*logN) O(1) 无 界限 界限 界限 界限 计数排序 O(N) O(M) 有 基数排序 O(N) O(N) 有 工具函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 排序算法验证函数for testpublic static void main(String[] args) &#123; int testTime = 500000;//测试次数 int maxSize = 100;//最大测试容量 int maxValue = 100;//最大测试数据 boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1);//这两个数组除了数值相同内存地址完全没关系，请看copyArray()方法实现 selectionSort(arr1);//用自己的算法排序 comparator(arr2);//用java.util.Arrays包的排序算法排序 if (!isEqual(arr1, arr2)) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;); int[] arr = generateRandomArray(maxSize, maxValue); printArray(arr);// 排序前，打印数组 selectionSort(arr);// 排序 printArray(arr);// 排序后，打印数组&#125; // 交换arr的i和j位置上的值public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; // 更骚的交换，但i和j是一个位置的话，会出错 /*arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; */&#125;// 排序对数器for testpublic static void comparator(int[] arr) &#123; Arrays.sort(arr);&#125;// 返回随机长度，随机值的数组for testpublic static int[] generateRandomArray(int maxSize, int maxValue) &#123; // Math.random() -&gt; [0,1) 所有的小数，等概率返回一个 // Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个 // (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个 int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; // 长度随机 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr;&#125;// 数组深拷贝for testpublic static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res;&#125;// 数组值比较for testpublic static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true;&#125;// 数组值打印for testpublic static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println();&#125; 选择排序过程： arr[0 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到0位置 arr[1 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到1位置 arr[2 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到2位置 … arr[N-1 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到N-1位置 估算： 明显，如果arr长度为N,每一步都是常数操作的数量，如等差数列一般。所以总的常数操作数量=a(N^2)+bN+c,其中abc都是常数。所以是O(N^2) 123456789101112131415public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; // 0 ~ N-1 找到最小值，在哪，放到0位置上 // 1 ~ n-1 找到最小值，在哪，放到1 位置上 // 2 ~ n-1 找到最小值，在哪，放到2 位置上 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; // i ~ N-1 上找最小值的下标 minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; swap(arr, i, minIndex); &#125; &#125; 冒泡排序过程： 在arr[0 ~ N-1]范围上， arr[0]和arr[1],谁大谁来到1位置；arr[1]和arr[2],谁大谁来到2位置…arr[N-2]和arr[N-1],谁大谁来到N-1位置 在arr[0 ~ N-1]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2],谁大谁来到N-2位置 在arr[0 ~ N-1]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3],谁大谁来到N-3位置 … 最后在arr[0 ~ 1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1],谁大谁来到1位置 估算： 很明显，如果arr长度为N,每一步都是常数操作的数量，如等差数列一般。所以总的常数操作数量=a(N^2)+bN+c,其中abc都是常数。所以是O(N^2) 123456789101112131415public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; // 0 ~ N-1 // 0 ~ N-2 // 0 ~ N-3 for (int e = arr.length - 1; e &gt; 0; e--) &#123; // 0 ~ e for (int i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap(arr, i, i + 1); &#125; &#125; &#125; &#125; 插入排序过程： 想让arr[0~0]上有序，这个范围只有一个数，当然有序 想让arr[0~1]上有序，所以从arr[1]往前看，如果arr[1]&lt;arr[0],就交换。否则什么都不做 … 想让arr[0~i]上有序，所以从arr[i]往前看，arr[i]这个数不停向左移动，一直移动到左边数字&gt;=自己，停止移动。 估算时发现，复杂度明显会因数据状况不同而不同。最好情况是只看不交换O(N),最差情况就是O(N^2) 1234567891011public static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; // 不只1个数 for (int i = 1; i &lt; arr.length; i++) &#123; // 0 ~ i 做到有序 for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; 比较器与堆堆结构是比堆排序重要得多的知识。 堆结构 堆结构就是用数组实现的完全二叉树。(完全二叉树，上面的层是满的，即使不满，那么一定是从左到右逐渐变满) 完全二叉树如果每棵子树的最大值都在顶部就是大根堆 完全二叉树如果每棵子树的最小值都在顶部就是小根堆 堆结构关键就是heapInsert和heapify操作 堆结构的增大和减少 优先级队列结构，就是堆结构 heap堆结构[0,1,2,3,4,5]，对应到我们想象的堆结构是： 0 1 2 3 4 5 这里有一个关系heap的数组索引为i。假设当前节点为i,且节点索引从0开始使用。那么它的 - 左节点：2i+1 - 右节点：2i+2 - 父节点：(i-1)/2 当然某些题目可能节点索引从1开始。为什么这么奸？因为可以用位运算。那么它的， - 左节点：2i - 右节点：2i+1 - 父节点：(i)/2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import java.util.Comparator;import java.util.PriorityQueue;public class Code02_Heap &#123; public static class MyMaxHeap &#123; // O(longN)的大根堆数组 private int[] heap; // 限制堆的大小 private final int limit; // 当前堆的实时大小 private int heapSize; public MyMaxHeap(int limit) &#123; heap = new int[limit]; this.limit = limit; heapSize = 0; &#125; public boolean isEmpty() &#123; return heapSize == 0; &#125; public boolean isFull() &#123; return heapSize == limit; &#125; public void push(int value) &#123; // 大根堆数组尾部添加节点 if (heapSize == limit) &#123; throw new RuntimeException(&quot;heap is full&quot;); &#125; // 大根堆添加节点，一定是来到最后的位置。原来的最后是heapSize-1索引处 heap[heapSize] = value; // 先将最新的索引作为参数传入，然后heapSize长度+1 heapInsert(heap, heapSize++); &#125; public int pop() &#123; // 大根堆数组弹出顶部节点 /* * 用户此时，让你返回最大值，并且在大根堆中，把最大值删掉.剩下的数，依然保持大根堆组织 * */ // 先把最大值记录下来 int ans = heap[0]; // 然后把最后一个节点和第一个位置交换，然后长度-- swap(heap, 0, --heapSize); // 接下来就是0索引节点值从上往下窜 heapify(heap, 0, heapSize); return ans; &#125; private void heapInsert(int[] arr, int index) &#123; /* * 从下往上窜，添加节点，生成大根堆，可以用于建堆 * index表示大根堆添加节点的索引，比较当前节点和父节点值，直到要么index到顶，要么父节点比当前节点大. * 新加进来的数，现在停在了index位置，请依次往上移动， * 移动到0位置，或者干不掉自己的父亲了，停！ * [index]是当前节点， [index-1]/2是父节点 * index == 0是顶部，即使到顶部arr[0]&gt;arr[0]也可以跳出循环 */ while (arr[index] &gt; arr[(index - 1) / 2]) &#123; // 只要当前值大于父节点值，就交换，并且索引更新为父节点索引，一直往上窜 swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; private void heapify(int[] arr, int index, int heapSize) &#123; /* * 从上往下窜，将当前节点调整为大根堆，可以用于建堆 * index表示当前节点的索引，比较当前节点和子节点最大的一个，直到要么index到底，要么父节点比当前节点大 * 从index位置，往下看，不断的下沉 * 停：较大的孩子都不再比index位置的数大；已经没孩子了 * */ // left表示左子节点 int left = index * 2 + 1; // 如果有左孩子 while (left &lt; heapSize) &#123; // 如果有左孩子，有没有右孩子，可能有可能没有！ // 如果有右孩子且右大于左，则右孩子给largest。否则给左孩子。 int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; // 比较当前节点和子节点最大的一个，哪一个大 largest = arr[largest] &gt; arr[index] ? largest : index; // 如果父节点比当前节点大，直接跳出循环。index就是当前父节点，largest是子节点最大的一个 if (largest == index) &#123; break; &#125; // index和较大孩子，要互换 swap(arr, largest, index); // 当前节点往下更新索引 index = largest; // 同时更新左子节点 left = index * 2 + 1; &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; &#125; public static class RightMaxHeap &#123; // O(N)的大根堆数组，巨暴力的一个大根堆 private int[] arr; private final int limit; private int size; public RightMaxHeap(int limit) &#123; arr = new int[limit]; this.limit = limit; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public boolean isFull() &#123; return size == limit; &#125; public void push(int value) &#123; // 暴力的往后添加节点 if (size == limit) &#123; throw new RuntimeException(&quot;heap is full&quot;); &#125; arr[size++] = value; &#125; public int pop() &#123; // 每次找到最大值，并弹出 int maxIndex = 0; for (int i = 1; i &lt; size; i++) &#123; if (arr[i] &gt; arr[maxIndex]) &#123; maxIndex = i; &#125; &#125; int ans = arr[maxIndex]; arr[maxIndex] = arr[--size]; return ans; &#125; &#125; public static class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125; public static void main(String[] args) &#123; // 小根堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(new MyComparator()); heap.add(5); heap.add(5); heap.add(5); heap.add(3); // 5 , 3 System.out.println(heap.peek()); heap.add(7); heap.add(0); heap.add(7); heap.add(0); heap.add(7); heap.add(0); System.out.println(heap.peek()); while (!heap.isEmpty()) &#123; System.out.println(heap.poll()); &#125; int value = 1000; int limit = 100; int testTimes = 1000000; for (int i = 0; i &lt; testTimes; i++) &#123; int curLimit = (int) (Math.random() * limit) + 1; MyMaxHeap my = new MyMaxHeap(curLimit); // 对数器 RightMaxHeap test = new RightMaxHeap(curLimit); int curOpTimes = (int) (Math.random() * limit); for (int j = 0; j &lt; curOpTimes; j++) &#123; if (my.isEmpty() != test.isEmpty()) &#123; System.out.println(&quot;Oops!&quot;); &#125; if (my.isFull() != test.isFull()) &#123; System.out.println(&quot;Oops!&quot;); &#125; if (my.isEmpty()) &#123; int curValue = (int) (Math.random() * value); my.push(curValue); test.push(curValue); &#125; else if (my.isFull()) &#123; if (my.pop() != test.pop()) &#123; System.out.println(&quot;Oops!&quot;); &#125; &#125; else &#123; if (Math.random() &lt; 0.5) &#123; int curValue = (int) (Math.random() * value); my.push(curValue); test.push(curValue); &#125; else &#123; if (my.pop() != test.pop()) &#123; System.out.println(&quot;Oops!&quot;); &#125; &#125; &#125; &#125; &#125; System.out.println(&quot;finish!&quot;); &#125;&#125; 堆排序 第一步：先生成大根堆 第二步：先将最大值交换到最后，循环逻辑：heapify调整当前值在剩下范围内为大根堆，再交换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import java.util.Arrays;import java.util.PriorityQueue;public class Code03_HeapSort &#123; // 堆排序额外空间复杂度O(1) public static void heapSort(int[] arr) &#123; // 小根堆排序 if (arr == null || arr.length &lt; 2) &#123; return; &#125; // 解法1：第一步：先生成大根堆。复杂度：O(N*logN) for (int i = 0; i &lt; arr.length; i++) &#123; // O(N) // 建堆，注意这是每次只给一个节点 heapInsert(arr, i); // O(logN) &#125; // 解法2：第一步：先生成大根堆，注意是从右往左的。复杂度：O(N)// for (int i = arr.length - 1; i &gt;= 0; i--) &#123;// // 建堆,注意这是一次给所有arr节点// heapify(arr, i, arr.length);// &#125; int heapSize = arr.length; // 第二步：先将最大值交换到最后，循环逻辑：heapify调整当前值在剩下范围内为大根堆，再交换。复杂度:O(N*logN) // 先size--。将大根堆的最大值交换到最后，即最大值下沉。 swap(arr, 0, --heapSize); // O(N*logN) // 在剩下的0到size-1上，heapify调整当前值为大根堆，再交换。下沉第二大的值，size-- while (heapSize &gt; 0) &#123; // O(N) // heapify调整当前值在剩下范围内为大根堆 heapify(arr, 0, heapSize); // O(logN) // 先size-- // 将当前最大值交换到最后，即最大值下沉 swap(arr, 0, --heapSize); // O(1) &#125; &#125; private static void heapInsert(int[] arr, int index) &#123; /* * 从下往上窜，添加节点，生成大根堆。可以用于建堆，注意这是每次只给一个节点 * index表示大根堆添加节点的索引，比较当前节点和父节点值，直到要么index到顶，要么父节点比当前节点大. * 新加进来的数，现在停在了index位置，请依次往上移动， * 移动到0位置，或者干不掉自己的父亲了，停！ * [index]是当前节点， [index-1]/2是父节点 * index == 0是顶部，即使到顶部arr[0]&gt;arr[0]也可以跳出循环 */ while (arr[index] &gt; arr[(index - 1) / 2]) &#123; // 只要当前值大于父节点值，就交换，并且索引更新为父节点索引，一直往上窜 swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; private static void heapify(int[] arr, int index, int heapSize) &#123; /* * 从上往下窜，将当前节点调整为大根堆。可以用于建堆，注意这是一次给所有arr节点 * index表示当前节点的索引，比较当前节点和子节点最大的一个，直到要么index到底，要么父节点比当前节点大 * 从index位置，往下看，不断的下沉 * 停：较大的孩子都不再比index位置的数大；已经没孩子了 * */ // left表示左子节点 int left = index * 2 + 1; // 如果有左孩子 while (left &lt; heapSize) &#123; // 如果有左孩子，有没有右孩子，可能有可能没有！ // 如果有右孩子且右大于左，则右孩子给largest。否则给左孩子。 int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; // 比较当前节点和子节点最大的一个，哪一个大 largest = arr[largest] &gt; arr[index] ? largest : index; // 如果父节点比当前节点大，直接跳出循环。index就是当前父节点，largest是子节点最大的一个 if (largest == index) &#123; break; &#125; // index和较大孩子，要互换 swap(arr, largest, index); // 当前节点往下更新索引 index = largest; // 同时更新左子节点 left = index * 2 + 1; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; // for test public static void comparator(int[] arr) &#123; Arrays.sort(arr); &#125; // for test public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; // for test public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; // for test public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; // for test public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; // for test public static void main(String[] args) &#123; // 系统自带的优先级队列，默认小根堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); heap.add(6); heap.add(8); heap.add(0); heap.add(2); heap.add(9); heap.add(1); System.out.println(&quot;hello&quot;); while (!heap.isEmpty()) &#123; System.out.println(heap.poll()); &#125; int testTime = 500000; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); heapSort(arr1); comparator(arr2); if (!isEqual(arr1, arr2)) &#123; succeed = false; break; &#125; &#125; System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;); int[] arr = generateRandomArray(maxSize, maxValue); printArray(arr); heapSort(arr); printArray(arr); &#125;&#125; 与堆有关的题目 题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素的移动距离可以不超过k，并且k相对于整个数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。 第一步：先建一个小根堆，0…K。这里一定有最小值，因为题目给出排序移动距离不超过k. 第二步：先弹出小根堆的最小值，然后再添加，再弹出 第三步：最后发现没有可以添加的节点了，直接逐个弹出节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import java.util.Arrays;import java.util.PriorityQueue;public class Code04_SortArrayDistanceLessK &#123; public static void sortedArrDistanceLessK(int[] arr, int k) &#123; // 复杂度O(N*logK) if (k == 0) &#123; return; &#125; // 默认小根堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); int index = 0; // 第一步：先建一个小根堆，0...K。这里一定有最小值，因为题目给出排序移动距离不超过k. // 比如k=3,则下标索引0,1,2,3。 for (; index &lt;= Math.min(arr.length - 1, k); index++) &#123; heap.add(arr[index]); &#125; int i = 0; // 第二步：先弹出小根堆的最小值，然后再添加，再弹出 for (; index &lt; arr.length; i++, index++) &#123; arr[i] = heap.poll(); heap.add(arr[index]); &#125; // 第三步：最后发现没有可以添加的节点了，直接逐个弹出节点。最后arr就是升序排好序的结果 while (!heap.isEmpty()) &#123; arr[i++] = heap.poll(); &#125; &#125; // for test public static void comparator(int[] arr, int k) &#123; Arrays.sort(arr); &#125; // for test public static int[] randomArrayNoMoveMoreK(int maxSize, int maxValue, int K) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; // 先排个序 Arrays.sort(arr); // 然后开始随意交换，但是保证每个数距离不超过K // swap[i] == true, 表示i位置已经参与过交换 // swap[i] == false, 表示i位置没有参与过交换 boolean[] isSwap = new boolean[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; int j = Math.min(i + (int) (Math.random() * (K + 1)), arr.length - 1); if (!isSwap[i] &amp;&amp; !isSwap[j]) &#123; isSwap[i] = true; isSwap[j] = true; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; &#125; return arr; &#125; // for test public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; // for test public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; // for test public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; // for test public static void main(String[] args) &#123; System.out.println(&quot;test begin&quot;); int testTime = 500000; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int k = (int) (Math.random() * maxSize) + 1; int[] arr = randomArrayNoMoveMoreK(maxSize, maxValue, k); int[] arr1 = copyArray(arr); int[] arr2 = copyArray(arr); sortedArrDistanceLessK(arr1, k); comparator(arr2, k); if (!isEqual(arr1, arr2)) &#123; succeed = false; System.out.println(&quot;K : &quot; + k); printArray(arr); printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;); &#125;&#125; 比较器 比较器的实质是重载比较运算符 比较器可以很好的应用在特殊标准的排序上 写代码变得异常容易，还用于泛型编程 比较器通用规则 a-b的return返回值，如果结果为： 负数,表示a排前，b在后，即升序 正数,表示b排前，a在后，即降序 0,表示ab相等 1234var arr=[3,12,23,43,11,6,123];function cmp(a,b)&#123;return a-b;&#125;//比较器arr.sort(cmp);//使用比较器console.log(String(arr));//3,6,11,12,23,43,123 利用比较器，自己实现动态小根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.util.ArrayList;import java.util.Comparator;import java.util.HashMap;import java.util.List;public class HeapGreater&lt;T&gt; &#123; // 利用比较器，自己实现动态的小根堆.即增删改后，始终都是小根堆。因为系统不提供动态的小根堆，只是一个静态的小根堆.关键就是节点索引记录表，知道了i,可以上窜或下窜。 // 加入小根堆的节点 private ArrayList&lt;T&gt; heap; // 节点索引记录表：加入过小根堆的节点对应的索引值 private HashMap&lt;T, Integer&gt; indexMap; private int heapSize; // 比较器规则 private Comparator&lt;? super T&gt; comp; public HeapGreater(Comparator&lt;? super T&gt; c) &#123; heap = new ArrayList&lt;&gt;(); indexMap = new HashMap&lt;&gt;(); heapSize = 0; comp = c; &#125; public boolean isEmpty() &#123; return heapSize == 0; &#125; public int size() &#123; return heapSize; &#125; public boolean contains(T obj) &#123; // 判断是否加入过小根堆 return indexMap.containsKey(obj); &#125; // 去除小根堆的顶部 public T peek() &#123; return heap.get(0); &#125; // 添加节点到小根堆 public void push(T obj) &#123; // 直接先添加 heap.add(obj); // 节点表添加节点索引 indexMap.put(obj, heapSize); // 上窜，并且按照cop比较器规则上窜 heapInsert(heapSize++); &#125; // 弹出小根堆顶部节点 public T pop() &#123; // 先取出要返回的节点，然后小根堆化 T ans = heap.get(0); // 交换到最后 swap(0, heapSize - 1); // 两个map同步删除 indexMap.remove(ans); heap.remove(--heapSize); // 把顶部节点下窜，并且按照cop比较器规则下窜 heapify(0); return ans; &#125; // 删除一个小根堆节点 public void remove(T obj) &#123; T replace = heap.get(heapSize - 1); int index = indexMap.get(obj); indexMap.remove(obj); heap.remove(--heapSize); if (obj != replace) &#123; heap.set(index, replace); indexMap.put(replace, index); resign(replace); &#125; &#125; // 更新了节点值，重置小根堆，使其小根堆化 public void resign(T obj) &#123; // 因为不确定节点是上窜还是下窜，关键就是这个索引值即记录表 // 要么上窜 heapInsert(indexMap.get(obj)); // 要么下窜 heapify(indexMap.get(obj)); &#125; // 请返回堆上的所有元素 public List&lt;T&gt; getAllElements() &#123; List&lt;T&gt; ans = new ArrayList&lt;&gt;(); for (T c : heap) &#123; ans.add(c); &#125; return ans; &#125; // 上窜 private void heapInsert(int index) &#123; // 按照比较器规则上窜，因为是负数，所以整体是升序，对应小根堆 while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) &lt; 0) &#123; swap(index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; // 下窜 private void heapify(int index) &#123; int left = index * 2 + 1; while (left &lt; heapSize) &#123; // 按照比较器规则下窜，因为是负数，所以整体是升序，对应小根堆 int best = left + 1 &lt; heapSize &amp;&amp; comp.compare(heap.get(left + 1), heap.get(left)) &lt; 0 ? (left + 1) : left; best = comp.compare(heap.get(best), heap.get(index)) &lt; 0 ? best : index; if (best == index) &#123; break; &#125; swap(best, index); index = best; left = index * 2 + 1; &#125; &#125; // 交换 private void swap(int i, int j) &#123; T o1 = heap.get(i); T o2 = heap.get(j); // heap有变动，indexMap也变动，强同步 heap.set(i, o2); heap.set(j, o1); indexMap.put(o2, i); indexMap.put(o1, j); &#125;&#125; 数组数组范围和关键词：利用前缀和，两者相减即为范围和 题目：求arr的2-3的范围和，如3+6=9 1234567891011121314151617181920212223public static void main (String[] args) throws java.lang.Exception &#123; int [] a = &#123;2,4,3,6,12,8,5,6,7,2,3,9&#125;; int b = rangeNum(a,2,4,getHelp(a)); System.out.println(b); &#125; public static int[] getHelp(int[] arr)&#123; // 利用前缀和数组辅助，差值就是范围和 int N = arr.length; int [] help=new int[N]; help[0]=arr[0]; for(int i =1;i&lt;N;i++)&#123; help[i]=help[i-1]+arr[i]; &#125; return help; &#125; public static int rangeNum(int[] arr,int L,int R,int[] help)&#123; //求数组任意范围的和,如求arr的3-7范围和等于help[7]-help[2] // 注意边界0 return L==0?help[R]:help[R]-help[L-1]; &#125; 随机数难倒英雄汉Math.random()等概率返回值 1234567891011121314151617181920212223242526272829/* package codechef; // don&#x27;t place package name! */import java.util.*;import java.lang.*;import java.io.*;/* Name of the class has to be &quot;Main&quot; only if the class is public. */class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; int testTimes = 10000000; int k = 6; int counts[] = new int[k]; for (int i = 0; i &lt; testTimes; i++) &#123; counts[f()]++; &#125; for (int i = 0; i &lt; k; i++) &#123; System.out.println(i + &quot;这个数，出现了 &quot; + counts[i] + &quot; 次&quot;); &#125; &#125; // 此函数只能用，不能修改 // 等概率返回1~5 public static int f() &#123; // (int) (Math.random() * k)表示等概率返回[0,k-1]范围值 return (int) (Math.random() * 5) + 1; &#125;&#125; 题目：已知15随机等概率，求17随机等概率 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* package codechef; // don&#x27;t place package name! */import java.util.*;import java.lang.*;import java.io.*;/* Name of the class has to be &quot;Main&quot; only if the class is public. */class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; int testTimes = 10000000; int k = 8; int counts[] = new int[k]; for (int i = 0; i &lt; testTimes; i++) &#123; counts[f06()]++; &#125; for (int i = 0; i &lt; k; i++) &#123; System.out.println(i + &quot;这个数，出现了 &quot; + counts[i] + &quot; 次&quot;); &#125; &#125; public static int f01()&#123; // 将1-5等概率转化为01等概率 int ans = 0; // do&#123; ans = f(); &#125;while(ans == 3); return ans &lt;3?0:1; &#125; public static int f07()&#123; // 通过01移位等概率返回0~7， return (f01()&lt;&lt;2)+(f01()&lt;&lt;1)+(f01()); &#125; public static int f06()&#123; //1~7等概率 // 将0~7等概率得到的7强制重新等概率，就变成了0~6等概率 int ans = 0; // do&#123; ans = f07(); &#125;while(ans == 7);// 如果遇到7，则继续等概率，使之不要出现7 return ans+1;//0~6等概率，然后+1，变成1~7等概率 &#125; // 此函数只能用，不能修改 // 等概率返回1~5 public static int f() &#123; // (int) (Math.random() * k)表示等概率返回[0,k-1]范围值 return (int) (Math.random() * 5) + 1; &#125;&#125; 题目：已知ab随机等概率，求cd随机等概率 思路： 1.将a~b等概率转化为01等概率发生器，利用do.while均分，剔除一些不要的 2.cd等价于0(k)等概率+c,其中k=d-c 3.求0~k等概率，利用二进制特性左移，求取等概率，其中某些数据不要则利用do.while均分，剔除一些不要的 题目：已知01随机不等概率，求01随机等概率 1234567891011121314151617181920// 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！ public static int x() &#123; return Math.random() &lt; 0.84 ? 0 : 1; &#125; // 等概率返回0和1 // f 0(p%) 1(1-p%) // 两两组合，只有01和10是等概率，另外两个推倒重做 // 00 pp // 11 (1-p)(1-p) // 01 p(1-p) // 10 (1-p)p public static int y() &#123; int ans = 0; do &#123; ans = x(); &#125; while (ans == x()); // 表示第一次和第二次的值相同，则继续循环即推倒重做 return ans; &#125; 字符串KMP算法参考 【天勤考研】KMP算法易懂版 KMP字符串匹配算法1 从头到尾彻底理解KMP KMP算法详解 定义KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。该算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的，以其名字首字母命名。 KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class KMP &#123; public static void main(String[] args) &#123; System.out.println(getIndexOf(&quot;sssb&quot;,&quot;sb&quot;)); &#125; public static int getIndexOf(String s, String m) &#123; // KMP算法核心：分2步走，s为主串，m为模板串 // 第一步：求解模板串的最长公共前后缀的长度值 // 第二步：主串和模板串比较，采用不进行主串回溯的比较方法，高效 if (s == null || m == null || m.length() &lt; 1 || s.length() &lt; m.length()) &#123; return -1; &#125; //下面就是KMP算法的全部步骤 char[] str1 = s.toCharArray(); char[] str2 = m.toCharArray(); int i1 = 0; int i2 = 0; // 第一步：求解模板串的最长公共前后缀的长度值 int[] next = getNextArray(str2); // 第二步：主串和模板串比较，采用不进行主串回溯的比较方法，高效 while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123; if (str1[i1] == str2[i2]) &#123; // 主串和模板串值相同，则继续后移比较 i1++; i2++; //-1为起始位置 &#125; else if (next[i2] == -1) &#123; // -1表示模板串的指针到首位了，则主串继续后移 i1++; &#125; else &#123; // 只要模板串的指针不是首位，则该指针继续回溯往前比较 i2 = next[i2]; &#125; &#125; //如果i2滑到最后了，那证明找到了，返回匹配的索引开始值；如果到最后都不等于，那返回负一，没找到 return i2 == str2.length ? i1 - i2 : -1; &#125; public static int[] getNextArray(char[] str2)&#123; // 求解最长公共前后缀表 /* 首先确定好第i个位置上的匹配长度L 第i+1位置匹配长度判断时，需要判断第i位置上匹配长度中前半段A的下个字符和第i位置上的字符进行比较 如果相等则第i+1位置匹配长度为L+1 如果不相等将前半段A的匹配长度读出，再分出A的前半段B，再返回步骤2，进行判断。 最后前半段中只包含整个字符串中的第一个字符，此时还不相等则返回0，相等则返回1。 */ if(str2.length == 1)&#123; return new int[] &#123;-1&#125;; &#125; int[] next = new int[str2.length]; next[0] = -1; next[1] = 0; //i代表数组开始的位置 int i = 2; //cn代表匹配的前后缀的最大长度 int cn = 0; while(i&lt;next.length)&#123; //如果前一个和最长串的相等，则直接最长串+1就是当前最长串 if(str2[i-1] == str2[cn])&#123; // 条件1 next[i++] = ++cn; &#125;else if(cn&gt;0)&#123; // 条件2 // 最长串有值且当前值不相等，则需要找上一个最长串，刚好是next[cn]，往前递归回溯，一直到满足条件1或3 cn = next[cn]; &#125;else&#123; // 条件3 // cn=0表示前面没有最长串，同时又不相等，则直接计算为0 next[i++] = 0; &#125; &#125; return next; &#125;&#125; 判断旋转词题目：旋转词是指，左侧部分字符整体搬移到右侧。例如：str=”123456”,str的旋转词有：“234561”，“345612”。。。判断str1=”113332”是不是str的旋转词？ 暴力方法：O(N2)，求出str所有旋转词，逐一匹配 最佳解法：str+str得到一个双倍长串，判断str1是否为长串的连续子串。很神奇喔，因为旋转后刚好和str+str长串一致。 判断二叉树T2是否为T1的子树题目：子树是指所有节点值相同，且小数的叶子节点也是大树的叶子节点。 解法1：暴力求解法 解法2：利用KMP算法 解法1：暴力求解法，逐一比较所有节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; // 判断二叉树T2是否为T1的子树 // T1 41235和T2 123 TreeNode tree1 = new TreeNode(4); tree1.left = new TreeNode(1); tree1.right = new TreeNode(5); tree1.left.left = new TreeNode(2); tree1.left.right = new TreeNode(3); TreeNode tree2 = new TreeNode(1); tree2.left = new TreeNode(2); tree2.right = new TreeNode(3); System.out.println(containsTree1(tree1,tree2)); &#125; public static class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; public TreeNode(int value)&#123; val = value; &#125; &#125; public static boolean containsTree1(TreeNode big,TreeNode small)&#123; // 判断小树是否为大树的子树 if(small == null)&#123; // 边界，小树为空 return true; &#125; if(big == null)&#123; // 边界，大树为空 return false; &#125; if(isSameValStructure(big,small))&#123; // 大树和小树的是否完全一样 return true; &#125; // 说明当前节点的数结构与小数不一样，则继续递归左右两边的节点 return containsTree1(big.left,small) || containsTree1(big.right,small); &#125; public static boolean isSameValStructure(TreeNode head1,TreeNode head2)&#123; // 判断两棵树是否完全相等 if(head1 == null &amp;&amp; head2 != null)&#123; return false; &#125; if(head1 != null &amp;&amp; head2 == null)&#123; return false; &#125; if(head1 == null &amp;&amp; head2 == null)&#123; // 说明完全相等 return true; &#125; if(head1.val != head2.val)&#123; return false; &#125; // 递归各个子节点 return isSameValStructure(head1.left,head2.left)&amp;&amp;isSameValStructure(head1.right,head2.right); &#125;&#125; 解法2：KMP算法，将T1，T2两棵树先序遍历转为数组，然后判断T2是否为T1的子串数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.util.ArrayList;public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; // 判断二叉树T2是否为T1的子树 // T1 41235和T2 123 TreeNode tree1 = new TreeNode(4); tree1.left = new TreeNode(1); tree1.right = new TreeNode(5); tree1.left.left = new TreeNode(2); tree1.left.right = new TreeNode(3); TreeNode tree2 = new TreeNode(1); tree2.left = new TreeNode(2); tree2.right = new TreeNode(3); System.out.println(containsTree2(tree1,tree2)); &#125; public static class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; public TreeNode(int value)&#123; val = value; &#125; &#125; public static boolean containsTree2(TreeNode big,TreeNode small)&#123; // 利用KMP子串特性巧妙求解，核心：先把树转为字符串数组，然后利用kmp算法求解 // 判断小树是否为大树的子树 if(small == null)&#123; // 边界，小树为空 return true; &#125; if(big == null)&#123; // 边界，大树为空 return false; &#125; ArrayList &lt;String&gt; b = preSerial(big); ArrayList &lt;String&gt; s = preSerial(small); String[] str = new String[b.size()]; for(int i =0;i&lt;str.length;i++)&#123; str[i] = b.get(i); &#125; String[] match = new String[s.size()]; for(int i =0;i&lt;match.length;i++)&#123; match[i] = s.get(i); &#125; return getIndexOf(str,match) != -1; &#125; public static ArrayList &lt;String&gt; preSerial(TreeNode head)&#123; // 将树结构通过先序遍历转为数组 ArrayList &lt;String&gt; ans = new ArrayList&lt;&gt;(); pres(head,ans); return ans; &#125; public static void pres(TreeNode head,ArrayList &lt;String&gt; ans)&#123; // 先序遍历 if(head == null)&#123; // 树为空则填充空值 ans.add(null); &#125;else&#123; ans.add(String.valueOf(head.val)); pres(head.left,ans); pres(head.right,ans); &#125; &#125; public static int getIndexOf(String[] str1,String[] str2)&#123; // 判断字符串数组是否存在KMP子串数组 if(str1 == null||str2 == null || str1.length == 0 ||str1.length &lt; str2.length)&#123; return -1; &#125; int x = 0; int y = 0; int[] next = getNextArray(str2); while(x&lt;str1.length&amp;&amp;y&lt;str2.length)&#123; if(isEqual(str1[x],str2[y]))&#123; x++; y++; &#125;else if(next[y] == -1)&#123; x++; &#125;else&#123; y = next[y]; &#125; &#125; return y == str2.length?x-y:-1; &#125; public static int[] getNextArray(String[] ms)&#123; if(ms.length == 1)&#123; return new int[]&#123;-1&#125;; &#125; int[] next = new int[ms.length]; next[0] = -1; next[1] = 0; int i =2; int cn = 0; while(i&lt;next.length)&#123; if(isEqual(ms[i-1],ms[cn]))&#123; next[i++] = ++cn; &#125;else if (cn&gt;0)&#123; cn = next[cn]; &#125;else&#123; next[i++] = 0; &#125; &#125; return next; &#125; public static boolean isEqual(String a,String b)&#123; // 判断两个字符串是否相等 if(a == null &amp;&amp; b==null)&#123; return true; &#125;else&#123; if(a==null||b==null)&#123; return false; &#125;else&#123; return a.equals(b); &#125; &#125; &#125;&#125; 单链表没有复杂的数据结构，纯记忆多做即可 单链表反转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;import java.lang.*;import java.io.*;class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; // 单链表反转，注意一定要有返回值的头结点，否则容易断链 Node node0 = new Node(0); node0.next = new Node(1); node0.next.next = new Node(2); node0.next.next.next = new Node(3); print(node0); System.out.println(); node0 = reverseLinkedList(node0); print(node0); &#125; public static Node reverseLinkedList(Node head)&#123; // 单链表反转。 //注意一定要有返回值，让头结点指针指向第一个节点。否则头结点只能指向最后一个节点，导致其他节点丢失 Node pre = null; Node next = null; while(head != null)&#123; // 先将当前节点的下个节点临时保存下 next = head.next; // 把当前节点的下一个节点往前指 head.next = pre; // 把前一个节点变成当前，方便下一次继续往前指 pre = head; // 上面就已经完成了反转，但还需要继续遍历下去，所以用到了第一步临时的next head = next; &#125; // 当node为空，停止，并返回反转后的第一个节点pre return pre; &#125; public static class Node&#123; // 单链表结构 public int value; public Node next; public Node(int val)&#123; value = val; &#125; &#125; public static void print(Node node)&#123; while(node !=null)&#123; System.out.print(node.value+&quot;-&gt;&quot;); node = node.next; &#125; &#125;&#125; 双链表反转1234567891011121314151617181920public static Node reverseDoubleList(Node head)&#123; // 单链表反转。 //注意一定要有返回值，让头结点指针指向第一个节点。否则头结点只能指向最后一个节点，导致其他节点丢失 Node pre = null; Node next = null; while(head != null)&#123; // 先将当前节点的下个节点临时保存下 next = head.next; // 把当前节点的下一个节点往前指 head.next = pre; // 把当前节点的上一个节点往后指 head.last = next; // 把前一个节点变成当前，方便下一次继续往前指 pre = head; // 上面就已经完成了反转，但还需要继续遍历下去，所以用到了第一步临时的next head = next; &#125; // 当node为空，停止，并返回反转后的第一个节点pre return pre; &#125; 用单链表结构实现队列先进先出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.*;import java.lang.*;import java.io.*;class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; //基于单链表结构实现的队列 MyQueue mq = new MyQueue(); mq.offer(1); mq.offer(2); mq.offer(3); for(int i =0;i&lt;3;i++)&#123; System.out.print(mq.poll()+&quot;-&gt;&quot;); &#125; &#125; public static class Node&lt;V&gt; &#123; // value的类型为泛型，单链表结构 public V value; public Node&lt;V&gt; next; public Node(V v) &#123; value = v; next = null; &#125; &#125; public static class MyQueue&lt;V&gt; &#123; // 基于链表结构的队列，先进先出。只需要记录头尾指针，内部的跳转使用单链表关联起来。 // 头指针 private Node&lt;V&gt; head; // 尾指针 private Node&lt;V&gt; tail; private int size; public MyQueue() &#123; head = null; tail = null; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public void offer(V value) &#123; // 队列添加数据 // cur是单链表结构 Node&lt;V&gt; cur = new Node&lt;V&gt;(value); if (tail == null) &#123; // 全空，则头尾指针指向当前节点 head = cur; tail = cur; &#125; else &#123; // 尾巴的节点先指向当前节点 tail.next = cur; // 然后尾巴指针指向当前节点 tail = cur; &#125; size++; &#125; // C/C++的同学需要做节点析构的工作 public V poll() &#123; // 队列弹出数据 V ans = null; if (head != null) &#123; // 直接取出头指针节点 ans = head.value; // 头指针下移一个 head = head.next; size--; &#125; if (head == null) &#123; tail = null; &#125; return ans; &#125; // C/C++的同学需要做节点析构的工作 public V peek() &#123; // 查询队列的头结点 V ans = null; if (head != null) &#123; ans = head.value; &#125; return ans; &#125; &#125;&#125; 用单链表结构实现栈先进后出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class MyStack&lt;V&gt; &#123; // 基于链表结构的栈，先进后出。 // 只需要用到一个头指针 private Node&lt;V&gt; head; private int size; public MyStack() &#123; head = null; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public void push(V value) &#123; // 栈添加数据 Node&lt;V&gt; cur = new Node&lt;&gt;(value); if (head == null) &#123; head = cur; &#125; else &#123; // 当前节点的下一个指向老头节点 cur.next = head; // 新头指向当前节点 head = cur; &#125; size++; &#125; public V pop() &#123; // 栈弹出数据 V ans = null; if (head != null) &#123; ans = head.value; head = head.next; size--; &#125; return ans; &#125; public V peek() &#123; // 查看栈顶数据 return head != null ? head.value : null; &#125; &#125; 用双链表结构实现双端队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import java.util.*;import java.lang.*;import java.io.*;class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; //基于双链表结构实现的双端队列，队列的头部和尾部都可以添加和删除元素 MyDeque mq = new MyDeque(); mq.pushHead(1); mq.pushHead(2); mq.pushHead(3); for(int i =0;i&lt;3;i++)&#123; System.out.print(mq.pollHead()+&quot;-&gt;&quot;); &#125; &#125; public static class Node&lt;V&gt; &#123; // 双链表，不复杂，就是两个指针，一个往前指，一个往后指 public V value; public Node&lt;V&gt; last; public Node&lt;V&gt; next; public Node(V v) &#123; value = v; last = null; next = null; &#125; &#125; public static class MyDeque&lt;V&gt; &#123; // 基于双链表实现的双端队列，即头部可添加删除元素，尾部也可添加删除元素 // 依然是头指针和尾指针 private Node&lt;V&gt; head; private Node&lt;V&gt; tail; private int size; public MyDeque() &#123; head = null; tail = null; size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public void pushHead(V value) &#123; // 头部添加元素 Node&lt;V&gt; cur = new Node&lt;&gt;(value); if (head == null) &#123; // 先判空，头尾指针都指向当前节点 head = cur; tail = cur; &#125; else &#123; // 当前节点的下一个指针指向老头指针 cur.next = head; // 老头指针指向当前节点 head.last = cur; // 头指针变成当前节点 head = cur; &#125; // 队列长度+1 size++; &#125; public void pushTail(V value) &#123; // 尾部添加元素 Node&lt;V&gt; cur = new Node&lt;&gt;(value); if (head == null) &#123; head = cur; tail = cur; &#125; else &#123; tail.next = cur; cur.last = tail; tail = cur; &#125; size++; &#125; public V pollHead() &#123; // 头部弹出元素 V ans = null; if (head == null) &#123; return ans; &#125; size--; ans = head.value; if (head == tail) &#123; head = null; tail = null; &#125; else &#123; head = head.next; head.last = null; &#125; return ans; &#125; public V pollTail() &#123; // 尾部弹出元素 V ans = null; if (head == null) &#123; return ans; &#125; size--; ans = tail.value; if (head == tail) &#123; head = null; tail = null; &#125; else &#123; tail = tail.last; tail.next = null; &#125; return ans; &#125; public V peekHead() &#123; // 头部查询元素 V ans = null; if (head != null) &#123; ans = head.value; &#125; return ans; &#125; public V peekTail() &#123; // 尾部查询元素 V ans = null; if (tail != null) &#123; ans = tail.value; &#125; return ans; &#125; &#125;&#125; 单链表的k个节点的组内逆序调整12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.*;import java.lang.*;import java.io.*;class Codechef&#123; public static void main (String[] args) throws java.lang.Exception &#123; // 该算法难度为hard,一定要画图，否则玩个6啊 // 测试链接：https://leetcode.com/problems/reverse-nodes-in-k-group/ //单链表的k个节点的组内逆序调整，不足k个的不需要逆序。 // 1-2-3-4-5-6-7-8逆序后3-2-1-6-5-4-7-8 ListNode node = new ListNode(1); node.next = new ListNode(2); node.next.next = new ListNode(3); node.next.next.next = new ListNode(4); node.next.next.next.next = new ListNode(5); node.next.next.next.next.next = new ListNode(6); node.next.next.next.next.next.next = new ListNode(7); node.next.next.next.next.next.next.next = new ListNode(8); node = reverseKGroup(node,3); for(int i =0;i&lt;8;i++)&#123; System.out.print(node.val+&quot;-&gt;&quot;); node = node.next; &#125; &#125; // 不要提交这个类 public static class ListNode&lt;V&gt; &#123; public V val; public ListNode&lt;V&gt; next; public ListNode(V value)&#123; val = value; next = null; &#125; &#125; public static ListNode reverseKGroup(ListNode head, int k) &#123; ListNode start = head; ListNode end = getKGroupEnd(start, k); if (end == null) &#123; // 不足一组k个的情况，不用反转，直接返回头结点 return head; &#125; // 第一组凑齐了！ head = end; // 第一组直接反转 reverse(start, end); // 当前组的最后一个节点是逆序后的原头节点 ListNode lastEnd = start; while (lastEnd.next != null) &#123; // 继续组内的头结点到尾节点的反转操作 start = lastEnd.next; end = getKGroupEnd(start, k); if (end == null) &#123; // 当前组不需要反转，直接返回外层的头结点 return head; &#125; reverse(start, end); // 逆序后，上一组的尾节点指向当前组的逆序后的头节点 lastEnd.next = end; // 将上一组的尾节点变为当前组的逆序后的尾节点 lastEnd = start; &#125; return head; &#125; public static ListNode getKGroupEnd(ListNode start, int k) &#123; // 已知节点，获取同组第k个节点 while (--k != 0 &amp;&amp; start != null) &#123; // k=0表示k个节点，同时节点不能为空 // 根据链表特性，依次获取下去 start = start.next; &#125; // 返回从开始节点算起的第k个节点 return start; &#125; public static void reverse(ListNode start, ListNode end) &#123; // 将一组内的k个节点，全部反转 // 先将尾指针指向最后一个的下一个 end = end.next; ListNode pre = null; // 将头节点给起当前节点 ListNode cur = start; ListNode next = null; // 循环逆序当前这一组 while (cur != end) &#123; // 链表反转的经典常规操作 next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; // 原来的头结点指向下一组的第一个节点 start.next = end; &#125;&#125; 两个链表相加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.*;import java.lang.*;import java.io.*;class Codechef&#123; // 测试链接：https://leetcode.com/problems/add-two-numbers/ public static void main (String[] args) throws java.lang.Exception &#123; // 两个链表相加，计算进位信息 // 1-2-3-4和9-4-8-9-9相加得0-7-1-4-0-1 ListNode node = new ListNode(1); node.next = new ListNode(2); node.next.next = new ListNode(3); node.next.next.next = new ListNode(4); ListNode node1 = new ListNode(9); node1.next = new ListNode(4); node1.next.next = new ListNode(8); node1.next.next.next = new ListNode(9); node1.next.next.next.next = new ListNode(9); node = addTwoNumbers(node,node1); while(node != null)&#123; System.out.print(node.val+&quot;-&gt;&quot;); node = node.next; &#125; &#125; // 不要提交这个类 public static class ListNode &#123; public int val; public ListNode next; public ListNode(int val) &#123; this.val = val; &#125; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125; public static ListNode addTwoNumbers(ListNode head1, ListNode head2) &#123; // 两个链表相加，从左到右依次为低位到高位，有进位要计算进位 int len1 = listLength(head1); int len2 = listLength(head2); // 获取两个链表中的哪一个长，哪一个短一些 ListNode l = len1 &gt;= len2 ? head1 : head2; ListNode s = l == head1 ? head2 : head1; /* 计算分三步走： 第一步：l节点有值，s节点有值，则直接计算ls包括进位符，该进位进位 第二步：l有值，s无值，则直接计算l包括进位符，该进位进位 第三部：l无值，s无值，则看进位符是否有，高位新增一个节点，保存进位值 */ ListNode curL = l; ListNode curS = s; ListNode last = curL; // 表示当前进位符 int carry = 0; int curNum = 0; while (curS != null) &#123; // 第一步，l+s+carry进位符 curNum = curL.val + curS.val + carry; // 取余，最终结果复制到长链表中 curL.val = (curNum % 10); // 更新进位符 carry = curNum / 10; // 时刻跟随最新的节点 last = curL; // 长短链表，依次往下指 curL = curL.next; curS = curS.next; &#125; while (curL != null) &#123; // 第二步 curNum = curL.val + carry; curL.val = (curNum % 10); carry = curNum / 10; last = curL; curL = curL.next; &#125; if (carry != 0) &#123; // 第三步，如果最后一个还有进位，则追加一个链表节点到最后 last.next = new ListNode(1); &#125; return l; &#125; // 求链表长度 public static int listLength(ListNode head) &#123; int len = 0; while (head != null) &#123; len++; head = head.next; &#125; return len; &#125;&#125; 链表套路套路： 对于笔试，不用关注空间复杂度，一切为了时间复杂度。比如：hash表，数组等 对于面试，时间复杂度依然第一，还要找到空间最省的方法。比如：快慢指针 快慢指针定义：一般情况下，快指针的移动步长为慢指针的两倍。利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以 此来 达到找到中间节点的目的。 题目： 输入链表头结点，奇数长度返回中点，偶数长度返回上中点 输入链表头结点，奇数长度返回中点，偶数长度返回下中点 输入链表头结点，奇数长度返回中点前一个，偶数长度返回上中点前一个 输入链表头结点，奇数长度返回中点前一个，偶数长度返回下中点前一个 解法1：暴力求解，把节点加入到数组中，二分取值—用于笔试 解法2：快慢指针，—用于面试，如果笔试中能写出也可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import java.util.ArrayList;public class Code01_LinkedListMid &#123; public static class Node &#123; public int value; public Node next; public Node(int v) &#123; value = v; &#125; &#125; // 判断链表中是否存在环 public boolean hasCycle(Node head) &#123; if (head == null) return false; //快慢两个指针，初始时都指向链表的头结点 Node slow = head; Node fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; //慢指针每次走一步 slow = slow.next; //快指针每次走两步 fast = fast.next.next; //如果相遇，说明有环，直接返回true if (slow == fast) return true; &#125; //否则就是没环 return false; &#125; // 题目1：解法2：快慢指针，---用于面试，如果笔试中能写出也可以 public static Node midOrUpMidNode(Node head) &#123; // 链表没有节点，有1个节点，2个节点 if (head == null || head.next == null || head.next.next == null) &#123; return head; &#125; // 链表有3个点或以上 // 根据题意，确定快慢指针的起始位置，起始值位置不用记忆，直接按照结果尝试奇偶即可 Node slow = head.next; Node fast = head.next.next; // 快慢指针的走法都是每次慢指针走一步，快指针走两步 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // 题目2 public static Node midOrDownMidNode(Node head) &#123; if (head == null || head.next == null) &#123; return head; &#125; Node slow = head.next; Node fast = head.next; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // 题目3 public static Node midOrUpMidPreNode(Node head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return null; &#125; Node slow = head; Node fast = head.next.next; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // 题目4 public static Node midOrDownMidPreNode(Node head) &#123; if (head == null || head.next == null) &#123; return null; &#125; if (head.next.next == null) &#123; return head; &#125; Node slow = head; Node fast = head.next; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; // 题目1：解法1：暴力求解，把节点加入到数组中，二分取值---用于笔试 public static Node right1(Node head) &#123; if (head == null) &#123; return null; &#125; Node cur = head; ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;(); while (cur != null) &#123; arr.add(cur); cur = cur.next; &#125; return arr.get((arr.size() - 1) / 2); &#125; public static Node right2(Node head) &#123; if (head == null) &#123; return null; &#125; Node cur = head; ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;(); while (cur != null) &#123; arr.add(cur); cur = cur.next; &#125; return arr.get(arr.size() / 2); &#125; public static Node right3(Node head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return null; &#125; Node cur = head; ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;(); while (cur != null) &#123; arr.add(cur); cur = cur.next; &#125; return arr.get((arr.size() - 3) / 2); &#125; public static Node right4(Node head) &#123; if (head == null || head.next == null) &#123; return null; &#125; Node cur = head; ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;(); while (cur != null) &#123; arr.add(cur); cur = cur.next; &#125; return arr.get((arr.size() - 2) / 2); &#125; public static void main(String[] args) &#123; Node test = null; test = new Node(0); test.next = new Node(1); test.next.next = new Node(2); test.next.next.next = new Node(3); test.next.next.next.next = new Node(4); test.next.next.next.next.next = new Node(5); test.next.next.next.next.next.next = new Node(6); test.next.next.next.next.next.next.next = new Node(7); test.next.next.next.next.next.next.next.next = new Node(8); Node ans1 = null; Node ans2 = null; ans1 = midOrUpMidNode(test); ans2 = right1(test); System.out.println(ans1 != null ? ans1.value : &quot;无&quot;); System.out.println(ans2 != null ? ans2.value : &quot;无&quot;); ans1 = midOrDownMidNode(test); ans2 = right2(test); System.out.println(ans1 != null ? ans1.value : &quot;无&quot;); System.out.println(ans2 != null ? ans2.value : &quot;无&quot;); ans1 = midOrUpMidPreNode(test); ans2 = right3(test); System.out.println(ans1 != null ? ans1.value : &quot;无&quot;); System.out.println(ans2 != null ? ans2.value : &quot;无&quot;); ans1 = midOrDownMidPreNode(test); ans2 = right4(test); System.out.println(ans1 != null ? ans1.value : &quot;无&quot;); System.out.println(ans2 != null ? ans2.value : &quot;无&quot;); &#125;&#125; 链表是否回文题目：给定一个单链表头结点head,请判断该链表是否为回文结构 栈方法特别简单—笔试用 改原链表的方法就需要注意边界—面试用 解法： 解法1：把链表所有节点放进栈中，然后逐一出栈(相当于逆序)和链表逐一比对 解法2：利用快慢指针，找到中点或上中点。中点以后的节点全部入栈，然后逐一出栈(相当于逆序)和链表逐一比对，直到栈空为止。可以想象成纸对折逐一比对。 解法3：不使用额外空间，利用快慢指针，找到中点或上中点。中点以后的节点全部逆序指向，定义左右两个指针，逐一比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206import java.util.Stack;public class Code02_IsPalindromeList &#123; public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125; &#125; // 解法1：把链表所有节点放进栈中，然后逐一出栈(相当于逆序)和链表逐一比对 public static boolean isPalindrome1(Node head) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node cur = head; while (cur != null) &#123; stack.push(cur); cur = cur.next; &#125; while (head != null) &#123; if (head.value != stack.pop().value) &#123; return false; &#125; head = head.next; &#125; return true; &#125; // 解法2：利用快慢指针，找到中点或上中点。中点以后的节点全部入栈，然后逐一出栈(相当于逆序)和链表逐一比对，直到栈空为止。可以想象成纸对折逐一比对。 public static boolean isPalindrome2(Node head) &#123; if (head == null || head.next == null) &#123; return true; &#125; Node right = head.next; Node cur = head; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; right = right.next; cur = cur.next.next; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (right != null) &#123; stack.push(right); right = right.next; &#125; while (!stack.isEmpty()) &#123; if (head.value != stack.pop().value) &#123; return false; &#125; head = head.next; &#125; return true; &#125; // 解法3：不使用额外空间，利用快慢指针，找到中点或上中点。中点以后的节点全部逆序指向，定义左右两个指针，逐一比较。 public static boolean isPalindrome3(Node head) &#123; /* * 1-&gt;2-&gt;3-&gt;-&gt;3-&gt;2-&gt;1 * null * ^ * | * 1-&gt;2-3&lt;&lt;-3&lt;-2&lt;-1 * n2 n1 n3 * */ if (head == null || head.next == null) &#123; return true; &#125; Node n1 = head;// 慢指针 Node n2 = head;// 快指针 while (n2.next != null &amp;&amp; n2.next.next != null) &#123; // find mid node n1 = n1.next; // n1 -&gt; mid n2 = n2.next.next; // n2 -&gt; end &#125; // n1 中点 // 把n1以后的节点全部逆序指向 n2 = n1.next; // n2 -&gt; right part first node n1.next = null; // mid.next -&gt; null Node n3 = null; while (n2 != null) &#123; // right part convert n3 = n2.next; // n3 -&gt; save next node n2.next = n1; // next of right node convert n1 = n2; // n1 move n2 = n3; // n2 move &#125; // 临时记录下右节点 n3 = n1; // n3 -&gt; save last node n2 = head;// n2 -&gt; left first node boolean res = true; // 比较左右节点是否相等 while (n1 != null &amp;&amp; n2 != null) &#123; // check palindrome if (n1.value != n2.value) &#123; res = false; break; &#125; n1 = n1.next; // left to mid n2 = n2.next; // right to mid &#125; // 将n3-...&gt;n1指向逆序还原回来 n1 = n3.next; n3.next = null; while (n1 != null) &#123; // recover list n2 = n1.next; n1.next = n3; n3 = n1; n1 = n2; &#125; return res; &#125; public static void printLinkedList(Node node) &#123; System.out.print(&quot;Linked List: &quot;); while (node != null) &#123; System.out.print(node.value + &quot; &quot;); node = node.next; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Node head = null; printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); head.next.next = new Node(3); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); head.next.next = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); head.next.next = new Node(3); head.next.next.next = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); head.next.next = new Node(2); head.next.next.next = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); head = new Node(1); head.next = new Node(2); head.next.next = new Node(3); head.next.next.next = new Node(2); head.next.next.next.next = new Node(1); printLinkedList(head); System.out.print(isPalindrome1(head) + &quot; | &quot;); System.out.print(isPalindrome2(head) + &quot; | &quot;); System.out.println(isPalindrome3(head) + &quot; | &quot;); printLinkedList(head); System.out.println(&quot;=========================&quot;); &#125;&#125; 链表的复制题目：一种特殊的单链表结构，其中有个Node rand随机属性。rand可能指向任意节点，也可能指向null.请设计一个函数完成这个链表的复制，返回复制的链表的头结点。 解法1：把所有节点放入hashmap,从头结点开始遍历，依次copy出新链表 解法2：在每个节点后面插入前一个节点的copy节点，然后设置radom，再分离新老节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.HashMap;// 测试链接 : https://leetcode.com/problems/copy-list-with-random-pointer/public class Code04_CopyListWithRandom &#123; public static class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125; &#125; // 解法1：把所有节点放入hashmap,从头结点开始遍历，依次copy出新链表 public static Node copyRandomList1(Node head) &#123; // key 老节点 // value 新节点 HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;(); Node cur = head; // 所有节点放入hashmap while (cur != null) &#123; map.put(cur, new Node(cur.val)); cur = cur.next; &#125; cur = head; // 从头结点开始遍历，依次copy while (cur != null) &#123; // cur 老节点 // map.get(cur) 新节点 // 新.next -&gt; cur.next克隆节点找到 map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; &#125; return map.get(head); &#125; // 解法2：在每个节点后面插入前一个节点的copy节点，然后设置radom，再分离新老节点 public static Node copyRandomList2(Node head) &#123; if (head == null) &#123; return null; &#125; Node cur = head; Node next = null; // 1 -&gt; 2 -&gt; 3 -&gt; null // 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; // 每个节点后面插入前一个节点的copy节点 while (cur != null) &#123; next = cur.next; cur.next = new Node(cur.val); cur.next.next = next; cur = next; &#125; cur = head; Node copy = null; // 1 1&#x27; 2 2&#x27; 3 3&#x27;， 其中1‘是1的复制节点 // 依次设置 1&#x27; 2&#x27; 3&#x27; 的random指针 while (cur != null) &#123; next = cur.next.next; copy = cur.next; // 注意cur.random的节点 一定是对应cur.random.next。因为下一个节点是当前节点的复制。 copy.random = cur.random != null ? cur.random.next : null; cur = next; &#125; Node res = head.next; cur = head; // 老 新 混在一起，next方向上，random正确 // next方向上，把新老链表分离，一定动手实际画图，想是想不清楚的 while (cur != null) &#123; next = cur.next.next; copy = cur.next; cur.next = next; copy.next = next != null ? next.next : null; cur = next; &#125; return res; &#125;&#125; 两链表是否相交题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实 现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返 回null。要求时间复杂度O(N),空间复杂度O(1) 思路：这是一个超大题目。涉及知识点： 必考知识点：找到链表第一个入环节点，如果无环，返回null 必考知识点：如果两个链表都无环，返回第一个相交节点，如果不想交，返回null 必考知识点：两个有环链表，返回第一个相交节点，如果不想交返回null 解法： 解法：先求链表的入环节点，然后按照无环和有环分情况讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190public class Code01_FindFirstIntersectNode &#123; public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125; &#125; public static Node getIntersectNode(Node head1, Node head2) &#123; // 解法：先求链表的入环节点，然后按照无环和有环分情况讨论 if (head1 == null || head2 == null) &#123; return null; &#125; // 找到链表第一个入环节点，如果无环，返回null Node loop1 = getLoopNode(head1); Node loop2 = getLoopNode(head2); // 如果两个链表都是无环链表 if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1, head2); &#125; // 如果两个链表都是有环链表 if (loop1 != null &amp;&amp; loop2 != null) &#123; return bothLoop(head1, loop1, head2, loop2); &#125; // 一链表有环，一链表无环，一定不会相交。画画图就知道了 return null; &#125; // 必考知识点：找到链表第一个入环节点，如果无环，返回null public static Node getLoopNode(Node head) &#123; /* * 解法1：用额外空间，遍历链表，每到一个节点就判断是否在Set里，如果突然发现在了。说明是第一个入环节点。 * 解法2：快慢指针，慢指针一定不会走够两圈以上，在环内相遇时，将快指针放到开头，慢指针原地不动。然后两个开始一次走一步，最后会在入环节点相遇。本文采用解法2. * */ if (head == null || head.next == null || head.next.next == null) &#123; return null; &#125; // n1 慢指针 n2 快指针，让n1,n2都先走一次，方便下面的while判断 Node slow = head.next; // n1 -&gt; slow Node fast = head.next.next; // n2 -&gt; fast while (slow != fast) &#123; if (fast.next == null || fast.next.next == null) &#123; return null; &#125; fast = fast.next.next; slow = slow.next; &#125; // 到这里，说明slow fast 相遇了 // 抖机灵做法：快指针回到头结点，然后快慢指针再次相遇，就是入环节点 fast = head; // n2 -&gt; walk again from head while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125; // 必考知识点：如果两个链表都无环，返回第一个相交节点，如果不想交，返回null public static Node noLoop(Node head1, Node head2) &#123; /* * 先统计head1到end1并且记住长度假设是100，然后统计head2和end2并且记住长度假设是80。如果end1！=end2则没有相交部分。 * 如果一样，则head1先走20步，然后一起走直到找到相同内存的节点，即相交节点。可以通过n记录链表一和二的长度之差，节约一个变量。 * */ if (head1 == null || head2 == null) &#123; return null; &#125; Node cur1 = head1; Node cur2 = head2; int n = 0; while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; // 因为是无环链表，如果最后的节点都不相同，结果一定是不相交，后续不用执行 if (cur1 != cur2) &#123; return null; &#125; // n 表示链表1长度减去链表2长度的值 cur1 = n &gt; 0 ? head1 : head2; // 谁长，谁的头变成cur1 cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2 n = Math.abs(n); // 长链表减去多余的部分，然后一起往下走 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; // 如果相遇，则是相交点 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; // 必考知识点：两个有环链表，返回第一个相交节点，如果不想交返回null public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; /* * 情况1：如果有入环节点相同 * 情况2:如果有入环点不同，可能有两个入环点 * 情况3：如果有入环点不同，可能不相交 * */ Node cur1 = null; Node cur2 = null; // 情况1：和前面的无环链表判断类似，只不过节点找到入环节点就可以，也没有入环节点的判断 if (loop1 == loop2) &#123; cur1 = head1; cur2 = head2; int n = 0; while (cur1 != loop1) &#123; n++; cur1 = cur1.next; &#125; while (cur2 != loop2) &#123; n--; cur2 = cur2.next; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; n = Math.abs(n); while (n != 0) &#123; n--; cur1 = cur1.next; &#125; while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; else &#123; // 情况2 cur1 = loop1.next; // 链表1从自己的入环点开始遍历一圈，找下是否有节点和链表2的入环点相同，相同即返回节点 while (cur1 != loop1) &#123; if (cur1 == loop2) &#123; return loop1;// 或返回loop2都行，因为有2个入环点，随便一个都可以 &#125; cur1 = cur1.next; &#125; //情况3 return null; &#125; &#125; public static void main(String[] args) &#123; // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null Node head1 = new Node(1); head1.next = new Node(2); head1.next.next = new Node(3); head1.next.next.next = new Node(4); head1.next.next.next.next = new Node(5); head1.next.next.next.next.next = new Node(6); head1.next.next.next.next.next.next = new Node(7); // 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null Node head2 = new Node(0); head2.next = new Node(9); head2.next.next = new Node(8); head2.next.next.next = head1.next.next.next.next.next; // 8-&gt;6 System.out.println(getIntersectNode(head1, head2).value); // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4... head1 = new Node(1); head1.next = new Node(2); head1.next.next = new Node(3); head1.next.next.next = new Node(4); head1.next.next.next.next = new Node(5); head1.next.next.next.next.next = new Node(6); head1.next.next.next.next.next.next = new Node(7); head1.next.next.next.next.next.next = head1.next.next.next; // 7-&gt;4 // 0-&gt;9-&gt;8-&gt;2... head2 = new Node(0); head2.next = new Node(9); head2.next.next = new Node(8); head2.next.next.next = head1.next; // 8-&gt;2 System.out.println(getIntersectNode(head1, head2).value); // 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6.. head2 = new Node(0); head2.next = new Node(9); head2.next.next = new Node(8); head2.next.next.next = head1.next.next.next.next.next; // 8-&gt;6 System.out.println(getIntersectNode(head1, head2).value); &#125;&#125; 不给头结点删除节点题目：能不能不给单链表的头结点，只给想要删除的节点，就能做到在链表上把这个点删除掉？ 解法：抖机灵的做法，把删除节点的下一个节点复制到当前节点，删除下一个节点。 弊端：无法删除链表最后一个节点；因为是复制节点，如果节点表示服务器，那就不可能这么操作。 二叉树二叉树遍历 先序遍历：对于所有子树，先访问头结点-左节点-右节点 中序遍历：对于所有子树，先访问左结点-头节点-右节点 后序遍历：对于所有子树，先访问左结点-右节点-头节点 题目：二叉树节点结构 第一层1 第二层2 3 第三层 4 5 6 7。 递归遍历 递归序：1，2，4，4，4，5，5，5，2，1，3，6，6，6，3，7，7，7，3，1 相当于第一次到自己的时候输出一下，然后左子树走完后输出一下，右子树走完后输出一下。这是递归实现，所有的递归都可以用非递归替代。 先序遍历（头左右）：1，2，4，5，3，6，7 相当于递归序里第一次来到的时候打印，第二三次到的时候什么也不做 中序遍历（左头右）：4，2，5，1，6，3，7 相当于递归序里第二次来到的时候打印，第一三次到的时候什么也不做 后序遍历（左右头）：4，2，5，1，6，3，7 相当于递归序里第三次来到的时候打印，第一二次到的时候什么也不做 1234567891011121314151617181920212223// 传统二叉树递归遍历public static void pre(Node head) &#123; if (head == null) &#123; return; &#125; System.out.println(&quot;先序遍历&quot; + head.value); pre(head.left); System.out.println(&quot;中序遍历&quot; + head.value); pre(head.right); System.out.println(&quot;后序遍历&quot; + head.value);&#125;// 递归序遍历public static void f(Node head) &#123; if (head == null) &#123; return; &#125; // 1-第1次到达 f(head.left); // 2-第2次到达 f(head.right); // 3-第2次到达&#125; 非递归遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import java.util.Stack;public class Code03_UnRecursiveTraversalBT &#123; public static class Node &#123; public int value; public Node left; public Node right; public Node(int v) &#123; value = v; &#125; &#125; // 先序遍历 /*用栈实现：因为栈的特性是先进后出，右比左先压入，所以先打印左然后右 * 1.栈压入头结点 * 2.栈弹出节点，打印 * 3.如果右节点存在，压入右节点 * 4.如果左节点存在，压入左节点 * 5.循环2,3,4 * */ public static void pre(Node head) &#123; System.out.print(&quot;pre-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.add(head); while (!stack.isEmpty()) &#123; head = stack.pop(); System.out.print(head.value + &quot; &quot;); if (head.right != null) &#123; stack.push(head.right); &#125; if (head.left != null) &#123; stack.push(head.left); &#125; &#125; &#125; System.out.println(); &#125; // 中序遍历 /*用栈实现：因为栈的特性是先进后出，右比左先压入，所以先打印左然后右 * 1.初始化当前cur为头结点 * 2.从cur出发，依次压入所有左节点。直到为null. * 3.栈弹出节点，打印 * 4.cur来到cur的右节点 * 5.循环2,3,4 * */ public static void in(Node cur) &#123; System.out.print(&quot;in-order: &quot;); if (cur != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || cur != null) &#123; if (cur != null) &#123; // 第2步 stack.push(cur); cur = cur.left; &#125; else &#123; // 第3,4步 cur = stack.pop(); System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; &#125; &#125; System.out.println(); &#125; // 后续遍历：解法1 /*用栈实现：准备2个栈。因为栈的特性是先进后出，初步得到是头-右-左。直接利用栈s2逆序弹出就是左右头。 * 1.栈压入头结点 * 2.栈弹出节点，打印 * 3.如果左节点存在，压入左节点 * 4.如果右节点存在，压入右节点 * 5.循环2,3,4 * */ public static void pos1(Node head) &#123; System.out.print(&quot;pos-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); s1.push(head); while (!s1.isEmpty()) &#123; head = s1.pop(); // 头 右 左 s2.push(head); if (head.left != null) &#123; s1.push(head.left); &#125; if (head.right != null) &#123; s1.push(head.right); &#125; &#125; // 左 右 头 while (!s2.isEmpty()) &#123; System.out.print(s2.pop().value + &quot; &quot;); &#125; &#125; System.out.println(); &#125; // 后续遍历：解法2，很难想到这种思路 /*思路： * 先看栈顶元素有无左孩子，有就入栈，这里完成左边界入栈。 * 然后从栈顶peek，如果该节点没有左右孩子，则pop掉并打印，并且将该元素赋给变量h，再peek栈顶元素，这个节点因为是h的父元素，所以看有没有右孩子，如果有，将右孩子压入栈。 * 将该节点右孩子处理完后，此节点被pop，以此类推。 * */ public static void pos2(Node h) &#123; System.out.print(&quot;pos-order: &quot;); if (h != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(h); Node c = null; while (!stack.isEmpty()) &#123; c = stack.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123; // 先压入所有左节点 stack.push(c.left); &#125; else if (c.right != null &amp;&amp; h != c.right) &#123; // 然后压入右节点 stack.push(c.right); &#125; else &#123; // 先处理左树，然后处理右树，再处理头节点 System.out.print(stack.pop().value + &quot; &quot;); h = c; &#125; &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Node head = new Node(1); head.left = new Node(2); head.right = new Node(3); head.left.left = new Node(4); head.left.right = new Node(5); head.right.left = new Node(6); head.right.right = new Node(7); pre(head); System.out.println(&quot;========&quot;); in(head); System.out.println(&quot;========&quot;); pos1(head); System.out.println(&quot;========&quot;); pos2(head); System.out.println(&quot;========&quot;); &#125;&#125; 二叉树宽度优先遍历本质就是按照层遍历，用队列实现 12345678910111213141516171819202122// 二叉树宽度优先遍历，利用队列实现public static void level(Node head) &#123; if (head == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); // 头结点入队列 queue.add(head); while (!queue.isEmpty()) &#123; // 节点先出队列 Node cur = queue.poll(); System.out.println(cur.value); // 如果有左子节点，加入队列 if (cur.left != null) &#123; queue.add(cur.left); &#125; // 如果有右子节点，加入队列。循环上面操作 if (cur.right != null) &#123; queue.add(cur.right); &#125; &#125;&#125; 二叉树的最大宽度题目：求每一层二叉树中最大宽度的层的宽度 解法1，利用map记录node来到的层数，方便遍历完一层后，才开始比较大小 解法2，不使用map,通过设置flag变量的方式，来发现某一层的结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 二叉树的最大宽度：解法1，利用map记录node来到的层数，方便遍历完一层后，才开始比较大小public static int maxWidthUseMap(Node head) &#123; if (head == null) &#123; return 0; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(head); // key 在 哪一层，value, HashMap&lt;Node, Integer&gt; levelMap = new HashMap&lt;&gt;(); // 头结点在第1层，从第1层开始 levelMap.put(head, 1); int curLevel = 1; // 当前你正在统计哪一层的宽度 int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少 // 最大宽度 int max = 0; while (!queue.isEmpty()) &#123; Node cur = queue.poll(); int curNodeLevel = levelMap.get(cur); // 利用队列进行宽度优先遍历 if (cur.left != null) &#123; // 记录节点层数 levelMap.put(cur.left, curNodeLevel + 1); queue.add(cur.left); &#125; if (cur.right != null) &#123; // 记录节点层数 levelMap.put(cur.right, curNodeLevel + 1); queue.add(cur.right); &#125; if (curNodeLevel == curLevel) &#123; // 当前节点还在当前记录的层数上，宽度+1 curLevelNodes++; &#125; else &#123; // 当前节点的层数不是当前记录的层数，那么一定是来到了下一层，可以小结比较了 max = Math.max(max, curLevelNodes); // 记录的层数+1，已经来到新的下一层 curLevel++; // 已经来到下新的下一层，宽度记录为1 curLevelNodes = 1; &#125; &#125; // 最后比较全局最大宽度和最后一层的宽度 max = Math.max(max, curLevelNodes); return max;&#125;// 二叉树的最大宽度：解法2，不使用map,通过设置flag变量的方式，来发现某一层的结束public static int maxWidthNoMap(Node head) &#123; if (head == null) &#123; return 0; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(head); Node curEnd = head; // 当前层，最右节点是谁 Node nextEnd = null; // 下一层，最右节点是谁 int max = 0; int curLevelNodes = 0; // 当前层的节点数 while (!queue.isEmpty()) &#123; // 常规的宽度优先遍历 Node cur = queue.poll(); if (cur.left != null) &#123; queue.add(cur.left); // 在当前层，就已经拿到下一层的最右一个节点 nextEnd = cur.left; &#125; if (cur.right != null) &#123; queue.add(cur.right); nextEnd = cur.right; &#125; // 当前层宽度++ curLevelNodes++; // 当前节点来到当前层的最右节点时 if (cur == curEnd) &#123; max = Math.max(max, curLevelNodes); // 下一层马上要变成当前层了 // 初始化下一层的宽度为0 curLevelNodes = 0; // 把当前层的最右节点更新为下一层的最右节点，继续循环 curEnd = nextEnd; &#125; &#125; return max;&#125; 二叉树的序列化和反序列化内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树。 思路：先序列化，将一棵树遍历（先序遍历），然后空就用#代替，存储成一个字符串。然后反序列化就是用一个队列将字符串拆成值并一一压入，再递归构建树。不是很难，用什么逻辑序列化就是相同逻辑反序列化。 按照先序遍历的逻辑，序列化和反序列化 按照宽度优先遍历逻辑，序列化和反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化， * 以下代码全部实现了。 * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化 * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。 * 比如如下两棵树 * __2 * / * 1 * 和 * 1__ * \\ * 2 * 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125; * * */ // 序列化：先序遍历，在遍历的时候，序列节点 public static Queue&lt;String&gt; preSerial(Node head) &#123; Queue&lt;String&gt; ans = new LinkedList&lt;&gt;(); pres(head, ans); return ans; &#125; public static void pres(Node head, Queue&lt;String&gt; ans) &#123; if (head == null) &#123; // 空需要补空，序列化空 ans.add(null); &#125; else &#123; // 先序遍历，先加入到队列中，序列化节点 ans.add(String.valueOf(head.value)); pres(head.left, ans); pres(head.right, ans); &#125; &#125; // 反序列化：按照先序遍历的逻辑，反向操作 public static Node buildByPreQueue(Queue&lt;String&gt; prelist) &#123; if (prelist == null || prelist.size() == 0) &#123; return null; &#125; return preb(prelist); &#125; public static Node preb(Queue&lt;String&gt; prelist) &#123; // 和先序遍历的逻辑如出一辙 String value = prelist.poll(); if (value == null) &#123; // 空返回空节点，反序列化节点 return null; &#125; // 反序列化的节点 Node head = new Node(Integer.valueOf(value)); // 反序列化的节点，补齐它的左子节点 head.left = preb(prelist); // 反序列化的节点，补齐它的右子节点 head.right = preb(prelist); return head; &#125; // 序列化：按照层遍历即宽度优先遍历，在遍历的时候，序列节点 public static Queue&lt;String&gt; levelSerial(Node head) &#123; Queue&lt;String&gt; ans = new LinkedList&lt;&gt;(); if (head == null) &#123; // 空节点序列化补空 ans.add(null); &#125; else &#123; // 在遍历的时候，序列节点 ans.add(String.valueOf(head.value)); Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.add(head); while (!queue.isEmpty()) &#123; head = queue.poll(); // head 父 子 if (head.left != null) &#123; // 添加节点的时候，序列化 ans.add(String.valueOf(head.left.value)); queue.add(head.left); &#125; else &#123; // 空节点也要序列化 ans.add(null); &#125; if (head.right != null) &#123; ans.add(String.valueOf(head.right.value)); queue.add(head.right); &#125; else &#123; ans.add(null); &#125; &#125; &#125; return ans; &#125; // 反序列化：按照宽度优先遍历，反向逻辑操作 public static Node buildByLevelQueue(Queue&lt;String&gt; levelList) &#123; // 边界条件 if (levelList == null || levelList.size() == 0) &#123; return null; &#125; // 先反序列生成头结点 Node head = generateNode(levelList.poll()); // 建立需要while遍历的队列 Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); if (head != null) &#123; queue.add(head); &#125; Node node = null; // 借助队列，遍历所有节点 while (!queue.isEmpty()) &#123; // 弹出反序列化的节点 node = queue.poll(); // 反序列化的节点的左子节点 node.left = generateNode(levelList.poll()); // 反序列化的节点的右子节点 node.right = generateNode(levelList.poll()); if (node.left != null) &#123; // 不为空的节点，要加入到循环队列，方便后面继续宽度优先遍历 queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; return head; &#125; // 节点生成函数 public static Node generateNode(String val) &#123; if (val == null) &#123; return null; &#125; return new Node(Integer.valueOf(val)); &#125; 二叉树任意节点的后继节点题目：给你二叉树中的某个节点，返回该节点的后继节点 后继节点定义：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点。前驱结点：也是相对于中序遍历而言的。一个节点的前一个节点。 中序遍历：对于每个节点，都按照左头右访问。 解法1：先中序遍历然后存入一个List,然后再遍历找到当前节点的下一个节点，但是时间复杂度是O(N) 解法2：要求时间复杂度为O(K)，其中K为两个节点的距离 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Code06_SuccessorNode &#123; public static class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125; &#125; public static Node getSuccessorNode(Node node) &#123; // 解法2：返回后继节点，利用中序遍历中后继节点的特性 if (node == null) &#123; return node; &#125; if (node.right != null) &#123; // 如果该节点有右孩子，那么右子树的最左节点就是后继节点。 return getLeftMost(node.right); &#125; else &#123; // 如果该节点无右孩子，那么它的后继节点一定是往上找父节点，直到节点是其父节点的左孩子，返回。因为左头 Node parent = node.parent; // 父节点不能为null,null表示到根节点了。同时只要当前节点是其父节点的右孩子，循环继续。直到节点是其父节点的左孩子，跳出循环。 while (parent != null &amp;&amp; parent.right == node) &#123; // 当前节点是其父亲节点右孩子 // 更新当前节点 node = parent; // 取出当前节点的父节点 parent = node.parent; &#125; // 返回那个节点是其父节点的左孩子的节点，就是后继节点 return parent; &#125; &#125; // 返回该节点的最左节点 public static Node getLeftMost(Node node) &#123; if (node == null) &#123; return node; &#125; // 只要节点的左节点不为空，就循环找，直到该节点的左节点为空。返回该节点 while (node.left != null) &#123; node = node.left; &#125; return node; &#125; public static void main(String[] args) &#123; Node head = new Node(6); head.parent = null; head.left = new Node(3); head.left.parent = head; head.left.left = new Node(1); head.left.left.parent = head.left; head.left.left.right = new Node(2); head.left.left.right.parent = head.left.left; head.left.right = new Node(4); head.left.right.parent = head.left; head.left.right.right = new Node(5); head.left.right.right.parent = head.left.right; head.right = new Node(9); head.right.parent = head; head.right.left = new Node(8); head.right.left.parent = head.right; head.right.left.left = new Node(7); head.right.left.left.parent = head.right.left; head.right.right = new Node(10); head.right.right.parent = head.right; Node test = head.left.left; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.left.left.right; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.left; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.left.right; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.left.right.right; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.right.left.left; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.right.left; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.right; System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value); test = head.right.right; // 10&#x27;s next is null System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test)); &#125;&#125; 折纸问题请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后 展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从 上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如:N=1时，打印: down N=2时，打印: down down up思路：试验一下会发现，每次折完之后，会在每个上一次出现的痕迹处上面出现一个凹痕下面出现一个凸痕，其实可以理解为树，这个数根节点是凹痕，然后所有左子树的根节点都是凹痕，所有右子树的根节点都是凸痕。然后通过中序遍历递归去实现打印。 1234567891011121314151617181920212223242526public class Code07_PaperFolding &#123; public static void printAllFolds(int N) &#123; process(1, N, true); System.out.println(); &#125; // 当前你来了一个节点，脑海中想象的！ // 这个节点在第i层，一共有N层，N固定不变的 // 这个节点如果是凹的话，down = T // 这个节点如果是凸的话，down = F // 函数的功能：中序打印以你想象的节点为头的整棵树！ public static void process(int i, int N, boolean down) &#123; if (i &gt; N) &#123; return; &#125; process(i + 1, N, true); // 这里打印，本质就是用递归模拟中序遍历 System.out.print(down ? &quot;凹 &quot; : &quot;凸 &quot;); process(i + 1, N, false); &#125; public static void main(String[] args) &#123; int N = 4; printAllFolds(N); &#125;&#125; 二叉树递归套路本质利用递归遍历二叉树的便利性。 假设以X节点为头，假设可以向X左子树和X右子树获取任何信息 在上一步的假设下，套路以X为头结点的树，得到答案的可能性。(最重要) 列出所有可能性后，确定到底需要向左树和右树获取什么样的信息 把左树信息和右树信息整合，就是任何一棵子树需要返回的信息S 递归函数都返回S,每棵子树都这么要求 写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息 套路实践-判断平衡二叉树题目：给定一棵二叉树的头结点head,返回这棵树是否为平衡二叉树ALV. ALV平衡二叉树定义：必须是二叉搜索树；每个节点的左子树和右子树的高度差至多为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static boolean isBalanced2(Node head) &#123; // 返回根节点的平衡性 return process(head).isBalanced;&#125;public static class Info &#123; // 先组织定义任意节点的平衡性信息数据结构 // 该节点下，是否是平衡二叉树ALV public boolean isBalanced; // 该节点下，树的高度 public int height; public Info(boolean i, int h) &#123; isBalanced = i; height = h; &#125;&#125;public static Info process(Node x) &#123; // 返回任意节点的平衡性信息数据结构 // 叶子节点，一定是平衡二叉树ALV,且高度为0 if (x == null) &#123; return new Info(true, 0); &#125; // 获取左子树的平衡信息---套路步骤1 Info leftInfo = process(x.left); // 获取右子树的平衡信息---套路步骤1 Info rightInfo = process(x.right); // 当前节点的树的高度信息，就是取左右子树最大高度+1自己 int height = Math.max(leftInfo.height, rightInfo.height) + 1; boolean isBalanced = true; // ---套路步骤2 if (!leftInfo.isBalanced) &#123; // 左子树不平衡，不是平衡树 isBalanced = false; &#125; // ---套路步骤2 if (!rightInfo.isBalanced) &#123; // 右子树不平衡，不是平衡树 isBalanced = false; &#125; // ---套路步骤2 if (Math.abs(leftInfo.height - rightInfo.height) &gt; 1) &#123; // 左右子树的高度差大于1，也不是平衡树 isBalanced = false; &#125; return new Info(isBalanced, height);&#125; 套路实践-判断满二叉树 解法1：收集整棵树的高度h，和节点数n。满二叉树满足 : 2 ^ h - 1 == n 12345678910111213141516171819202122232425262728293031323334// 解法1：收集整棵树的高度h，和节点数n。满二叉树满足 : 2 ^ h - 1 == npublic static boolean isFull1(Node head) &#123; if (head == null) &#123; return true; &#125; Info1 all = process1(head); // 满二叉树：节点数=(2^height) - 1 return (1 &lt;&lt; all.height) - 1 == all.nodes;&#125;public static class Info1 &#123; // 二叉树高度 public int height; // 二叉树节点个数 public int nodes; public Info1(int h, int n) &#123; height = h; nodes = n; &#125;&#125;public static Info1 process1(Node head) &#123; if (head == null) &#123; return new Info1(0, 0); &#125; Info1 leftInfo = process1(head.left); Info1 rightInfo = process1(head.right); // 高度，取左右子树中最高的那个+1自己 int height = Math.max(leftInfo.height, rightInfo.height) + 1; // 节点个数，同理 int nodes = leftInfo.nodes + rightInfo.nodes + 1; return new Info1(height, nodes);&#125; 套路实践-判断完全二叉树完全二叉树：上面的层是满的，即使不满，那么一定是从左到右逐渐变满。 解法1：利用宽度优先遍历，排除两种情况后，一定是满二叉树。 解法2：二叉树递归套路，完全二叉树有4种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import java.util.LinkedList;// 测试链接 : https://leetcode.com/problems/check-completeness-of-a-binary-tree/public class Code01_IsCBT &#123; // 不要提交这个类 public static class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; public TreeNode(int v) &#123; val = v; &#125; &#125; //解法1：利用宽度优先遍历，排除两种情况后，一定是满二叉树。 public static boolean isCompleteTree1(TreeNode head) &#123; /* * 情况a：无左孩子，有右孩子 * 情况b：遇到过节点的左右孩子不全的节点，且节点不是叶子节点。 * */ /* 具体分析： * 对一个节点而言有四种可能： 1. 当前节点有两个孩子 2.当前节点有左孩子 没有右孩子 3，当前节点 没有左孩子 有 右孩子 4，当前节点 没有孩子 我们层次遍历每一个节点，若碰到3的情况 一定不是完全二叉树 ，直接返回， 当我们 第一次碰到： 2 或者 4 的情况的时候， 这意味着我们之后遍历的节点都必须是叶子，否则不是完全二叉树。 若程序能执行到结束， 返回 true； * */ if (head == null) &#123; return true; &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 是否遇到过左右两个孩子不双全的节点 boolean leaf = false; TreeNode l = null; TreeNode r = null; queue.add(head); // 基于队列的宽度优先遍历 while (!queue.isEmpty()) &#123; head = queue.poll(); l = head.left; r = head.right; if ( // 情况a||情况b (l == null &amp;&amp; r != null)||(leaf &amp;&amp; !(l == null || r == null)) ) &#123; return false; &#125; if (l != null) &#123; queue.add(l); &#125; if (r != null) &#123; queue.add(r); &#125; // 遇到了叶子节点，左右都没孩子，不双全，标记true if (l == null || r == null) &#123; leaf = true; &#125; &#125; return true; &#125; public static boolean isCompleteTree2(TreeNode head) &#123; return process(head).isCBT; &#125; public static class Info &#123; // 节点的子树为满二叉树 public boolean isFull; // 节点的子树为完全二叉树 public boolean isCBT; // 节点的子树高度 public int height; public Info(boolean full, boolean cbt, int h) &#123; isFull = full; isCBT = cbt; height = h; &#125; &#125; // 解法2：二叉树递归套路，完全二叉树有4种情况。 public static Info process(TreeNode x) &#123; /*假设树有3层， 1 1 1 1 2 3 2 3 2 3 2 3 4 5 6 7 4 4 5 4 5 6 * 情况1：最后一层都满了，一定要求：左树是满树&amp;右树是满树&amp;左树高度=右树高度 * 情况2：最后一层只有1个节点，一定要求：左树是完全树&amp;右树是满树&amp;左树高度=右树高度+1 * 情况3：最后一层只有2个节点，一定要求：左树是满树&amp;右树是满树&amp;左树高度=右树高度+1 * 情况4：最后一层只有3个节点，一定要求：左树是满树&amp;右树是完全树&amp;左树高度=右树高度 * */ if (x == null) &#123; return new Info(true, true, 0); &#125; Info leftInfo = process(x.left); Info rightInfo = process(x.right); int height = Math.max(leftInfo.height, rightInfo.height) + 1; boolean isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height; boolean isCBT = false; if (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height) &#123; // 情况1 isCBT = true; &#125; else if (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + 1) &#123; // 情况2 isCBT = true; &#125; else if (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + 1) &#123; // 情况3 isCBT = true; &#125; else if (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123; // 情况4 isCBT = true; &#125; return new Info(isFull, isCBT, height); &#125; // for test public static TreeNode generateRandomBST(int maxLevel, int maxValue) &#123; return generate(1, maxLevel, maxValue); &#125; // for test public static TreeNode generate(int level, int maxLevel, int maxValue) &#123; if (level &gt; maxLevel || Math.random() &lt; 0.5) &#123; return null; &#125; TreeNode head = new TreeNode((int) (Math.random() * maxValue)); head.left = generate(level + 1, maxLevel, maxValue); head.right = generate(level + 1, maxLevel, maxValue); return head; &#125; public static void main(String[] args) &#123; int maxLevel = 5; int maxValue = 100; int testTimes = 1000000; for (int i = 0; i &lt; testTimes; i++) &#123; TreeNode head = generateRandomBST(maxLevel, maxValue); if (isCompleteTree1(head) != isCompleteTree2(head)) &#123; System.out.println(&quot;Oops!&quot;); &#125; &#125; System.out.println(&quot;finish!&quot;); &#125;&#125; 套路实践-二叉树的最大距离题目：给定一棵二叉树的头结点head,任何两个节点之间都存在距离。返回整颗二叉树的最大距离 1234567891011121314151617181920212223242526272829303132333435public static class Info &#123; // 先组织节点的最远距离的信息数据结构 // 该节点作为树根节点的最大距离 public int maxDistance; // 该节点作为树根节点的高度 public int height; public Info(int m, int h) &#123; maxDistance = m; height = h; &#125;&#125;public static Info process(Node x) &#123; // 如果空节点，则00 if (x == null) &#123; return new Info(0, 0); &#125; // 左子树信息---套路步骤1 Info leftInfo = process(x.left); // 右子树信息---套路步骤1 Info rightInfo = process(x.right); // 节点的树高度 int height = Math.max(leftInfo.height, rightInfo.height) + 1; // 节点下的最大距离 // 情况1：最大距离不经过x节点：左子树的最大距离 ---套路步骤2 int p1 = leftInfo.maxDistance; // 情况2：最大距离不经过x节点：右子树的最大距离 ---套路步骤2 int p2 = rightInfo.maxDistance; // 情况3：最大距离经过x节点：左子树+左子树的高度+1自己 ---套路步骤2 int p3 = leftInfo.height + rightInfo.height + 1; // 节点的最大距离一定是情况123中的最大值，好好想想 int maxDistance = Math.max(Math.max(p1, p2), p3); return new Info(maxDistance, height);&#125; 套路实践-二叉搜索子树头结点题目：给定一棵二叉树的头结点head,返回这颗二叉树中最大的二叉搜索子树的头结点。 思路： (1)最大二叉搜索树不经过X节点 a)最大二叉搜索树要么是左子树 b)最大二叉搜索树要么是右子树 (2)最大二叉搜索树经过X节点 c)左子树是BST且右子树是BST且左子树的最大值&lt;x&lt;右子树的最小值 最终结果取a,b,c中的一种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public static int maxSubBSTHead2(Node head) &#123; if (head == null) &#123; return -1; &#125; // 解法1：初始化就是传入头结点，并返回最大二叉搜索树的头结点 return process(head).maxSubBSTSize; // 解法2：提前处理好null节点 // return dfs(head).ans; &#125; // 先定义每一棵子树,二叉搜索树的信息数据结构 public static class Info &#123; // 最大二叉搜索子树的头节点，如果存在则有值。不存在，则是null public Node maxSubBSTHead; // 最大二叉搜索子树的大小，就是最大二叉搜索子树的所有节点个数 public int maxSubBSTSize; // 最大二叉搜索子树的最小值 public int min; // 最大二叉搜索子树的最大值 public int max; public Info(Node h, int size, int mi, int ma) &#123; maxSubBSTHead = h; maxSubBSTSize = size; min = mi; max = ma; &#125; &#125; public static Info process(Node X) &#123; // 判空的时候，不知道返回什么，就返回空，后续自己处理 if (X == null) &#123; return null; &#125; // ---套路步骤1,假设拿到左树信息 Info leftInfo = process(X.left); // ---套路步骤1,假设拿到右树信息 Info rightInfo = process(X.right); /* *---套路步骤2 * (1)最大二叉搜索树不经过X节点 * a)最大二叉搜索树要么是左子树 * b)最大二叉搜索树要么是右子树 * (2)最大二叉搜索树经过X节点 * c)左子树是BST且右子树是BST且左子树的最大值&lt;x&lt;右子树的最小值 * 最终结果取a,b,c中的一种 * */ // 先假设最大最小为当前值 int min = X.value; int max = X.value; // 先假设最大二叉搜索子树为空 Node maxSubBSTHead = null; // 先假设最大二叉搜索子树的大小为0 int maxSubBSTSize = 0; // 情况1：套路步骤2中的a if (leftInfo != null) &#123; // 比较全局最小和当前子树最小值，取最小的值 min = Math.min(min, leftInfo.min); max = Math.max(max, leftInfo.max); maxSubBSTHead = leftInfo.maxSubBSTHead; maxSubBSTSize = leftInfo.maxSubBSTSize; &#125; // 情况2：套路步骤2中的b if (rightInfo != null) &#123; min = Math.min(min, rightInfo.min); max = Math.max(max, rightInfo.max); // 这里要看一眼右节点比之前的值是不是更大，更大才更新 if (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123; maxSubBSTHead = rightInfo.maxSubBSTHead; maxSubBSTSize = rightInfo.maxSubBSTSize; &#125; &#125; // 情况3：套路步骤2中的c /* * 如果leftInfo == null，表示左子树为空，没有节点。那么也属于BST，直接给true * 如果leftInfo != null，leftInfo.maxSubBSTHead == X.left表示X的左子节点是X左子树的最大搜索二叉树的节点即左子树是BST， * leftInfo.max &lt; X.value表示左子树的最大值&lt;x，这种才满足c的一部分条件。右子树也是同样判断 * */ if ((leftInfo == null ? true : (leftInfo.maxSubBSTHead == X.left &amp;&amp; leftInfo.max &lt; X.value)) &amp;&amp; (rightInfo == null ? true : (rightInfo.maxSubBSTHead == X.right &amp;&amp; rightInfo.min &gt; X.value))) &#123; // 满足以上条件的，X节点才是X为头结点的最大二叉搜索树的头节点 maxSubBSTHead = X; // 二叉搜索树的大小就是左+有+1自己节点 maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize) + (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1; &#125; // ---套路步骤5,终极目的就是递归这四个值 return new Info(maxSubBSTHead, maxSubBSTSize, min, max); &#125; public static class SuperNode &#123; int ans; int small, large; boolean isBST; public SuperNode() &#123; ans = 0; isBST = true; small = Integer.MAX_VALUE; large = -Integer.MAX_VALUE; &#125; &#125; public static SuperNode dfs(Node node) &#123; // 解法2：提前处理好null节点 if (node == null) &#123; return new SuperNode(); &#125; SuperNode now = new SuperNode(); SuperNode left = dfs(node.left); SuperNode right = dfs(node.right); now.small = Math.max(left.small, node.value); now.large = Math.max(right.large, node.value); if (left.isBST &amp;&amp; right.isBST &amp;&amp; left.large &lt;= node.value &amp;&amp; right.small &gt;= node.value) &#123; // 最大二叉搜索树经过X节点 now.ans = left.ans + right.ans + 1; now.isBST = true; &#125; else &#123; // 如果最大二叉搜索树不经过X节点，则最大值一定在左右中最大的一个 now.ans = Math.max(left.ans, right.ans); // 标记为非BST now.isBST = false; &#125; return now; &#125; 套路实践-员工快乐值题目：定义员工Employee信息，每个员工可能有多个直接下级，但只有一个上级。基层员工没有下级。现在公司办party,要决定哪些人来或不来。规则如下： 1.如果某个员工来了，那么这个员工的所有直接下级都不能来2.派对的整体快乐值是所有到场员工快乐值的累加3.你的目标是让派对的整体快乐值尽量大给定一棵多叉树的头节点boss，请返回派对的最大快乐值。 思路：员工X,假设有a,b,c三个下属 (1)X来时,yes快乐值=a不来的快乐值+b不来的快乐值+c不来的快乐值 (2)X不来时，no快乐值=max(a来的快乐值,a不来的快乐值)+max(b来的快乐值,b不来的快乐值)+max(c来的快乐值,c不来的快乐值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Code04_MaxHappy &#123; public static class Employee &#123; // 员工可以带来的快乐值 public int happy; // 该员工的直接下属员工 public List&lt;Employee&gt; nexts; public Employee(int h) &#123; happy = h; nexts = new ArrayList&lt;&gt;(); &#125; &#125; public static int maxHappy2(Employee head) &#123; Info allInfo = process(head); return Math.max(allInfo.no, allInfo.yes); &#125; // 先定义员工节点的快乐值，因为是树结构，要考虑其下属来不来 public static class Info &#123; // 员工不来的情况下，他的快乐值 public int no; // 员工来的情况下，他的快乐值 public int yes; public Info(int n, int y) &#123; no = n; yes = y; &#125; &#125; public static Info process(Employee x) &#123; /* * 思路：X,假设有a,b,c三个下属 * (1)X来时,yes快乐值=a不来的快乐值+b不来的快乐值+c不来的快乐值 * (2)X不来时，no快乐值=max(a来的快乐值,a不来的快乐值)+max(b来的快乐值,b不来的快乐值)+max(c来的快乐值,c不来的快乐值) * */ // base case 没有员工了 if (x == null) &#123; return new Info(0, 0); &#125; // 员工不来的初始快乐值为0 int no = 0; // 员工来的初始快乐值为自己的happy int yes = x.happy; // 遍历所有下属 for (Employee next : x.nexts) &#123; // 假设能获取下属的信息 Info nextInfo = process(next); // X不来时，快乐值就是如下 no += Math.max(nextInfo.no, nextInfo.yes); // X来时，快乐值就是如下 yes += nextInfo.no; &#125; return new Info(no, yes); &#125;&#125; 套路实践-最低公共祖先节点题目：给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点。 解法1：利用一个map构件节点向上找父节点的效果，利用set查找两者第一个相同的向上找到的父节点 解法2：二叉树递归套路。构建基本信息，递归分情况讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125;// 解法1：利用一个map构件节点向上找父节点的效果，利用set查找两者第一个相同的向上找到的父节点public static Node lowestAncestor1(Node head, Node o1, Node o2) &#123; if (head == null) &#123; return null; &#125; // key的父节点是value HashMap&lt;Node, Node&gt; parentMap = new HashMap&lt;&gt;(); parentMap.put(head, null); // 构建所有节点的父节点表 fillParentMap(head, parentMap); HashSet&lt;Node&gt; o1Set = new HashSet&lt;&gt;(); Node cur = o1; o1Set.add(cur); // 递归取出o1节点的所有父节点，加入o1Set while (parentMap.get(cur) != null) &#123; cur = parentMap.get(cur); o1Set.add(cur); &#125; cur = o2; // 递归取出o2节点的所有父节点，判断是否存在o1Set中，存在了就是最近的公共祖先。 while (!o1Set.contains(cur)) &#123; cur = parentMap.get(cur); &#125; return cur;&#125;// 递归调用，填写map,含义key:当前节点,value：当前节点的父节点public static void fillParentMap(Node head, HashMap&lt;Node, Node&gt; parentMap) &#123; if (head.left != null) &#123; // 存在左节点，加入map parentMap.put(head.left, head); // 继续递归左节点 fillParentMap(head.left, parentMap); &#125; if (head.right != null) &#123; parentMap.put(head.right, head); fillParentMap(head.right, parentMap); &#125;&#125;// 解法2：二叉树递归套路。构建基本信息，递归分情况讨论public static Node lowestAncestor2(Node head, Node a, Node b) &#123; return process(head, a, b).ans;&#125;// 任何节点作为头结点的子树信息public static class Info &#123; // 子树上是否存在a节点 public boolean findA; // 子树上是否存在b节点 public boolean findB; // 子树上的a,b的最初交汇点即最近的公共祖先，可能存在，也可能不存在为null public Node ans; public Info(boolean fA, boolean fB, Node an) &#123; findA = fA; findB = fB; ans = an; &#125;&#125;public static Info process(Node x, Node a, Node b) &#123; // base case if (x == null) &#123; return new Info(false, false, null); &#125; // 二叉树递归套路，先要来左右子树的信息 Info leftInfo = process(x.left, a, b); Info rightInfo = process(x.right, a, b); // 判断子树上是否存在a节点.要么当前节点就是a,要么a在左子树上，要么a在右子树上 boolean findA = (x == a) || leftInfo.findA || rightInfo.findA; boolean findB = (x == b) || leftInfo.findB || rightInfo.findB; // 接下来就是对于当前子树，它对于a,b的交汇点在哪 Node ans = null; /* * 最低公共祖先一定在以下三种情况： * 情况1：如果左子树的交汇点不为空，那么交汇点就是它 * 情况2：如果右子树的交汇点不为空，那么交汇点就是它 * 情况3：如果都不在，但是又有最低祖先，那么一定在当前节点上 * */ if (leftInfo.ans != null) &#123; // 情况1 ans = leftInfo.ans; &#125; else if (rightInfo.ans != null) &#123; // 情况2 ans = rightInfo.ans; &#125; else &#123; // 情况3 if (findA &amp;&amp; findB) &#123; ans = x; &#125; &#125; // 不满足情况123的就表示没有最低公共祖先 return new Info(findA, findB, ans);&#125; BFPRT算法简称：五个好朋友算法，是5个人共同提出的算法。开创了算法的优化一个新局面。 bfprt算法最牛逼划时代的意义是，在你还没有完全求解出来时，你就已经知道算法收敛于O(n),也叫五个好朋友算法。 题目：无序数组中，求第K小的数 解法1：常规解法，利用快排分组，利用荷兰国旗问题，获取值，笔试常用。平均复杂度nlog(n)，最差n2 解法2：bfprt算法也叫五个好朋友算法也叫中位数的中位数算法，只有第一步的选值特别讲究，后续都和1一样，面试装逼.平均复杂度n 解法1：利用快排，只不过没有快排的两边排序，只排序一边即可。流程：a随机选一个数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class FindMinK &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;; int k = 2; System.out.println(select(arr, 0, arr.length - 1, k - 1)); &#125; //在arr[L..R]范围上，求如果排序的话，i位置的数是谁，返回 //i一定且必须出现在L~R范围上 public static int select(int[] arr, int L, int R, int i) &#123; if (L == R) &#123; return arr[L]; &#125; // 解法1：常规解法，a随机选一个数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归 int pivot = arr[L+(int)(Math.random()*(R-L+1))]; // partition过程 根据pivot做划分值 &lt;p ==p &lt;p 返回等于区域的左边界和右边界 // range[0] 等于区域的左边界的索引值 // range[1] 等于区域的右边界的索引值 int[] range = partition(arr, L, R, pivot); // 注意range存放的是边界的索引值，不是数组值 // 左右分组后，range左边的索引值数都是小于range值索引值数，右边都是大于值。比如range[6-10],说明左边有5个小数，右边是大数。 if (i &gt;= range[0] &amp;&amp; i &lt;= range[1]) &#123; return arr[i]; &#125; else if (i &lt; range[0]) &#123; return select(arr, L, range[0] - 1, i); &#125; else &#123; return select(arr, range[1] + 1, R, i); &#125; &#125; public static int[] partition(int[] arr, int L, int R, int pivotValue) &#123; // 常规荷兰国旗问题分组 int small = L - 1; int cur = L; int big = R + 1; while (cur != big) &#123; if (arr[cur] &lt; pivotValue) &#123; swap(arr, ++small, cur++); &#125; else if (arr[cur] &gt; pivotValue) &#123; swap(arr, cur, --big); &#125; else &#123; cur++; &#125; &#125; int[] range = new int[2]; range[0] = small + 1; range[1] = big - 1; return range; &#125; public static void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125; 解法2：利用bfprt算法，流程：a非常非常讲究的选一个数即中位数的中位数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class FindMinK &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;; int k = 2; System.out.println(bfprt(arr, 0, arr.length - 1, k - 1)); &#125; //在arr[L..R]范围上，求如果排序的话，i位置的数是谁，返回。 //i一定且必须出现在L~R范围上 public static int bfprt(int[] arr, int L, int R, int i) &#123; if (L == R) &#123; return arr[L]; &#125; // 解法2: bfprt算法，a非常非常讲究的选一个数即中位数的中位数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归 int pivot = medianOfMedians(arr, L, R); // partition过程 根据pivot做划分值 &lt;p ==p &lt;p 返回等于区域的左边界和右边界 // range[0] 等于区域的左边界的索引值 // range[1] 等于区域的右边界的索引值 int[] range = partition(arr, L, R, pivot); // 注意range存放的是边界的索引值，不是数组值 // 左右分组后，range左边的索引值数都是小于range值索引值数，右边都是大于值。比如range[6-10],说明左边有5个小数，右边是大数。 if (i &gt;= range[0] &amp;&amp; i &lt;= range[1]) &#123; return arr[i]; &#125; else if (i &lt; range[0]) &#123; return bfprt(arr, L, range[0] - 1, i); &#125; else &#123; return bfprt(arr, range[1] + 1, R, i); &#125; &#125; public static int medianOfMedians(int[] arr, int begin, int end) &#123; /* 求解中位数 1.每5个数分为一组 2.内部排序，每组的中位数组成新数组marr 3.继续调用中位数算法bfprt(marr,marr的中位数即长度一半) */ // 数组总长度 int num = end - begin + 1; // 每五个一组，查看是否有多余的数，有的话则单独成一位 int offset = num % 5 == 0 ? 0 : 1; // 创建存储每五个数据排序后中位数的数组 int[] mArr = new int[num / 5 + offset]; // 遍历此数组 for (int i = 0; i &lt; mArr.length; i++) &#123; // 当前mArr来源自原来数组中的起始位置 int beginI = begin + i * 5; // 当前mArr来源自原来数组中的终止位置 int endI = beginI + 4; // 计算出当前i位置5个数排序后的中位数 mArr[i] = getMedian(arr, beginI, Math.min(end, endI)); &#125; // 在这些中位数的点中，挑选出排好序之后的中位数返回，即继续调用bfprt功能前一半小的数也就是中位数 return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2); &#125; public static int getMedian(int[] arr, int begin, int end) &#123; // 对数组排序，获取中位数或中间的偏左位置。因为可能刚好4个数，取第2个 insertionSort(arr, begin, end); int sum = end + begin; int mid = (sum / 2) + (sum % 2); return arr[mid]; &#125; public static void insertionSort(int[] arr, int begin, int end) &#123; // 插入排序 for (int i = begin + 1; i != end + 1; i++) &#123; for (int j = i; j != begin; j--) &#123; if (arr[j - 1] &gt; arr[j]) &#123; swap(arr, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125; &#125; public static int[] partition(int[] arr, int L, int R, int pivotValue) &#123; int small = L - 1; int cur = L; int big = R + 1; while (cur != big) &#123; if (arr[cur] &lt; pivotValue) &#123; swap(arr, ++small, cur++); &#125; else if (arr[cur] &gt; pivotValue) &#123; swap(arr, cur, --big); &#125; else &#123; cur++; &#125; &#125; int[] range = new int[2]; range[0] = small + 1; range[1] = big - 1; return range; &#125; public static void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;&#125; Morris算法遍历Morris序比如二叉树：第一层：1，第二层：2,3；第三层，4,5,6,7。Morris序是：1242513637 算法流程： 首先cur表示当前节点，cur指向树的头结点。直到最终cur指向null停止。 如果cur无左树，cur=cur.right 如果cur有左树，找到左树的最右节点mostRight,即左树的右右右…不为空的节点。 1)如果mostRight的右指针指向null,则mostRight.right =cur,cur=cur.left 2)如果mostRight的右指针指向cur,则mostRight.right =null,cur=cur.right 时间复杂度：O(N),因为每个节点的左树右边界最多趟过2次，即2N是N规模的复杂度。 空间复杂度：O(1)即不需要额外空间 123456789101112131415161718192021222324252627282930313233343536373839404142public static class Node &#123; public int value; Node left; Node right; public Node(int data) &#123; this.value = data; &#125;&#125;public static void morris(Node head) &#123; if (head == null) &#123; return; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; // 第一次到达cur // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // 第二次到达cur // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125; // 1.如果cur没有左孩子 cur = cur.right; &#125;&#125; Morris遍历和传统二叉树遍历Morris遍历是向传统遍历致敬，做到了优化的前序和中序遍历，后续遍历需要额外代码。 传统二叉树遍历代码： 12345678910111213public static void process(Node head) &#123; if (head == null) &#123; return; &#125; // 先序遍历 System.out.println(“先序遍历：头左右”); process(head.left); // 中序遍历 System.out.println(“中序遍历：左头右”); process(head.right); // 后序遍历 System.out.println(“后序遍历：左右头”); &#125; 先序遍历 只打印没有左节点或第一次进入的节点 12345678910111213141516171819202122232425262728293031323334353637public static void morrisPre(Node head) &#123; // 中序遍历 if (head == null) &#123; return; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; &#125; // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 if (mostRight.right == null) &#123; mostRight.right = cur; // 只打印第一次进入的节点 System.out.println(&quot;先序遍历&quot;+cur.value); cur = cur.left; continue; &#125; else &#123; // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125;else&#123; // 只打印没有左节点 System.out.println(&quot;先序遍历&quot;+cur.value); &#125; // 1.如果cur没有左孩子 cur = cur.right; &#125; &#125; 中序遍历 只打印没有左节点或第二次进入的节点 12345678910111213141516171819202122232425262728293031323334public static void morrisIn(Node head) &#123; // 中序遍历 if (head == null) &#123; return; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; &#125; // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125; // 一行代码，只打印没有左节点或第二次进入的节点 System.out.println(&quot;中序遍历&quot;+cur.value); // 1.如果cur没有左孩子 cur = cur.right; &#125; &#125; 后序遍历 打印第二次进入节点的左树的右边界的逆序，其中Morris序是：1242513637。 第二个2的左树右边界只有4，第二个1的左树右边界逆序是52，第二个3的左树右边界逆序是6 打印整棵树的右边界逆序，731 最终结果为4526731 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void morrisPos(Node head) &#123; // 后序遍历 if (head == null) &#123; return; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; &#125; // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; // 打印第二次进入节点的左树的右边界的逆序 printEdge(cur.left); &#125; &#125; // 打印整棵树的右边界逆序 printEdge(head); // 1.如果cur没有左孩子 cur = cur.right; &#125; &#125; public static void printEdge(Node head) &#123; // 打印整棵树的右树逆序 // 1.先逆序所有的右节点 Node tail = reverseEdge(head); Node cur = tail; while (cur != null) &#123; // 2.打印所有右节点 System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; // 3.再还原回来，因为是在原树上处理，没有额外空间 reverseEdge(tail); &#125; public static Node reverseEdge(Node from) &#123; // 逆序所有的右节点，和链表逆序原理一致 Node pre = null; Node next = null; while (from != null) &#123; next = from.right; from.right = pre; pre = from; from = next; &#125; return pre; &#125; 判断是否为二叉搜索树BST利用Morris序判断是否为二叉搜索树BST,BST定义：左节点小于根，根小于右节点。即中序遍历是依次递增的就是BST. 123456789101112131415161718192021222324252627282930313233343536373839404142public static boolean isBST(Node head) &#123; // 利用Morris序判断是否为二叉搜索树BST,BST定义：左节点小于根，根小于右节点。即中序遍历是依次递增的就是BST. if (head == null) &#123; // 空，则是BST return true; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; Integer pre = null; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; &#125; // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125; // 中序遍历的所有值，判断前一个大于等于后一个，一定不是BST if (pre != null &amp;&amp; pre &gt;= cur.value) &#123; return false; &#125; // 指针下移，继续判断下一个 pre = cur.value; // 1.如果cur没有左孩子 cur = cur.right; &#125; // 跑完了，不报错就是BST return true; &#125; 求二叉树的最小高度叶节点才有最小高度. 解法1：利用无脑递归 解法2：利用Morris序，有点复杂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class MorrisMinHeight &#123; public static void main(String[] args) &#123; Node node1 = new Node(1); Node node2 = new Node(2); node1.right = node2; Node node3 = new Node(3); node2.left = node3; Node node4 = new Node(4); Node node5 = new Node(5); node3.left = node4; node3.right = node5; System.out.println(minDepth2(node1)); &#125; public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125; &#125; public static int minDepth1(Node head) &#123; // 二叉树最小高度，常规递归遍历 if (head == null) &#123; return 0; &#125; return p(head); &#125; public static int minDepth2(Node head) &#123; // 利用morris遍历改写获取二叉树最小高度 /* 1.需要知道当前节点的高度，即curLevel值 2.每次比较相近的叶节点的高度，判定最小值，最终就是最小高度。 1)比较左侧的所有叶节点高度 2)在上面的基础上，比较最右叶节点高度，去最小值即可 */ if (head == null) &#123; return 1; &#125; // 从头结点开始 Node cur = head; Node mostRight = null; // 当前节点的高度 int curLevel = 0; // 最终返回的最小高度 int minHeight = Integer.MAX_VALUE; // cur指向null停止，跳出while循环。 while (cur != null) &#123; // cur只要不为null,就一直跑下去 mostRight = cur.left; if (mostRight != null) &#123; // 定义cur左子树上，右边界的节点个数 int leftTreeRightSize = 1; // 2.如果cur有左孩子 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向) mostRight = mostRight.right; // 只要有右节点则高度加1 leftTreeRightSize++; &#125; if (mostRight.right == null) &#123; // 第一次到达cur // 说明往左节点去了，高度加1 curLevel++; // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动 mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // 第二次到达cur if (mostRight.left == null) &#123; // 左节点为空了，说明已经到达叶子节点，判定最小值 minHeight = Math.min(minHeight, curLevel); &#125; // 因为是第二次到cur，所以是当前节点-当前树的右边界节点个数 curLevel -= leftTreeRightSize; // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125; else &#123; // 无左节点，直接往右，高度加1 curLevel++; &#125; // 1.如果cur没有左孩子 cur = cur.right; &#125; // 因为morris序上面的过程是没有计算整树的右边界的最右节点，所以人工把最右节点计算下 int finalRight = 1; cur = head; while (cur.right != null) &#123; // 不断寻找右节点 finalRight++; cur = cur.right; &#125; // 最后不要忘了单独看看整棵树的最右节点是不是叶节点 if (cur.left == null &amp;&amp; cur.right == null) &#123; // 到了最右的叶子节点，取最小值 minHeight = Math.min(minHeight, finalRight); &#125; return minHeight; &#125; public static int p(Node head) &#123; // 左右节点都为空直接返回1 if (head.left == null &amp;&amp; head.right == null) &#123; return 1; &#125; int leftH = Integer.MAX_VALUE; if (head.left != null) &#123; // 如果左节点为空，则继续遍历左子树 leftH = p(head.left); &#125; int rightH = Integer.MAX_VALUE; if (head.right != null) &#123; // 如果右节点为空，则继续遍历右子树 rightH = p(head.right); &#125; // 每次迭代，都深度加1，且取左右子树的最小深度 return 1 + Math.min(leftH, rightH); &#125;&#125; 图定义 由点的集合和边的集合组成 虽然存在有向图和无向图，但都可以用有向图来表示 边上可能带有权值 图的结构表达 邻接表法 邻接矩阵法 除此之外还有其他众多方法 邻接表法 每个节点直接指向的下一个节点。一个表，第一列是当前节点，后面是可到达节点。 A:(B3),(C1) B:(C2) C:(A5) 邻接矩阵法 节点的nxn矩阵，无穷表示不可达，有值则表示权值。 A B C A 无穷(表示不连接) 3 1 B 无穷 无穷 2 C 5 无穷 无穷 图的面试题如何搞定图的算法不算难，只不过coding的代价比较高 先用最熟悉的方式，实验图结构的表达 在自己熟悉的结构上，实现所有常用的图算法作为模板 把面试提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GraphGenerator &#123; public static void main(String[] args) &#123; Node nodeA = new Node(0); Node nodeB = new Node(1); int[][] matrix = &#123;&#123;3, 0, 1&#125;&#125;; Graph ga = createGraph(matrix); System.out.println(ga); &#125; public static Graph createGraph(int[][] matrix) &#123; // 将不熟悉的图结构转化为熟悉的图结构 // 这种结构不是最精简，但能覆盖大多数题目 Graph graph = new Graph(); for (int i = 0; i &lt; matrix.length; i++) &#123; // 拿到每一条边， matrix[i] // 权值 int weight = matrix[i][0]; // 起点 int from = matrix[i][1]; // 终点 int to = matrix[i][2]; // 是否添加到节点集 if (!graph.nodes.containsKey(from)) &#123; graph.nodes.put(from, new Node(from)); &#125; // 是否添加到节点集 if (!graph.nodes.containsKey(to)) &#123; graph.nodes.put(to, new Node(to)); &#125; // 核心：上述完成图的节点集 Node fromNode = graph.nodes.get(from); Node toNode = graph.nodes.get(to); // 创建一个边集 Edge newEdge = new Edge(weight, fromNode, toNode); // 起点加了一个指出的邻接点 fromNode.nexts.add(toNode); // 起点出度加1 fromNode.out++; // 起点添加边集 fromNode.edges.add(newEdge); // 终点入度加1 toNode.in++; // 核心：完成图的边集 graph.edges.add(newEdge); &#125; return graph; &#125; public static class Graph &#123; // 熟悉的图结构信息 // 节点的集合 public HashMap&lt;Integer, Node&gt; nodes; // 节点出去的有向边的集合 public HashSet&lt;Edge&gt; edges; public Graph() &#123; nodes = new HashMap&lt;&gt;(); edges = new HashSet&lt;&gt;(); &#125; &#125; public static class Edge &#123; // 有向边的信息 // 权值 public int weight; // 起点 public Node from; // 终点 public Node to; public Edge(int weight, Node from, Node to) &#123; this.weight = weight; this.from = from; this.to = to; &#125; &#125; public static class Node &#123; // 节点的信息 // 节点值 public int value; // 节点的入度即指入的有向边数 public int in; // 节点的出度即指出的有向边数 public int out; // 节点指出的邻接节点 public ArrayList&lt;Node&gt; nexts; // 节点指出的邻接有向边 public ArrayList&lt;Edge&gt; edges; public Node(int val) &#123; this.value = val; this.in = 0; this.out = 0; this.nexts = new ArrayList&lt;&gt;(); this.edges = new ArrayList&lt;&gt;(); &#125; &#125;&#125; 图的宽度(广度)优先遍历BFS定义：BFS（Breadth First Search）,每一层逐一遍历，同层顺序可任意。 利用队列实现 从源节点开始依次按照宽度进队列，然后弹出 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列 直到队列变空 123456789101112131415161718192021222324252627282930// 从node出发，进行宽度(广度)优先遍历 public static void bfs(Node start) &#123; if (start == null) &#123; return; &#125; // 准备一个队列，先进先出 Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); // 准备一个set，登记不允许重复进入 HashSet&lt;Node&gt; set = new HashSet&lt;&gt;(); // 入队列 queue.add(start); // 登记 set.add(start); while (!queue.isEmpty()) &#123; // 只要队列不为空，就弹出 Node cur = queue.poll(); // 出队列即打印 System.out.println(cur.value); // 将当前节点的邻接节点都加入set for (Node next : cur.nexts) &#123; if (!set.contains(next)) &#123; // 必须是没有被添加过set的节点,否则容易死循环 // 登记 set.add(next); // 入队列 queue.add(next); &#125; &#125; &#125; &#125; 图的深度优先遍历DFS定义:DFS（Depth First Search）,一句话，每次都要走到死胡同才走新的路 利用栈实现 从源节点开始把节点按照深度放入栈，然后弹出 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈 直到栈变空 123456789101112131415161718192021222324252627282930313233// 深度优先遍历 public static void dfs(Node node) &#123; if (node == null) &#123; return; &#125; // 栈本质上保存了当前深度的一条路 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); // 登记表 HashSet&lt;Node&gt; set = new HashSet&lt;&gt;(); // 压栈 stack.add(node); // 登记 set.add(node); // 每次压栈时打印 System.out.println(node.value); while (!stack.isEmpty()) &#123; // 这里会不停的回溯到所有节点，一句话，每次都要走到死胡同才走新的路 Node cur = stack.pop(); // 遍历当前节点的所有邻接点 for (Node next : cur.nexts) &#123; if (!set.contains(next)) &#123; // 如果其中一个邻接点没有登记过，则登记并压栈当前节点和邻接点 stack.push(cur); stack.push(next); set.add(next); // 每次压栈时打印 System.out.println(next.value); // 后续的邻接点直接跳过，因为有回溯 break; &#125; &#125; &#125; &#125; 图的拓扑排序算法 在图中找到所有入度为0的点输出 把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始 图的所有点都被删除后，依次输出的顺序就是拓扑排序 要求：一定是有向无环图即有向图且没有环 应用：事件安排、编译顺序 1234567891011121314151617181920212223242526272829303132// directed graph and no loop有向无环图的拓扑算法排序 public static List&lt;Node&gt; sortedTopology(Graph graph) &#123; // key 某个节点 value 剩余的入度 HashMap&lt;Node, Integer&gt; inMap = new HashMap&lt;&gt;(); // 只有剩余入度为0的点，才进入这个队列 Queue&lt;Node&gt; zeroInQueue = new LinkedList&lt;&gt;(); for (Node node : graph.nodes.values()) &#123; // 遍历所有图的节点 inMap.put(node, node.in); if (node.in == 0) &#123; // 找到第一批入度为0的点 zeroInQueue.add(node); &#125; &#125; List&lt;Node&gt; result = new ArrayList&lt;&gt;(); while (!zeroInQueue.isEmpty()) &#123; // 周而复始的查找入度为0的节点 Node cur = zeroInQueue.poll(); // 弹出队列，并添加到list result.add(cur); // 遍历当前节点的所有邻接节点 for (Node next : cur.nexts) &#123; // 邻接节点的入度减1 inMap.put(next, inMap.get(next) - 1); if (inMap.get(next) == 0) &#123; // 找到入度为0的点 zeroInQueue.add(next); &#125; &#125; &#125; return result; &#125; 最小生成树之Kruskal即K算法最小生成树定义：所有的点都连通且无环的最小权值边的集合。 总是从权值最小的边开始考虑，依次考察权值依次变大的边，可用小根堆排序 遍历所有边，当前的边要么进入最小生成树的集合，要么丢弃 如果边的2个节点至少1个不在最小生成树的集合中，就要当前边 如果边的2个节点都在最小生成树的集合中，就不要当前边 考察完所有边之后，最小生成树的集合也得到了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.*;public class Kruskal &#123; public static Set&lt;Edge&gt; kruskalMST(Graph graph) &#123; // K算法 UnionFind unionFind = new UnionFind(); unionFind.makeSets(graph.nodes.values()); // 从小的边到大的边，依次弹出，小根堆！ PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;&gt;(new EdgeComparator()); for (Edge edge : graph.edges) &#123; // M 条边 priorityQueue.add(edge); // O(logM) &#125; Set&lt;Edge&gt; result = new HashSet&lt;&gt;(); // 遍历所有的边集 while (!priorityQueue.isEmpty()) &#123; // M 条边 // 依次弹出最小权值的边 Edge edge = priorityQueue.poll(); // O(logM) // 判断边的2个节点是否在最小生成树的集合并查集里 if (!unionFind.isSameSet(edge.from, edge.to)) &#123; // O(1) // 不在，则添加 result.add(edge); unionFind.union(edge.from, edge.to); &#125; &#125; return result; &#125; // Union-Find Set左神的并查集 public static class UnionFind &#123; // key 某一个节点， value key节点往上的节点 private HashMap&lt;Node, Node&gt; fatherMap; // key 某一个集合的代表节点, value key所在集合的节点个数 private HashMap&lt;Node, Integer&gt; sizeMap; public UnionFind() &#123; fatherMap = new HashMap&lt;Node, Node&gt;(); sizeMap = new HashMap&lt;Node, Integer&gt;(); &#125; public void makeSets(Collection&lt;Node&gt; nodes) &#123; fatherMap.clear(); sizeMap.clear(); for (Node node : nodes) &#123; fatherMap.put(node, node); sizeMap.put(node, 1); &#125; &#125; private Node findFather(Node n) &#123; Stack&lt;Node&gt; path = new Stack&lt;&gt;(); while (n != fatherMap.get(n)) &#123; path.add(n); n = fatherMap.get(n); &#125; while (!path.isEmpty()) &#123; fatherMap.put(path.pop(), n); &#125; return n; &#125; public boolean isSameSet(Node a, Node b) &#123; return findFather(a) == findFather(b); &#125; public void union(Node a, Node b) &#123; if (a == null || b == null) &#123; return; &#125; Node aDai = findFather(a); Node bDai = findFather(b); if (aDai != bDai) &#123; int aSetSize = sizeMap.get(aDai); int bSetSize = sizeMap.get(bDai); if (aSetSize &lt;= bSetSize) &#123; fatherMap.put(aDai, bDai); sizeMap.put(bDai, aSetSize + bSetSize); sizeMap.remove(aDai); &#125; else &#123; fatherMap.put(bDai, aDai); sizeMap.put(aDai, aSetSize + bSetSize); sizeMap.remove(bDai); &#125; &#125; &#125; &#125; public static class EdgeComparator implements Comparator&lt;Edge&gt; &#123; @Override public int compare(Edge o1, Edge o2) &#123; return o1.weight - o2.weight; &#125; &#125;&#125; 最小生成树之Prim即P算法核心：点解锁边，边解锁点，点解锁边…不断重复下去，直到所有点加入集合中 定义一个已解锁点集合nodeSet和一个已解锁边集合edgeSet 随机选择一个点加入nodeSet中，并将与它相连的边加入edgeSet。假设我们选择了A点 选择已解锁边集合中权值最小且边的另一个点不在已解锁点集合中，选择后将该边从已解锁边集合删除，并把另一个点加入已解锁点集合中 重复第②步直到所有的点加入了已解锁集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class Prim &#123; //定义一个堆比较器，将边的权值从小到大排序 public static class EdgeComparator implements Comparator&lt;Edge&gt; &#123; @Override public int compare(Edge o1, Edge o2) &#123; // TODO Auto-generated method stub return o1.weight - o2.weight; &#125; &#125; public static Set&lt;Edge&gt; primSet(Graph graph) &#123; // P算法 // ，按照从小到大排序 PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;&gt;(new EdgeComparator()); //解锁出来的Node HashSet&lt;Node&gt; nodeSet = new HashSet&lt;&gt;(); //解锁出来的edge,也可以不用，用了可以提高效率和去重 HashSet&lt;Edge&gt; edgeSet = new HashSet&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Set&lt;Edge&gt; result = new HashSet&lt;&gt;(); //依次挑选的边放在result for (Node node : graph.nodes.values()) &#123; //随便挑了一个点,此for循环防止出现森林即多个独立的图 //node是开始点，任意点开始 if (!nodeSet.contains(node)) &#123; // 当前节点不在集合中，则可解锁 nodeSet.add(node); // 点解锁边 for (Edge edge : node.edges) &#123; //由该点解锁所有相关的边 if (!edgeSet.contains(edge)) &#123; // 过滤当前节点没有被解锁的边集 priorityQueue.add(edge); edgeSet.add(edge); &#125; &#125; // 逐一遍历已解锁的最小权值的边集 while (!priorityQueue.isEmpty()) &#123; Edge edge = priorityQueue.poll(); //弹出已解锁边中的最小边 Node toNode = edge.to; //可能的新一个节点 // 边解锁点 if (!nodeSet.contains(toNode)) &#123; nodeSet.add(toNode); result.add(edge); &#125; // 点解锁边 for (Edge nextEdge : toNode.edges) &#123; if (!edgeSet.contains(nextEdge)) &#123; priorityQueue.add(nextEdge); edgeSet.add(nextEdge); &#125; &#125; &#125; &#125; break; &#125; return result; &#125;&#125; 最短路径算法之Dijkstra算法狄利克斯拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。 迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。 解法1：贪心法遍历所有节点 解法2：改进后的dijkstra算法，就是利用动态小根堆，优化getMinDistanceAndUnselectedNode方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Map.Entry;public class Code06_Dijkstra &#123; // 狄利克斯拉算法 public static class Edge &#123; // 有向边的信息 // 权值 public int weight; // 起点 public Node from; // 终点 public Node to; public Edge(int weight, Node from, Node to) &#123; this.weight = weight; this.from = from; this.to = to; &#125; &#125; public static class Node &#123; // 节点的信息 // 节点值 public int value; // 节点的入度即指入的有向边数 public int in; // 节点的出度即指出的有向边数 public int out; // 节点指出的邻接节点 public ArrayList&lt;Node&gt; nexts; // 节点指出的邻接有向边 public ArrayList&lt;Edge&gt; edges; public Node(int val) &#123; this.value = val; this.in = 0; this.out = 0; this.nexts = new ArrayList&lt;&gt;(); this.edges = new ArrayList&lt;&gt;(); &#125; &#125; // 解法1：贪心法遍历所有节点 public static HashMap&lt;Node, Integer&gt; dijkstra1(Node from) &#123; // 狄利克斯拉算法:从任意一个点出发，得到一个map的最小距离表 HashMap&lt;Node, Integer&gt; distanceMap = new HashMap&lt;&gt;(); // 键表示默认form-key，比如from到from,所以距离为0 distanceMap.put(from, 0); // 已经计算好的节点，把它锁定 HashSet&lt;Node&gt; selectedNodes = new HashSet&lt;&gt;(); // 在剩下已有的最短距离表中，剔除掉锁定算好的节点，依次找出最小距离的点。定义为当前最小距离点 Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); while (minNode != null) &#123; // 原始点form -&gt; minNode(跳转点) 最小距离distance int distance = distanceMap.get(minNode); // 取出最小距离点的所有指向边 for (Edge edge : minNode.edges) &#123; // 遍历所有的边，以便接下来完成该点的更新 Node toNode = edge.to; if (!distanceMap.containsKey(toNode)) &#123; // 如果最小距离表中没有该节点，直接添加。注意需要加上之前的距离 distanceMap.put(toNode, distance + edge.weight); &#125; else &#123; // toNode // 如果添加过，则判断过去的值与当前值，取最小值更新 distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight)); &#125; &#125; // 当前最小距离点计算完后，就锁定，后续不再更新它的最短距离，完成该点的更新 selectedNodes.add(minNode); // 继续找下一个当前最小距离点 minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); &#125; return distanceMap; &#125; public static Node getMinDistanceAndUnselectedNode(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes) &#123; // 方法名很长，很唬人，本质是返回最小距离表中，未被锁定且最小距离的节点。方便后续继续计算最短记录。 Node minNode = null; int minDistance = Integer.MAX_VALUE; for (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123; // 遍历最小距离表 Node node = entry.getKey(); int distance = entry.getValue(); if (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123; // 找出最小距离表中，未被锁定且最小距离的节点 minNode = node; minDistance = distance; &#125; &#125; return minNode; &#125; public static class NodeRecord &#123; // 最小距离表的节点 public Node node; // 最短距离 public int distance; public NodeRecord(Node node, int distance) &#123; this.node = node; this.distance = distance; &#125; &#125; public static class NodeHeap &#123; // 动态小根堆结构 private Node[] nodes; // 实际的堆结构 // 节点索引记录表：key 某一个node， value 上面堆中的位置 private HashMap&lt;Node, Integer&gt; heapIndexMap; // key 某一个节点， value 从源节点出发到该节点的目前最小距离 private HashMap&lt;Node, Integer&gt; distanceMap; private int size; // 堆上有多少个点 public NodeHeap(int size) &#123; nodes = new Node[size]; heapIndexMap = new HashMap&lt;&gt;(); distanceMap = new HashMap&lt;&gt;(); size = 0; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance // 集成添加，更新，直接跳过 public void addOrUpdateOrIgnore(Node node, int distance) &#123; // 已经在小根堆里，更新最小距离，然后上窜 if (inHeap(node)) &#123; // 更新最短距离 distanceMap.put(node, Math.min(distanceMap.get(node), distance)); // 上窜 insertHeapify(heapIndexMap.get(node)); &#125; // 没有进去过记录表的，直接添加，然后上窜 if (!isEntered(node)) &#123; nodes[size] = node; heapIndexMap.put(node, size); distanceMap.put(node, distance); // 上窜 insertHeapify(size++); &#125; // 已经记录并更新的节点，锁定，直接跳过 &#125; // 弹出小根堆顶部最小值，并继续小根堆化 public NodeRecord pop() &#123; NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0])); swap(0, size - 1); heapIndexMap.put(nodes[size - 1], -1); distanceMap.remove(nodes[size - 1]); // free C++同学还要把原本堆顶节点析构，对java同学不必 nodes[size - 1] = null; // 下窜 heapify(0, --size); return nodeRecord; &#125; // 上窜 private void insertHeapify(int index) &#123; while (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - 1) / 2])) &#123; swap(index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; // 下窜 private void heapify(int index, int size) &#123; int left = index * 2 + 1; while (left &lt; size) &#123; int smallest = left + 1 &lt; size &amp;&amp; distanceMap.get(nodes[left + 1]) &lt; distanceMap.get(nodes[left]) ? left + 1 : left; smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index; if (smallest == index) &#123; break; &#125; swap(smallest, index); index = smallest; left = index * 2 + 1; &#125; &#125; private boolean isEntered(Node node) &#123; return heapIndexMap.containsKey(node); &#125; private boolean inHeap(Node node) &#123; return isEntered(node) &amp;&amp; heapIndexMap.get(node) != -1; &#125; private void swap(int index1, int index2) &#123; heapIndexMap.put(nodes[index1], index2); heapIndexMap.put(nodes[index2], index1); Node tmp = nodes[index1]; nodes[index1] = nodes[index2]; nodes[index2] = tmp; &#125; &#125; // 解法2：改进后的dijkstra算法，就是利用动态小根堆，优化getMinDistanceAndUnselectedNode方法。 // 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回 public static HashMap&lt;Node, Integer&gt; dijkstra2(Node head, int size) &#123; NodeHeap nodeHeap = new NodeHeap(size); // 从0开始更新 nodeHeap.addOrUpdateOrIgnore(head, 0); HashMap&lt;Node, Integer&gt; result = new HashMap&lt;&gt;(); while (!nodeHeap.isEmpty()) &#123; // 从小根堆汇总逐一弹出顶部节点 NodeRecord record = nodeHeap.pop(); Node cur = record.node; int distance = record.distance; // 遍历节点的所有指向边 for (Edge edge : cur.edges) &#123; // 继续更新最短距离点 nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance); &#125; // 更新一个节点，锁定一个，返回一个 result.put(cur, distance); &#125; return result; &#125;&#125; TSP问题也叫商旅问题，非常之难。问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。 单词接龙题目：给出两个单词（start和end）和一个字典，找出所有从start到end的最短转换序列。 变换规则如下： 每次只能改变一个字母。 变换过程中的中间单词必须在字典中出现。 解法1：图的宽度优先遍历和深度优先遍历的最强综合应用。返回从start变换到end的所有最短路径集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Queue;// 本题测试链接 : https://leetcode.com/problems/word-ladder-ii/public class Code04_WordLadderII &#123; // 解法1：图的宽度优先遍历和深度优先遍历的最强综合应用。返回从start变换到end的所有最短路径集合 public static List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; list) &#123; list.add(start); // 返回list列表的,每个字符串对应的所有直接邻居(限制在当前list)。因为是所有list元素的直接邻居，可以认为是一张list节点的图 HashMap&lt;String, List&lt;String&gt;&gt; nexts = getNexts(list); // 在图的结构中，获取所有节点到start节点的最短距离，利用宽度优先遍历求解，横向一直走，只保留距离+1的节点 HashMap&lt;String, Integer&gt; fromDistances = getDistances(start, nexts); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); // 如果最短距离列表中，没有目的节点，那么一定不能变换，返回空 if (!fromDistances.containsKey(end)) &#123; return res; &#125; // 同上 HashMap&lt;String, Integer&gt; toDistances = getDistances(end, nexts); LinkedList&lt;String&gt; pathList = new LinkedList&lt;&gt;(); // 获取最短路径，入参：从start当前节点变换到ends字符串，nexts是邻居表，fromDistances是当前节点到start节点的距离，toDistances是当前节点到end节点的距离，pathList表示实时路径，res是最终路径集合 getShortestPaths(start, end, nexts, fromDistances, toDistances, pathList, res); return res; &#125; public static HashMap&lt;String, List&lt;String&gt;&gt; getNexts(List&lt;String&gt; words) &#123; HashSet&lt;String&gt; dict = new HashSet&lt;&gt;(words); HashMap&lt;String, List&lt;String&gt;&gt; nexts = new HashMap&lt;&gt;(); for (int i = 0; i &lt; words.size(); i++) &#123; nexts.put(words.get(i), getNext(words.get(i), dict)); &#125; return nexts; &#125; // word, 在表中，有哪些邻居，把邻居们，生成list返回 public static List&lt;String&gt; getNext(String word, HashSet&lt;String&gt; dict) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); char[] chs = word.toCharArray(); for (char cur = &#x27;a&#x27;; cur &lt;= &#x27;z&#x27;; cur++) &#123; for (int i = 0; i &lt; chs.length; i++) &#123; if (chs[i] != cur) &#123; char tmp = chs[i]; chs[i] = cur; if (dict.contains(String.valueOf(chs))) &#123; res.add(String.valueOf(chs)); &#125; chs[i] = tmp; &#125; &#125; &#125; return res; &#125; // 图的宽度优先遍历：生成距离表，从start开始，根据邻居表，宽度优先遍历，对于能够遇到的所有字符串，生成(字符串，距离)这条记录，放入距离表中 public static HashMap&lt;String, Integer&gt; getDistances(String start, HashMap&lt;String, List&lt;String&gt;&gt; nexts) &#123; HashMap&lt;String, Integer&gt; distances = new HashMap&lt;&gt;(); distances.put(start, 0); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(start); while (!queue.isEmpty()) &#123; String cur = queue.poll(); for (String next : nexts.get(cur)) &#123; if (!set.contains(next)) &#123; distances.put(next, distances.get(cur) + 1); queue.add(next); set.add(next); &#125; &#125; &#125; return distances; &#125; // cur 当前来到的字符串 可变 // to 目标，固定参数 // nexts 每一个字符串的邻居表 // cur 到开头距离5 -&gt; 到开头距离是6的支路 fromDistances距离表 // cur 到结尾距离5 -&gt; 到开头距离是4的支路 toDistances距离表 // path : 来到cur之前，深度优先遍历之前的历史是什么 // res : 当遇到cur，把历史，放入res，作为一个结果 // 图的深度优先遍历 public static void getShortestPaths(String cur, String to, HashMap&lt;String, List&lt;String&gt;&gt; nexts, HashMap&lt;String, Integer&gt; fromDistances, HashMap&lt;String, Integer&gt; toDistances, LinkedList&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res) &#123; // 直接添加当前节点 path.add(cur); if (to.equals(cur)) &#123; // 当前节点和目的节点相同，说明变换成功了，直接记录一条路径 res.add(new LinkedList&lt;String&gt;(path)); &#125; else &#123; // 递归邻居表 for (String next : nexts.get(cur)) &#123; // 当下一个节点放进来后，往前的距离+1，往后的距离-1，才进行递归 if (fromDistances.get(next) == fromDistances.get(cur) + 1 &amp;&amp; toDistances.get(next) == toDistances.get(cur) - 1) &#123; getShortestPaths(next, to, nexts, fromDistances, toDistances, path, res); &#125; &#125; &#125; // 如果不满足上述条件，需要弹出前面添加的节点，路径重新添加分支走下去 path.pollLast(); &#125;&#125; 动态规划核心重要重要重要：笔试最差也要改为傻缓存dp表跟随的动态规划（也就是记忆化搜索方法），面试尽可能改为精细化动态规划填dp表 动态规划的终极套路 先写暴力递归的尝试过程 将暴力递归改为为记忆化搜索即带缓存的暴力递归，leetcode能通过。记忆化搜索也是dp的一种。 用dp状态转移方程精细化后变成动态规划，leetcode能通过 动态规划的4种经典尝试模型 DP1：从左往右的尝试模型，关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。 DP2：从L–R范围上的尝试模型，关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填 DP3：多样本位置对应的尝试模型，2个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间 DP4：业务限制类的尝试模型，比如走棋盘，固定的几个方向可以走，先填边界，再填中间。 记忆化搜索即带缓存的暴力递归-leetcode通过 用缓存dp替代暴力递归中的重复计算过程。 暴力递归改为记忆化搜索套路： (1)先判断下重复过程，dp跟几个参数有关就是几维数组。 (2)递归过程一定携带dp,注意递归还是递归，不改 (3)return的地方改写为取dp值，注意先缓存，再返回值 动态规划-leetcode通过 将记忆化搜索或暴力递归，直接改写为填写dp表，返回结果需要用到的dp值。前提：需要将记忆化搜索直观的转成可理解的dp表，最好画图。 暴力递归改为dp动态规划套路： (1)return的地方就是设置dp值 (2)添加遍历，注意是dp是几维数组就是几维遍历，关键分析是从左到右，还是从上到下，这个重要 (3)所有递归调用的地方，直接改为dp。这里需要注意前面return的，就是这里的限制条件。这里的本质：填写dp表，把最终的结果用dp表的值返回 任何一个暴力递归优化成结构化描述的动态规划，需要满足两个条件： 暴力递归中有重复计算的过程 有限的可变参数影响结果 不满足以上2个条件的暴力递归，要么无法改为动态规划(不是有限可变参数)，要么即使改成动态规划也意义不大(没有重复过程，缓存没有意义)。 暴力递归暴力递归就是尝试 把问题转化为规模缩小的同类问题的子问题 有明确的不需要继续进行递归的条件(base case) 有当得到了子问题的结果之后的决策过程 不记录每一个子问题的解。如果真的要记录了，就是动态规划了 熟悉什么叫尝试 1.打印n层汉诺塔从最左边移动到最右边的全过程 2.打印一个字符串的全部子序列 3.打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复 4.打印一个字符串的全部排列 5.打印一个字符串的全部排列，要求不重复的排列 子串、子序列、排列区别： 例子：abcd 子串：连续的有序，a,ab,abc,abcd,b,bc,bcd,c,cd 子序列：不连续有序，是a,b,c,d,ab,ac,ad,bc,bd,cd,abc,abd,acd,abcd 全排列：不连续无序，abcd,abdc,acbd,acdb… 排列组合：不连续无序，a,b,c,ab,ac,ad…. 1.汉诺塔问题 题目：三个柱子，A、B、C，在A柱子上从上到下依次放着从小到大的盘子，每次只能拿一个盘子，怎么把盘子搬动到另外的柱子上而保证盘子的大小顺序完全一致？要求搬动过程中，必须保证大盘子在下，小盘子在上。 思路：核心就是拆解为三大步,假设三个柱子是from other to。N层汉诺塔问题的步数一定是2^N-1步。 第一步：1到N-1个盘子从from移动到other,腾位置给后续第N个盘子移动 第二步：第N个盘子从from移动到to 第三步：1到N-1个盘子从other移动到to。搞定 解法1：暴力递归的三步曲 解法2：暴力递归的三部曲优化为from起点,to终点,other其他.推荐 解法3：非递归方法，利用栈模拟递归调用，关键参数base表示多少层，finish1表示第一步是否完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import java.util.Stack;public class Code02_Hanoi &#123; public static void hanoi1(int n) &#123; // 解法1：暴力递归的三步曲 leftToRight(n); &#125; // 请把1~N层圆盘 从左 -&gt; 右 public static void leftToRight(int n) &#123; // 明确的不需要继续进行递归的条件(base case)即左边只剩下一个N号盘子，直接移动过去 if (n == 1) &#123; // base case System.out.println(&quot;Move 1 from left to right&quot;); return; &#125; // 第一步：1到N-1个盘子从from移动到other,腾位置给后续第N个盘子移动 leftToMid(n - 1); // 第二步：第N个盘子从from移动到to System.out.println(&quot;Move &quot; + n + &quot; from left to right&quot;); // 第三步：1到N-1个盘子从other移动到to。 midToRight(n - 1); &#125; // 请把1~N层圆盘 从左 -&gt; 中 public static void leftToMid(int n) &#123; // 同上一样的三步曲 if (n == 1) &#123; System.out.println(&quot;Move 1 from left to mid&quot;); return; &#125; leftToRight(n - 1); System.out.println(&quot;Move &quot; + n + &quot; from left to mid&quot;); rightToMid(n - 1); &#125; public static void rightToMid(int n) &#123; // 同上一样的三步曲 if (n == 1) &#123; System.out.println(&quot;Move 1 from right to mid&quot;); return; &#125; rightToLeft(n - 1); System.out.println(&quot;Move &quot; + n + &quot; from right to mid&quot;); leftToMid(n - 1); &#125; public static void midToRight(int n) &#123; // 同上一样的三步曲 if (n == 1) &#123; System.out.println(&quot;Move 1 from mid to right&quot;); return; &#125; midToLeft(n - 1); System.out.println(&quot;Move &quot; + n + &quot; from mid to right&quot;); leftToRight(n - 1); &#125; public static void midToLeft(int n) &#123; // 同上一样的三步曲 if (n == 1) &#123; System.out.println(&quot;Move 1 from mid to left&quot;); return; &#125; midToRight(n - 1); System.out.println(&quot;Move &quot; + n + &quot; from mid to left&quot;); rightToLeft(n - 1); &#125; public static void rightToLeft(int n) &#123; // 同上一样的三步曲 if (n == 1) &#123; System.out.println(&quot;Move 1 from right to left&quot;); return; &#125; rightToMid(n - 1); System.out.println(&quot;Move &quot; + n + &quot; from right to left&quot;); midToLeft(n - 1); &#125; public static void hanoi2(int n) &#123; // 解法2：暴力递归的三部曲优化为from起点,to终点,other其他. if (n &gt; 0) &#123; func(n, &quot;left&quot;, &quot;right&quot;, &quot;mid&quot;); &#125; &#125; // n个盘子，从from移动到to,借助other public static void func(int N, String from, String to, String other) &#123; if (N == 1) &#123; // base case // 最后form剩下N号盘子，直接移动过去 System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to); &#125; else &#123; // from还有盘子话 // 第一步：1到N-1个盘子从from移动到other,腾位置 func(N - 1, from, other, to); // 第二步：第N个盘子从from移动到to System.out.println(&quot;Move &quot; + N + &quot; from &quot; + from + &quot; to &quot; + to); // 第三步：1到N-1个盘子从other移动到to。搞定 func(N - 1, other, to, from); &#125; &#125; public static class Record &#123; public boolean finish1; public int base; public String from; public String to; public String other; public Record(boolean f1, int b, String f, String t, String o) &#123; finish1 = false; base = b; from = f; to = t; other = o; &#125; &#125; // 解法3：非递归方法，利用栈模拟递归调用，关键参数base表示多少层，finish1表示第一步是否完成。 public static void hanoi3(int N) &#123; if (N &lt; 1) &#123; return; &#125; Stack&lt;Record&gt; stack = new Stack&lt;&gt;(); stack.add(new Record(false, N, &quot;left&quot;, &quot;right&quot;, &quot;mid&quot;)); while (!stack.isEmpty()) &#123; Record cur = stack.pop(); if (cur.base == 1) &#123; // 第二步：第N个盘子从from移动到to System.out.println(&quot;Move 1 from &quot; + cur.from + &quot; to &quot; + cur.to); if (!stack.isEmpty()) &#123; stack.peek().finish1 = true; &#125; &#125; else &#123; if (!cur.finish1) &#123; // 表示没完成 stack.push(cur); // 第一步：1到N-1个盘子从from移动到other,腾位置 stack.push(new Record(false, cur.base - 1, cur.from, cur.other, cur.to)); &#125; else &#123; // 第一步完成了，执行下面 System.out.println(&quot;Move &quot; + cur.base + &quot; from &quot; + cur.from + &quot; to &quot; + cur.to); // 第三步：1到N-1个盘子从other移动到to。搞定 stack.push(new Record(false, cur.base - 1, cur.other, cur.to, cur.from)); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int n = 3; hanoi1(n); System.out.println(&quot;============&quot;); hanoi2(n); System.out.println(&quot;============&quot;); hanoi3(n); &#125;&#125; 2.打印一个字符串的全部子序列 1234567891011121314151617181920212223242526// 打印一个字符串的全部子序列public static List&lt;String&gt; subs(String s) &#123; char[] str = s.toCharArray(); String path = &quot;&quot;; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); process1(str, 0, ans, path); return ans; &#125; // str 固定参数 // 来到了str[index]字符，index是位置 // str[0..index-1]已经走过了！之前的决定，都在path上 // 之前的决定已经不能改变了，就是path // str[index....]还能决定，之前已经确定，而后面还能自由选择的话， // 把所有生成的子序列，放入到ans里去 public static void process1(char[] str, int index, List&lt;String&gt; ans, String path) &#123; // 索引已经来到最后一个字符，找到了字符串，加入到list if (index == str.length) &#123; ans.add(path); return; &#125; // 分支左：没有要index位置的字符，path继续 process1(str, index + 1, ans, path); // 分支右：要了index位置的字符，path拼接起来 process1(str, index + 1, ans, path + String.valueOf(str[index])); &#125; 3.打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复 123456789101112131415161718192021222324// 打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复。public static List&lt;String&gt; subsNoRepeat(String s) &#123; // 最终结果使用set集合即可，同题目2，99%相似 char[] str = s.toCharArray(); String path = &quot;&quot;; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); process2(str, 0, set, path); List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (String cur : set) &#123; ans.add(cur); &#125; return ans; &#125; public static void process2(char[] str, int index, HashSet&lt;String&gt; set, String path) &#123; if (index == str.length) &#123; set.add(path); return; &#125; String no = path; process2(str, index + 1, set, no); String yes = path + String.valueOf(str[index]); process2(str, index + 1, set, yes); &#125; 4.打印一个字符串的全部排列 123456789101112131415161718192021222324252627public static List&lt;String&gt; permutation2(String s) &#123; // 打印一个字符串的全部排列 List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return ans; &#125; char[] str = s.toCharArray(); g1(str, 0, ans); return ans;&#125;public static void g1(char[] str, int index, List&lt;String&gt; ans) &#123; // 索引已经来到最后一个字符，找到了字符串，加入到list if (index == str.length) &#123; ans.add(String.valueOf(str)); &#125; else &#123; // 尝试将索引值index及其后续的字符交换到index上，找到字符串 for (int i = index; i &lt; str.length; i++) &#123; // 交换 swap(str, index, i); // 递归下一个索引值 g1(str, index + 1, ans); // 每次交换完，再恢复到原始现场，方便下次递归使用原始变量 swap(str, index, i); &#125; &#125;&#125; 5.打印一个字符串的全部排列，要求不重复的排列 最终结果也可以使用set集合即可，同题目4，99%相似。 优化方法：利用分支限界，提前杀死分支支路。即出现过的字符，则不再执行逻辑。 1234567891011121314151617181920212223242526public static List&lt;String&gt; permutation3(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return ans; &#125; char[] str = s.toCharArray(); g2(str, 0, ans); return ans;&#125;public static void g2(char[] str, int index, List&lt;String&gt; ans) &#123; if (index == str.length) &#123; ans.add(String.valueOf(str)); &#125; else &#123; // 分支限界，visited类似hash表记录字符是否已被使用过 boolean[] visited = new boolean[256]; for (int i = index; i &lt; str.length; i++) &#123; if (!visited[str[i] - &#x27;a&#x27;]) &#123; // 使用过的字符，不再使用 visited[str[i] - &#x27;a&#x27;] = true; swap(str, index, i); g2(str, index + 1, ans); swap(str, index, i); &#125; &#125; &#125;&#125; 栈的逆序 题目：给你一个栈，请你逆序这个栈。不能申请额外的数据结构。只能使用递归函数。如何实现。 思路：递归自己一级一级捋。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Stack;public class Code05_ReverseStackUsingRecursive &#123; public static void reverse(Stack&lt;Integer&gt; stack) &#123; if (stack.isEmpty()) &#123; return; &#125; // i临时记录栈底的元素，并剩余元素盖下来 int i = f(stack); // 递归调用反转函数 reverse(stack); // 先压入1，然后2，然后3 stack.push(i); &#125; // 功能：返回移除掉的栈底元素，上面的元素盖下来。 /* * 1 * 2 1 * 3 2 * 栈，返回3，栈 * */ public static int f(Stack&lt;Integer&gt; stack) &#123; // r临时记录栈顶元素，最后是要返回的 int result = stack.pop(); if (stack.isEmpty()) &#123; return result; &#125; else &#123; // l临时记录栈底元素 int last = f(stack); // 栈底的元素再压进来，这样每次都是先压上面的 stack.push(result); return last; &#125; &#125; public static void main(String[] args) &#123; Stack&lt;Integer&gt; test = new Stack&lt;Integer&gt;(); test.push(1); test.push(2); test.push(3); test.push(4); test.push(5); reverse(test); while (!test.isEmpty()) &#123; System.out.println(test.pop()); &#125; &#125;&#125; 尝试模型从左往右的尝试模型1-字符串转化题目：规定1和A对应，2和B对应，3和C对应，那么一串“111”可以转化为“AAA”，“KA”，“AK”三种转化结果。问给定一个只有数字字符组成的字符串str,有多少种转化结果。 解法1：暴力递归的尝试过程 解法2：记忆化搜索即带缓存dp的暴力递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class Code02_ConvertToLetterString &#123; // str只含有数字字符0~9 // 返回多少种转化方案 public static int number(String str) &#123; // 解法1：暴力递归的尝试过程 // 边界条件 if (str == null || str.length() == 0) &#123; return 0; &#125; // 记录从0开始往后有多少种转换方法 return process(str.toCharArray(), 0); &#125; // str[0..i-1]转化无需过问 // 表示str[i.....]去转化，返回有多少种转化方法 public static int process(char[] str, int i) &#123; // i到最后，说明没有有字符，记录一种转化方法 if (i == str.length) &#123; return 1; &#125; // 单独的0是不能记录为一种转化方法的 if (str[i] == &#x27;0&#x27;) &#123; // 之前的决定有问题 return 0; &#125; // str[i] != &#x27;0&#x27; // 可能性一，1-9都是可以单独转换的，i不用管,继续往后转换，从i+1开始，有多少种转换 int ways = process(str, i + 1); // 可能性二，10到26即小于27的两位数都是可以转换的 if (i + 1 &lt; str.length &amp;&amp; (str[i] - &#x27;0&#x27;) * 10 + str[i + 1] - &#x27;0&#x27; &lt; 27) &#123; // 继续向后转换 ways += process(str, i + 2); &#125; return ways; &#125; // 从右往左的动态规划 // 就是上面方法的动态规划版本 // dp[i]表示：str[i...]有多少种转化方式 public static int dp1(String s) &#123; // 解法2：暴力递归改为dp动态规划 /*暴力递归改为dp动态规划的核心核心，重要重要重要 * (1)return的地方就是设置dp值 * (2)添加遍历，注意是dp是几维数组就是几维遍历，关键分析是从左到右，还是从上到下，这个重要 * (3)所有递归调用的地方，直接改为dp。这里需要注意前面return的，就是这里的限制条件。 * */ if (s == null || s.length() == 0) &#123; return 0; &#125; char[] str = s.toCharArray(); int N = str.length; // 开始改写为dp。因为每个所有的字符都要用到，所以N也要。那么久需要N+1的长度。 int[] dp = new int[N + 1]; /*dp对应的暴力代码 if (i == str.length) &#123; return 1; &#125;*/ // return的地方就是设置dp值 dp[N] = 1; // 因为dp是一维数组 // 前面的值依赖后面的值，所以从右往左遍历 for (int i = N - 1; i &gt;= 0; i--) &#123; // 因为前面的return,所以加限制条件 if (str[i] != &#x27;0&#x27;) &#123; // 递归调用的地方，直接改为dp int ways = dp[i + 1]; if (i + 1 &lt; str.length &amp;&amp; (str[i] - &#x27;0&#x27;) * 10 + str[i + 1] - &#x27;0&#x27; &lt; 27) &#123; ways += dp[i + 2]; &#125; // return的地方就是设置dp值 dp[i] = ways; &#125; &#125; // 因为暴力递归是要return process(str.toCharArray(), 0);返回0转态的，所以是0 return dp[0]; &#125; // 从左往右的动态规划 // dp[i]表示：str[0...i]有多少种转化方式 public static int dp2(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; char[] str = s.toCharArray(); int N = str.length; if (str[0] == &#x27;0&#x27;) &#123; return 0; &#125; int[] dp = new int[N]; dp[0] = 1; for (int i = 1; i &lt; N; i++) &#123; if (str[i] == &#x27;0&#x27;) &#123; // 如果此时str[i]==&#x27;0&#x27;，那么他是一定要拉前一个字符(i-1的字符)一起拼的， // 那么就要求前一个字符，不能也是‘0’，否则拼不了。 // 前一个字符不是‘0’就够了嘛？不够，还得要求拼完了要么是10，要么是20，如果更大的话，拼不了。 // 这就够了嘛？还不够，你们拼完了，还得要求str[0...i-2]真的可以被分解！ // 如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行，因为之前的搞定不了。 if (str[i - 1] == &#x27;0&#x27; || str[i - 1] &gt; &#x27;2&#x27; || (i - 2 &gt;= 0 &amp;&amp; dp[i - 2] == 0)) &#123; return 0; &#125; else &#123; dp[i] = i - 2 &gt;= 0 ? dp[i - 2] : 1; &#125; &#125; else &#123; dp[i] = dp[i - 1]; if (str[i - 1] != &#x27;0&#x27; &amp;&amp; (str[i - 1] - &#x27;0&#x27;) * 10 + str[i] - &#x27;0&#x27; &lt;= 26) &#123; dp[i] += i - 2 &gt;= 0 ? dp[i - 2] : 1; &#125; &#125; &#125; return dp[N - 1]; &#125; // 为了测试 public static String randomString(int len) &#123; char[] str = new char[len]; for (int i = 0; i &lt; len; i++) &#123; str[i] = (char) ((int) (Math.random() * 10) + &#x27;0&#x27;); &#125; return String.valueOf(str); &#125; // 为了测试 public static void main(String[] args) &#123; int N = 30; int testTime = 1000000; System.out.println(&quot;测试开始&quot;); for (int i = 0; i &lt; testTime; i++) &#123; int len = (int) (Math.random() * N); String s = randomString(len); int ans0 = number(s); int ans1 = dp1(s); int ans2 = dp2(s); if (ans0 != ans1 || ans0 != ans2) &#123; System.out.println(s); System.out.println(ans0); System.out.println(ans1); System.out.println(ans2); System.out.println(&quot;Oops!&quot;); break; &#125; &#125; System.out.println(&quot;测试结束&quot;); &#125;&#125; 从左往右的尝试模型2-背包问题题目：给定两个长度都为N的weights和values,weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag,表示一个载重bag的袋子，你能装的物品不总重量不能超过bag。返回你能装下的最多价值是多少？ 解法1：暴力递归 解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class Code01_Knapsack &#123; // 所有的货，重量和价值，都在w和v数组里 // 为了方便，其中没有负数 // bag背包容量，不能超过这个载重 // 返回：不超重的情况下，能够得到的最大价值 public static int maxValue(int[] w, int[] v, int bag) &#123; // 解法1：暴力递归 if (w == null || v == null || w.length != v.length || w.length == 0) &#123; return 0; &#125; // 尝试函数！ return process(w, v, 0, bag); &#125; // 表示0到index-1已做好货物选择，后续做选择的情况返回 // 返回-1，表示不能成立，不能选择 // 返回非-1，表示返回值是货物的实际价值 // rest 表示背包剩余的可用价值 public static int process(int[] w, int[] v, int index, int rest) &#123; // 剩余空间小于0，则不能选择 if (rest &lt; 0) &#123; return -1; &#125; // 重量没超，但是后面没货了，那就是0 if (index == w.length) &#123; return 0; &#125; // 可能性一：不要当前货物，直接求后续货物 int p1 = process(w, v, index + 1, rest); int p2 = 0; // 可能性二：要当前货物，计算后续货物实际价值 int next = process(w, v, index + 1, rest - w[index]); if (next != -1) &#123; // 后续货物还可以放，没超，即要了当前货物+后续货物实际价值 p2 = v[index] + next; &#125; // 取两种可能性的最大值，并返回能装下的货物的最终实际价值 return Math.max(p1, p2); &#125; public static int dp(int[] w, int[] v, int bag) &#123; // 解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行 if (w == null || v == null || w.length != v.length || w.length == 0) &#123; return 0; &#125; int N = w.length; /* dp二维表，行表示已处理好的货物索引位置index,列表示剩余可用的重量bag。x表示不需要统计计算 所以根据确定的最终结果，初始值是最后一行，那么后面一定是从第N行推出第N-1行，N-1行推出N-2行...以此类推 0 1 2 3 4 5 ——bag 0 x x x x x x 1 2 3 4 0 0 0 0 0 0(初始值) | index */ int[][] dp = new int[N + 1][bag + 1]; // 第一步：计算初始位置值,因为dp二维数组默认就给0，所以不用再计算赋值 // dp[N][0到bag] = 0 // 第二步：开始规划计算，根据确定的最终结果，初始值是最后一行，那么后面一定是从第N行推出第N-1行，N-1行推出N-2行...以此类推 /*将以下过程改为dp * // 可能性一：不要当前货物，直接求后续货物 int p1 = process(w, v, index + 1, rest); int p2 = 0; // 可能性二：要当前货物，计算后续货物实际价值 int next = process(w, v, index + 1, rest - w[index]); if (next != -1) &#123; // 后续货物还可以放，没超，即要了当前货物+后续货物实际价值 p2 = v[index] + next; &#125; // 取两种可能性的最大值，并返回能装下的货物的最终实际价值 return Math.max(p1, p2); * */ for (int index = N - 1; index &gt;= 0; index--) &#123; for (int rest = 0; rest &lt;= bag; rest++) &#123; // 拿暴力递归过程逐行转换为dp int p1 = dp[index + 1][rest]; int p2 = 0; // 这里改造dp注意数组越界 int next = rest - w[index] &lt; 0 ? -1 : dp[index + 1][rest - w[index]]; if (next != -1) &#123; p2 = v[index] + next; &#125; dp[index][rest] = Math.max(p1, p2); &#125; &#125; // 返回0位置，剩余空间bag的对应值 return dp[0][bag]; &#125; public static void main(String[] args) &#123; int[] weights = &#123;3, 2, 4, 7, 3, 1, 7&#125;; int[] values = &#123;5, 6, 3, 19, 12, 4, 2&#125;; int bag = 15; // 解法1：暴力递归 System.out.println(maxValue(weights, values, bag)); // 解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行 System.out.println(dp(weights, values, bag)); &#125;&#125; 范围上的尝试模型-纸牌游戏题目：给定一个整形数组arr,代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张牌，规定玩家A先拿，B后拿。但每个玩家每次只能拿走最左或最右的牌。玩家AB都绝顶聪明(都是心机婊，只允许自己拿牌比下一次对方拿牌大)。请但会最后获胜者的分数。 解法1：暴力递归的尝试过程 解法2：记忆化搜索即带缓存dp的暴力递归 解法3：动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class Code02_CardsInLine &#123; // 根据规则，返回获胜者的分数 public static int win1(int[] arr) &#123; // 解法1：暴力递归的尝试过程 if (arr == null || arr.length == 0) &#123; return 0; &#125; // 先手人拿牌和后手人拿牌，看下谁大 int first = f1(arr, 0, arr.length - 1); int second = g1(arr, 0, arr.length - 1); return Math.max(first, second); &#125; // arr[L..R]，先手获得的最好分数返回 public static int f1(int[] arr, int L, int R) &#123; // 还剩一张牌，先手人直接拿走 if (L == R) &#123; return arr[L]; &#125; // 可能性1：先手的人拿走左边牌，然后变成当前的后手拿牌，求和 int p1 = arr[L] + g1(arr, L + 1, R); // 可能性1：先手的人拿走右边牌，然后变成当前的后手拿牌，求和 int p2 = arr[R] + g1(arr, L, R - 1); // 因为先手人是心机婊，他一定想拿最大值 return Math.max(p1, p2); &#125; // arr[L..R]，后手获得的最好分数返回 public static int g1(int[] arr, int L, int R) &#123; // 还剩一张牌，后手人一定是等先手人拿走最后一张，自己球都没有，得0分 if (L == R) &#123; return 0; &#125; // 可能性1：先手人拿走左边牌，后手人被迫在剩下的进行先手拿牌 int p1 = f1(arr, L + 1, R); // 对手拿走了L位置的数 // 可能性2：先手人拿走右边牌，后手人被迫在剩下的进行先手拿牌 int p2 = f1(arr, L, R - 1); // 对手拿走了R位置的数 // 因为先手人是心机婊，他不会允许后手人拿到较大的牌，最会留较小牌给你 return Math.min(p1, p2); &#125; public static int win2(int[] arr) &#123; // 解法2：记忆化搜索即带缓存dp的暴力递归 if (arr == null || arr.length == 0) &#123; return 0; &#125; int N = arr.length; int[][] fmap = new int[N][N]; int[][] gmap = new int[N][N]; // 第一步：计算初始位置值，随便给值都行，-1也可以 for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; fmap[i][j] = -1; gmap[i][j] = -1; &#125; &#125; // 第二步：开始改写dp int first = f2(arr, 0, arr.length - 1, fmap, gmap); int second = g2(arr, 0, arr.length - 1, fmap, gmap); return Math.max(first, second); &#125; // arr[L..R]，先手获得的最好分数返回 public static int f2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) &#123; if (fmap[L][R] != -1) &#123; return fmap[L][R]; &#125; int ans = 0; if (L == R) &#123; ans = arr[L]; &#125; else &#123; int p1 = arr[L] + g2(arr, L + 1, R, fmap, gmap); int p2 = arr[R] + g2(arr, L, R - 1, fmap, gmap); ans = Math.max(p1, p2); &#125; fmap[L][R] = ans; return ans; &#125; // // arr[L..R]，后手获得的最好分数返回 public static int g2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) &#123; if (gmap[L][R] != -1) &#123; return gmap[L][R]; &#125; int ans = 0; if (L != R) &#123; int p1 = f2(arr, L + 1, R, fmap, gmap); // 对手拿走了L位置的数 int p2 = f2(arr, L, R - 1, fmap, gmap); // 对手拿走了R位置的数 ans = Math.min(p1, p2); &#125; gmap[L][R] = ans; return ans; &#125; public static int win3(int[] arr) &#123; // 解法3：动态规划 if (arr == null || arr.length == 0) &#123; return 0; &#125; int N = arr.length; int[][] fmap = new int[N][N]; int[][] gmap = new int[N][N]; for (int i = 0; i &lt; N; i++) &#123; // 第一步：计算初始位置值，设置对角线值 fmap[i][i] = arr[i]; &#125; // 第二步：开始填写两张dp表，然后最终返回需要的dp表结果值 for (int startCol = 1; startCol &lt; N; startCol++) &#123; int L = 0; int R = startCol; while (R &lt; N) &#123; // 根据解法2的物理逻辑，可以转成两张dp表的取值逻辑 fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]); gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]); L++; R++; &#125; &#125; return Math.max(fmap[0][N - 1], gmap[0][N - 1]); &#125; public static void main(String[] args) &#123; int[] arr = &#123;5, 7, 4&#125;; // 解法1：暴力递归的尝试过程 System.out.println(win1(arr)); // 解法2：记忆化搜索即带缓存dp的暴力递归 System.out.println(win2(arr)); // 解法3：动态规划 System.out.println(win3(arr)); &#125;&#125; 业务限制类的尝试模型-N皇后题目：N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一斜线上。给定一个整数n,返回n皇后的摆法有多少种。 解法1：暴力递归，返回所有的皇后的合理摆法 解法2：利用位运算，最多解决32个皇后问题。超过就不行了。因为二进制最多32位。两者时间复杂度均为N的N次方，只不过解法2比1常数项系数更小。核心是基于位运算的左移右移和斜线逻辑刚好一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class Code03_NQueens &#123; public static int num1(int n) &#123; // 解法1：暴力递归 if (n &lt; 1) &#123; return 0; &#125; int[] record = new int[n]; // 从0开始，所有的皇后摆法 // 0是第0行开始，record是记录每一行的皇后列摆放位置，n是共多少行 return process1(0, record, n); &#125; // 潜台词：record[0...i-1]的皇后已摆好 // 目前来到第i行，要求第i行的皇后与之前的任意皇后不共行，不共列，不共斜线 // record[0...i-1]表示之前的行，摆放了皇后的位置 // 例如int[] record record[x] = y 之前的第x行的皇后，放在了y列上 // 返回：不关心i以上发生了什么。返回值是i.... 后续有多少合法的方法数 public static int process1(int i, int[] record, int n) &#123; // 暴力递归，摆完所有的行，统计一种情况 if (i == n) &#123; return 1; &#125; int res = 0; // 对于第i行来说，遍历所有的列，尝试能不能摆皇后 for (int j = 0; j &lt; n; j++) &#123; // 假设黑盒函数判断能摆皇后 if (isValid(record, i, j)) &#123; // record函数记录第i行的皇后的摆放位置j record[i] = j; // 同时记录累加递归计算下一行 res += process1(i + 1, record, n); &#125; &#125; return res; &#125; public static boolean isValid(int[] record, int i, int j) &#123; // 判断第(i,j)的皇后位置不能合record数组中的皇后位置冲突 for (int k = 0; k &lt; i; k++) &#123; // 遍历record所有之前的皇后位置，判断是否冲突 // 注意不用判断同行，因为一定不同行 // 如果同列或同斜线，则冲突，返回false。Math.abs是绝对值判断法，简单粗暴 if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123; return false; &#125; &#125; return true; &#125; // 请不要超过32皇后问题 public static int num2(int n) &#123; // 解法2：巧妙的位运算 if (n &lt; 1 || n &gt; 32) &#123; return 0; &#125; // 如果你是13皇后问题，limit 最右13个1，其他都是0 // limit表示问题的规模，有多少个皇后，则表示右边有多少个连续的1 int limit = n == 32 ? -1 : (1 &lt;&lt; n) - 1; return process2(limit, 0, 0, 0); &#125; // limit : 0....0 1 1 1 1 1 1 1 // 之前皇后的列影响：colLim，列的限制即之前皇后已经摆放过的列，后续皇后就不能摆放这些列 // 之前皇后的左下对角线影响：leftDiaLim，左斜线限制同上理解 // 之前皇后的右下对角线影响：rightDiaLim，右斜线限制 public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) &#123; // 当列的限制等于原始规模，就表示所有皇后都摆完了，记录一种情况 if (colLim == limit) &#123; return 1; &#125; // pos中所有是1的位置，是你可以去尝试皇后的位置 int pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim)); // 提取出一个二进制的最右1的值 int mostRightOne = 0; // 记录多少种最终返回情况 int res = 0; // 只要pos不为0，表示当前还可以尝试放皇后 while (pos != 0) &#123; // 左神最常规的取出最右的1的值 mostRightOne = pos &amp; (~pos + 1); // 当前值减去最右1，这样最右的第2个1变成了最右的第1个1，继续循环提取pos上所有1即列的位置 pos = pos - mostRightOne; // 当前的限制加上最右的位置成为最新的限制，继续递归统计 res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &lt;&lt; 1, (rightDiaLim | mostRightOne) &gt;&gt;&gt; 1); &#125; return res; &#125; public static void main(String[] args) &#123; int n = 14; // 解法2：位运算算法 long start = System.currentTimeMillis(); System.out.println(num2(n)); long end = System.currentTimeMillis(); System.out.println(&quot;cost time: &quot; + (end - start) + &quot;ms&quot;); // 解法1：常规暴力递归算法 start = System.currentTimeMillis(); System.out.println(num1(n)); end = System.currentTimeMillis(); System.out.println(&quot;cost time: &quot; + (end - start) + &quot;ms&quot;); &#125;&#125; 单链表按照划分值分组题目：将单链表按照某划分值分成左边小、中间相等、右边大的形式。 解法1：(笔试用)将链表节点全部入数组，在数组上玩荷兰国旗的Partition，然后按照顺序串成链表 解法2：(面试用)利用6个变量指针，分成3个区域的链表，小于pivot区域，等于pivot区域，大于pivot区域，然后前后串起来即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class Code03_SmallerEqualBigger &#123; public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125; &#125; // 解法1：(笔试用)将链表节点全部入数组，在数组上玩荷兰国旗的Partition，然后按照顺序串成链表 public static Node listPartition1(Node head, int pivot) &#123; if (head == null) &#123; return head; &#125; Node cur = head; int i = 0; while (cur != null) &#123; i++; cur = cur.next; &#125; Node[] nodeArr = new Node[i]; i = 0; cur = head; for (i = 0; i != nodeArr.length; i++) &#123; nodeArr[i] = cur; cur = cur.next; &#125; arrPartition(nodeArr, pivot); for (i = 1; i != nodeArr.length; i++) &#123; nodeArr[i - 1].next = nodeArr[i]; &#125; nodeArr[i - 1].next = null; return nodeArr[0]; &#125; public static void arrPartition(Node[] nodeArr, int pivot) &#123; int small = -1; int big = nodeArr.length; int index = 0; while (index != big) &#123; if (nodeArr[index].value &lt; pivot) &#123; swap(nodeArr, ++small, index++); &#125; else if (nodeArr[index].value == pivot) &#123; index++; &#125; else &#123; swap(nodeArr, --big, index); &#125; &#125; &#125; public static void swap(Node[] nodeArr, int a, int b) &#123; Node tmp = nodeArr[a]; nodeArr[a] = nodeArr[b]; nodeArr[b] = tmp; &#125; // 解法2：(面试用)利用6个变量指针，分成3个区域的链表，小于pivot区域，等于pivot区域，大于pivot区域，然后前后串起来即可。 public static Node listPartition2(Node head, int pivot) &#123; Node sH = null; // small head小于划分值pivot区域的头结点 Node sT = null; // small tail小于划分值pivot区域的尾结点 Node eH = null; // equal head Node eT = null; // equal tail Node mH = null; // big head Node mT = null; // big tail Node next = null; // save next node // every node distributed to three lists while (head != null) &#123; // 先记录下当前节点的下一个节点，方便下一次while遍历 next = head.next; // 开始断开当前节点的next指针 head.next = null; if (head.value &lt; pivot) &#123; // 小于pivot区域 if (sH == null) &#123; // 一个节点都没有，直接加进来，调整头尾指针 sH = head; sT = head; &#125; else &#123; // 老尾巴的下一个节点指向当前节点 sT.next = head; // 尾指针移动到当前插入的节点 sT = head; &#125; &#125; else if (head.value == pivot) &#123; // 等于pivot区域，逻辑同上 if (eH == null) &#123; eH = head; eT = head; &#125; else &#123; eT.next = head; eT = head; &#125; &#125; else &#123; // 大于pivot区域，逻辑同上 if (mH == null) &#123; mH = head; mT = head; &#125; else &#123; mT.next = head; mT = head; &#125; &#125; //下一次while遍历赋值 head = next; &#125; // 接下来就是链表前后串起来：小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头。注意因为划分值不同，可能小于区域，等于区域，大于区域不存在。 if (sT != null) &#123; // 如果小于区域存在 // 第一步：小于区域的尾节点连接到等于区域的头节点 sT.next = eH; // 找下等于区域的尾指针在哪里， eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT &#125; // 第二步：一定是需要用eT 去接 大于区域的头 // 有等于区域，eT -&gt; 等于区域的尾结点 // 无等于区域，eT -&gt; 小于区域的尾结点 // eT 尽量不为空的尾巴节点 if (eT != null) &#123; // 如果小于区域和等于区域，不是都没有 // 第三步：等于区域的尾指针连接大于区域的头指针。至此链表全部串起来了 eT.next = mH; &#125; // 最后返回头结点，注意各个头结点是否存在 return sH != null ? sH : (eH != null ? eH : mH); &#125; public static void printLinkedList(Node node) &#123; System.out.print(&quot;Linked List: &quot;); while (node != null) &#123; System.out.print(node.value + &quot; &quot;); node = node.next; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Node head1 = new Node(7); head1.next = new Node(9); head1.next.next = new Node(1); head1.next.next.next = new Node(8); head1.next.next.next.next = new Node(5); head1.next.next.next.next.next = new Node(2); head1.next.next.next.next.next.next = new Node(5); printLinkedList(head1); // head1 = listPartition1(head1, 4); head1 = listPartition2(head1, 5); printLinkedList(head1); &#125;&#125; 暴力递归到动态规划该方法可以解决所有的动态规划问题 什么叫动态规划？ 把暴力递归中的重复计算想办法用缓存替代，就是动态规划。只不过这种叫记忆化搜索的动态规划。 斐波那契数列题目：在数学当中，由斐波那契数字（Fibonacci number，记作 Fn ）构成的序列，被称为斐波那契数列（Fibonacci sequence）。该数列中的每一个数字等于排在它前面的两个数字之和。 数列从0和1开始： F0=0 , F1=1 数列第n个（n&gt;1）数字为：Fn=Fn−1+Fn−2 按照上述公式，计算得到斐波那契数列为：0,1,1,2,3,5,8,13,21,34,55,89,… 解法1：最暴力的方法，之所以暴力，是因为有大量重复的计算 1234567public static int f(int N) &#123; // 解法1：斐波那契数列的最暴力解法 if (N &lt; 2) &#123; return N; &#125; return f(N - 2) + f(N - 1); &#125; 阿里面试题爬楼题目：假设有排成一行的N个位置，几位1~N,N一定大于或等于2。 开始时机器人在其中的N位置上(M一定是1~N中的一个)； 如果机器人来到1位置，那么下一步只能往右走来到2位置； 如果机器人来到N位置，那么下一步只能往左走来到N-1位置; 如果机器人来到中间位置，那么下一步可以往左走也可以往右走； 规定机器人必须走K步，最终能来到P位置。 给定四个参数N,M,K,P,返回机器人能走的多少种方法数。 解法1：暴力递归，中间有重复计算的冗余过程。leetcode提交代码一定超时，不通过 解法2：带缓存的暴力递归，本质：在暴力递归的基础上，利用缓存数组，去掉中间有重复计算的冗余过程。leetcode可以通过 解法3：动态规划，将解法2的暴力递归过程优化为结构化描述的动态规划。因为此题有重复计算过程和有限个参数的相关计算(M,k两个变量)。leetcode可以通过 从解法1到解法2，总结：不是所有的暴力递归都可以改为动态规划，所有的动态规划都来自于暴力递归的改写。 任何一个暴力递归优化成结构化描述的动态规划，需要满足两个条件： 暴力递归中有重复计算的过程 有限的可变参数影响结果 不满足以上2个条件的暴力递归，要么无法改为动态规划(不是有限可变参数)，要么即使改成动态规划也意义不大(没有重复过程，缓存没有意义)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Code01_RobotWalk &#123; public static int ways1(int N, int M, int K, int P) &#123; // 解法1：暴力递归，中间有重复计算的冗余过程 // 参数无效直接返回 0 if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; // 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数 return walk1(N, M, K, P); &#125; // 机器人当前来到的位置是cur， // 机器人还有rest步需要去走， // 最终的目标是P， // 返回：机器人从cur出发，走过rest步之后，最终停在P的方法数，是多少？ public static int walk1(int N, int cur, int rest, int P) &#123; // 如果没有剩余步数了，看下当前cur位置在哪里 if (rest == 0) &#123; // cur当前位置在最终位置P,则之前的移动有效，记录为一种情况。否则，无效记为0. return cur == P ? 1 : 0; &#125; // 如果cur当前位置在1位置上，那么接下来只能往右边的2移动 if (cur == 1) &#123; // 1 -&gt; 2 return walk1(N, cur + 1, rest - 1, P); &#125; // 如果cur当前位置在N位置上，那么接下来只能往左边的N-1移动 if (cur == N) &#123; // N-1 &lt;- N return walk1(N, cur - 1, rest - 1, P); &#125; // 如果cur当前位置在中间，那么有可能性往左移动、有可能往右移动，累加起来 return walk1(N, cur - 1, rest - 1, P) + walk1(N, cur + 1, rest - 1, P); &#125; public static int ways2(int N, int M, int K, int P) &#123; // 解法2：带缓存的暴力递归，本质：在暴力递归的基础上，利用缓存数组，去掉中间有重复计算的冗余过程 // 参数无效直接返回 0 if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; // dp就是缓存表，M有可能从1-N，K的话最多K，所以用长度N+1,K+1 // dp[cur][rest] == -1 -&gt; process1(cur, rest)之前没算过！ // dp[cur][rest] != -1 -&gt; process1(cur, rest)之前算过！返回值，dp[cur][rest] // N+1 * K+1 int[][] dp = new int[N + 1][K + 1]; for (int i = 0; i &lt;= N; i++) &#123; for (int j = 0; j &lt;= K; j++) &#123; dp[i][j] = -1; &#125; &#125; // 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数 return walk2(N, M, K, P, dp); &#125; public static int walk2(int N, int cur, int rest, int P, int[][] dp) &#123; // 先去找缓存表，因为N和P是固定值，返回值只与cur、rest有关 if (dp[cur][rest] != -1) &#123; // 先去缓存表找一下，如果找到有缓存，直接把结果返回 return dp[cur][rest]; &#125; // 如果没有缓存，说明之前没算过！那就先缓存，再把缓存结果返回 int ans = 0; if (rest == 0) &#123; ans = cur == P ? 1 : 0; &#125; else if (cur == 1) &#123; ans = walk2(N, cur + 1, rest - 1, P, dp); &#125; else if (cur == N) &#123; ans = walk2(N, cur - 1, rest - 1, P, dp); &#125; else &#123; ans = walk2(N, cur - 1, rest - 1, P, dp) + walk2(N, cur + 1, rest - 1, P, dp); &#125; // 先缓存 dp[cur][rest] = ans; // 再返回结果 return ans; &#125; public static int ways3(int N, int M, int K, int P) &#123; // 解法3：动态规划，将解法2的暴力递归过程优化为动态计算的动态规划。因为此题是关于有限个参数的相关计算(M,k两个变量) // 参数无效直接返回 0 if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; /* 二维表，行表示cur,列表示rest。假设N=5,P=3.x表示不存在的情况，不要统计计算。 0 1 2 3 4 5 ——rest 0 x x x x x x 1 0 0 取左下斜线值 2 0 取左上斜线值和左下斜线值 3 1 4 0 取左上斜线值 | cur */ int[][] dp = new int[N + 1][K + 1]; // 第一步：根据确定的最终结果，计算初始位置值,dp[其他值][0]=0.所以初始值是第一列，那么后面一定是从第1列推出第2列，2列推出3列...以此类推 dp[P][0] = 1; // 因为cur=P且rest=0.已经初始化了，接下啦只需要计算rest从1到K,cur从1到N // 第二步：开始规划计算 for (int rest = 1; rest &lt;= K; rest++) &#123; // 当cur在1的位置,取左下斜线值 dp[1][rest] = dp[2][rest - 1]; // 当cur在2到N-1的位置,取左上斜线值和左下斜线值 for (int cur = 2; cur &lt; N; cur++) &#123; dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1]; &#125; // 当cur在N位置，取左上斜线值 dp[N][rest] = dp[N - 1][rest - 1]; &#125; return dp[M][K]; &#125; public static void main(String[] args) &#123; System.out.println(ways1(7, 4, 9, 5)); System.out.println(ways2(7, 4, 9, 5)); System.out.println(ways3(7, 4, 9, 5)); &#125;&#125; 货币面值问题题目：不同金额的货币，可以使用多张，凑成目标值的方法数。现在有arr[1元，5元，10元].确定每种面额的纸币有多少张，最终来判断，不同张数的组合最终是否等于x元。比如x=10,那么有10张1元，2张5元，1张10元… 解法1：暴力递归的尝试过程 解法2：暴力递归的尝试过程改为记忆化搜索 解法3：动态规划，根据暴力递归填写dp表。 解法4：动态规划的优化版，将解法3中枚举的遍历人为直观的转变下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191public class Code03_CoinsWayNoLimit &#123; public static int way(int[] arr, int aim) &#123; // 解法1：暴力递归的尝试过程 if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; return process(arr, 0, aim); &#125; // arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？ public static int process(int[] arr, int index, int rest) &#123; /* 剩余的钱数都为负数了，说明这方法不行，记为0。这段可以去掉，因为在调用zhang * arr[index] &lt;= rest保证了不小于0 if (rest &lt; 0) &#123; return 0; &#125; */ // 后续没有钱可以选了，那么看下剩余的可用钱是否都刚好用完。如果刚好用完，记为一种用法。否则无效记为0 if (index == arr.length) &#123; // 没钱了 return rest == 0 ? 1 : 0; &#125; int ways = 0; // 先不要抽象画过程，先具象化过程 /* * arr[10,...] 要完成1000元任务 * 情况1 不用10元，f(1,1000) * 情况2 用1个10元，f1(1,1000-10) * 情况3 用2个10元，f1(1,1000-20) * 直到1000-x&gt;=0 * 那么可以设置变量可用的钱的张数为张，rest-(张数Xarr[index]面值)&gt;=0。循环遍历即可，把每种情况累加起来。 * */ for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123; ways += process(arr, index + 1, rest - (zhang * arr[index])); &#125; // 最后返回累加的结果值 return ways; &#125; public static int way1(int[] arr, int aim) &#123; // 解法2：暴力递归的尝试过程改为记忆化搜索 if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; // arr[10,100,...],用了10张10元和用了1张100元，剩余情况是相同，有重复过程。所以dp是二维表，记录剩下的。 // dp记录了所有情况 int[][] dp = new int[arr.length + 1][aim + 1]; return process1(arr, 0, aim, dp); &#125; // arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？ public static int process1(int[] arr, int index, int rest, int[][] dp) &#123; // 判断是否有缓存，默认是0.不为0，说明写入了，就返回 if (dp[index][rest] != 0) &#123; // return地方改为dp return dp[index][rest]; &#125; // 后续没有钱可以选了，那么看下剩余的可用钱是否都刚好用完。如果刚好用完，记为一种用法。否则无效记为0 if (index == arr.length) &#123; // 没钱了 // return地方改为dp，先写入缓存，再返回 dp[index][rest] = rest == 0 ? 1 : 0; return dp[index][rest]; &#125; int ways = 0; // 先不要抽象画过程，先具象化过程 /* * arr[10,...] 要完成1000元任务 * 情况1 不用10元，f(1,1000) * 情况2 用1个10元，f1(1,1000-10) * 情况3 用2个10元，f1(1,1000-20) * 直到1000-x&gt;=0 * 那么可以设置变量可用的钱的张数为张，rest-(张数Xarr[index]面值)&gt;=0。循环遍历即可，把每种情况累加起来。 * */ for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123; ways += process1(arr, index + 1, rest - (zhang * arr[index]), dp); &#125; // 最后返回累加的结果值 // return地方改为dp，先写入缓存，再返回 dp[index][rest] = ways; return dp[index][rest]; &#125; public static int dp1(int[] arr, int aim) &#123; // 解法3：动态规划，根据暴力递归填写dp表。 if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; int N = arr.length; int[][] dp = new int[N + 1][aim + 1]; // 第一步：根据确定的最终结果，计算初始位置值.最后知道的结果一定是index来到N,同时剩余空间为0.这是一种情况，记录为1. dp[N][0] = 1; for (int index = N - 1; index &gt;= 0; index--) &#123; for (int rest = 0; rest &lt;= aim; rest++) &#123; // 二维表dp填写 // 按照原来的逻辑逐行替代为dp int ways = 0; for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123; ways += dp[index + 1][rest - (zhang * arr[index])]; &#125; // return的地方改为dp赋值 dp[index][rest] = ways; &#125; &#125; // 最终结果是[arr从0开始,aim]的dp返回值 return dp[0][aim]; &#125; public static int dp2(int[] arr, int aim) &#123; // 解法4：动态规划的优化版，将解法3中枚举的遍历人为直观的转变下。 /* * 要想做出解法4，必须经过解法1，2,3。某些奸人也是经过解法123，但不说，直接告诉解法4.然后强行 * 拿某种关系解释。看起来很牛，太奸了。 * */ if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; int N = arr.length; int[][] dp = new int[N + 1][aim + 1]; // 第一步：根据确定的最终结果，计算初始位置值.最后知道的结果一定是index来到N,同时剩余空间为0.这是一种情况，记录为1. dp[N][0] = 1; // 第二步：从最后一行往前推，因为最后一行已知。每行从左往右推。 for (int index = N - 1; index &gt;= 0; index--) &#123; for (int rest = 0; rest &lt;= aim; rest++) &#123; // 这个关系是画图看出来的 dp[index][rest] = dp[index + 1][rest]; // 这个关系是画图和递归逻辑看出来的 if (rest - arr[index] &gt;= 0) &#123; dp[index][rest] += dp[index][rest - arr[index]]; &#125; &#125; &#125; // 最终结果是[arr从0开始,aim]的dp返回值 return dp[0][aim]; &#125; // 为了测试 public static int[] randomArray(int maxLen, int maxValue) &#123; int N = (int) (Math.random() * maxLen); int[] arr = new int[N]; boolean[] has = new boolean[maxValue + 1]; for (int i = 0; i &lt; N; i++) &#123; do &#123; arr[i] = (int) (Math.random() * maxValue) + 1; &#125; while (has[arr[i]]); has[arr[i]] = true; &#125; return arr; &#125; // 为了测试 public static void printArray(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; // 为了测试 public static void main(String[] args) &#123; int maxLen = 10; int maxValue = 30; int testTime = 1000000; System.out.println(&quot;测试开始&quot;); for (int i = 0; i &lt; testTime; i++) &#123; int[] arr = randomArray(maxLen, maxValue); int aim = (int) (Math.random() * maxValue); int ans1 = way(arr, aim); int ans4 = way1(arr, aim); int ans2 = dp1(arr, aim); int ans3 = dp2(arr, aim); if (ans1 != ans2 || ans1 != ans3 || ans1 != ans4) &#123; System.out.println(&quot;Oops!&quot;); printArray(arr); System.out.println(aim); System.out.println(ans1); System.out.println(ans2); System.out.println(ans3); System.out.println(ans4); break; &#125; &#125; System.out.println(&quot;测试结束&quot;);// int[] arr = randomArray(maxLen, maxValue);// int aim = (int) (Math.random() * maxValue);// printArray(arr);// System.out.println(aim);// System.out.println(way(arr, aim));// System.out.println(way1(arr, aim));// System.out.println(dp1(arr, aim));// System.out.println(dp2(arr, aim)); &#125;&#125; 贪心算法 最自然智慧的算法 用一种局部最功利的标准，总是做出当前看来最好的选择 难点在于证明局部最功利的标准可以得到全局最优解 对于贪心算法的学习主要以增加阅历和经验为主 字典序 定义：表示英文单词在字典中的先后顺序，类似中文的拼音目录。ab abc abd. 排序规则：字母单词在字典中的顺序，位数一样的依次比较，如果位数不一样，将短的补长为和长的一样长，多的位用0补。逐一从左到右依次比较，小的放前，大的放后。 贪心-最小字典序题目：给定一个由字符串组成的数组arrs,必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果。 解法1：列出所有的字符串的全排列，找到全局最小。注意求解全排列，有多层循环递归和深度优先遍历两种方法。 解法2：将字符串数组按照字典序排序，直接拼接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import java.util.Arrays;import java.util.Comparator;import java.util.HashSet;import java.util.TreeSet;public class Code05_LowestLexicography &#123; // 解法1：列出所有的字符串的全排列，找到全局最小 public static String lowestString1(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return &quot;&quot;; &#125; TreeSet&lt;String&gt; all = new TreeSet&lt;&gt;(); // 解法a:多层循环递归，返回全排列 all = process(strs); // 解法b:深度优先遍历，返回全排列// HashSet&lt;Integer&gt; use = new HashSet&lt;&gt;();// String path = &quot;&quot;;// process2(strs, use, path, all); String lowest = null; // 遍历找到全局最小 for (String str : all) &#123; if (lowest == null) &#123; lowest = str; &#125; else &#123; lowest = str.compareTo(lowest) &lt; 0 ? str : lowest; &#125; &#125; return lowest; &#125; // 解法a：多层循环递归，返回全排列。strs中所有字符串全排列，返回所有可能的结果 public static TreeSet&lt;String&gt; process(String[] strs) &#123; TreeSet&lt;String&gt; ans = new TreeSet&lt;&gt;(); if (strs.length == 0) &#123; // 数组为空，直接返回 ans.add(&quot;&quot;); return ans; &#125; // 从前往后遍历，使用当前元素+(剩余元素的组合list)一一匹配 for (int i = 0; i &lt; strs.length; i++) &#123; String first = strs[i]; // 排除当前元素，剩余还有哪些元素 String[] nexts = removeIndexString(strs, i); // 返回剩余元素的所有排列组合 TreeSet&lt;String&gt; next = process(nexts); // 当前元素+剩余元素，遍历组合，一一匹配 for (String cur : next) &#123; ans.add(first + cur); &#125; &#125; return ans; &#125; // 解法b：深度优先遍历，strs中所有字符串全排列，返回所有可能的结果 public static void process2(String[] strs, HashSet&lt;Integer&gt; use, String path, TreeSet&lt;String&gt; all) &#123; // str放着所有字符串，use表示使用过的字符串索引，path表示当前的字符串拼接路径，all就是所有字符串的排列组合 if (use.size() == strs.length) &#123; // 全部都用了，就加入一条路径 all.add(path); &#125; else &#123; for (int i = 0; i &lt; strs.length; i++) &#123; // 遍历所有元素，找到没加入过的元素，更新use,更新path,递归剩下元素 if (!use.contains(strs[i])) &#123; // 更新use use.add(i); // 更新path,递归剩下元素 process2(strs, use, path + strs[i], all); // 注意，深度优先遍历，一定要回溯，就要删除刚加的元素，恢复现场 use.remove(i); &#125; &#125; &#125; &#125; // &#123;&quot;abc&quot;, &quot;cks&quot;, &quot;bct&quot;&#125; // 0 1 2 // removeIndexString(arr , 1) -&gt; &#123;&quot;abc&quot;, &quot;bct&quot;&#125; // 返回arr删除index索引的元素剩下的元素 public static String[] removeIndexString(String[] arr, int index) &#123; int N = arr.length; String[] ans = new String[N - 1]; int ansIndex = 0; for (int i = 0; i &lt; N; i++) &#123; if (i != index) &#123; ans[ansIndex++] = arr[i]; &#125; &#125; return ans; &#125; public static class MyComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String a, String b) &#123; return (a + b).compareTo(b + a); &#125; &#125; // 解法2：将字符串数组按照字典序排序，直接拼接 public static String lowestString2(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return &quot;&quot;; &#125; Arrays.sort(strs, new MyComparator()); String res = &quot;&quot;; for (int i = 0; i &lt; strs.length; i++) &#123; res += strs[i]; &#125; return res; &#125; // for test public static String generateRandomString(int strLen) &#123; char[] ans = new char[(int) (Math.random() * strLen) + 1]; for (int i = 0; i &lt; ans.length; i++) &#123; int value = (int) (Math.random() * 5); ans[i] = (Math.random() &lt;= 0.5) ? (char) (65 + value) : (char) (97 + value); &#125; return String.valueOf(ans); &#125; // for test public static String[] generateRandomStringArray(int arrLen, int strLen) &#123; String[] ans = new String[(int) (Math.random() * arrLen) + 1]; for (int i = 0; i &lt; ans.length; i++) &#123; ans[i] = generateRandomString(strLen); &#125; return ans; &#125; // for test public static String[] copyStringArray(String[] arr) &#123; String[] ans = new String[arr.length]; for (int i = 0; i &lt; ans.length; i++) &#123; ans[i] = String.valueOf(arr[i]); &#125; return ans; &#125; public static void main(String[] args) &#123; int arrLen = 6; int strLen = 5; int testTimes = 10000; System.out.println(&quot;test begin&quot;); for (int i = 0; i &lt; testTimes; i++) &#123; String[] arr1 = generateRandomStringArray(arrLen, strLen); String[] arr2 = copyStringArray(arr1); if (!lowestString1(arr1).equals(lowestString2(arr2))) &#123; for (String str : arr1) &#123; System.out.print(str + &quot;,&quot;); &#125; System.out.println(); System.out.println(&quot;Oops!&quot;); &#125; &#125; System.out.println(&quot;finish!&quot;); &#125;&#125; 线段树定义：是一棵二叉树。它的特点是：每个结点表示的是一个线段，或者说是一个区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309public class Code01_SegmentTree &#123; // 线段树的实现 public static class SegmentTree &#123; // arr[]为原序列的信息从0开始，但在arr里是从1开始的，注意从下标1开始是为了方便使用位运算。 // MAXN是拷贝数组的长度 // sum[]模拟线段树维护区间和 // lazy[]为累加和标记即懒加和标记 // change[]为更新的值 // update[]为更新标记即懒更新标记 private int[] arr; private int MAXN; private int[] sum; private int[] lazy; private int[] change; private boolean[] update; // 构造函数,初始化所有数组空间 public SegmentTree(int[] origin) &#123; // 创建原数组origin对应的拷贝数组arr，从下标1开始，方便后续的位运算 MAXN = origin.length + 1; arr = new int[MAXN]; // arr[0] 不用 从1开始使用 for (int i = 1; i &lt; MAXN; i++) &#123; arr[i] = origin[i - 1]; &#125; // 为了把所有数都刚好让左右等范围cover住，申请长度MAXN*4即左移2位 sum = new int[MAXN &lt;&lt; 2]; // 用来支持脑补概念中，某一个范围的累加和信息 lazy = new int[MAXN &lt;&lt; 2]; // 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務 change = new int[MAXN &lt;&lt; 2]; // 用来支持脑补概念中，某一个范围有没有更新操作的任务 update = new boolean[MAXN &lt;&lt; 2]; // 用来支持脑补概念中，某一个范围更新任务，更新成了什么 &#125; // 当前节点收集左右子节点的和信息。懒加和，懒更新后，都需要执行这个操作 private void pushUp(int rt) &#123; /* * rt是当前节点索引 * rt对应的左子节点是rt*2即rt &lt;&lt; 1 * rt对应的右子节点是rt*2+1即rt &lt;&lt; 1|1 * */ sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1]; &#125; // 下发懒更新和懒加和。懒加和，懒更新，都需要把自己的任务下发给左右子节点。分发策略:从父范围，分发给左右边界 private void pushDown(int rt, int ln, int rn) &#123; /* * ln表示左子树元素结点个数，rn表示右子树结点个数 * */ // 如果当前节点懒更新标记为true,则下发懒更新 if (update[rt]) &#123; /* * 下发给左右节点懒更新时， * 左右节点的懒更新标记为true * 左右节点的懒更新值为父节点值 * 左右节点的懒加和清空，置为0 * 左右节点的区间和，直接计算为长度*懒更新值 * 当前自己节点的懒更新标记为false，清空，表示后续不用再下发 * */ update[rt &lt;&lt; 1] = true; update[rt &lt;&lt; 1 | 1] = true; change[rt &lt;&lt; 1] = change[rt]; change[rt &lt;&lt; 1 | 1] = change[rt]; lazy[rt &lt;&lt; 1] = 0; lazy[rt &lt;&lt; 1 | 1] = 0; sum[rt &lt;&lt; 1] = change[rt] * ln; sum[rt &lt;&lt; 1 | 1] = change[rt] * rn; update[rt] = false; &#125; // 如果当前节点懒加和标记不为0,则下发懒加和 if (lazy[rt] != 0) &#123; /* * 下发给左右节点懒加和时， * 左右节点的懒加和=之前的值+当前父节点的值 * 左右节点的区间和=当前懒加和*长度 * 当前自己节点的懒加和标记为0，清空，表示后续不用再下发 * */ lazy[rt &lt;&lt; 1] += lazy[rt]; lazy[rt &lt;&lt; 1 | 1] += lazy[rt]; sum[rt &lt;&lt; 1] += lazy[rt] * ln; sum[rt &lt;&lt; 1 | 1] += lazy[rt] * rn; lazy[rt] = 0; &#125; &#125; // 初始化线段树：构建线段树的初值，sum数组填充。 public void build(int l, int r, int rt) &#123; /* * 在arr[l~r]范围上，去build构建sum数组信息。 * rt是sum数组的下标索引 * */ if (l == r) &#123; sum[rt] = arr[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, rt &lt;&lt; 1); build(mid + 1, r, rt &lt;&lt; 1 | 1); pushUp(rt); &#125; // 在L到R索引范围上，每个元素都加上C public void add(int L, int R, int C, int l, int r, int rt) &#123; /* *L~R, C 表示任务的3个变量 * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。 * */ // 任务如果把此时的范围全包了！那么这个节点区间直接命中 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; // 区间和=之前值+c*区间长度 sum[rt] += C * (r - l + 1); // 懒加载和=之前值+当前值C lazy[rt] += C; return; &#125; // 如果任务没有把你全包！ // 取二分中点，l r mid = (l+r)/2 int mid = (l + r) &gt;&gt; 1; // 先下发懒更新和懒加和 pushDown(rt, mid - l + 1, r - mid); // 如果任务的左边界越过区间的中点，去左边了，则去左子节点继续递归。rt &lt;&lt; 1等于rt*2 if (L &lt;= mid) &#123; add(L, R, C, l, mid, rt &lt;&lt; 1); &#125; // 如果任务的右边界越过区间的中点，去右边了，则去右子节点继续递归.rt &lt;&lt; 1|1等于rt*2+1 if (R &gt; mid) &#123; add(L, R, C, mid + 1, r, rt &lt;&lt; 1 | 1); &#125; // 等前面的子节点信息填好了后，再当前节点收集左右子节点的和信息 pushUp(rt); &#125; // 在L到R索引范围上，每个元素都更新为C public void update(int L, int R, int C, int l, int r, int rt) &#123; /* *L~R, C 表示任务的3个变量 * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。 * */ // 任务如果把此时的范围全包了！那么这个节点区间直接命中 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; /* * 当前节点的懒更新标记为true * 当前节点的懒更新值为C * 当前节点的区间和=C*区间长度 * 当前节点的懒加和清空，为0 * */ update[rt] = true; change[rt] = C; sum[rt] = C * (r - l + 1); lazy[rt] = 0; return; &#125; // 当前任务躲不掉，无法懒更新，要往下发 int mid = (l + r) &gt;&gt; 1; // 先下发懒更新和懒加和 pushDown(rt, mid - l + 1, r - mid); // 如果任务的左边界越过区间的中点，去左边了，则去左子节点继续递归。rt &lt;&lt; 1等于rt*2 if (L &lt;= mid) &#123; update(L, R, C, l, mid, rt &lt;&lt; 1); &#125; // 如果任务的右边界越过区间的中点，去右边了，则去右子节点继续递归.rt &lt;&lt; 1|1等于rt*2+1 if (R &gt; mid) &#123; update(L, R, C, mid + 1, r, rt &lt;&lt; 1 | 1); &#125; // 等前面的子节点信息填好了后，再当前节点收集左右子节点的和信息 pushUp(rt); &#125; // 查询L~R上的累加和是多少 public long query(int L, int R, int l, int r, int rt) &#123; /* *L~R 表示任务的2个变量 * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。 * */ // 任务区间包括了节点的区间值，命中 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; int mid = (l + r) &gt;&gt; 1; // 先下发懒更新和懒加和 pushDown(rt, mid - l + 1, r - mid); long ans = 0; // 如果任务的左边界越过区间的中点，去左边了。去左节点收集和 if (L &lt;= mid) &#123; ans += query(L, R, l, mid, rt &lt;&lt; 1); &#125; // 如果任务的右边界越过区间的中点，去右边了。去右节点收集和 if (R &gt; mid) &#123; ans += query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1); &#125; // 最后返回 return ans; &#125; &#125; public static class Right &#123; // 对数器：最暴力的直接求和 public int[] arr; public Right(int[] origin) &#123; arr = new int[origin.length + 1]; for (int i = 0; i &lt; origin.length; i++) &#123; arr[i + 1] = origin[i]; &#125; &#125; public void update(int L, int R, int C) &#123; for (int i = L; i &lt;= R; i++) &#123; arr[i] = C; &#125; &#125; public void add(int L, int R, int C) &#123; for (int i = L; i &lt;= R; i++) &#123; arr[i] += C; &#125; &#125; public long query(int L, int R) &#123; long ans = 0; for (int i = L; i &lt;= R; i++) &#123; ans += arr[i]; &#125; return ans; &#125; &#125; public static int[] genarateRandomArray(int len, int max) &#123; int size = (int) (Math.random() * len) + 1; int[] origin = new int[size]; for (int i = 0; i &lt; size; i++) &#123; origin[i] = (int) (Math.random() * max) - (int) (Math.random() * max); &#125; return origin; &#125; public static boolean test() &#123; int len = 100; int max = 1000; int testTimes = 5000; int addOrUpdateTimes = 1000; int queryTimes = 500; for (int i = 0; i &lt; testTimes; i++) &#123; int[] origin = genarateRandomArray(len, max); SegmentTree seg = new SegmentTree(origin); /* * S,N是线段树的某个节点的左右区间，root是某个节点的索引。这三个值可以认为是固定值。 * */ int S = 1; int N = origin.length; int root = 1; // 初始化线段树 seg.build(S, N, root); // 对数器的数组 Right rig = new Right(origin); for (int j = 0; j &lt; addOrUpdateTimes; j++) &#123; int num1 = (int) (Math.random() * N) + 1; int num2 = (int) (Math.random() * N) + 1; int L = Math.min(num1, num2); int R = Math.max(num1, num2); int C = (int) (Math.random() * max) - (int) (Math.random() * max); if (Math.random() &lt; 0.5) &#123; // 等概率小于0.5的添加值 seg.add(L, R, C, S, N, root); rig.add(L, R, C); &#125; else &#123; // 等概率大于等于0.5的更新值 seg.update(L, R, C, S, N, root); rig.update(L, R, C); &#125; &#125; // 测试500次，和对数器逐一比对，死都测出来 for (int k = 0; k &lt; queryTimes; k++) &#123; int num1 = (int) (Math.random() * N) + 1; int num2 = (int) (Math.random() * N) + 1; int L = Math.min(num1, num2); int R = Math.max(num1, num2); long ans1 = seg.query(L, R, S, N, root); long ans2 = rig.query(L, R); if (ans1 != ans2) &#123; return false; &#125; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; int[] origin = &#123;2, 1, 1, 2, 3, 4, 5&#125;; SegmentTree seg = new SegmentTree(origin); int S = 1; // 整个区间的开始位置，规定从1开始，不从0开始 -&gt; 固定 int N = origin.length; // 整个区间的结束位置，规定能到N，不是N-1 -&gt; 固定 int root = 1; // 整棵树的头节点位置，规定是1，不是0 -&gt; 固定 int L = 2; // 操作区间的开始位置 -&gt; 可变 int R = 5; // 操作区间的结束位置 -&gt; 可变 int C = 4; // 要加的数字或者要更新的数字 -&gt; 可变 // 区间生成，必须在[S,N]整个范围上build seg.build(S, N, root); // 区间修改，可以改变L、R和C的值，其他值不可改变 seg.add(L, R, C, S, N, root); // 区间更新，可以改变L、R和C的值，其他值不可改变 seg.update(L, R, C, S, N, root); // 区间查询，可以改变L和R的值，其他值不可改变 long sum = seg.query(L, R, S, N, root); System.out.println(sum); System.out.println(&quot;对数器测试开始...&quot;); System.out.println(&quot;测试结果 : &quot; + (test() ? &quot;通过&quot; : &quot;未通过&quot;)); &#125;&#125; 经典面试题每种能力的最高报酬题目：每种工作有难度和报酬，规定如下：class Job{public int hard;public int money;}。给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作，选工作的标准是难度不超过自身能力值，选择报酬最高的岗位。求返回int数组，表示每个人按照标准选择的最高报酬。 思路： 先将job数组按照难度值升序且报酬值降序排列，难度值相同的情况下，只保留最大报酬值的那个 在剩余数组中，逐一比较，如果难度值上升，报酬值也上升，这样的数据保留。否则，删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;public class Problem07_ChooseWork &#123; public static void main(String[] args) &#123; List&lt;Job&gt; job = new ArrayList&lt;Job&gt;(); Job job1 = new Job(1,1); Job job2 = new Job(2,5); Job job3 = new Job(4,4); Job job4 = new Job(5,7); Job job5 = new Job(8,8); job.add(job1); job.add(job2); job.add(job3); job.add(job4); job.add(job5); int[] ans = getMoneys((job.toArray(new Job[job.size()])),new int[]&#123;1,2,3&#125;); System.out.println(&quot;结束&quot;); &#125; public static class Job &#123; public int money; public int hard; public Job(int m, int h) &#123; money = m; hard = h; &#125; &#125; public static class JobComparator implements Comparator&lt;Job&gt; &#123; @Override public int compare(Job o1, Job o2) &#123; return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money); &#125; &#125; public static int[] getMoneys(Job[] job, int[] ability) &#123; Arrays.sort(job, new JobComparator()); // key : 难度 value：报酬 TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); map.put(job[0].hard, job[0].money); // pre : 上一份进入map的工作 Job pre = job[0]; for (int i = 1; i &lt; job.length; i++) &#123; if (job[i].hard != pre.hard &amp;&amp; job[i].money &gt; pre.money) &#123; // hard值相同的只取一个，报酬也要递增，很巧妙 pre = job[i]; map.put(pre.hard, pre.money); &#125; &#125; // map中就是各个难度岗位的最高报酬值，接下来就是匹配目标值向下取整即不超过目标能力值的报酬。 int[] ans = new int[ability.length]; for (int i = 0; i &lt; ability.length; i++) &#123; // ability[i] 当前人的能力 &lt;= ability[i] 且离它最近的 Integer key = map.floorKey(ability[i]); ans[i] = key != null ? map.get(key) : 0; &#125; return ans; &#125;&#125; 简单背包问题题目：背包容量为w,一共有n袋零食，第i袋零食体积为v[i]&gt;0.总体积不超过背包容量的情况下，一共有多少种零食放法(总体积为0也算是一种放法) 思路： 解法1：暴力递归的尝试过程 解法2：暴力递归改写的dp 解法3：另一种解法的dp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Code02_SnacksWays &#123; public static int ways1(int[] arr, int w) &#123; // 解法1：暴力递归的尝试过程 return process(arr, 0, w); &#125; // 从左往右的经典模型 // 还剩的容量是rest，arr[index...]自由选择， // 返回选择方案 // index ： 0～N，当前来到的零食索引值，表示纵坐标 // rest : 0~w，当前还剩余的可用容积，表示横坐标 public static int process(int[] arr, int index, int rest) &#123; if (rest &lt; 0) &#123; // 没有容量了 // -1 无方案的意思 return 0; &#125; // rest&gt;=0, if (index == arr.length) &#123; // 无零食可选 return 1; &#125; // rest &gt;=0 // 有零食index // index号零食，要 or 不要 // index, rest // (index+1, rest) // (index+1, rest-arr[i]) int next1 = process(arr, index + 1, rest); // 不要 int next2 = process(arr, index + 1, rest - arr[index]); // 要 return next1 + next2; &#125; public static int ways2(int[] arr, int w) &#123; // 解法2：暴力递归改简单动态规划，从下到上，从左到右改写。利用未使用容量求解 // dp[i][j]中i：0～N中，第i个位置，剩余容量j的方法数 int N = arr.length; int[][] dp = new int[N + 1][w + 1]; // 从N袋零食后，无零食可选了，就是一种方法了 for (int j = 0; j &lt;= w; j++) &#123; dp[N][j] = 1; &#125; for (int i = N - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= w; j++) &#123; dp[i][j] = dp[i + 1][j] + ((j - arr[i] &gt;= 0) ? dp[i + 1][j - arr[i]] : 0); &#125; &#125; // 返回index号零食开始，容量还剩w的方法数 return dp[0][w]; &#125; public static int ways3(int[] arr, int w) &#123; // 解法3：暴力递归改简单动态规划，利用已使用容量求解，不太好理解就使用解法2. // dp[i][j]中i：0～N中，第i个位置，已使用的容量j的方法数 int N = arr.length; int[][] dp = new int[N][w + 1]; for (int i = 0; i &lt; N; i++) &#123; dp[i][0] = 1; &#125; if (arr[0] &lt;= w) &#123; dp[0][arr[0]] = 1; &#125; for (int i = 1; i &lt; N; i++) &#123; for (int j = 1; j &lt;= w; j++) &#123; dp[i][j] = dp[i - 1][j] + ((j - arr[i]) &gt;= 0 ? dp[i - 1][j - arr[i]] : 0); &#125; &#125; int ans = 0; for (int j = 0; j &lt;= w; j++) &#123; ans += dp[N - 1][j]; &#125; return ans; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 4, 3, 2, 9 &#125;; int w = 8; System.out.println(ways1(arr, w)); System.out.println(ways2(arr, w)); System.out.println(ways3(arr, w)); &#125;&#125; 最长公共子串题目：注意区分子串和子序列的不同。给定两个字符串str1和str2，求两个字符串的最长公共子串。 思路：动态规划的空间压缩技巧 解法1：直接填写dp表，并统计最大值，返回max和i. 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 最长公共子串问题是面试常见题目之一public class Code03_LongestCommonSubstringConquerByHeight &#123; public static String lcs1(String str1, String str2) &#123; // 解法1：直接填写dp表，并统计最大值，返回max和i. if (str1 == null || str2 == null || str1.equals(&quot;&quot;) || str2.equals(&quot;&quot;)) &#123; return &quot;&quot;; &#125; char[] chs1 = str1.toCharArray(); char[] chs2 = str2.toCharArray(); int[][] dp = getdp(chs1, chs2); int end = 0; int max = 0; // 遍历找到最大值 for (int i = 0; i &lt; chs1.length; i++) &#123; for (int j = 0; j &lt; chs2.length; j++) &#123; if (dp[i][j] &gt; max) &#123; end = i; max = dp[i][j]; &#125; &#125; &#125; return str1.substring(end - max + 1, end + 1); &#125; public static int[][] getdp(char[] str1, char[] str2) &#123; // 填写dp表，dp[i][j]表示以str1的第i个字符结尾，以str2的第j个字符结尾的公共子串的长度 int[][] dp = new int[str1.length][str2.length]; // 对于第一列，只有ij对应的字符相等，长度才为1 for (int i = 0; i &lt; str1.length; i++) &#123; if (str1[i] == str2[0]) &#123; dp[i][0] = 1; &#125; &#125; // 对于第一行，只有ij对应的字符相等，长度才为1 for (int j = 1; j &lt; str2.length; j++) &#123; if (str1[0] == str2[j]) &#123; dp[0][j] = 1; &#125; &#125; // 其他的行列，就需要根据前面的值推导 for (int i = 1; i &lt; str1.length; i++) &#123; for (int j = 1; j &lt; str2.length; j++) &#123; if (str1[i] == str2[j]) &#123; // 如果当前字符相同，则当前长度在前面的基础上+1.不相同，则默认为0 dp[i][j] = dp[i - 1][j - 1] + 1; &#125; &#125; &#125; return dp; &#125; public static String lcs2(String s1, String s2) &#123; // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量 if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123; return &quot;&quot;; &#125; char[] str1 = s1.toCharArray(); char[] str2 = s2.toCharArray(); // 用行列两个变量简单记录，替代dp的二维表结构 // 定义行索引 int row = 0; // 定义列索引 int col = str2.length - 1; int max = 0; int end = 0; // 遍历行索引(遍历行，遍历列) /* * --------&lt;--- * | * | * V * | * */ while (row &lt; str1.length) &#123; // 局部变量i,j int i = row; int j = col; int len = 0; // 相当于斜着扫一遍 while (i &lt; str1.length &amp;&amp; j &lt; str2.length) &#123; if (str1[i] != str2[j]) &#123; // 字符不相同，当前字符串的公共长度为0 len = 0; &#125; else &#123; // 字符相同，则在前者的基础上累加。除非遇到不同，才置0. len++; &#125; if (len &gt; max) &#123; // 每次都找到全局最大值 max = len; end = i; &#125; // 斜着扫一遍 i++; j++; &#125; if (col &gt; 0) &#123; // 遍历列 col--; &#125; else &#123; // 遍历行 row++; &#125; &#125; return s1.substring(end - max + 1, end + 1); &#125; // 随机生成字符串 public static String randomNumberString(int len, int range) &#123; char[] str = new char[len]; for (int i = 0; i &lt; len; i++) &#123; str[i] = (char) ((int) (Math.random() * range) + &#x27;a&#x27;); &#125; return String.valueOf(str); &#125; public static void main(String[] args) &#123; long start; long end; String str1 = &quot;zxcvbn&quot;; String str2 = &quot;2e8ucvboi9u&quot;; start = System.currentTimeMillis(); end = System.currentTimeMillis(); // 解法1：直接填写dp表，并统计最大值，返回max和i. System.out.println(&quot;方法1结果 : &quot; + lcs1(str1, str2) + &quot; , 运行时间 : &quot; + (end - start) + &quot; ms&quot;); // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量 System.out.println(&quot;方法2结果 : &quot; + lcs2(str1, str2) + &quot; , 运行时间 : &quot; + (end - start) + &quot; ms&quot;); &#125;&#125; 最长公共子序列题目：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 解法1：暴力递归的尝试模型，leetcode超时 解法2：暴力递归改写dp。leetcode通过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// 这个问题leetcode上可以直接测// 链接：https://leetcode.com/problems/longest-common-subsequence/public class Code04_LongestCommonSubsequence &#123; public static int longestCommonSubsequence1(String s1, String s2) &#123; // 解法1：暴力递归的尝试模型，leetcode超时 if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123; return 0; &#125; char[] str1 = s1.toCharArray(); char[] str2 = s2.toCharArray(); // 尝试 return process1(str1, str2, str1.length - 1, str2.length - 1); &#125; // str1[0...i]和str2[0...j]，这个范围上最长公共子序列长度是多少？ // 可能性分类: // a) 最长公共子序列，不以str1[i]字符结尾、不以str2[j]字符结尾 // b) 最长公共子序列，以str1[i]字符结尾、不以str2[j]字符结尾 // c) 最长公共子序列，不以str1[i]字符结尾、以str2[j]字符结尾 // d) 最长公共子序列，以str1[i]字符结尾、以str2[j]字符结尾 // 注意：a)、b)、c)、d)并不是完全互斥的，他们可能会有重叠的情况 // 但是可以肯定，答案不会超过这四种可能性的范围 // 那么我们分别来看一下，这几种可能性怎么调用后续的递归。 // a) 最长公共子序列，一定不以str1[i]字符结尾、也一定不以str2[j]字符结尾 // 如果是这种情况，那么有没有str1[i]和str2[j]就根本不重要了，因为这两个字符一定没用啊 // 所以砍掉这两个字符，最长公共子序列 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归) // b) 最长公共子序列，可能以str1[i]字符结尾、但是一定不以str2[j]字符结尾 // 如果是这种情况，那么我们可以确定str2[j]一定没有用，要砍掉；但是str1[i]可能有用，所以要保留 // 所以，最长公共子序列 = str1[0...i]与str2[0...j-1]的最长公共子序列长度(后续递归) // c) 最长公共子序列，一定不以str1[i]字符结尾、但是可能以str2[j]字符结尾 // 跟上面分析过程类似，最长公共子序列 = str1[0...i-1]与str2[0...j]的最长公共子序列长度(后续递归) // d) 最长公共子序列，必须以str1[i]字符结尾、也必须以str2[j]字符结尾 // 同时可以看到，可能性d)存在的条件，一定是在str1[i] == str2[j]的情况下，才成立的 // 所以，最长公共子序列总长度 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归) + 1(共同的结尾) // 综上，四种情况已经穷尽了所有可能性。四种情况中取最大即可 public static int process1(char[] str1, char[] str2, int i, int j) &#123; // base case if (i == 0 &amp;&amp; j == 0) &#123; // str1[0..0]和str2[0..0]，都只剩一个字符了 // 那如果字符相等，公共子序列长度就是1，不相等就是0 return str1[i] == str2[j] ? 1 : 0; &#125; else if (i == 0) &#123; // 这里的情况为： // str1[0...0]和str2[0...j]，str1只剩1个字符了，但是str2不只一个字符 // 因为str1只剩一个字符了，所以str1[0...0]和str2[0...j]公共子序列最多长度为1 // 如果str1[0] == str2[j]，那么此时相等已经找到了！公共子序列长度就是1，也不可能更大了 // 如果str1[0] != str2[j]，只是此时不相等而已，那么str2[0...j-1]上有没有字符等于str1[0]呢？不知道，所以递归继续找 if (str1[i] == str2[j]) &#123; return 1; &#125; else &#123; return process1(str1, str2, i, j - 1); &#125; &#125; else if (j == 0) &#123; // 和上面的else if同理 if (str1[i] == str2[j]) &#123; return 1; &#125; else &#123; return process1(str1, str2, i - 1, j); &#125; &#125; else &#123; // i != 0 &amp;&amp; j != 0 // 这里的情况为： // str1[0...i]和str2[0...i]，str1和str2都不只一个字符 // 对应可能性a int p1 = process1(str1, str2, i - 1, j - 1); // 对应可能性c int p2 = process1(str1, str2, i - 1, j); // 对应可能性b int p3 = process1(str1, str2, i, j - 1); // 对应可能性d // 如果str1[i] == str2[j]，那么p3就求出来，参与pk // 如果str1[i] != str2[j]，那么让p3等于0，然后去参与pk，反正不影响 int p4 = 0; if (str1[i] == str2[j]) &#123; p4 = 1 + p1; &#125; // 取p1,p2,p3,p4中的最大值 return Math.max(Math.max(p1, p2), Math.max(p3, p4)); &#125; &#125; public static int longestCommonSubsequence2(String s1, String s2) &#123; // 解法2：暴力递归改写dp。leetcode通过 if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123; return 0; &#125; char[] str1 = s1.toCharArray(); char[] str2 = s2.toCharArray(); int N = str1.length; int M = str2.length; // dp[i][j]表示以str1以i结尾，str2以j结尾的最长公共子序列长度 int[][] dp = new int[N][M]; dp[0][0] = str1[0] == str2[0] ? 1 : 0; for (int j = 1; j &lt; M; j++) &#123; dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1]; &#125; for (int i = 1; i &lt; N; i++) &#123; dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0]; &#125; for (int i = 1; i &lt; N; i++) &#123; for (int j = 1; j &lt; M; j++) &#123; int p1 = dp[i - 1][j]; int p2 = dp[i][j - 1]; int p3 = dp[i-1][j - 1]; int p4 = str1[i] == str2[j] ? (1 + p3) : 0; // 取p1,p2,p3,p4中的最大值填写到dp表 dp[i][j] = Math.max(Math.max(p1, p2), Math.max(p3, p4)); &#125; &#125; return dp[N - 1][M - 1]; &#125;&#125; 词频最大前K个字符串题目：给定一个由字符串组成的数组String[] strs,给定一个正数K.返回词频最大的前K个字符串，假设结果是唯一的。 思路：先搞一个HashMap，遍历整个数组。 解法1：搞一个大根堆，然后遍历HashMap建立，最后从堆顶拿K个。 解法2：搞一个Size大小规定为K的小根堆，每次从HashMap里拿的时候直接跟栈顶比较，如果小于栈顶直接不考虑（即，进入小根堆的门槛），大于栈顶则丢掉栈顶，加入这个元素.最后的小根堆就是最大的前K个字符串。这个比较经典。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.*;public class Code06_TopKTimes &#123; public static void main(String[] args) &#123; String[] s = &#123;&quot;abc&quot;,&quot;ab&quot;,&quot;ab&quot;,&quot;bc&quot;,&quot;ac&quot;,&quot;abc&quot;,&quot;ef&quot;,&quot;kisd&quot;,&quot;ef&quot;,&quot;ef&quot;&#125;; printTopKAndRank(s,2); &#125; public static class Node &#123; public String str; public int times; public Node(String s, int t) &#123; this.str = s; this.times = t; &#125; &#125; // 按照词频规则排序 public static class NodeComparator implements Comparator&lt;Node&gt; &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.times - o2.times; &#125; &#125; // 解法2：创建小根堆，遍历剔除顶部值，最终留下的小根堆就是topk的字符串 public static void printTopKAndRank(String[] arr, int topK) &#123; if (arr == null || arr.length == 0 || topK &lt; 1 || topK &gt; arr.length) &#123; return; &#125; // 构建字符串和词频的键值对 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String str : arr) &#123; if (!map.containsKey(str)) &#123; map.put(str, 1); &#125; else &#123; map.put(str, map.get(str) + 1); &#125; &#125; topK = Math.min(arr.length,topK); // 按照词频建立小根堆 PriorityQueue heap = new PriorityQueue&lt;&gt;(new NodeComparator()); for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; // 新建节点 Node cur = new Node(entry.getKey(), entry.getValue()); if (heap.size() &lt; topK) &#123; // 如果小根堆不足k个，直接添加 heap.add(cur); &#125; else &#123; Node node = (Node)heap.peek(); if (node.times &lt; cur.times) &#123; // 如果当前值大于小根堆的顶部值，把当期值替换顶部值，小根堆内部heapfy heap.poll(); heap.add(cur); &#125; &#125; &#125; while(!heap.isEmpty()) &#123; // 依次弹出所有的小根堆数据，刚好就是前K个最大词频字符串 Node node = (Node)heap.poll(); System.out.println(node.str); &#125; &#125;&#125; 词频最大的K个元素题目：在实时数据流中找到最常使用的k个单词.实现TopK类中的三个方法:TopK(k), 构造方法add(word), 增加一个新单词topk(), 得到当前最常使用的k个单词. 解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import java.util.*;// 本题测试链接：https://www.lintcode.com/problem/top-k-frequent-words-ii/// 以上的代码不要粘贴, 把以下的代码粘贴进java环境编辑器// 把类名和构造方法名改成TopK, 可以直接通过public class Code02_TopK &#123; private Node[] heap; private int heapSize; // 词频表 key abc value (abc,7) private HashMap&lt;String, Node&gt; strNodeMap; // 自己实现的动态小根堆-索引表 private HashMap&lt;Node, Integer&gt; nodeIndexMap; private NodeHeapComp comp; // 自己实现的动态小根堆 private TreeSet&lt;Node&gt; treeSet; public Code02_TopK(int K) &#123; heap = new Node[K]; heapSize = 0; strNodeMap = new HashMap&lt;String, Node&gt;(); nodeIndexMap = new HashMap&lt;Node, Integer&gt;(); comp = new NodeHeapComp(); treeSet = new TreeSet&lt;&gt;(new NodeTreeSetComp()); &#125; public static class Node &#123; public String str; public int times; public Node(String s, int t) &#123; str = s; times = t; &#125; &#125; public static class NodeHeapComp implements Comparator&lt;Node&gt; &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.times != o2.times ? (o1.times - o2.times) : (o2.str.compareTo(o1.str)); &#125; &#125; public static class NodeTreeSetComp implements Comparator&lt;Node&gt; &#123; @Override public int compare(Node o1, Node o2) &#123; return o1.times != o2.times ? (o2.times - o1.times) : (o1.str.compareTo(o2.str)); &#125; &#125; // 解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。 public void add(String str) &#123; if (heap.length == 0) &#123; return; &#125; // str 找到对应节点 curNode Node curNode = null; // 对应节点 curNode 在堆上的位置 int preIndex = -1; if (!strNodeMap.containsKey(str)) &#123; curNode = new Node(str, 1); strNodeMap.put(str, curNode); nodeIndexMap.put(curNode, -1); &#125; else &#123; curNode = strNodeMap.get(str); // 要在time++之前，先在treeSet中删掉 // 原因是因为一但times++，curNode在treeSet中的排序就失效了 // 这种失效会导致整棵treeSet出现问题 if (treeSet.contains(curNode)) &#123; treeSet.remove(curNode); &#125; curNode.times++; preIndex = nodeIndexMap.get(curNode); &#125; if (preIndex == -1) &#123; if (heapSize == heap.length) &#123; if (comp.compare(heap[0], curNode) &lt; 0) &#123; treeSet.remove(heap[0]); treeSet.add(curNode); nodeIndexMap.put(heap[0], -1); nodeIndexMap.put(curNode, 0); heap[0] = curNode; heapify(0, heapSize); &#125; &#125; else &#123; treeSet.add(curNode); nodeIndexMap.put(curNode, heapSize); heap[heapSize] = curNode; heapInsert(heapSize++); &#125; &#125; else &#123; treeSet.add(curNode); heapify(preIndex, heapSize); &#125; &#125; // 返回topK个最大的节点即最终的小根堆 public List&lt;String&gt; topk() &#123; ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (Node node : treeSet) &#123; ans.add(node.str); &#125; return ans; &#125; private void heapInsert(int index) &#123; while (index != 0) &#123; int parent = (index - 1) / 2; if (comp.compare(heap[index], heap[parent]) &lt; 0) &#123; swap(parent, index); index = parent; &#125; else &#123; break; &#125; &#125; &#125; private void heapify(int index, int heapSize) &#123; int l = index * 2 + 1; int r = index * 2 + 2; int smallest = index; while (l &lt; heapSize) &#123; if (comp.compare(heap[l], heap[index]) &lt; 0) &#123; smallest = l; &#125; if (r &lt; heapSize &amp;&amp; comp.compare(heap[r], heap[smallest]) &lt; 0) &#123; smallest = r; &#125; if (smallest != index) &#123; swap(smallest, index); &#125; else &#123; break; &#125; index = smallest; l = index * 2 + 1; r = index * 2 + 2; &#125; &#125; private void swap(int index1, int index2) &#123; nodeIndexMap.put(heap[index1], index2); nodeIndexMap.put(heap[index2], index1); Node tmp = heap[index1]; heap[index1] = heap[index2]; heap[index2] = tmp; &#125;&#125; 已知树的先序和中序，求后序题目：已知一棵二叉树中没有重复节点，给定它的先序和中序遍历数组，求后序遍历数组。比如int[] pre={1,2,4,5,3,6,7},int[] in={4,2,5,1,6,3,7}返回{4,5,2,6,7,3,1} 解法1：暴力递归，每次查询树范围索引mid,不断左树右树递归，恢复pos数组 解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class Code01_PreAndInArrayToPosArray &#123; public static class Node &#123; public int value; public Node left; public Node right; public Node(int v) &#123; value = v; &#125; &#125; public static int[] preInToPos1(int[] pre, int[] in) &#123; // 解法1：暴力递归，每次查询树范围索引 if (pre == null || in == null || pre.length != in.length) &#123; return null; &#125; int N = pre.length; int[] pos = new int[N]; // 传入2个数组和索引值，将后序数组pos排好即可 process1(pre, 0, N - 1, in, 0, N - 1, pos, 0, N - 1); return pos; &#125; // 传入2个数组和索引值，将后序数组pos排好即可 // L1...R1 L2...R2 L3...R3 public static void process1(int[] pre, int L1, int R1, int[] in, int L2, int R2, int[] pos, int L3, int R3) &#123; // 边界，索引值不对，直接返回 if (L1 &gt; R1) &#123; return; &#125; // 如果只有一个元素了，先序的第一个节点即根节点就是后续的最后一个节点 if (L1 == R1) &#123; pos[L3] = pre[L1]; return; &#125; // 首先，先序的第一个节点即根节点就是后续的最后一个节点。取出了根节点，然后就要取出左右节点范围 pos[R3] = pre[L1]; int mid = L2; for (; mid &lt;= R2; mid++) &#123; // 在中序数组中，找到对应头结点的索引。mid索引值大小就是区分左右节点的范围 if (in[mid] == pre[L1]) &#123; break; &#125; &#125; int leftSize = mid - L2; // [L1 + 1, L1 + leftSize]对应先序的左树，[L2, mid - 1]对应中序的左树，[L3, L3 + leftSize - 1]对应后序的左树。剩余的左树范围的pos后序数组继续填充 process1(pre, L1 + 1, L1 + leftSize, in, L2, mid - 1, pos, L3, L3 + leftSize - 1); // ...右树，右树，右树。剩余的右树范围的pos后序数组继续填充 process1(pre, L1 + leftSize + 1, R1, in, mid + 1, R2, pos, L3 + leftSize, R3 - 1); &#125; public static int[] preInToPos2(int[] pre, int[] in) &#123; // 解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出 if (pre == null || in == null || pre.length != in.length) &#123; return null; &#125; int N = pre.length; // 缓存map HashMap&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; inMap.put(in[i], i); &#125; int[] pos = new int[N]; process2(pre, 0, N - 1, in, 0, N - 1, pos, 0, N - 1, inMap); return pos; &#125; public static void process2(int[] pre, int L1, int R1, int[] in, int L2, int R2, int[] pos, int L3, int R3, HashMap&lt;Integer, Integer&gt; inMap) &#123; if (L1 &gt; R1) &#123; return; &#125; if (L1 == R1) &#123; pos[L3] = pre[L1]; return; &#125; pos[R3] = pre[L1]; // 直接取出索引值 int mid = inMap.get(pre[L1]); int leftSize = mid - L2; process2(pre, L1 + 1, L1 + leftSize, in, L2, mid - 1, pos, L3, L3 + leftSize - 1, inMap); process2(pre, L1 + leftSize + 1, R1, in, mid + 1, R2, pos, L3 + leftSize, R3 - 1, inMap); &#125; public static void print(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[] pre=&#123;1,2,4,5,3,6,7&#125;; int[] in=&#123;4,2,5,1,6,3,7&#125;; int[] ans1 = preInToPos1(pre, in); int[] ans2 = preInToPos2(pre, in); print(ans1); print(ans2); &#125;&#125; 最长递增子序列题目：给出数组{4,10,4,3,8,9}，求最长的递增子序列的长度。 思路：子序列可以不连续，但要按照原数组顺序。还要递增。所以{3,8,9}或{4,8,9}等等 长度为3. 解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做 解法2：ends数组辅助加速获取最大递增子序列的长度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 本题测试链接 : https://leetcode.com/problems/longest-increasing-subsequencepublic class Code03_LIS &#123; public static void main(String[] args) &#123; int[] arr=&#123;4,10,4,3,8,9&#125;; System.out.println(lengthOfLIS0(arr)); System.out.println(lengthOfLIS1(arr)); &#125; public static int lengthOfLIS0(int[] arr) &#123; // 解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做 int [] dp = new int[arr.length]; // 取dp数组最大值返回 int dpMax = 0; for(int i=0;i&lt;arr.length;i++)&#123; int max = 1; for(int j=0;j&lt;i;j++)&#123; // 逐一比较,找到前面的所有序列的最大长度值 // 固定i,j从0到i-1扫一遍，如果arr[i]&gt;arr[j]，长度是dp[j]+1.否则长度就是1.记录全局最大值即可 max=Math.max(max,arr[i]&gt;arr[j]?dp[j]+1:1); &#125; dp[i]=max; dpMax = Math.max(dpMax,max); &#125; return dpMax; &#125; public static int lengthOfLIS1(int[] arr) &#123; // 解法2：ends数组辅助加速获取最大递增子序列的长度。 if (arr == null || arr.length == 0) &#123; return 0; &#125; // ends数组,非常难以理解，它是一个递增数组。更新ends规则：要么更新，要么扩容添加。它用来加速获取最大递增子序列值，避免了双重循环。 // ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾元素 int[] ends = new int[arr.length]; // 根据含义, 一开始ends[0] = arr[0] ends[0] = arr[0]; // ends有效区范围是0...right，right往右为无效区 // 所以一开始right = 0, 表示有效区只有0...0范围 int right = 0; // 寻找 &gt;= 当前数(arr[i])的最左位置，赋值给l int max = 1; for (int i = 1; i &lt; arr.length; i++) &#123; int l = 0; int r = right; // 在ends[l...r]范围上二分 // 如果 当前数(arr[i]) &gt; ends[m]，砍掉左侧 // 如果 当前数(arr[i]) &lt;= ends[m]，砍掉右侧 // 整个二分就是在ends里寻找 &gt;= 当前数(arr[i])的最左位置,即l // 如果存在l,则更新值。如果不存在l,则扩容添加 // 比如存在l : ends = &#123; 3, 5, 9, 12, 再往右无效&#125; // 如果当前数为8, 从while里面出来时，l将来到2位置，ends更新为&#123; 3, 5, 8, 12, 再往右无效&#125; // 比如不存在l : ends = &#123; 3, 5, 9, 12, 再往右无效&#125; // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，扩容到4位置，ends扩容添加为&#123; 3, 5, 9, 12, 13,再往右无效&#125; while (l &lt;= r) &#123; int m = (l + r) / 2; if (arr[i] &gt; ends[m]) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; &#125; // 从while里面出来，看l的位置 // 如果l比right大，说明扩充了有效区，那么right变量要随之变大---&gt;扩容 // 如果l不比right大，说明l没有来到有效区的越界位置，right不变---&gt;更新 right = Math.max(right, l); // l的位置，就是当前数应该填到ends数组里的位置，更新或扩容添加，都要赋值 ends[l] = arr[i]; // 更新全局变量，一定是end中最大值的索引+1 max = Math.max(max, l + 1); &#125; return max; &#125;&#125; 俄罗斯套娃信封题目：给一定数量的信封，带有整数对 (w, h) 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。求最大的信封嵌套层数。 12345输入：[[5,4],[6,4],[6,7],[2,3]]输出：3解释：最大的信封嵌套层数是 3 ([2,3] =&gt; [5,4] =&gt; [6,7])。 解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.Comparator;// 本题测试链接 : https://leetcode.com/problems/russian-doll-envelopes/public class Code04_EnvelopesProblem &#123; public static int maxEnvelopes(int[][] matrix) &#123; // 解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值 Envelope[] arr = sort(matrix); int[] ends = new int[matrix.length]; ends[0] = arr[0].h; int right = 0; int l = 0; int r = 0; int m = 0; // 二分法，查找l for (int i = 1; i &lt; arr.length; i++) &#123; l = 0; r = right; while (l &lt;= r) &#123; m = (l + r) / 2; if (arr[i].h &gt; ends[m]) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; &#125; right = Math.max(right, l); ends[l] = arr[i].h; &#125; return right + 1; &#125; public static class Envelope &#123; public int l; public int h; public Envelope(int weight, int hight) &#123; l = weight; h = hight; &#125; &#125; public static class EnvelopeComparator implements Comparator&lt;Envelope&gt; &#123; @Override // l升序，h降序 public int compare(Envelope o1, Envelope o2) &#123; return o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h; &#125; &#125; public static Envelope[] sort(int[][] matrix) &#123; Envelope[] res = new Envelope[matrix.length]; for (int i = 0; i &lt; matrix.length; i++) &#123; res[i] = new Envelope(matrix[i][0], matrix[i][1]); &#125; Arrays.sort(res, new EnvelopeComparator()); return res; &#125;&#125; 最大累加和题目：给定一个数组arr,返回子数组的最大累加和 1234567891011121314151617181920// 本题测试链接 : https://leetcode.com/problems/maximum-subarray/public class Code02_SubArrayMaxSum &#123; public static int maxSubArray(int[] arr) &#123; // 解法1：利用两个变量记录cur和max. if (arr == null || arr.length == 0) &#123; return 0; &#125; int max = Integer.MIN_VALUE; int cur = 0; for (int i = 0; i &lt; arr.length; i++) &#123; // 记录实时累加值 cur += arr[i]; // 比较获取全局最大值 max = Math.max(max, cur); // 如果实时累加值为负数的，则前面的直接丢弃，从0重新开始累加计算 cur = cur &lt; 0 ? 0 : cur; &#125; return max; &#125;&#125; 二叉树转为双向链表题目：将BST二叉搜索树转换为已排序的循环双向链表。可以将左右指针视为双向链表中上一个和下一个指针的同义词。 解法1：使用二叉树递归套路，利用中序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 本题测试链接 : https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/public class Code04_BSTtoDoubleLinkedList &#123; // 提交时不要提交这个类 public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125; &#125; // 提交下面的代码 public static Node treeToDoublyList(Node head) &#123; // 解法1：使用二叉树递归套路，利用中序遍历 if (head == null) &#123; return null; &#125; Info allInfo = process(head); // 因为是双向链表，最后还要首尾连接起来 allInfo.end.right = allInfo.start; allInfo.start.left = allInfo.end; return allInfo.start; &#125; // 组装头尾节点数据结构，头节点和尾节点 public static class Info &#123; public Node start; public Node end; public Info(Node start, Node end) &#123; this.start = start; this.end = end; &#125; &#125; // 给定一个根节点为x的树，转化为链表后，返回头尾节点数据结构 public static Info process(Node X) &#123; if (X == null) &#123; return new Info(null, null); &#125; // 得到左子树的头尾节点 Info lInfo = process(X.left); // 得到右子树的头尾节点 Info rInfo = process(X.right); // 将x与左子树串起来 X.left = lInfo.end; // 将x与右子树串起来 X.right = rInfo.start; // 将左子树与x串起来 if (lInfo.end != null) &#123; lInfo.end.right = X; &#125; // 将右子树与x串起来 if (rInfo.start != null) &#123; rInfo.start.left = X; &#125; // 整体链表的头，继续往左子树找 lInfo.start != null ? lInfo.start : X // 整体链表的尾，继续往右子树找 rInfo.end != null ? rInfo.end : X return new Info(lInfo.start != null ? lInfo.start : X, rInfo.end != null ? rInfo.end : X); &#125;&#125; str1编辑成str2的最小代价题目：给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。 【举例】 str1=”abc”，str2=”adc”，ic=5，dc=3，rc=2 从”abc”编辑成”adc”，把’b’替换成’d’是代价最小的，所以返回2 str1=”abc”，str2=”adc”，ic=5，dc=3，rc=100 从”abc”编辑成”adc”，先删除’b’，然后插入’d’是代价最小的，所以返回8 str1=”abc”，str2=”abc”，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Code03_EditCost &#123; public static int minCost1(String s1, String s2, int ic, int dc, int rc) &#123; // 解法1：直接写dp，dp[i][j]表示s1的前i个字符串变成s2的前j个字符串的最小代价 if (s1 == null || s2 == null) &#123; return 0; &#125; char[] str1 = s1.toCharArray(); char[] str2 = s2.toCharArray(); int N = str1.length + 1; int M = str2.length + 1; int[][] dp = new int[N][M]; // dp[0][0] = 0，不用任何操作 // dp边界，从有字符串变成空，需要依次删除的代价 for (int i = 1; i &lt; N; i++) &#123; dp[i][0] = dc * i; &#125; // dp边界，从空变成有字符串，需要依次添加的代价 for (int j = 1; j &lt; M; j++) &#123; dp[0][j] = ic * j; &#125; /*s1变成s2,正常的四种情况 * s1 0---i-1,i * s2 0---j-1,j * 1.如果s1的前i-1和s2的前j-1是相等的 * a.s1[i]==s2[j],代价就是dp[i-1][j-1] * b.s1[i]!=s2[j],代价就是dp[i-1][j-1]+rc(一个替换的代价) * 2.如果s1的前i-1和s2的前j-1是不等的 * c.s1[0---i]替换s2[0---j-1],代价是dp[i][j-1]+ic(一个新增的代价，因为从i变成了j-1,理论上字符变少了一个，所以最后要追加一个) * d.s1[0---i-1]替换s2[0---j],代价是dp[i-1][j]+dc(一个删除的代价，因为从i-1变成了j,理论上字符变多了一个，所以最后要删除一个) * */ for (int i = 1; i &lt; N; i++) &#123; for (int j = 1; j &lt; M; j++) &#123; // 情况a,情况b dp[i][j] = dp[i - 1][j - 1] + (str1[i - 1] == str2[j - 1] ? 0 : rc); // 情况c dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic); // 情况d dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc); &#125; &#125; // 最后返回s1前N个字符串变成s2前M个字符串的代价。N个对应N-1的索引 return dp[N - 1][M - 1]; &#125;&#125; str1删除成str2的最小个数字符 题目：给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = “abcde”，s2 = “axbc”。返回 1 解法1：求出str2所有的子序列，然后按照长度排序，长度大的排在前面。然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。 123456789101112131415161718192021222324252627282930public class Code04_DeleteMinCost &#123; // 解法一 // 求出str2所有的子序列，然后按照长度排序，长度大的排在前面。 // 然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。 // 分析： // 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。 // 但是如果某一次考试给定的s2长度远大于s1，这么做就不合适了。 public static int minCost1(String s1, String s2) &#123; List&lt;String&gt; s2Subs = new ArrayList&lt;&gt;(); // 递归求解s2的所有子序列 process(s2.toCharArray(), 0, &quot;&quot;, s2Subs); // 对所有子序列的长度按照降序排列 s2Subs.sort(new LenComp()); for (String str : s2Subs) &#123; // 查看s2的所有子序列是否是s1的子串 if (s1.indexOf(str) != -1) &#123; // indexOf底层和KMP算法代价几乎一样，也可以用KMP代替 // 只要找到了，那么删除的长度就是s2-当前子序列的长度 return s2.length() - str.length(); &#125; &#125; // 如果一个都没找到，说明要全删除 return s2.length(); &#125; public static class LenComp implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; return o2.length() - o1.length(); &#125; &#125;&#125; 求完全二叉树节点的个数题目：要求时间复杂度低于O(N). 解法1：递归套路，O(h2)即O((logN)2)，之前是O(n) * a.计算出最大深度，一直向左窜 * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树 * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树 * d.直到某个节点来到最大深度，节点个数为1 1 //本题测试链接 : https://leetcode.cn/problems/count-complete-tree-nodes/ public class Code04_CompleteTreeNodeNumber &#123; // 提交时不要提交这个类 public class TreeNode &#123; int val; TreeNode left; TreeNode right; &#125; /* * 解法1：递归套路，O(h2)即O((logN)2)，之前是O(n) * a.计算出最大深度，一直向左窜 * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树 * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树 * d.直到某个节点来到最大深度，节点个数为1 * */ public static int countNodes(TreeNode head) &#123; if (head == null) &#123; return 0; &#125; // 给定头结点，节点的所在层数，节点的树高度，返回节点个数 return bs(head, 1, mostLeftLevel(head, 1)); &#125; // 当前来到node节点，node节点在level层，总层数是h // 返回node为头的子树(必是完全二叉树)，有多少个节点 public static int bs(TreeNode node, int Level, int h) &#123; // base case:说明节点来到了最后一层 if (Level == h) &#123; return 1; &#125; // 判断节点的右子树的最左节点是否到达最后一层 if (mostLeftLevel(node.right, Level + 1) == h) &#123; // 如果到达最后一层，说明左子树是满的，继续递归右子树 // 已知高度h计算节点个数：(2^h)-1,所以2^(h - Level)左树节点 -1 +1根节点 return (1 &lt;&lt; (h - Level)) + bs(node.right, Level + 1, h); &#125; else &#123; // 如果没有到达最后一层，说明右子树是满的，继续递归左子树 // 2^(h - Level-1)右树节点 —1 +1根节点 return (1 &lt;&lt; (h - Level - 1)) + bs(node.left, Level + 1, h); &#125; &#125; // 如果node在第level层，求以node为头的子树，最大深度是多少。这是一个固定值 // 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。定义根节点是第1层 public static int mostLeftLevel(TreeNode node, int level) &#123; // 因为是完全二叉树，所以可以左节点一直往下扎，计算树的高度 while (node != null) &#123; level++; node = node.left; &#125; // 高度 return level - 1; &#125; &#125; 12345678### LRU算法LRU算法全称是最近最少使用算法（Least Recently Use），广泛的应用于缓存机制中。如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。所以顾名思义，LRU算法会选出最近最少使用的数据进行淘汰。- 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)- 解法2：基于LinkedHashMap实现的LRU import java.util.HashMap; // 本题测试链接 : https://leetcode.com/problems/lru-cache/ // 提交时把类名和构造方法名改成 : LRUCache public class Code01_LRUCache &#123; public Code01_LRUCache(int capacity) &#123; cache = new MyCache&lt;&gt;(capacity); &#125; private MyCache&lt;Integer, Integer&gt; cache; public int get(int key) &#123; Integer ans = cache.get(key); return ans == null ? -1 : ans; &#125; public void put(int key, int value) &#123; cache.set(key, value); &#125; public static class Node&lt;K, V&gt; &#123; public K key; public V value; public Node&lt;K, V&gt; last; public Node&lt;K, V&gt; next; public Node(K key, V value) &#123; this.key = key; this.value = value; &#125; &#125; // 双向链表，LRU的关键，头结点是最不常使用，尾节点是最长使用。所以LRU是删除头结点，更新尾节点 public static class NodeDoubleLinkedList&lt;K, V&gt; &#123; private Node&lt;K, V&gt; head; private Node&lt;K, V&gt; tail; public NodeDoubleLinkedList() &#123; head = null; tail = null; &#125; // 现在来了一个新的node，请挂到尾巴上去 public void addNode(Node&lt;K, V&gt; newNode) &#123; if (newNode == null) &#123; return; &#125; if (head == null) &#123; head = newNode; tail = newNode; &#125; else &#123; tail.next = newNode; newNode.last = tail; tail = newNode; &#125; &#125; // 将当前节点挂到整个链表的尾巴上 public void moveNodeToTail(Node&lt;K, V&gt; node) &#123; if (tail == node) &#123; return; &#125; if (head == node) &#123; // 如果要移动的节点是头结点 // 当前节点的下一个节点变成新头 head = node.next; // 头结点的上一节点指向空 head.last = null; &#125; else &#123; // 如果要移动的节点是其他结点，那么这个节点前后节点要重新粘起来。如：当前节点的上一个节点的下一个指向当前节点的下一个节点。 node.last.next = node.next; node.next.last = node.last; &#125; // 当前节点的上一个节点指向老尾巴节点 node.last = tail; // 老尾巴节点的下一个节点指向当前节点 tail.next = node; // 当前节点的下一节点指向空 node.next = null; // 新尾巴更新为当前节点 tail = node; &#125; // 双向链表删除头结点 public Node&lt;K, V&gt; removeHead() &#123; if (head == null) &#123; return null; &#125; // 先提取出返回值 Node&lt;K, V&gt; res = head; // 调整头尾指针 if (head == tail) &#123; // 头尾节点相同，说明只有一个节点，直接全指向空 head = null; tail = null; &#125; else &#123; // 说明至少有2个节点 // 新头部指向当前节点下一个节点 head = res.next; // 新头部的前一个节点指向空 head.last = null; // 当前节点的下一个节点 断开 res.next = null; &#125; return res; &#125; &#125; // 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N) public static class MyCache&lt;K, V&gt; &#123; // map中key对应节点key，value对应节点的内存地址 private HashMap&lt;K, Node&lt;K, V&gt;&gt; keyNodeMap; // 节点的双向链表 private NodeDoubleLinkedList&lt;K, V&gt; nodeList; // LRU的容量 private final int capacity; public MyCache(int cap) &#123; keyNodeMap = new HashMap&lt;K, Node&lt;K, V&gt;&gt;(); nodeList = new NodeDoubleLinkedList&lt;K, V&gt;(); capacity = cap; &#125; // 读取节点，更新链表尾巴 public V get(K key) &#123; if (keyNodeMap.containsKey(key)) &#123; Node&lt;K, V&gt; res = keyNodeMap.get(key); // 节点移动到尾巴 nodeList.moveNodeToTail(res); // 返回节点value值 return res.value; &#125; return null; &#125; // 新增或更新节点，更新链表尾巴和更新哈希表 public void set(K key, V value) &#123; // 如果是更新节点，直接移动节点到链表尾巴 if (keyNodeMap.containsKey(key)) &#123; Node&lt;K, V&gt; node = keyNodeMap.get(key); node.value = value; // 直接移动节点到链表尾巴 nodeList.moveNodeToTail(node); &#125; else &#123; // 如果是新增节点，直接添加到链表尾巴 // 新增！注意先删除，再添加 if (keyNodeMap.size() == capacity + 1) &#123; // 超出容量，移除头结点 removeMostUnusedCache(); &#125; Node&lt;K, V&gt; newNode = new Node&lt;K, V&gt;(key, value); keyNodeMap.put(key, newNode); nodeList.addNode(newNode); &#125; &#125; // 删除LRU缓存时，要删除链表头节点和哈希表中的节点 private void removeMostUnusedCache() &#123; Node&lt;K, V&gt; removeNode = nodeList.removeHead(); keyNodeMap.remove(removeNode.key); &#125; &#125; &#125; 1234567891011### Easy Equation题目：求助已知有n个整数，x1,x2,x3….xn.(1&lt;=n&lt;=10，0&lt;=xi&lt;=30)，以及m个整数a1,a2,a3….am(1&lt;=m&lt;=20,0&lt;=ai&lt;=25);现在取出所有的a1,a2,a3…am.将他们随意分成n组，每组求和的值为b1,b2,b3…bn，然后成为x1,x2,x3…xn的系数。（可以选择0个ai，组成一个对应的bj=0,但是数组a中的所有的ai必须选完）。求满足b1*x1+b2*x2+b3*x3+…+bn*xn=s的分组方法数。其中s为输入的一个数据（0&lt;=s&lt;=20000）。但是这个方法数也许会比较巨大,请输出分组方法数mod 1000000007 的结果。 输入： 4 4 68 1 2 4 8 1 2 4 8 输出： 3 1 public class 139 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int s = scanner.nextInt(); int[] x = new int[n]; int[] a = new int[m]; for (int i = 0; i &lt; n; i++) &#123; x[i] = scanner.nextInt(); &#125; for (int i = 0; i &lt; m; i++) &#123; a[i] = scanner.nextInt(); &#125; // result[i] 表示取a前i个参数（后面参数视为0）所构成的等式的结果种数 int[][] result = new int[m][s + 1]; for (int i = 0; i &lt; n; i++) &#123; // 初始化第一行，表示取a中第一个参数构成的等式的的结果种数 // 如x = &#123;1,1,2,2&#125; ，a=&#123;1,2&#125;，那么 取a的第一个参数就构成的等式结果 为&#123;0，2，2&#125; result[0][x[i] * a[0]] += 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 0; j &lt;= s; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; // 等式构成的结果减去增加的新项，无需管分组求和 // 因为(a1+a2) * x1 = a1*x1 + a2*x1，这里的a[i] * x[k]就是 a2*x1，index就是a1*x1 int index = j - a[i] * x[k]; if (index &lt; 0) &#123; continue; &#125; // 增加的新项构成的等式结果种树 就等于 index的结果+已经有的 result[i][j] += result[i - 1][index]; result[i][j] = result[i][j] % 1000000007; &#125; &#125; &#125; System.out.println(result[m - 1][s]); &#125; &#125;","categories":[{"name":"E_数据结构","slug":"E-数据结构","permalink":"https://fuyunjinglong.github.io/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"","slug":"Test","date":"2022-10-22T08:05:41.618Z","updated":"2022-11-08T23:20:08.901Z","comments":true,"path":"2022/10/22/Test/","link":"","permalink":"https://fuyunjinglong.github.io/2022/10/22/Test/","excerpt":"","text":"let shoeObj = {} shoeObj.list = [] // 增加订阅者 shoeObj.listen = function(key, fn){ if(!this.list[key]){ // 如果不存在key的订阅事件，则置为空 this.list[key] = [] } // 把函数fn加入回调数组 this.list[key].push(fn) } // 发布消息 shoeObj.trigger=function(){ // 取出key let key = Array.prototype.shift.call(arguments) let fns =this.list[key] // 遍历数组，执行函数fn if(!fns||!fns.length){ return } for(let i = 0;i","categories":[],"tags":[]},{"title":"","slug":"模板","date":"2022-09-12T03:55:29.067Z","updated":"2024-03-09T03:46:47.976Z","comments":true,"path":"2022/09/12/模板/","link":"","permalink":"https://fuyunjinglong.github.io/2022/09/12/%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"书单","slug":"Z_书单","date":"2022-09-12T00:33:16.000Z","updated":"2023-07-16T03:45:41.245Z","comments":true,"path":"2022/09/12/Z_书单/","link":"","permalink":"https://fuyunjinglong.github.io/2022/09/12/Z_%E4%B9%A6%E5%8D%95/","excerpt":"","text":"大黑书有一个共同点就是厚、并且很适合盖泡面。哪有人开始打牌的时候就出王炸的呢 工作技能汇总 java-books-collections 前端awesome-book 黑马程序员pink 黑马程序员JavaScript核心教程 Vue-电商平台数据可视化实时监控系统-Echarts-vue Vue源码解析 javascript三剑客 JavaScript数据结构与算法 第3版 9787115510174 JavaScript DOM编程艺术 第2版 9787115249999 JavaScript高级程序设计 第4版 9787115545381 《Javascript权威指南》 javascript dom编程艺术 javascript高级程序设计（红宝书） 和javascript权威指南（犀牛书） Vuejs设计与实现 javascript忍者秘籍 前端开发核心知识进阶 javascript迷你正则书 你不知道的javascript （小黄书） Javascript20周年（历史书） javascript语言精粹与编程实践 《前端技术架构与工程》 《浏览器工作原理与实践-李兵》 《Web前端工程师修炼之道（原书第5版）》 《JavaScript权威指南 原书第7版》 《Vue.js入门与商城开发实战》 《TypeScript入门与实战》 《TypeScript项目开发实战》 《Webpack实战：入门、进阶与调优》 《WebAssembly原理与核心技术》 《Electron实战：入门、进阶与性能优化》 《WebRTC从入门到进阶》 《WebRTC技术详解：从0到1构建多人视频会议系统》 《WebRTC音视频实时互动技术：原理、实战与源码分析》 《实战低代码》 《[HTML与CSS入门经典(第7版)].（美）奥利弗，（美）莫里森.扫描版》 百度云链接 (opens new window)提取码：t8lj 《[JavaScript.DOM编程艺术（第2版）]》 百度云链接 (opens new window)提取码：gpaz 《Bootstrap实战》 百度云链接 (opens new window)提取码：7xtf 《HTML5揭秘》 百度云链接 (opens new window)提取码：v9qw 《HTML5与CSS3基础教程（第8版）》 百度云链接 (opens new window)提取码：9i5k 《Javascript 高效图形编程-中文版》 百度云链接 (opens new window)提取码：ksmm 《javascript高级程序设计》 百度云链接 (opens new window)提取码：zmz4 《jQuery高级编程，中文完整扫描版》 百度云链接 (opens new window)提取码：x1wi 《jQuery技术内幕 深入解析jQuery架构设计与实现原理》 百度云链接 (opens new window)提取码：1e3e 《jQuery权威指南》 百度云链接 (opens new window)提取码：tflj 《Node.js开发指南》 百度云链接 (opens new window)提取码：r1oj 《nodebook》 百度云链接 (opens new window)提取码：himg 《JavaScript高级程序设计（第3版）中文 高清》 百度云链接 (opens new window)提取码：uus7 《疯狂AJAX讲义》 百度云链接 (opens new window)提取码：w85h 《深入浅出Node.js》 百度云链接 (opens new window)提取码：cmkj 后端Java尚硅谷宋红康老师的 Java 零基础视频 尚学堂高琪老师的Java视频 求知课堂2019Java入门视频 尚硅谷Java8新特性 B站最强的Java项目-谷粒商城 《深入分析JavaWeb技术内幕》 百度云链接 (opens new window)提取码：g1qz 《深入剖析Tomcat》 百度云链接 (opens new window)提取码：o06x 《Effective Java 2nd Edition 英文版》 百度云链接 (opens new window)提取码：czeq 《Effective Java 中文第二版》 百度云链接 (opens new window)提取码：5p9e 《Java性能优化权威指南》 百度云链接 (opens new window)提取码：9g85 《Java核心技术(卷1）第8版》 百度云链接 (opens new window)提取码：pmx2 《Java核心技术(卷2）第8版》 百度云链接 (opens new window)提取码：in8y 《Head First Java第二版涵盖java5.0》 百度云链接 (opens new window)提取码：qfz2 《Java 8 实战》 百度云链接 (opens new window)提取码：3ej1 《阿里巴巴Java开发手册–1.0.0公开版》 百度云链接 (opens new window)提取码：pl9v 《阿里巴巴Java开发手册–1.1.0正式版》 百度云链接 (opens new window)提取码：zrxy 《阿里巴巴Java开发手册–1.2.0升级版》 百度云链接 (opens new window)提取码：n45a 《阿里巴巴Java开发手册–1.3.0终极版》 百度云链接 (opens new window)提取码：ycoc 《阿里巴巴Java开发手册–1.4.0详尽版》 百度云链接 (opens new window)提取码：dya6 《阿里巴巴Java开发手册–华山版》 百度云链接 (opens new window)提取码：z3fh 《阿里巴巴Java开发手册-嵩山版》 百度云链接 (opens new window)提取码：z8mf 《阿里巴巴Java开发手册–泰山版》 百度云链接 (opens new window)提取码：6cxz 《Java编程思想（第四版）》 百度云链接 (opens new window)提取码：ogz5 《Java并发编程的艺术》 百度云链接 (opens new window)提取码：v8pj 《JAVA并发编程实践》 百度云链接 (opens new window)提取码：se4k 《Java从小白到大牛精简版》 百度云链接 (opens new window)提取码：zmer 《Java核心技术卷1基础知识原书第10版》 百度云链接 (opens new window)提取码：c6d5 《Java核心技术卷2高级特性原书第10版》 百度云链接 (opens new window)提取码：gjlh 《码出高效：Java开发手册》 百度云链接 (opens new window)提取码：4i0f 《阿里巴巴Java开发手册v1.2.0》 百度云链接 (opens new window)提取码：129f 《深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）》 百度云链接 (opens new window)提取码：qbfq 《Camel in Action》 百度云链接 (opens new window)提取码：kcs0 《Head First Servlet and JSP(高清中文版)》 百度云链接 (opens new window)提取码：q55k 《Maven实战（高清完整带书签）》 百度云链接 (opens new window)提取码：4q4a 《Spring 5 Recipes, 4th Edition》 百度云链接 (opens new window)提取码：o3uk 《Spring in action 中文版（第4版）》 百度云链接 (opens new window)提取码：daya 《轻量级JavaEE企业应用实战》 百度云链接 (opens new window)提取码：1rn2 《ThinkInJava（JAVA编程思想）》 百度云链接 (opens new window)提取码：e5rp 《Head First Java 中文高清版》 百度云链接 (opens new window)提取码：yry8 《Netty in Action第五版》 百度云链接 (opens new window)提取码：ty0o 《Java核心知识点整理》 百度云链接 (opens new window)提取码：3s2p 《Java并发编程实践 英语版》 百度云链接 (opens new window)提取码：9mp0 《Effective Java（中文版第3版）》 百度云链接 (opens new window)提取码：ruo1 《Netty实战》 百度云链接 (opens new window)提取码：rd2m 《Spring实战（第4版）》 百度云链接 (opens new window)提取码：7kfk 《java从入门到精通（第4版）》 百度云链接 (opens new window)提取码：movm 《Spring.in.Action.5th.Edition》 百度云链接 (opens new window)提取码：le2h 《Spring 技术内幕》 百度云链接 (opens new window)提取码：gni3 《Java EE框架整合开发入门到实战：Spring+Spring MVC+MyBatis（微课版）》 百度云链接 (opens new window)提取码：asxu 《大型网站技术架构：核心原理与案例分析》 百度云链接 (opens new window)提取码：q0ua 《大话java性能优化》 百度云链接 (opens new window)提取码：hfeg 《分布式Java应用基础与实践》 百度云链接 (opens new window)提取码：dv70 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）+(华章原创精品)+-+周志明》 百度云链接 (opens new window)提取码：rs4z 《Java核心技术(卷I)基础知识(原书第9版)》 百度云链接 (opens new window)提取码：4d76 《深入分析Java Web技术内幕 旧版》 百度云链接 (opens new window)提取码：8s2v 《SSM企业级框架实战》 百度云链接 (opens new window)提取码：h5p2 架构 《Redis开发与运维(付磊)》 百度云链接 (opens new window)提取码：rtow 《后台开发》 百度云链接 (opens new window)提取码：7k53 《后台开发核心技术与应用实践高清PDF》 百度云链接 (opens new window)提取码：syau 《深入理解Nginx模块开发与架构解析第2版》 百度云链接 (opens new window)提取码：o14w 《Kafka权威指南》 百度云链接 (opens new window)提取码：pn4r 《RabbitMQ实战指南》 百度云链接 (opens new window)提取码：l0xj 大数据 《大数据架构师指南》 百度云链接 (opens new window)提取码：vi00 《大数据之路：阿里巴巴大数据实践》 百度云链接 (opens new window)提取码：xbco 《深入理解Spark：核心思想与源码分析》 百度云链接 (opens new window)提取码：rkov 《图解Spark - 核心技术与案例实战》 百度云链接 (opens new window)提取码：kfaj 《Apache+Kylin权威指南》 百度云链接 (opens new window)提取码：y31o 《Hadoop The Definitive Guide》 百度云链接 (opens new window)提取码：ws9o 《Hadoop技术内幕：深入理解MapReduce架构设计与实现原理》百度云链接 (opens new window)提取码：afhy 《Kafka &amp; Mafka技术分享及讨论》 百度云链接 (opens new window)提取码：4u7i 《Scala编程中文版(33章全)》 百度云链接 (opens new window)提取码：6m1n 《Spark大数据处理：技术、应用与性能优化(全)》 百度云链接 (opens new window)提取码：ghw3 《Spark机器学习》 百度云链接 (opens new window)提取码：3li7 《Spark快速大数据分析》 百度云链接 (opens new window)提取码：jlqc 《Spark最佳实践》 百度云链接 (opens new window)提取码：ziy5 《ClickHouse中文文档》 百度云链接 (opens new window)提取码：vjb3 《Flink基础教程》 百度云链接 (opens new window)提取码：7ttp 《CDH集群运维手册》 百度云链接 (opens new window)提取码：38qp 《Elasticsearch.权威指南（中文版）》 百度云链接 (opens new window)提取码：fmo0 《Hadoop应用架构》 百度云链接 (opens new window)提取码：ezgg 《Elasticsearch集成Hadoop最佳实践》 百度云链接 (opens new window)提取码：eiro 《Apache Spark源码剖析》 百度云链接 (opens new window)提取码：pe9u 《Flume构建高可用、可扩展的海量日志采集系统》 百度云链接 (opens new window)提取码：qxc4 《HBase_权威指南》 百度云链接 (opens new window)提取码：y8bm 《HBase实战中文版》 百度云链接 (opens new window)提取码：6tek 《Hive编程指南》 百度云链接 (opens new window)提取码：a88l 《HBase不睡觉书 带目录（高清）》 百度云链接 (opens new window)提取码：wpmv 《Apache Kafka实战》 百度云链接 (opens new window)提取码：1zdo 《Mahout算法解析与案例实战》 百度云链接 (opens new window)提取码：0vtf 《Kafka权威指南(2018中文版)》 百度云链接 (opens new window)提取码：nwrk 《Kafka源码解析与实战》 百度云链接 (opens new window)提取码：t83m 《MapReduce设计模式 [（美）迈纳，（美）舒克著]》 百度云链接 (opens new window)提取码：flxj 《Spark快速数据处理》 百度云链接 (opens new window)提取码：4m6s 《spark开发基础之Scala快餐》 百度云链接 (opens new window)提取码：hxz0 《Lucene实战（第2版）》 百度云链接 (opens new window)提取码：uot4 《Spark最佳实践陈欢，林世飞著》 百度云链接 (opens new window)提取码：nmmq 《Spark大数据分析核心概念技术及实践OCR》 百度云链接 (opens new window)提取码：zbvo 《Storm技术内幕与大数据实践》 百度云链接 (opens new window)提取码：duju 《Spark内核设计的艺术架构设计与实现（耿嘉安）》 百度云链接 (opens new window)提取码：xuww 《Presto技术内幕》 百度云链接 (opens new window)提取码：tsw5 《决战大数据》 百度云链接 (opens new window)提取码：eu4p 《Apache Kafka源码剖析》 百度云链接 (opens new window)提取码：qryy 《从Paxos到Zookeeper 分布式一致性原理与实践》 百度云链接 (opens new window)提取码：6iyn 《可视化数据》 百度云链接 (opens new window)提取码：f29x 《基于Apache Kylin 构建大数据分析平台》 百度云链接 (opens new window)提取码：vn2b 《从零开始学Storm》 百度云链接 (opens new window)提取码：jfrn 《最全的大数据解决方案》 百度云链接 (opens new window)提取码：me79 《深入学习MongoDB》 百度云链接 (opens new window)提取码：4qzy 《大数据技术原理与应用概念、存储、处理、分析与应用(第2版)》 百度云链接 (opens new window)提取码：h10h 《机器学习与数据挖掘方法和应用（经典）》 百度云链接 (opens new window)提取码：ry6j 《大数据Spark企业级实战版》 百度云链接 (opens new window)提取码：v6im 《实战Elasticsearch、Logstash、Kibana：分布式大数据搜索与日志挖掘及可视》 百度云链接 (opens new window)提取码：yrpe 《深入理解Spark 核心思想与源码分析 耿嘉安著》 百度云链接 (opens new window)提取码：z2eu 《相关性搜索：利用Solr与Elasticsearch创建智能应用》 百度云链接 (opens new window)提取码：its4 数据结构与算法青岛大学王卓老师 清华邓俊辉老师 Y神的背包九讲 《程序员代码面试指南》《算法数据结构体系学习班》《算法与数据结构基础班》 《数据结构与算法JavaScript描述》 《JavaScript设计模式》 《漫画算法-小灰的算法之旅》 学习javascript数据结构和算法 啊哈算法 小灰说算法 《谷歌大佬总结的三本LeetCode刷题笔记，支持Java、C++、Go三种语言》 百度云链接 (opens new window)提取码：ujuc 《啊哈！算法 哈磊》 百度云链接 (opens new window)提取码：5fop 《大话数据结构》 百度云链接 (opens new window)提取码：ehu4 《背包九讲》 百度云链接 (opens new window)提取码：8ioa 《带你快速刷完67道剑指offer》 百度云链接 (opens new window)提取码：dxm0 《编程之美-完整版》 百度云链接 (opens new window)提取码：yumy 《编程珠玑 第二版 人民邮电出版社》 百度云链接 (opens new window)提取码：gqg5 《编程珠玑 英文第二版-Programming.Pearls》 百度云链接 (opens new window)提取码：xsdt 《程序员代码面试指南 IT名企算法与数据结构题目最优解（左程云著）》 百度云链接 (opens new window)提取码：p6r8 《程序员的算法趣题》 百度云链接 (opens new window)提取码：1r8q 《程序员面试金典》 百度云链接 (opens new window)提取码：7k9q 《计算机程序设计艺术卷1：基本算法》 百度云链接 (opens new window)提取码：4ey6 《计算机程序设计艺术卷2：半数值算法》 百度云链接 (opens new window)提取码：tmep 《计算机程序设计艺术卷3：排序与查找》 百度云链接 (opens new window)提取码：ebud 《剑指Offer》 百度云链接 (opens new window)提取码：20z4 《漫画算法：小灰的算法之旅》 百度云链接 (opens new window)提取码：2fof 《妙趣横生的算法（C语言实现 第2版）》 百度云链接 (opens new window)提取码：uvm8 《数据结构-C语言 严蔚敏 pdf》 百度云链接 (opens new window)提取码：g0o5 《严蔚敏：数据结构题集(C语言版)》 百度云链接 (opens new window)提取码：u7m0 《数据结构与算法 Python语言描述_裘宗燕》 百度云链接 (opens new window)提取码：1c9u 《数据结构与算法分析C++描述》 百度云链接 (opens new window)提取码：nhnz 《数据结构与算法分析—Java语言描述》 百度云链接 (opens new window)提取码：cyn6 《数据结构与算法分析：C语言描述原书第2版 高清版》 百度云链接 (opens new window)提取码：gy53 《算法（第4版）》 百度云链接 (opens new window)提取码：e65w 《算法导论原书第3版》 百度云链接 (opens new window)提取码：xl63 《算法导论中文版》 百度云链接 (opens new window)提取码：okm5 《算法分析与设计》 百度云链接 (opens new window)提取码：mmcx 《算法谜题》 百度云链接 (opens new window)提取码：tq0f 《算法图解》 百度云链接 (opens new window)提取码：i2k7 《挑战程序设计竞赛(第1版)》 百度云链接 (opens new window)提取码：gm3c 《挑战程序设计竞赛(第2版)》 百度云链接 (opens new window)提取码：app8 《Cookbook-LeetCode》 百度云链接 (opens new window)提取码：evzs 《Cormen-Introduction to Algorithms》 百度云链接 (opens new window)提取码：unt9 《JavaScrit数据结构与算法（第2版）》 百度云链接 (opens new window)提取码：sbxc 《Java数据结构和算法.（第二版）》 百度云链接 (opens new window)提取码：owjm 《labuladong的算法小抄官方完整版》 百度云链接 (opens new window)提取码：x3uv 《Sedgewick-Algorithms》 百度云链接 (opens new window)提取码：reyi 《Data-Structures-Problem-Solving-Using-Java》 百度云链接 (opens new window)提取码：mkvu 《leetcode-solution》 百度云链接 (opens new window)提取码：zfdq 《算法竞赛入门经典训练指南》 百度云链接 (opens new window)提取码：ktkh 《算法竞赛入门经典及答案》 百度云链接 (opens new window)提取码：hw1u 《分布式算法导论》 百度云链接 (opens new window)提取码：i8oy 《算法之道》 百度云链接 (opens new window)提取码：f2td 《C++数据结构与算法 （第4版）带书签目录 完整版》 百度云链接 (opens new window)提取码：6yyw 《趣学算法》 百度云链接 (opens new window)提取码：lkah 计算机系统知识 《大话计算机》 百度云链接 (opens new window)提取码：9jc8 《编码：隐匿在计算机软硬件背后的语言》 百度云链接 (opens new window)提取码：60p1 《程序是怎样跑起来的》 百度云链接 (opens new window)提取码：u30m 《计算机是怎样跑起来的》 百度云链接 (opens new window)提取码：uwfk 《程序员的自我修养—链接、装载与库–书签目录版本》 百度云链接 (opens new window)提取码：ivmv 《计算机组成与设计：硬件_软件接口》 百度云链接 (opens new window)提取码：dhda 《Patterson-Computer Organization and Design_The Hardware_Software Interface》 百度云链接 (opens new window)提取码：zn24 《Code - The Hidden Language of Computer Hardware and Software》 百度云链接 (opens new window)提取码：pytl 《计算机组成 结构化方法 中文 第6版》 百度云链接 (opens new window)提取码：c1qy 计算机网络韩立刚老师 计算机网络微课堂 《图解 http》 《深入浅出 https》 《计算机网络-自顶向下方法-第6版》 百度云链接 (opens new window)提取码：oj35 《计算机网络：自顶向下方法课后习题参考答案》 百度云链接 (opens new window)提取码：d25h 《HTTP核心总结》 百度云链接 (opens new window)提取码：2fk9 《HTTP权威指南》 百度云链接 (opens new window)提取码：1jhn 《TCPIP详解三部曲卷1：协议》 百度云链接 (opens new window)提取码：j2iq 《TCPIP详解三部曲卷2：实现》 百度云链接 (opens new window)提取码：r1cl 《TCPIP详解三部曲卷3》 百度云链接 (opens new window)提取码：zee6 《TCP源码分析》 百度云链接 (opens new window)提取码：dhlo 《Wireshark 数据包分析实战（第二版）》 百度云链接 (opens new window)提取码：shyo 《Wireshark网络分析的艺术》 百度云链接 (opens new window)提取码：lljf 《Wireshark网络分析就这么简单》 百度云链接 (opens new window)提取码：9j5j 《计算机网络 第七版》 百度云链接 (opens new window)提取码：89yv 《计算机网络：系统方法》 百度云链接 (opens new window)提取码：uhke 《图解HTTP》 百度云链接 (opens new window)提取码：faxi 《图解TCPIP(第5版)》 百度云链接 (opens new window)提取码：j86n 《网络是怎样连接的 (图灵程序设计丛书)》 百度云链接 (opens new window)提取码：vhm1 《Computer Networking_ A Top-down Approach》 百度云链接 (opens new window)提取码：ewr3 《Computer Networks, A Systems Approach》 百度云链接 (opens new window)提取码：o98i 数据库尚硅谷的MySQ入门视频 + 高级篇 黑马的MySQL实战教程 尚硅谷MySQL数据库高级教程 《MySQL必知必会 PDF + 源码》 百度云链接 (opens new window)提取码：45id 《数据库系统实现（第二版）》 百度云链接 (opens new window)提取码：hjds 《高性能MySQL（第3版）].Baron.Scbwartz等.扫描版》 百度云链接 (opens new window)提取码：nszh 《深入浅出MySQL++数据库开发、优化与管理维护+第2版+唐汉明》 百度云链接 (opens new window)提取码：a0uo 《数据库系统概念》 百度云链接 (opens new window)提取码：eugi 《Database System Concepts》 百度云链接 (opens new window)提取码：1u2u 《MongoDB权威指南》 百度云链接 (opens new window)提取码：vcca 《MySQL技术内幕 InnoDB存储引擎 第2版》 百度云链接 (opens new window)提取码：c9qa 《Redis设计与实现》 百度云链接 (opens new window)提取码：r7r6 《Redis实战》 百度云链接 (opens new window)提取码：eebx 《Redis开发与运维》 百度云链接 (opens new window)提取码：ot6f 《SQLite 权威指南》 百度云链接 (opens new window)提取码：5bh2 《SQL查询的艺术》 百度云链接 (opens new window)提取码：tsfm 《分布式数据库系统 大数据时代新型数据库技术》 百度云链接 (opens new window)提取码：zsxl 《分布式数据库系统原理.第3版》 百度云链接 (opens new window)提取码：xkv4 《数据库系统概念 中文第6版》 百度云链接 (opens new window)提取码：fupf 《Nosql数据库入门》 百度云链接 (opens new window)提取码：ll6k 《MySQL5.5从零开始学》 百度云链接 (opens new window)提取码：3u1c 《NoSQL精粹_中文完整版》 百度云链接 (opens new window)提取码：vwcg 《Redis入门指南》 百度云链接 (opens new window)提取码：wcga 《数据库原理、应用与实践（SQL Server）》 百度云链接 (opens new window)提取码：mgw3 操作系统清华大学陈老师 哈工大李治军 《深入理解计算机系统 第3版》 百度云链接 (opens new window)提取码：rqey 《现代操作系统 - 英文版》 百度云链接 (opens new window)提取码：9kvb 《现代操作系统（第三版）中文版》 百度云链接 (opens new window)提取码：qmfc 《30天自制操作系统 (图灵程序设计丛书)》 百度云链接 (opens new window)提取码：vtbf 《操作系统设计与实现》 百度云链接 (opens new window)提取码：fvo8 《操作系统真象还原》 百度云链接 (opens new window)提取码：blrx 《操作系统精髓与设计原理 第8版》 百度云链接 (opens new window)提取码：buzn 《操作系统精髓与设计原理 第9版》 百度云链接 (opens new window)提取码：y7pk 《自己动手写操作系统》 百度云链接 (opens new window)提取码：zzvy 《CMU2017-Lab》 百度云链接 (opens new window)提取码：fabh 《Compilers_ Principles, Techniques, and Tools》 百度云链接 (opens new window)提取码：o3h5 《Computer Systems_ A Programmer’s Perspective》 百度云链接 (opens new window)提取码：p5kp 《Orange’s一个操作系统的实现》 百度云链接 (opens new window)提取码：u6ic 《编译原理》 百度云链接 (opens new window)提取码：8i54 《操作系统概念 - 英文版》 百度云链接 (opens new window)提取码：2rof 《操作系统概念》 百度云链接 (opens new window)提取码：u3by 《操作系统概述 - 公众号资源》 百度云链接 (opens new window)提取码：apgg 《操作系统之哲学原理 第2版》 百度云链接 (opens new window)提取码：xzzn 《分布式系统概念与设计 原书第5版》 百度云链接 (opens new window)提取码：r2wn 《计算机系统要素 - 从零开始构建现代计算机》 百度云链接 (opens new window)提取码：hylp linux韩顺平 一周学会Linux 尚硅谷Linux教程 《Linux 内核设计与实现》 百度云链接 (opens new window)提取码：1f28 《Linux UNIX系统编程手册 - 上》 百度云链接 (opens new window)提取码：htnh 《Linux UNIX系统编程手册 - 下》 百度云链接 (opens new window)提取码：lxd4 《UNIX网络编程卷1：套接字 API》 百度云链接 (opens new window)提取码：3g7h 《UNIX网络编程卷2：进程间通信》 百度云链接 (opens new window)提取码：7anx 《UNIX环境高级编程 第三版》 百度云链接 (opens new window)提取码：eb50 《《UNIX系统编程手册 上》.((德)Michael Kerrisk ).[PDF]@ckook》 百度云链接 (opens new window)提取码：2gkj 《《UNIX系统编程手册 下》.((德)Michael Kerrisk ).[PDF]@ckook》 百度云链接 (opens new window)提取码：wtyp 《Linux宝典》 百度云链接 (opens new window)提取码：225z 《Linux常用命令大全》 百度云链接 (opens new window)提取码：8b4u 《LINUX防火墙（原书第3版）》 百度云链接 (opens new window)提取码：o9md 《Linux高级程序设计中文第三版杨宗德–人电出版社》 百度云链接 (opens new window)提取码：4cms 《Linux环境编程：从应用到内核》 百度云链接 (opens new window)提取码：8v8w 《Linux内核设计与实现 第3版》 百度云链接 (opens new window)提取码：vzmc 《Linux内核完全注释》 百度云链接 (opens new window)提取码：wr95 《Linux系统命令及shell脚本实践指南Linux unix技术丛书》 百度云链接 (opens new window)提取码：gygv 《Unix &amp; Linux 大学教程》 百度云链接 (opens new window)提取码：thfb 《汇编语言基于Linux环境第3版》 百度云链接 (opens new window)提取码：0357 《鸟哥的Linux私房菜基础篇和服务器篇》 百度云链接 (opens new window)提取码：kbpi 《深入Linux内核架构 (图灵程序设计丛书·Linux UNIX系列)》 百度云链接 (opens new window)提取码：6int 《深入理解Linux内核》 百度云链接 (opens new window)提取码：sm3l 《[Linux命令详解词典].施威铭研究室.扫描版》 百度云链接 (opens new window)提取码：oc3u 《Advanced Programming in the UNIX® Environment》 百度云链接 (opens new window)提取码：sm6b 《Harley Hahn’s Guide to UNIX and Linux》 百度云链接 (opens new window)提取码：99c1 《Linux Kernel Development》 百度云链接 (opens new window)提取码：rvnn 《Linux多线程服务端编程 书签高清非扫描 - 陈硕》 百度云链接 (opens new window)提取码：5kq1 《Linux网络编程》 百度云链接 (opens new window)提取码：vdbg 《Linux高性能服务器编程》 百度云链接 (opens new window)提取码：jt32 《Unix-Linux编程实践教程》 百度云链接 (opens new window)提取码：w5p1 《UNIX编程艺术-中文版【The+Art+of+UNIX+Programming】》 百度云链接 (opens new window)提取码：8hhc 设计模式《JavaScript设计模式与开发实践》 《JavaScript设计模式核⼼原理与应⽤实践》 《大话设计模式》 百度云链接 (opens new window)提取码：4o24 《HeadFirst设计模式（中文版）》 百度云链接 (opens new window)提取码：5c3f 《图解设计模式》 百度云链接 (opens new window)提取码：ih0f 《研磨设计模式》 百度云链接 (opens new window)提取码：wafq 《常见设计模式解析与实现 - C++版》 百度云链接 (opens new window)提取码：3q7d 《敏捷开发-设计模式》 百度云链接 (opens new window)提取码：h1xq 《head first design patterns》 百度云链接 (opens new window)提取码：err5 《设计模式之禅（第2版）》 百度云链接 (opens new window)提取码：m68r Git 《Git参考手册-新》 百度云链接 (opens new window)提取码：amrb 《从0开始学习GitHub系列》 百度云链接 (opens new window)提取码：uhcw 《专业git中文》 百度云链接 (opens new window)提取码：4q2z 《Git权威指南》 百度云链接 (opens new window)提取码：yj4c 爬虫崔庆才老师 数学相关 《程序员的数学卷1 - 清晰版》 百度云链接 (opens new window)提取码：4ztn 《程序员的数学卷2 - 概率统计》 百度云链接 (opens new window)提取码：7o4m 《程序员的数学卷3 - 线性统计》 百度云链接 (opens new window)提取码：3kq6 《计算复杂性：现代方法》 百度云链接 (opens new window)提取码：yu3m 《离散数学及其应用》 百度云链接 (opens new window)提取码：gcbx 《数学之美》 百度云链接 (opens new window)提取码：vxqr 《Computational Complexity_ A Modern Approach》 百度云链接 (opens new window)提取码：vq08 《Discrete Mathematics and Its Applications》 百度云链接 (opens new window)提取码：fuox 《Operations Research Applications And Algorithms》 百度云链接 (opens new window)提取码：lrou 《概率论与数理统计 - 陈希孺》 百度云链接 (opens new window)提取码：iks9 程序员软技能 《码农翻身：用故事给技术加点料_刘欣》 百度云链接 (opens new window)提取码：t2di 《奔跑吧，程序员：从零开始打造产品、技术和团队》 百度云链接 (opens new window)提取码：yx4j 《代码大全2中文版》 百度云链接 (opens new window)提取码：0lml 《代码整洁之道》 百度云链接 (opens new window)提取码：3c81 《黑客与画家》 百度云链接 (opens new window)提取码：1i8c 《浪潮之巅（完整版）》 百度云链接 (opens new window)提取码：ikcl 《敏捷软件开发：原则、模式与实践》 百度云链接 (opens new window)提取码：sw72 《重构：改善既有代码的设计（第2版）》 百度云链接 (opens new window)提取码：kbup 《how-to-be-a-programmer-cn》 百度云链接 (opens new window)提取码：ns57 《华为大数据应用开发指南》 百度云链接 (opens new window)提取码：2snr 《华为金融大数据解决方案汇报V2.0》 百度云链接 (opens new window)提取码：s9zi 《人月神话-中文-目录-文字版》 百度云链接 (opens new window)提取码：vumo 《孙金城丨阿里巴巴-Blink SQL关键技术及实现原理》 百度云链接 (opens new window)提取码：6mjd 《程序员健康指南》 百度云链接 (opens new window)提取码：0bxr 《概念与技术（第3版）》 百度云链接 (opens new window)提取码：oolp 《技术之瞳+阿里巴巴技术笔试心得》 百度云链接 (opens new window)提取码：978f 《阿里双十一技术》 百度云链接 (opens new window)提取码：y5dd 《程序开发心理学》 百度云链接 (opens new window)提取码：1a20 《大数据之路：阿里巴巴大数据实践》 百度云链接 (opens new window)提取码：8uvo 《软件工程-实践者的研究方法.8th》 百度云链接 (opens new window)提取码：qb99 工作思维习惯《高效能人士的七个习惯》《万物发明指南——时间旅行者生存手册》 《富有的习惯》 社会商战智商《心计》 天道、青瓷、浮沉、生存法则、黑冰、黑洞、征服、破冰行动 天道原著为《遥远的救世主》 2006年《圈子圈套1》2006年《输赢1》2006年《圈子圈套2》2007年《圈子圈套3》2008年《浮沉1》2009年 《思科九年》2009年《做单》2009年《浮沉2》2010年《纵横》2012年《输赢2》2015年《商战往事》 教育《你就是孩子最好的玩具》《自驱型成长》 《为什么我的青春期孩子不和我说话？》《陪孩子终身成长》《被忽视的孩子》《解码青春期》《不管教的勇气》《原生家庭》《正面管教》《养育男孩》《养育女孩》 法律《忏悔录》《思想录》《申辩篇》《知识分子与社会》《论法的精神》《旧制度与大革命》《近距离看美国》 网盘资源影单《在深夜加油站遇见苏格拉底》","categories":[{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"博客_VuePress","slug":"H_工程热点_博客_VuePress","date":"2022-09-11T23:33:16.000Z","updated":"2023-06-06T23:16:31.434Z","comments":true,"path":"2022/09/12/H_工程热点_博客_VuePress/","link":"","permalink":"https://fuyunjinglong.github.io/2022/09/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%8D%9A%E5%AE%A2_VuePress/","excerpt":"","text":"vuePress官网 快速上手 创建并进入一个新目录 1mkdir vuepress-starter &amp;&amp; cd vuepress-starter 使用你喜欢的包管理器进行初始化 1yarn init # npm init 将 VuePress 安装为本地依赖 我们已经不再推荐全局安装 VuePress 1yarn add -D vuepress # npm install -D vuepress 注意 如果你的现有项目依赖了 webpack 3.x，我们推荐使用 Yarn (opens new window)而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。 创建你的第一篇文档 1mkdir docs &amp;&amp; echo &#x27;# Hello VuePress&#x27; &gt; docs/README.md 在 package.json 中添加一些 scripts(opens new window) 这一步骤是可选的，但我们推荐你完成它。在下文中，我们会默认这些 scripts 已经被添加。 123456&#123; &quot;scripts&quot;: &#123; &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot; &#125;&#125; 在本地启动服务器 1yarn docs:dev # npm run docs:dev vuePress配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980module.exports = &#123; base: &#x27;/&#x27; /* 基础虚拟路径 */, dest: &#x27;dist&#x27; /* 打包文件基础路径, 在命令所在目录下 */, title: &#x27;yuman&#x27;, // 标题 description: &#x27;前端研究院&#x27;, // 标题下的描述 themeConfig: &#123; // 主题配置 // logo: &#x27;/images/logo.png&#x27;, nav: [ &#123; text: &#x27;前端&#x27;, items: [ &#123; text: &#x27;Vue3&#x27;, link: &#x27;C_Vue3.0入门2&#x27; &#125;, ] &#125;, &#123; text: &#x27;学习路线&#x27;, items: [ &#123; text: &#x27;前端&#x27;, link: &#x27;http://www.atguigu.com/web/&#x27; &#125; ] &#125;, ], markdown: &#123; lineNumbers: false // 代码块显示行号 &#125;, sidebar: &#x27;auto&#x27;, // 侧边栏配置 // sidebarDepth: 2, // 侧边栏显示2级 // sidebar: [ // // 左侧导航 // &#x27;00_课程介绍&#x27;, // &#123; // title: &#x27;一.TypeScript快速上手&#x27;, // collapsable: false, // children: [ // &#123; // title: &#x27;初识 TypeScript&#x27;, // 标题 // children: [ // // 下级列表 // &#x27;chapter1/01_初识TS&#x27;, // &#x27;chapter1/02_安装TS&#x27;, // &#x27;chapter1/03_HelloWorld&#x27;, // &#x27;chapter1/04_webpack打包&#x27; // ] // &#125;, // &#123; // title: &#x27;TypeScript 常用语法&#x27;, // children: [&#x27;chapter2/1_type&#x27;, &#x27;chapter2/2_interface&#x27;, &#x27;chapter2/3_class&#x27;, &#x27;chapter2/4_function&#x27;, &#x27;chapter2/5_generic&#x27;, &#x27;chapter2/6_other&#x27;] // &#125; // ] // &#125;, // &#123; // title: &#x27;二.Vue3快速上手&#x27;, // collapsable: false, // children: [&#x27;chapter3/01_认识Vue3&#x27;, &#x27;chapter3/02_创建vue3项目&#x27;] // &#125;, // &#123; // title: &#x27;三.Composition API&#x27;, // collapsable: false, // children: [ // &#x27;chapter4/01_Composition API_常用部分&#x27;, // &#x27;chapter4/02_Composition API_其它部分&#x27;, // &#x27;chapter4/03_手写组合API&#x27;, // &#x27;chapter4/04_Composition VS Option&#x27; // ] // &#125;, // &#123; // title: &#x27;四.其它新组合和API&#x27;, // collapsable: false, // children: [&#x27;chapter5/01_新组件&#x27;, &#x27;chapter5/02_其他新API&#x27;] // &#125;, // &#123; // title: &#x27;五.Vue3综合案例&#x27;, // collapsable: false, // children: [&#x27;chapter6/&#x27;] // &#125;, // &#x27;chapter7/快速搭建在线文档&#x27; // ] &#125;, head: [[&#x27;link&#x27;, &#123; rel: &#x27;shortcut icon&#x27;, type: &#x27;image/x-icon&#x27;, href: `./images/favicon.ico` &#125;]]&#125; 部署Github page 手动部署：本地打包，上传编译后的文件到git仓库 自动部署：借助gh-pages插件，自动上传编译后文件到固定分支 其实这里的原理就是在github上重建一个分支，然后将build后的代码放到这个分支，在访问这个地址的时候就可以正常运行了,我们可以看到有一个gh-pages的分支，里面的内容恰恰就是build后的内容 12#！因为远程仓库一直报错，&#x27;origin&#x27; does not appear to be a git repository#1 所以采用手动上传编译后的文件到vuePressPage仓库 手动部署本地编译 1npm run docs:build 本地代码提交git仓库 1234567git init // 初次初始化git remote add origin git@github.com:fuyunjinglong/fuyunjinglong.github.io.git // 建立远程仓库链接git checkout -b vuePressPage //初次创建分支并拉取分支代码git pull origin vuePressPage // 拉取代码git add . // 提交代表到本地仓git commit -m &#x27;hello&#x27; // 提交代表到本地仓git push -u origin vuePressPage // 推送代码 自动部署到gh-pages分支123456# 下载工具包npm i add -D gh-pages# 执行打包命令npm run doc:build# 执行部署命令npm run doc:deploy","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"Github入门","slug":"D_框架_Github入门","date":"2022-09-05T23:33:16.000Z","updated":"2023-05-20T01:09:37.750Z","comments":true,"path":"2022/09/06/D_框架_Github入门/","link":"","permalink":"https://fuyunjinglong.github.io/2022/09/06/D_%E6%A1%86%E6%9E%B6_Github%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git入门教程 Github入门教程 仓库关系 工作区：用来编辑保存项目文件的地方，也是用户能直接操作到的地方。 暂存区：保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，是一个叫index的文件，通常多数说法还是叫暂存区域； 版本库：也叫本地版本库，之所以说git 快，是因为它是分布式版本控制系统，大部分提交都是对本地仓库而言的，不依赖网络，最后一次会推送的到远程仓库。 主流开发流程代码分支Gitflow工作流(Gitflow Workflow)是2010年由Vincent Driessen在他的一篇博客里提出来的。它定义了一整套完善的基于Git分支模型的框架，结合了版本发布的研发流程，适合管理具有固定发布周期的大型项目。 master 生产主分支,发布到生产环境使用这个分支,由hotfix或者release分支合并过来，不直接提交代码。 develop 主开发分支 , 基于master分支克隆，由feature分支合并过来，一般不直接提交代码。 feature 功能开发分支 , 基于develop分支克隆 , 主要用于新需求新功能的开发，同时存在多个。 release 预发布分支 , 基于feature分支合并到develop之后 , 从develop分支克隆，测试完成后合并到master并打上版本号，同时也合并到develop。 hotfix 补丁分支 , 基于master分支克隆 , 主要用于对线上的版本进行BUG修复,完成后合并到master分支和develop分支。 –no-ff 在这的作用是禁止快进式合并 develop分支管理 123// 从master分支上创建develop分支，并推送到远端git checkout –b developgit push -u origin develop feaeure分支管理 12345678910111213141516171819202122# feaeure分支基于develop创建git checkout -b some-feature develop# 或者, 推送至远程服务器:git push -u origin some-feature # 一波骚操作 git statusgit add .git commit -m &#x27;xx&#x27; git push# 切换develop分支git checkout develop git pull origin develop# 合并到develop分支并pushgit merge --no-ff some-featuregit push origin develop# 删除feature分支(也可以不删除)git branch -d some-featuregit push origin --delete some-feature Release分支管理 123456789101112131415# Release分支基于develop创建git checkout -b some-release develop# ...一波骚操作# 代码发布后合并到master分支并提交git checkout mastergit merge --no-ff some-releasegit tag -a 0.1# 合并到develop分支并提交git checkout git merge --no-ff some-release# 删除release分支git branch -d some-releasegit push origin --delete some-release Hotfix分支管理 123456789101112131415# Hotfix分支基于master创建git checkout -b hotfix-0.1.1 master # ...一波骚操作# 合并到master分支并提交git checkout mastergit merge --no-ff hotfix-0.1.1git tag -a 0.1.1# 合并到develop分支并提交git checkout developgit merge --no-ff hotfix-0.1.1# 删除hotfix分支git branch -d hotfix-0.1git push origin --delete hotfix-0.1.1 代码合并-基操假设有： alias-主分支 alias-zhangsan-某个组员分支 建立新组员分支 建立新分支alias-zhangsan，git checkout -b alias-zhangsan 分支合并拉取 alias-zhangsan先上传代码： git add . git commit -m ‘xx’ git push git checkout alias alias合并分支: git pull(此处可能有冲突，可以先提交当前，再拉取) git merge alias-zhangsan git push git merge和git rebase当前分支状态： a—&gt;b—&gt;c—&gt;d master分支 |—&gt;e—&gt;f dev分支 定义 git merge：会把当前分支和待合入分支commit合并在一起，形成一个新的commit git rebase：会把待合入分支插入到当前分支的最前面，叫做变基。 1.git merge 123456$ git merge master // 合并master分支代码$ git log --graph --oneline // 查看log点线图 * 表示一个commit， 注意不要管*在哪一条主线上 | 表示分支前进 / 表示分叉 \\ 表示合入 执行后变为： 当前分支状态： a—&gt;b——————————g dev分支 |—&gt;e—&gt;f—&gt;c—&gt;d—| 2.git rebase 执行后变为： 当前分支状态： a—&gt;b—&gt;c—&gt;d—&gt;e—&gt;f dev分支 git merge和git rebase的优缺点 git merge 优点：不会破坏原分支的提交记录。 缺点：会产生额外的提交记录，并进行两条分支线的合并。 git rebase 优点：无需新增提交记录到目标分支，reabse后可以直接将对象分支的提交历史加到目标分支上，形成线性提交历史记录，更加直观。 缺点：不能在一个共享分支上进行reabse操作，会带来分支安全问题。 git merge和git rebase的应用场景 合代码到公共分支的时候使用git merge，书写正确规范的merge commits留下记录。 合代码到个人分值的时候使用git rebase，可以不污染分支的历史提交记录，形成简介的线性记录。开源项目代码合并常使用。 参考 一文搞懂 git rebase 【Git】 什么！？都快2023年了还搞不清楚 git rebase 与 git merge Git合并那些事儿 认识几种Merge方法 介绍什么是快进式合并，三方合并，压缩合并 Merge策略（上） 认识Criss-Cross现象，以及Recursive，Ours等策略 Merge策略（下） 认识Octopus和Subtree策略 当冲突发生的时候 讲述冲突发生时，那些你也许不曾知道的事儿 撤销合并 讲述冲各种撤销合并的方法 神奇的Rebase 认识Rebase及其用法，以及什么时候用到它 交互式Rebase 介绍更多有关Rebase的玩法 Rebase的烦恼 通过一个例子来演示Rebase使用不当带来的麻烦 Git工作流面面观 分支模型 Git强大的分支模型，所有Git工作流的基础 集中式工作流 最为基本的一种Git工作流，适合习惯传统版本控制方式的团队 特性分支工作流 非常重要的一种Git工作流，充分发挥分支模型的优势 Gitflow工作流 广泛应用的一种Git工作流，适合管理有固定发布周期的大项目 Forking工作流 开源项目的标准Git工作流，灵活与约束并存的分布式工作流 课程 中文资源 英文资源 《如何使用Hello Git》 视频 视频 《新建本地库》 视频 视频 《添加新文件》 视频 视频 《连接远程库》 视频 视频 《理解暂存》 视频 视频 《恢复到指定版本》 视频 视频 《撤销本地更改》 视频 视频 《删除文件》 视频 视频 《理解分支》 视频 视频 《解决分支冲突》 视频 视频 《利用分支修复bug》 视频 视频 《利用分支开发特性》 视频 视频 《解决多人开发冲突》 视频 视频 《理解rebase》 视频 视频 《管理标签》 视频 视频 《Hello Git Cheat Sheet(小抄)》 查看 给开源项目贡献代码pr问题 对有些项目是可以的，但是对有些项目不行，因为你如果merge了已经fork的仓库，会产生merge commit，你再pull request的时候，源仓库的管理人员会退回你的request，因为他们想要保持git history干净整洁，你应该用git rebase自己的分支，这样你提交上去后人家才愿意合并（前提是你的改动是已经被接纳）。可以看看github的help页面有详细解释。 贡献代码步骤 fork开源项目 创建新分支：git checkout -b new-user-contribution，git add.,git commit,git push 提交pr 参考 开源指北-科普 常用命令git命令详解 Git 的 4 个阶段的撤销更改 惊艳！小姐姐用动画图解 Git 的 10 大命令，这也太秀了吧！ git最常用命令1234567891011121314git init // 初始化git add . // 提交代表到本地仓git commit -m &#x27;hello&#x27; // 提交代表到本地仓git branch -M main // 重命名分支git remote add origin git@github.com:fuyunjinglong/fuyunjinglong.github.io.git // 建立远程仓库链接git pull origin master // 拉取代码git push -u origin master // 推送代码git checkout -b newBranch //创建并切换到新分支git reset --hard 97ea0f9 //回退并删除提交记录git revert -n 97ea0f9 // 回退但不删除提交记录如果你在开发着业务，突然另一个分支有一个bug要改，你怎么办git stash //将本次修改存到暂存区（紧急切换分支时）git stash pop //将所有暂存区的内容取出来 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]# 建立远程仓库链接$ git remote add origin git@github.com:fuyunjinglong/fuyunjinglong.github.io.git 配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加 / 删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop Github仓库使用git拉取远程代码12345678git initgit add .git commit -m &#x27;h&#x27;git remote add origin git@github.com:fuyunjinglong/fuyunjinglong.github.io.gitgit pull origin maingit checkout -b vue2-zhufenggit checkout vue2-zhufenggit push origin vue2-zhufeng 建立github远程仓库和本地仓库连接创建远程仓库及SSH秘钥 创建个人仓库 注意：仓库名称必须为&lt;username&gt;.github.io，其中username是GitHub的用户名即图中Owner所对应的。 初始化git 进入到博客文件夹运行git init 123456$ git config --global user.name fuyunjinglong$ git config --global user.email 806435328@qq.com# 可以用以下两条命令检查是否输入正确$ git config –global user.name$ git config –global user.email 配置SSH密钥 创建SSH密钥，输入如下命令，根据提示输入三次回车（email为GitHub邮箱）： 1ssh-keygen -t rsa -C &lt;email&gt; 完成后会生成一幅圈圈星星图，这个时候就已经生成了.ssh的文件夹，文件一般位于用户文件夹下，即C:\\Users\\&lt;Administrator&gt;\\.ssh，其中&lt;Administrator&gt;为Windows用户名。文件夹内容如下： id_rsa，私钥。 id_rsa.pub，公钥。 known_hosts，顾名思义，此文件保存着**其他主机远程登陆本机**的信息。 先将公钥文件id_rsa.pub以记事本方式打开，复制全部信息到剪切板。 然后在GitHub主页的设置Settings（不是仓库的设置）中，页面左侧找到SSH and GPG keys的设置选项，点击右上角New SSH key，把复制的id_rsa.pub内容粘贴到Key中，写个标题，点击Add SSH key即可。 回到命令行输入如下命令，查看是否成功： 123$ ssh -T git@github.com# 最后一行输出如下信息即为成功# Hi hwame! You&#x27;ve successfully authenticated... GitHub Pages免费站点创建站点官方说明 配置发布源在对应fuyunjinglong.github.io仓库里，打开setting-&gt;pages-&gt;branch，指定分支和目录层级。 保存后，访问https://fuyunjinglong.github.io/即可访问该仓库的指定分支的指定目录层级的index.html","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"Vue3.0_框架搭建","slug":"D_框架_Vue3.0_框架搭建","date":"2022-06-25T23:33:16.000Z","updated":"2024-03-07T14:52:31.112Z","comments":true,"path":"2022/06/26/D_框架_Vue3.0_框架搭建/","link":"","permalink":"https://fuyunjinglong.github.io/2022/06/26/D_%E6%A1%86%E6%9E%B6_Vue3.0_%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Vue3模板及目录 从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境 模板工具： 编程语言：TypeScript 4.x 、JavaScript 前端框架：Vue 3.x 构建工具：Vite 2.x UI 框架：Element Plus 图标工具：icones CSS预编译：Sass CSS框架：Windi CSS HTTP工具：Axios 路由管理：Vue Router 4.x 状态管理：Pinia 代码规范：EditorConifg、Prettier、ESLint、Airbnb JavaScript Style Guide 提交规范：husky、Commitlint 、lint-staged 实现自动按需加载（**墙裂推荐）：unplugin-auto-import、unplugin-vue-components、unplugin-icons** 实现 SVG图标 的组件化：vite-svg-loader 让各种 API 支持响应式：VueUse 让加载页面时有所反馈：NProgress 支持 markdown：vite-plugin-md vetur -&gt; volar:对于 vue3 的支持，vetur 很明显的不如 volar，这边建议小伙伴们禁用vuetur而使用volor 单元测试：vue-test-utils + jest + vue-jest + ts-jest 自动部署：GitHub Actions 模板代码目录结构： 1234567891011121314151617181920├── publish/└── src/ ├── assets/ // 静态资源目录(js,css,img) ├── common/ // 通用类库目录 ├── components/ // 公共组件目录 ├── router/ // 路由配置目录 ├── store/ // 状态管理目录 ├── style/ // 通用 CSS 目录 ├── utils/ // 工具函数目录 ├── api/ // http接口配置 ├── layout/ // 项目的布局 ├── views/ // 页面组件目录 ├── App.vue ├── main.ts ├── shims-vue.d.ts├── tests/ // 单元测试目录├── index.html├── tsconfig.json // TypeScript 配置文件├── vite.config.ts // Vite 配置文件└── package.json 环境搭建-vue3+vite+ts(大崔哥)创建基本模板 1npm create vite@latest my-vue-app --template vue-ts 安装jest 1npm i jest -D 配置package.json 123&quot;scripts&quot;: &#123; &quot;test:unit&quot;: &quot;jest&quot; &#125;, 编写第一个测试用例 test/unit/index.spec.js 123test(&quot;1+1=2&quot;, () =&gt; &#123; expect(1 + 1).toBe(2);&#125;); 执行单元测试命令 1npm run test:unit 使用vite初始化1npm init @vitejs/app 安装常用依赖包(router,element-plus,axios) 1npm i vue-router@next element-plus axios -S 安装自动按需引入包最佳实践：按需引入 1npm i unplugin-vue-components unplugin-auto-import -D vite.config.js配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;;import Components from &#x27;unplugin-vue-components/vite&#x27;;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;;import &#123; join &#125; from &#x27;path&#x27;;import eslintPlugin from &#x27;vite-plugin-eslint&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: join(__dirname, &#x27;src&#x27;), &#125;, &#125;, plugins: [ vue(), AutoImport(&#123; // 自动引入ref,computed等钩子 imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;pinia&#x27;], // 第三方组件库的解析器 resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), eslintPlugin(&#123; // 配置 cache: false, // 禁用 eslint 缓存 &#125;), ], // 静态资源服务的文件夹 publicDir: &#x27;public&#x27;, base: &#x27;./&#x27;, // 本地运行配置，以及反向代理配置 server: &#123; host: &#x27;localhost.huawei.com&#x27;, port: 8082, strictPort: false, // 设为true时端口被占用则直接退出，不会尝试下一个可用端口 cors: true, // 为开发服务器配置 CORS , 默认启用并允许任何源 open: true, // 服务启动时自动在浏览器中打开应用, // 反向代理配置 // proxy: &#123; // &quot;/api&quot;: &#123; // target: &quot;https://xxxx.com/&quot;, // changeOrigin: true, // rewrite: (path) =&gt; path.replace(/^\\/api/, &quot;&quot;), // &#125;, // &#125;, &#125;, build: &#123; // 指定输出路径 outDir: &#x27;Vue3New2&#x27;, // 生成静态资源的存放路径 assetsDir: &#x27;assets&#x27;, // 小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 0 可以完全禁用此项 assetsInlineLimit: 4096, // 构建后是否生成 source map 文件 sourcemap: true, &#125;,&#125;); App.vue 1234567&lt;el-config-provider :locale=&quot;locale&quot;&gt; &lt;HelloWorld msg=&quot;Hello Vue 3 + TypeScript + Vite&quot; /&gt; &lt;/el-config-provider&gt;//国际化 import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;import en from &#x27;element-plus/es/locale/lang/en&#x27;const locale =en 配置router4创建src/router/index.js 12345678910111213141516import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;const he = ()=&gt;import(&#x27;@/components/HelloWorld.vue&#x27;)export default createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, component: he &#125;, &#123; path: &#x27;/he&#x27;, component: he &#125;, ]&#125;) main.js 123456import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;;const Vue = createApp(App)Vue.use(router)Vue.mount(&#x27;#app&#x27;) 配置axios123// 调用httpimport &#123; httpAxios, Api &#125; from &#x27;@/fetch&#x27;;httpAxios(&#x27;get&#x27;,&#x27;http://www.baidu.com&#x27;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// /api.axios.jsimport axios, &#123; isCancel &#125; from &#x27;axios&#x27;;import &#123; randomNum &#125; from &#x27;@/utils&#x27;;import &#123; useComStore &#125; from &#x27;@/store&#x27;;const instance = axios.create(&#123; timeout: 60000, // 设置超时 withCredentials: true, // 跨域携带cookie&#125;);instance.interceptors.request.use( (config) =&gt; &#123; if (config) &#123; const &#123; lang, userno, uniteCode &#125; = useComStore(); // 获取vuex参数 &#125; // url上面加上随机数 防止缓存 config.url = config.url.indexOf(&#x27;?&#x27;) !== -1 ? `$&#123;config.url&#125;&amp;k=$&#123;randomNum()&#125;` : `$&#123;config.url&#125;?k=$&#123;randomNum()&#125;`; return config; &#125;, (error) =&gt; &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 请求拦截器instance.interceptors.response.use( (response) =&gt; &#123; const &#123; data, config &#125; = response; // 用户登录cookie过期，跳转登录页面 if (String(data.code) === &#x27;403&#x27;) &#123; if (typeof window.publicNavBarModelNew.bindEvent.loginPage === &#x27;function&#x27;) &#123; // 新版本导航头跳转登录 window.publicNavBarModelNew.bindEvent.loginPage.call(window.publicNavBarModelNew); &#125; else &#123; // 旧版本导航头跳转登录 window.publicNavBarModelNew.bindEvent.logoutDo(); &#125; return Promise.reject(new Error(0)); &#125; // 导出文件 if (config.type === &#x27;file&#x27;) &#123; return response; // 导出文件需要整个响应data &#125; return data; // 返回响应数据 &#125;, (error) =&gt; &#123; // 对响应错误做点什么 if (isCancel(error)) &#123; return new Promise(() =&gt; &#123; // 取消请求的时候中断promise &#125;); &#125; // 拦截器报错 return Promise.reject(error); &#125;);// 请求方法const httpAxios = function (method, url, data = null, config = &#123;&#125;) &#123; method = method.toLowerCase(); if (method === &#x27;post&#x27;) &#123; // post请求 return instance.post(url, data, config); &#125; if (method === &#x27;get&#x27;) &#123; // get请求 return instance.get(url, &#123; params: data, ...config &#125;); &#125; if (method === &#x27;delete&#x27;) &#123; // delete请求 return instance.delete(url, &#123; params: data, ...config, &#125;); &#125; if (method === &#x27;put&#x27;) &#123; // put请求 return instance.put(url, data, config); &#125; return false;&#125;;// 导出请求方法export default httpAxios; 安装piniapinia没有module概念，全是扁平结构 1npm install pinia@next 创建store/index.js 1234567891011121314151617181920import &#123; defineStore &#125; from &quot;pinia&quot;;export const useComStore = defineStore(&#123; id: &quot;com&quot;, state: () =&gt; (&#123; counter: 1, name: &quot;Eduardo&quot;, &#125;), getters: &#123; doubleCount: (state) =&gt; state.counter * 2, &#125;, actions: &#123; setCounter(val) &#123; this.counter = val; &#125;, resetCounter(param) &#123; this.counter = this.counter * param; &#125;, &#125;,&#125;); main.ts 12345678import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;;import &#123; createPinia &#125; from &#x27;pinia&#x27;const Vue = createApp(App)Vue.use(router)Vue.use(createPinia())Vue.mount(&#x27;#app&#x27;) 使用pinia 123456789101112131415&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; useComStore &#125; from &#x27;@/store&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;//action可以直接通过comStore使用const comStore = useComStore()const &#123;counter,doubleCount &#125; = storeToRefs(comStore)cosnt &#123;setCounter&#125; = comStoredefineProps&lt;&#123; msg: string &#125;&gt;()&lt;/script&gt;&lt;template&gt; &lt;h1 @click=&quot;setCounter(8)&quot;&gt;设置counter参数&#123;&#123;counter&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;doubleCount&#125;&#125;&lt;/h2&gt;&lt;/template&gt; Vue3工程里使用Vue2生命周期 12345678910&lt;script lang=&quot;ts&quot;&gt;export default &#123; computed: &#123; ...mapState(useComStore, [&#x27;counter&#x27;, &#x27;doubleCount&#x27;]), &#125;, methods: &#123; ...mapActions(useComStore, [&#x27;setCounter&#x27;]), &#125;,&#125;;&lt;/script&gt; 安装Echart1npm install echarts --save 使用echart 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref,onMounted &#125; from &#x27;vue&#x27;import &#123; useComStore &#125; from &#x27;@/store&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import * as echarts from &#x27;echarts&#x27;const comStore = useComStore()const &#123;counter,doubleCount &#125; = storeToRefs(comStore)defineProps&lt;&#123; msg: string &#125;&gt;()const value = ref(new Date())const width = &#x27;800px&#x27;const height = &#x27;400px&#x27;onMounted(()=&gt;&#123; let myChart = echarts.init(document.getElementById(&quot;myChart&quot;)); // 绘制图表 myChart.setOption(&#123; tooltip: &#123;&#125;, xAxis: &#123; data: [&#x27;衬衫&#x27;, &#x27;羊毛衫&#x27;, &#x27;雪纺衫&#x27;, &#x27;裤子&#x27;, &#x27;高跟鞋&#x27;, &#x27;袜子&#x27;] &#125;, yAxis: &#123;&#125;, series: [ &#123; name: &quot;销量&quot;, type: &quot;bar&quot;, data: [5, 20, 36, 10, 10, 20, 20, 36, 10, 10, 20], &#125;, ] &#125;);&#125;)&lt;/script&gt;&lt;template&gt; &lt;h1 @click=&quot;comStore.setCounter(8)&quot;&gt;设置counter参数&#123;&#123;counter&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;doubleCount&#125;&#125;&lt;/h2&gt;----------------------------------- &lt;el-calendar v-model=&quot;value&quot; /&gt; &lt;div id=&quot;myChart&quot; :style=&quot;&#123; width: width, height: height &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 安装CSS 预编译器 Stylus/Sass/Less12345678npm i sass -D# ornpm i stylus -Dnpm i less -D// 使用&lt;style lang=&quot;scss&quot;&gt; ...&lt;/style&gt; 引入Eslint和Prettier 网最全的讲清eslint和prettier关系的视频 通用引入Eslint安装全局eslint 1npm i eslint -g 执行eslint初始化，自动创建.eslintrc.js文件 1npx eslint --init 12345678910111213141516171819module.exports = &#123; env: &#123; browser: true, es2021: true, &#125;, //解决eslint和prettier冲突，优先prettier extends: [&#x27;eslint:recommended&#x27;, &#x27;standard&#x27;, &#x27;plugin:prettier/recommended&#x27;], parserOptions: &#123; ecmaVersion: &#x27;latest&#x27;, &#125;, plugins: [], rules: &#123; //0是忽略，1是警告，2是报错 quotes: 1, // 每行末尾添加分号 semi: 2, &#x27;no-console&#x27;: 0, &#125;,&#125;; 通用引入Prettier1npm i prettier -D 手动创建.prettierrc.js文件 1234567891011//.prettierrc.js文件,0是忽略，1是警告，2是报错module.exports = &#123; // 每行末尾添加分号 semi: true, // 使用双引号 singleQuote: true, &#x27;no-console&#x27;: 2, printWidth: 200, //单行长度 tabWidth: 2, //缩进长度 endOfLine: &#x27;auto&#x27;, //不让prettier检测文件每行结束的格式&#125;; 通用Eslint和Prettier冲突问题安装插件完美解决两者冲突 1npm i eslint-config-prettier eslint-plugin-prettier -D .eslintrc.js配置 12//解决eslint和prettier冲突，优先prettier extends: [&#x27;eslint:recommended&#x27;, &#x27;standard&#x27;, &#x27;plugin:prettier/recommended&#x27;], VScode自动修复代码一定安装vscode的eslint和prettier插件，使用eslint检查规则，并使用prettier自动修复。每次修改完规则后，都需要重启vscode才会生效 setting.json 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;files.associations&quot;: &#123; &quot;*.vue&quot;: &quot;vue&quot;, &quot;*.wpy&quot;: &quot;vue&quot;, &quot;*.wxml&quot;: &quot;html&quot;, &quot;*.wxss&quot;: &quot;css&quot; &#125;, &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, &quot;git.enableSmartCommit&quot;: true, &quot;git.autofetch&quot;: true, &quot;emmet.triggerExpansionOnTab&quot;: true, &quot;emmet.showAbbreviationSuggestions&quot;: true, &quot;emmet.showExpandedAbbreviation&quot;: &quot;always&quot;, &quot;emmet.includeLanguages&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot;, &quot;wpy&quot;: &quot;html&quot; &#125;, //主题颜色 //&quot;workbench.colorTheme&quot;: &quot;Monokai&quot;, &quot;git.confirmSync&quot;: false, &quot;explorer.confirmDelete&quot;: false, &quot;editor.fontSize&quot;: 16, &quot;editor.wordWrap&quot;: &quot;on&quot;, &quot;editor.detectIndentation&quot;: false, // 重新设定tabsize &quot;editor.tabSize&quot;: 2, //失去焦点后自动保存 // &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, // #值设置为true时，每次保存的时候自动格式化； &quot;editor.formatOnSave&quot;: true, //每120行就显示一条线 &quot;editor.rulers&quot;: [], // 在使用搜索功能时，将这些文件夹/文件排除在外 &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/target&quot;: true, &quot;**/logs&quot;: true &#125;, &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; // 默认格式化工具选择prettier&#125; Vue3引入规则检查插件引入eslint12npx eslint --init默认引入ts文件，注意不要安装三个ts的依赖库，最好手动安装 1npm i eslint-plugin-vue@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D 1234567package.json配置&#123; &quot;scripts&quot;:&#123; // lint当前项目中的文件并且开启自动修复 &quot;lint&quot;: &quot;eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix&quot;, &#125;&#125; .eslint.js配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module.exports = &#123; globals: &#123; defineProps: &#x27;readonly&#x27;, &#125;, // 设置我们的运行环境为浏览器 + es2021 + node ,否则eslint在遇到 Promise，window等全局对象时会报错 env: &#123; browser: true, es2021: true, node: true, // 开启setup语法糖环境 &#x27;vue/setup-compiler-macros&#x27;: true, &#125;, // 新增，解析vue文件 parser: &#x27;vue-eslint-parser&#x27;, // 继承eslint推荐的规则集，vue基本的规则集，typescript的规则集 extends: [ &#x27;eslint:recommended&#x27;, // &quot;plugin:vue/essential&quot;, // 使用vue3的规则集 &#x27;plugin:vue/vue3-recommended&#x27;, // 使用airbnb规则集 &#x27;airbnb-base&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27;, ], // 支持ts的最新语法 parserOptions: &#123; ecmaVersion: 13, // 解析vue文件中&lt;script&gt;标签中的代码 parser: &#x27;@typescript-eslint/parser&#x27;, sourceType: &#x27;module&#x27;, &#125;, // 添加vue和@typescript-eslint插件，增强eslint的能力 plugins: [&#x27;vue&#x27;, &#x27;@typescript-eslint&#x27;], rules: &#123; // 解决Unable to resolve path to module报错，eslint不识别vite别名 &#x27;import/no-unresolved&#x27;: &#x27;off&#x27;, &#x27;import/extensions&#x27;: &#x27;off&#x27;, &#x27;import/no-absolute-path&#x27;: &#x27;off&#x27;, &#x27;import/no-extraneous-dependencies&#x27;: &#x27;off&#x27;, &#x27;no-param-reassign&#x27;: 0, &#x27;no-console&#x27;: 0, &#x27;import/prefer-default-export&#x27;: 0, // 强制导出必须有default &#x27;import/no-mutable-exports&#x27;: 0, // 强制导出为常量 &#x27;@typescript-eslint/no-this-alias&#x27;: 0, // eslint 为了防止this变量和局部变量混淆 &#x27;prefer-rest-params&#x27;: 0, // 永远不要定义一个参数为 arguments &#x27;no-unused-expressions&#x27;: 0, // 期待是一个函数，而不是表达式 &#x27;prefer-const&#x27;: 0, // 优先使用const申明 &#x27;global-require&#x27;: 0, // 防止require引入资源报错 &#x27;no-debugger&#x27;: 0, &#x27;vue/no-multiple-template-root&#x27;: 0, // 关闭唯一根元素提示 &#125;,&#125;; vite热启动自动进行eslint检测 1npm i vite-plugin-eslint --dev 配置vite.config.js 12345678910...import eslintPlugin from &#x27;vite-plugin-eslint&#x27;... plugins: [ ... eslintPlugin(&#123; // 配置 cache: false // 禁用 eslint 缓存 &#125;) ] 引入airbnb12// npm version &gt; 5npx install-peerdeps --dev eslint-config-airbnb-base 1234567// .eslintrc.js...extends: [ &#x27;plugin:vue/vue3-recommended&#x27;, &#x27;airbnb-base&#x27;, // ++],... 引入@别名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;;import Components from &#x27;unplugin-vue-components/vite&#x27;;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;;import &#123; join &#125; from &#x27;path&#x27;;import eslintPlugin from &#x27;vite-plugin-eslint&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: join(__dirname, &#x27;src&#x27;), &#125;, &#125;, plugins: [ vue(), AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), eslintPlugin(&#123; // 配置 cache: false, // 禁用 eslint 缓存 &#125;), ], //静态资源服务的文件夹 publicDir: &#x27;public&#x27;, base: &#x27;./&#x27;, //本地运行配置，以及反向代理配置 server: &#123; host: &#x27;localhost&#x27;, port: 8082, strictPort: false, //设为true时端口被占用则直接退出，不会尝试下一个可用端口 cors: true, //为开发服务器配置 CORS , 默认启用并允许任何源 open: true, //服务启动时自动在浏览器中打开应用, // 反向代理配置 // proxy: &#123; // &quot;/api&quot;: &#123; // target: &quot;https://xxxx.com/&quot;, // changeOrigin: true, // rewrite: (path) =&gt; path.replace(/^\\/api/, &quot;&quot;), // &#125;, // &#125;, &#125;, build: &#123; //指定输出路径 outDir: &#x27;Vue3New2&#x27;, //生成静态资源的存放路径 assetsDir: &#x27;assets&#x27;, //小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 0 可以完全禁用此项 assetsInlineLimit: 4096, //构建后是否生成 source map 文件 sourcemap: true, &#125;,&#125;); 12345678910// .eslint.jsrules: &#123; // 解决Unable to resolve path to module报错，eslint不识别vite的@别名 &#x27;import/no-unresolved&#x27;: &#x27;off&#x27;, &#x27;import/extensions&#x27;: &#x27;off&#x27;, &#x27;import/no-absolute-path&#x27;: &#x27;off&#x27;, &#x27;import/no-extraneous-dependencies&#x27;: &#x27;off&#x27;, &#x27;no-param-reassign&#x27;: 0, &#x27;no-console&#x27;: 0, &#125; 12345678910// tsconfig.json&quot;compilerOptions&quot;: &#123; //ts文件支持别名,防止ts编译报错 &quot;noImplicitThis&quot;: false, // js/ts 混用时设为false &quot;experimentalDecorators&quot;: true,//部分使用esbuild转化，部分使用官方typescript转化 &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125; 引入Prettier同前面的通用引入Prettier 1234567891011//.prettierrc.js文件,0是忽略，1是警告，2是报错module.exports = &#123; // 每行末尾添加分号 semi: true, // 使用双引号 singleQuote: true, &#x27;no-console&#x27;: 2, printWidth: 200, //单行长度 tabWidth: 2, //缩进长度 endOfLine: &#x27;auto&#x27;, //不让prettier检测文件每行结束的格式&#125;; Hellow.vue 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script setup lang=&quot;ts&quot;&gt;import * as echarts from &#x27;echarts&#x27;;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import &#123; useComStore &#125; from &#x27;@/store&#x27;;const comStore = useComStore();const &#123; counter, doubleCount &#125; = storeToRefs(comStore);defineProps&lt;&#123; msg: string &#125;&gt;();const value = ref(new Date());const width = &#x27;800px&#x27;;const height = &#x27;400px&#x27;;onMounted(() =&gt; &#123; let myChart = echarts.init(document.getElementById(&#x27;myChart&#x27;)); // 绘制图表 myChart.setOption(&#123; tooltip: &#123;&#125;, xAxis: &#123; data: [&#x27;衬衫&#x27;, &#x27;羊毛衫&#x27;, &#x27;雪纺衫&#x27;, &#x27;裤子&#x27;, &#x27;高跟鞋&#x27;, &#x27;袜子&#x27;], &#125;, yAxis: &#123;&#125;, series: [ &#123; name: &#x27;销量&#x27;, type: &#x27;bar&#x27;, data: [5, 20, 36, 10, 10, 20, 20, 36, 10, 10, 20], &#125;, ], &#125;);&#125;);&lt;/script&gt;&lt;template&gt; &lt;h1 @click=&quot;comStore.setCounter(8)&quot;&gt;设置counter参数&#123;&#123; counter &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; doubleCount &#125;&#125;&lt;/h2&gt; ----------------------------------- &lt;el-calendar v-model=&quot;value&quot; /&gt; &lt;div id=&quot;myChart&quot; :style=&quot;&#123; width: width, height: height &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 最终package.json12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;name&quot;: &quot;vue3new2&quot;, &quot;private&quot;: true, &quot;version&quot;: &quot;0.0.0&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot;, &quot;lint&quot;: &quot;eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;^0.27.2&quot;, &quot;echarts&quot;: &quot;^5.3.3&quot;, &quot;element-plus&quot;: &quot;^2.2.6&quot;, &quot;pinia&quot;: &quot;^2.0.0-rc.10&quot;, &quot;vite-plugin-eslint&quot;: &quot;^1.6.1&quot;, &quot;vue&quot;: &quot;^3.2.25&quot;, &quot;vue-router&quot;: &quot;^4.0.13&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^5.30.6&quot;, &quot;@typescript-eslint/parser&quot;: &quot;^5.30.6&quot;, &quot;@vitejs/plugin-vue&quot;: &quot;^2.3.3&quot;, &quot;eslint&quot;: &quot;^8.2.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^15.0.0&quot;, &quot;eslint-config-prettier&quot;: &quot;^8.5.0&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.25.2&quot;, &quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;^9.2.0&quot;, &quot;prettier&quot;: &quot;^2.7.1&quot;, &quot;sass&quot;: &quot;^1.54.0&quot;, &quot;typescript&quot;: &quot;^4.7.3&quot;, &quot;unplugin-auto-import&quot;: &quot;^0.9.2&quot;, &quot;unplugin-vue-components&quot;: &quot;^0.20.1&quot;, &quot;vite&quot;: &quot;^2.9.9&quot;, &quot;vite-plugin-windicss&quot;: &quot;^1.8.7&quot;, &quot;vue-tsc&quot;: &quot;^0.34.7&quot;, &quot;windicss&quot;: &quot;^3.5.6&quot; &#125;&#125;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"Vue3.0_入门","slug":"D_框架_Vue3.0_入门","date":"2022-06-25T23:33:16.000Z","updated":"2024-03-31T02:45:30.673Z","comments":true,"path":"2022/06/26/D_框架_Vue3.0_入门/","link":"","permalink":"https://fuyunjinglong.github.io/2022/06/26/D_%E6%A1%86%E6%9E%B6_Vue3.0_%E5%85%A5%E9%97%A8/","excerpt":"","text":"Vue 是一套用于构建用户界面的渐进式框架。Vue.js 3.0 “One Piece” 正式版在 2020 年 9 月份发布,经过了 2 年多开发, 100+位贡献者, 2600+次提交, 600+次 PR，同时 Vue3 也支持 Vue2 的大多数特性,且,更好的支持了 TypeScript,也增加了很多的新特性,如:Composition API,新组件(Fragment/Teleport/Suspense)等等. 入门认识 Vue31) 了解相关信息 Vue.js 3.0 “One Piece” 正式版在今年 9 月份发布 2 年多开发, 100+位贡献者, 2600+次提交, 600+次 PR Vue3 支持 vue2 的大多数特性 更好的支持 Typescript 2) 性能提升 打包大小减少 41% 初次渲染快 55%, 更新渲染快 133% 内存减少 54% 使用 Proxy 代替 defineProperty 实现数据响应式 重写虚拟 DOM 的实现和 Tree-Shaking 3) 新增特性 Composition (组合) API setup ref 和 reactive computed 和 watch 新的生命周期函数 provide 与 inject … 新组件 Fragment - 文档碎片 Teleport - 瞬移组件的位置 Suspense - 异步加载组件的 loading 界面 其它 API 更新 全局 API 的修改 将原来的全局 API 转移到应用对象 模板语法变化 创建 vue3 项目1) 使用 vue-cli 创建 文档指南 123456## 安装或者升级npm install -g @vue/cli## 保证 vue cli 版本在 4.5.0 以上vue --version## 创建项目vue create my-project 2) 使用 vite 创建 文档指南: vite 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发， 它做到了**本地快速开发启动**, 在生产环境下基于 Rollup 打包。 快速的冷启动，不需要等待打包操作； 即时的热模块更新，替换性能和模块数量的解耦让更新飞起； 真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。 1234npm init vite-app &lt;project-name&gt;cd &lt;project-name&gt;npm installnpm run dev Vue3手摸手一站式实战视频 相关库名称 在线地址 🔗 Vue 3.0 实战星座物语 H5 项目 在线地址 Vue 3.0 UI 组件库开发 在线地址 Vue 3.0 + Vite 手册阅读 在线地址 Vue 3.0 入门之项目搭建（杨村长） 在线地址 Vue 3.0 入门（技术胖） 在线地址 Vite 2.0 插件开发指南 在线地址 Vue 3.0 + Vite 2.0 快速搭建 Electron 应用 在线地址 教程文章 比如发布一些 Vue3 的教程： 我要成为海贼王的男人-Vue3最全宇宙入口 Vue3+TS快速上手-尚硅谷-video Vue3+TS快速上手-尚硅谷 Vite + Vue3 + Pinia + 实战项目 + TypeScript-小鹿线-video 📺 VueMastery原版 📺 然叔与杨村长的深度解读 🔥 39岁的夺路狂奔| 掘金年度征文 98赞 🔥 Element3开发内幕 - Vue CLI插件开发 167赞 🔥 天天造轮子系列 500+ 赞 🔥 Vue3.0全球发布会干货总结 267赞 《Vue 3.0 来了，我们该做些什么？》 《Vue3实战系列：结合 Ant-Design-of-Vue 实践 Composition API》 《Vue3 来了，Vue3 开源商城项目重构计划正式启动！》 《Vue3实战系列：Vue3.0 + Vant3.0 搭建种子项目》 《🎉🎉一个基于 Vue 3 + Vant 3 的开源商城项目🎉🎉》 《Vue3教程：用 Vue3 开发小程序，这里有一份实践代码！》 《Vue3教程：Vue 3.x 快在哪里？》 《Vue3教程：开发一个 Vue 3 + element-plus 的后台管理系统》 《🎉🎉Vue 3 + Element Plus + Vite 2 的后台管理系统开源啦🎉🎉》 程序员的副业：写了一个专栏《Vue 3企业级项目实战》 心脏跳动团队-商城 vue3保姆级教程Vue.js前端 Vue3.0 新特性以及使用经验总结 焕然一新的 Vue 3 中文文档要来了 Vue 3.0 生态 相关库名称 在线地址 🔗 Vue 3.0 官方文档(英文) 在线地址 Vue 3.0 中文文档 在线地址 国内加速版 Composition-API手册 在线地址 Vue 3.0 源码学习 在线地址 Vue-Router 官方文档 在线地址 Vuex 4.0 Github vue-devtools Github(Vue3.0 需要使用最新版本) Vite 源码学习 线上地址 Vite 2.0 中文文档 线上地址 Vue3 新动态 线上地址 Element-plus Vue 3.0 + Vite 2.0 + Vue-Router 4.0 + Element-Plus + Echarts 5.0 + Axios 开发的后台管理系统 ⭐ ： 419 Vue3.0+TypeScript+NodeJS+MySql编写的一套后台管理系统 ⭐ ： 262 Ant Design of Vue AntdV后台管理系统 ⭐ ： 2.8k vue3.x + ant-design-vue（beta 版本，免费商用，支持 PC、平板、手机） ⭐ ： 8.2k 基于 Vue3.0 + Vite + Ant Design Vue ⭐ ： 74 Vant newbee-mall Vue3 版本⭐ ： 1.7k 高仿微信记账本 ⭐ ： 48 仿京东淘宝电商 ⭐ ： 319 进阶 composition-api 文档 Vue3的8种组件通信 五大API-全局API全局API —— 全局会用到的API createApp()：创建一个应用实例 createSSRApp()：以SSR 激活的模式，来创建一个应用实例 app.mount()：将应用实例挂载到一个容器元素中 app.unmount()：卸载一个已挂载的应用实例 app.component()：如果传递的是一个字符串类型的组件名及其定义，则注册一个全局组件 app.directive()：如果同时传递一个名字和一个指令，那么将注册一个全局指令 app.use()：安装一个插件 app.mixin()：应用一个全局的组件mixin。(如果要进行逻辑复用的话，那么推荐使用组合式函数来替代) app.config.globalProperties：用于注册“能够被应用内所有组件实例所访问到的全局属性”的对象 nextTick()：用来等待下一次DOM更新和刷新 defineComponent()：在定义vue组件时，提供【类型推导】的辅助函数 defineAsyncComponent()：用来定义一个异步组件，当用了这个函数时，组件在运行时是懒加载的 五大API-组合式API组合式API —— vue3所拥有的组合式API setup 新的 option, 所有的组合 API 函数都在此使用, 只在初始化时执行一次 函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用 setup 细节 setup 执行的时机 在 beforeCreate 之前执行(一次), 此时组件对象还没有创建 this 是 undefined, 不能通过 this 来访问 data/computed/methods / props 其实所有的 composition API 相关回调函数中也都不可以 setup 的返回值 一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法 返回对象中的属性会与 data 函数返回对象的属性合并成为组件对象的属性 返回对象中的方法会与 methods 中的方法合并成功组件对象的方法 如果有重名, setup 优先 注意: 一般不要混合使用: methods 中可以访问 setup 提供的属性和方法, 但在 setup 方法中不能访问 data 和 methods setup 不能是一个 async 函数: 因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性数据 setup 的参数 setup(props, context) / setup(props, {attrs, slots, emit}) props: 包含 props 配置声明且传入了的所有属性的对象 attrs: 包含没有在 props 配置中声明的属性的对象, 相当于 this.$attrs slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots emit: 用来分发自定义事件的函数, 相当于 this.$emit 1234567891011121314151617181920212223242526&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;p&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;fn(&#x27;--&#x27;)&quot;&gt;更新&lt;/button&gt; &lt;child :msg=&quot;msg&quot; msg2=&quot;cba&quot; @fn=&quot;fn&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;import child from &#x27;./child.vue&#x27;export default &#123; components: &#123; child &#125;, setup() &#123; const msg = ref(&#x27;abc&#x27;) function fn(content: string) &#123; msg.value += content &#125; return &#123; msg, fn &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123; n &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; m &#125;&#125;&lt;/h3&gt; &lt;h3&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;h3&gt;msg2: &#123;&#123; $attrs.msg2 &#125;&#125;&lt;/h3&gt; &lt;slot name=&quot;xxx&quot;&gt;&lt;/slot&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; ref, defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123; name: &#x27;child&#x27;, props: [&#x27;msg&#x27;], emits: [&#x27;fn&#x27;], // 可选的, 声明了更利于程序员阅读, 且可以对分发的事件数据进行校验 data() &#123; console.log(&#x27;data&#x27;, this) return &#123; // n: 1 &#125; &#125;, beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;, this) &#125;, methods: &#123; // update () &#123; // this.n++ // this.m++ // &#125; &#125;, // setup (props, context) &#123; setup(props, &#123; attrs, emit, slots &#125;) &#123; console.log(&#x27;setup&#x27;, this) console.log(props.msg, attrs.msg2, slots, emit) const m = ref(2) const n = ref(3) function update() &#123; // console.log(&#x27;--&#x27;, this) // this.n += 2 // this.m += 2 m.value += 2 n.value += 2 // 分发自定义事件 emit(&#x27;fn&#x27;, &#x27;++&#x27;) &#125; return &#123; m, n, update &#125; &#125;&#125;)&lt;/script&gt; setup语法糖就是香 组件自动注册 组件核心 API 属性和方法直接使用，变量自动拆箱装箱 组件自动注册 它会自动以文件名为主，也就是不用再写name属性了 组件核心 API 1.使用 props 通过defineProps指定当前 props 类型，获得上下文的props对象。示例： 123456&lt;script setup&gt; import &#123; defineProps &#125; from &#x27;vue&#x27; const props = defineProps(&#123; title: String, &#125;)&lt;/script&gt; 2.使用 emits 使用defineEmit定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例： 1234&lt;script setup&gt; import &#123; defineEmits &#125; from &#x27;vue&#x27; const emit = defineEmits([&#x27;change&#x27;, &#x27;delete&#x27;])&lt;/script&gt; 3.获取 slots 和 attrs 可以通过useContext从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了useAttrs和useSlots。示例： 123456789101112// 旧&lt;script setup&gt; import &#123; useContext &#125; from &#x27;vue&#x27; const &#123; slots, attrs &#125; = useContext()&lt;/script&gt;// 新&lt;script setup&gt; import &#123; useAttrs, useSlots &#125; from &#x27;vue&#x27; const attrs = useAttrs() const slots = useSlots()&lt;/script&gt; 4.defineExpose API 传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 template模板，谁都不能访问内部的数据和方法。 如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。示例： 12345678&lt;script setup&gt; import &#123; defineExpose &#125; from &#x27;vue&#x27; const a = 1 const b = 2 defineExpose(&#123; a &#125;)&lt;/script&gt; 响应式核心-ref 作用: 定义一个数据的响应式 语法: const xxx = ref(initValue): 创建一个包含响应式数据的引用(reference)对象 js 中操作数据: xxx.value 模板中操作数据: 不需要.value 一般用来定义一个基本类型的响应式数据,实际开发中强烈推荐用这个-万物皆可用ref。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt; &lt;hr /&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; /* 在Vue3中依然可以使用data和methods配置, 但建议使用其新语法实现 */ // data () &#123; // return &#123; // count: 0 // &#125; // &#125;, // methods: &#123; // update () &#123; // this.count++ // &#125; // &#125; /* 使用vue3的composition API */ setup() &#123; // 定义响应式数据 ref对象 const count = ref(1) console.log(count) // 更新响应式数据的函数 function update() &#123; // alert(&#x27;update&#x27;) count.value = count.value + 1 &#125; return &#123; count, update &#125; &#125;&#125;&lt;/script&gt; ref 获取元素 利用 ref 函数获取组件中的标签元素 功能需求: 让输入框自动获取焦点 1234567891011121314151617181920212223&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;text&quot; ref=&quot;inputRef&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; onMounted, ref &#125; from &#x27;vue&#x27;/*ref获取元素: 利用ref函数获取组件中的标签元素功能需求: 让输入框自动获取焦点*/export default &#123; setup() &#123; const inputRef = ref&lt;HTMLElement | null&gt;(null) onMounted(() =&gt; &#123; inputRef.value &amp;&amp; inputRef.value.focus() &#125;) return &#123; inputRef &#125; &#125;&#125;&lt;/script&gt; 多个ref情况：itemRefs 不必是数组：它也可以是一个对象，其 ref 可以通过迭代的 key 被设置。如有需要，itemRefs 也可以是响应式的，且可以被侦听。 12345678910111213141516171819202122&lt;template&gt; &lt;div v-for=&quot;(item, i) in list&quot; :ref=&quot;el =&gt; &#123; if (el) divs[i] = el &#125;&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, reactive, onBeforeUpdate &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const list = reactive([1, 2, 3]) const divs = ref([]) // 确保在每次更新之前重置ref onBeforeUpdate(() =&gt; &#123; divs.value = [] &#125;) return &#123; list, divs &#125; &#125; &#125;&lt;/script&gt; 响应式核心-reactive 作用: 定义多个数据的响应式 const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”：会影响对象内部所有嵌套的属性 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;h2&gt;name: &#123;&#123; state.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;age: &#123;&#123; state.age &#125;&#125;&lt;/h2&gt; &lt;h2&gt;wife: &#123;&#123; state.wife &#125;&#125;&lt;/h2&gt; &lt;hr /&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;&lt;script&gt;/*reactive: 作用: 定义多个数据的响应式 const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”：会影响对象内部所有嵌套的属性 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的*/import &#123; reactive &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; /* 定义响应式数据对象 */ const state = reactive(&#123; name: &#x27;tom&#x27;, age: 25, wife: &#123; name: &#x27;marry&#x27;, age: 22 &#125; &#125;) console.log(state, state.wife) const update = () =&gt; &#123; state.name += &#x27;--&#x27; state.age += 1 state.wife.name += &#x27;++&#x27; state.wife.age += 2 &#125; return &#123; state, update &#125; &#125;&#125;&lt;/script&gt; reactive 与 ref细节 是 Vue3 的 composition API 中 2 个最重要的响应式 API ref 用来处理基本类型数据, reactive 用来处理对象(递归深度响应式) 如果用 ref 对象/数组, 内部会自动将对象/数组转换为 reactive 的代理对象 ref 内部: 通过给 value 属性添加 getter/setter 来实现对数据的劫持 reactive 内部: 通过使用 Proxy 来实现对对象内部所有数据的劫持, 并通过 Reflect 操作对象内部数据 ref 的数据操作: 在 js 中要.value, 在模板中不需要(内部解析模板时会自动添加.value) 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;p&gt;m1: &#123;&#123; m1 &#125;&#125;&lt;/p&gt; &lt;p&gt;m2: &#123;&#123; m2 &#125;&#125;&lt;/p&gt; &lt;p&gt;m3: &#123;&#123; m3 &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const m1 = ref(&#x27;abc&#x27;) const m2 = reactive(&#123; x: 1, y: &#123; z: &#x27;abc&#x27; &#125; &#125;) // 使用ref处理对象 ==&gt; 对象会被自动reactive为proxy对象 const m3 = ref(&#123; a1: 2, a2: &#123; a3: &#x27;abc&#x27; &#125; &#125;) console.log(m1, m2, m3) console.log(m3.value.a2) // 也是一个proxy对象 function update() &#123; m1.value += &#x27;--&#x27; m2.x += 1 m2.y.z += &#x27;++&#x27; m3.value = &#123; a1: 3, a2: &#123; a3: &#x27;abc---&#x27; &#125; &#125; m3.value.a2.a3 += &#x27;==&#x27; // reactive对对象进行了深度数据劫持 console.log(m3.value.a2) &#125; return &#123; m1, m2, m3, update &#125; &#125;&#125;&lt;/script&gt; 响应式核心-computed与watch computed 函数: 与 computed 配置功能一致 只有 getter 有 getter 和 setter watch 函数 与 watch 配置功能一致 监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调 默认初始时不执行回调, 但可以通过配置 immediate 为 true, 来指定初始时立即执行第一次 通过配置 deep 为 true, 来指定深度监视 watchEffect 函数 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据 默认初始时就会执行第一次, 从而可以收集需要监视的数据 监视数据发生变化时回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; fistName: &lt;input v-model=&quot;user.firstName&quot; /&gt; &lt;br /&gt; lastName: &lt;input v-model=&quot;user.lastName&quot; /&gt; &lt;br /&gt; fullName1: &lt;input v-model=&quot;fullName1&quot; /&gt; &lt;br /&gt; fullName2: &lt;input v-model=&quot;fullName2&quot; /&gt; &lt;br /&gt; fullName3: &lt;input v-model=&quot;fullName3&quot; /&gt; &lt;br /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, ref, computed, watch, watchEffect &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const user = reactive(&#123; firstName: &#x27;A&#x27;, lastName: &#x27;B&#x27; &#125;) // 只有getter的计算属性 const fullName1 = computed(() =&gt; &#123; console.log(&#x27;fullName1&#x27;) return user.firstName + &#x27;-&#x27; + user.lastName &#125;) // 有getter与setter的计算属性 const fullName2 = computed(&#123; get() &#123; console.log(&#x27;fullName2 get&#x27;) return user.firstName + &#x27;-&#x27; + user.lastName &#125;, set(value: string) &#123; console.log(&#x27;fullName2 set&#x27;) const names = value.split(&#x27;-&#x27;) user.firstName = names[0] user.lastName = names[1] &#125; &#125;) const fullName3 = ref(&#x27;&#x27;) /* watchEffect: 监视所有回调中使用的数据 */ /* watchEffect(() =&gt; &#123; console.log(&#x27;watchEffect&#x27;) fullName3.value = user.firstName + &#x27;-&#x27; + user.lastName &#125;) */ /* 使用watch的2个特性: 深度监视 初始化立即执行 */ watch( user, () =&gt; &#123; fullName3.value = user.firstName + &#x27;-&#x27; + user.lastName &#125;, &#123; immediate: true, // 是否初始化立即执行一次, 默认是false deep: true // 是否是深度监视, 默认是false &#125; ) /* watch一个数据 默认在数据发生改变时执行回调 */ watch(fullName3, value =&gt; &#123; console.log(&#x27;watch&#x27;) const names = value.split(&#x27;-&#x27;) user.firstName = names[0] user.lastName = names[1] &#125;) /* watch多个数据: 使用数组来指定 如果是ref对象, 直接指定 如果是reactive对象中的属性, 必须通过函数来指定 */ watch([() =&gt; user.firstName, () =&gt; user.lastName, fullName3], values =&gt; &#123; console.log(&#x27;监视多个数据&#x27;, values) &#125;) return &#123; user, fullName1, fullName2, fullName3 &#125; &#125;&#125;&lt;/script&gt; watch、watchEffect区别 1、watch是惰性执行，也就是只有监听的值发生变化的时候才会执行，但是watchEffect不同，每次代码加载watchEffect都会执行（忽略watch第三个参数的配置，如果修改配置项也可以实现立即执行） 2、watch需要传递监听的对象，watchEffect不需要 3、watch只能监听响应式数据：ref定义的属性和reactive定义的对象，如果直接监听reactive定义对象中的属性是不允许的，除非使用函数转换一下 4、watchEffect如果监听reactive定义的对象是不起作用的，只能监听对象中的属性。 watch 和 watchEffect 会共享以下四种行为： 停止监听：组件卸载时都会自动停止监听 清除副作用：onInvalidate 会作为回调的第三个参数传入 副作用刷新时机：响应式系统会缓存副作用函数，并异步刷新，避免同一个 tick 中多个状态改变导致的重复调用 监听器调试：开发模式下可以用 onTrack 和 onTrigger 进行调试 123456789101112131415161718let count = ref(0) let countObj = reactive(&#123;count: 0&#125;) // 惰性，首次加载不执行 watch(count, (newVal, oldVal) =&gt;&#123;console.log(newVal, oldVal)&#125; ) // watch 不能直接监听reactive里面的属性，只能监听ref、reactiveObject， function， array, 如果想监听reactive的某个属性，那么需要转换成函数 watch(() =&gt; countObj.count, (newVal, oldVal) =&gt; &#123;console.log(oldVal, newVal)&#125;, &#123;&#125;) watch (countObj, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal) &#125;) // 监听多个值，前面是监听数据的数组，后面的参数是两个数组，前面数组是变化后监听对象值的数组，后面是变化前监听对象值的数组 watch ([countObj, count], ([oneNewName, twoNewName], [oneOldName, twoOldName]) =&gt; &#123; console.log(oneNewName, oneOldName, twoNewName, twoOldName) &#125;) // watchEffect，和watch不一样，1、会立即执行，只要定义了就会执行。2、他只能监听某个值，监听对象不管用。3、不需要传递参数，会自动管制代码中的变量。4、没法获取newVal和oldVal const watchEf = watchEffect(() =&gt; &#123; console.log(countObj.count) &#125;) watchEffect副作用函数 定义：watchEffect的第三个参数是用于注册副作用清理的回调函数，该回调函数会在副作用函数下一次重新执行前调用，多用于取消重复请求、防抖、事件注册销毁等。 1234567891011121314151617181920212223242526272829303132333435// 取消重复请求watch(source, async (old, new, OnCleanup) =&gt; &#123; // 是否过期是标志 let expired = false // 注册过期回调 OnCleanup(()=&gt; &#123; expired = true &#125;) const res = await fetch(&#x27;something&#x27;) // 如果未过期，那么可以取res为finalData if (!expired) &#123; finalData = res &#125;&#125;)// 防抖const id = ref(13)watchEffect(onInvalidate =&gt; &#123; // 异步请求 const token = performAsyncOperation(id.value) // 如果id频繁改变，会触发失效函数，取消之前的接口请求 onInvalidate(() =&gt; &#123; // id has changed or watcher is stopped. // invalidate previously pending async operation token.cancel() &#125;)&#125;)// dom的事件监听和取消监听onMounted(()=&gt;&#123; watchEffect((onInvalidate) =&gt; &#123; document.querySelector(&#x27;.btn&#x27;).addEventListener(&#x27;click&#x27;, handleClick, false) onInvalidate(() =&gt; document.querySelector(&#x27;.btn&#x27;).removeEventListener(&#x27;click&#x27;, handleClick)) &#125;)&#125;) 响应式-工具函数ref相关 isRef()：检查某个值是否为ref unref()：如果参数为ref，则返回其内部的值，否则返回参数本身 toRef()：toRef 可以响应对象 Object ，其针对的是某一个响应式对象（ reactive 封装）的属性prop 。与 toRef 不一样的是， toRefs 是针对整个对象的所有属性，目标在于将响应式对象（ reactive 封装）转换为普通对象 toRefs()：普通对象里的每一个属性 prop 都对应一个 ref，常用于想要在合成函数中返回响应式对象 is相关 isProxy()：检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理 isReactive()：检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理 isReadonly()：检查一个对象是否是由 readonly() 或 shallowReadonly() 创建的代理 toRef 为源响应式对象上的某个属性创建一个 ref 对象, 二者内部操作的是同一个数据值, 更新时二者是同步的 区别 ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响 应用: 当要将 某个 prop 的 ref 传递给复合函数时，toRef 很有用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;p&gt;&#123;&#123; state &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; foo2 &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt; &lt;Child :foo=&quot;foo&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;/*toRef: 为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, 更新时二者是同步的 区别ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响 应用: 当要将某个 prop 的 ref 传递给复合函数时，toRef 很有用*/import &#123; reactive, toRef, ref &#125; from &#x27;vue&#x27;import Child from &#x27;./Child.vue&#x27;export default &#123; setup() &#123; const state = reactive(&#123; foo: 1, bar: 2 &#125;) const foo = toRef(state, &#x27;foo&#x27;) const foo2 = ref(state.foo) const update = () =&gt; &#123; state.foo++ // foo.value++ // foo2.value++ // foo和state中的数据不会更新 &#125; return &#123; state, foo, foo2, update &#125; &#125;, components: &#123; Child &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;h2&gt;Child&lt;/h2&gt; &lt;h3&gt;&#123;&#123; foo &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; length &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; computed, defineComponent, Ref, toRef &#125; from &#x27;vue&#x27;const component = defineComponent(&#123; props: &#123; foo: &#123; type: Number, require: true &#125; &#125;, setup(props, context) &#123; const length = useFeatureX(toRef(props, &#x27;foo&#x27;)) return &#123; length &#125; &#125;&#125;)function useFeatureX(foo: Ref) &#123; const lenth = computed(() =&gt; foo.value.length) return lenth&#125;export default component&lt;/script&gt; toRefs 把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref 应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用 问题: reactive 对象取出的所有属性值都是非响应式的 解决: 利用 toRefs 可以将一个响应式 reactive 对象的所有原始属性转换为响应式的 ref 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;h3&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/h3&gt; &lt;h3&gt;bar: &#123;&#123; bar &#125;&#125;&lt;/h3&gt; &lt;h3&gt;foo2: &#123;&#123; foo2 &#125;&#125;&lt;/h3&gt; &lt;h3&gt;bar2: &#123;&#123; bar2 &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, toRefs &#125; from &#x27;vue&#x27;/*toRefs: 将响应式对象中所有属性包装为ref对象, 并返回包含这些ref对象的普通对象 应用: 当从合成函数返回响应式对象时，toRefs 非常有用， 这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用*/export default &#123; setup() &#123; const state = reactive(&#123; foo: &#x27;a&#x27;, bar: &#x27;b&#x27; &#125;) const stateAsRefs = toRefs(state) setTimeout(() =&gt; &#123; state.foo += &#x27;++&#x27; state.bar += &#x27;++&#x27; &#125;, 2000) const &#123; foo2, bar2 &#125; = useReatureX() return &#123; // ...state, ...stateAsRefs, foo2, bar2 &#125; &#125;&#125;function useReatureX() &#123; const state = reactive(&#123; foo2: &#x27;a&#x27;, bar2: &#x27;b&#x27; &#125;) setTimeout(() =&gt; &#123; state.foo2 += &#x27;++&#x27; state.bar2 += &#x27;++&#x27; &#125;, 2000) return toRefs(state)&#125;&lt;/script&gt; 响应式-进阶函数响应式 shallowRef()：ref的浅层作用形式，和ref()不同的是，浅层ref的内部值将会原样存储和暴露，并且不会被深层递归转为响应式。只有.value的访问是响应式的。常见场景：①对大型数据结构的性能优化；②外部的状态管理系统集成。 triggerRef()：强制触发【依赖于浅层ref的副作用】，常用于：对浅引用shallowRef的内部值进行深度变更时。 customRef()：创建一个自定义ref，显示地声明将要对其进行【依赖追踪】和【更新触发】的控制方式。一般来说，track()应该在get()方法中调用，而trigger()方法应该在set()中调用。但其实，想要怎么调用，自己来控制就好啦！常用场景：防抖场景 shallowReactive()：reactive()的浅层作用形式。和reactive不同的是，这里没有深层级的转换，它只有【根级别】的属性是响应式的。属性的值乎一杯原样存储和暴露，这也就意味着值为ref的属性【不会被自动解包】。 只读 shallowReadonly()：readonly()的浅层作用形式。和readonly()不同的是，这里没有深层级的转换。只有根层级的属性变为了只读，其他层级的都可以正常访问。属性的值都会被原样存储和暴露，这也意味着根部【值为ref的属性】不会被自动解包。 raw toRaw()：根据一个vue创建的代理，返回其【原始对象】。toRaw可以返回由reactive()、readonly()、shallowReactive()创建的代理所对应的原始对象。常用于：①可以临时读取而不会引起代理访问/跟踪开销的场景；② 可以写入而不触发更改的特殊方法。 不建议保存对原始对象的持久引用，要注意谨慎使用 markRaw()：将一个对象标记为【不可被转为代理】，返回该【对象本身】。可以理解为让对象【不能拥有响应式功能】。markRaw()和类似shallowReactive()这样的浅层式API可以使你有选择地避开默认的深度响应/只读转换，并在状态关系中嵌入原始的、非代理的对象。 谨慎使用的几点原因： 有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象。 当呈现带有【不可变数据源】的大型列表时，跳过代理转换可以提高性能。 这可以说是一种进阶需求，因为只在根层访问能到原始值，所以如果把一个嵌套的、没有标记的原始对象设置成一个响应式对象，然后再次访问它，你获取到的是代理的版本。 它可能会导致对象身份风险，即执行一个依赖于对象身份的操作，但却同时使用了同一对象的原始版本和代理版本。 scope effectScope()：可以处理掉所创建的响应式副作用（即计算属性和侦听器watch/watchEffect）。也就是说，如果你创建了【无用的】响应式数据，那么可以通过effectScope()这个API，来处理掉这些无用的副作用 getCurrentScope()：如果有的话，返回当前活跃的【effect作用域】，即effectScope()中活跃的作用域 onScopeDispose()：在当前活跃的effect作用域上，注册一个处理回调的函数。当相关的effect作用域停止时，将会调用上述这个回调函数。常用场景：这个方法可以作为【可复用的组合式函数】中【onUnmounted】的替代品，且它不会与组件耦合，因为对于每一个vue组件的setup()函数来说，它们也是在一个【effect作用域】中调用的。 shallowReactive 与 shallowRef shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式) shallowRef: 只处理了 value 的响应式, 不进行对象的 reactive 处理 什么时候用浅响应式呢? 一般情况下使用 ref 和 reactive 即可 如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive 如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;h3&gt;m1: &#123;&#123; m1 &#125;&#125;&lt;/h3&gt; &lt;h3&gt;m2: &#123;&#123; m2 &#125;&#125;&lt;/h3&gt; &lt;h3&gt;m3: &#123;&#123; m3 &#125;&#125;&lt;/h3&gt; &lt;h3&gt;m4: &#123;&#123; m4 &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, ref, shallowReactive, shallowRef &#125; from &#x27;vue&#x27;/*shallowReactive与shallowRef shallowReactive: 只处理了对象内最外层属性的响应式(也就是浅响应式) shallowRef: 只处理了value的响应式, 不进行对象的reactive处理总结: reactive与ref实现的是深度响应式, 而shallowReactive与shallowRef是浅响应式 什么时候用浅响应式呢? 一般情况下使用ref和reactive即可, 如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive 如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef*/export default &#123; setup() &#123; const m1 = reactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;) const m2 = shallowReactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;) const m3 = ref(&#123; a: 1, b: &#123; c: 2 &#125; &#125;) const m4 = shallowRef(&#123; a: 1, b: &#123; c: 2 &#125; &#125;) const update = () =&gt; &#123; // m1.b.c += 1 // m2.b.c += 1 // m3.value.a += 1 m4.value.a += 1 &#125; return &#123; m1, m2, m3, m4, update &#125; &#125;&#125;&lt;/script&gt; customRef 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制 需求: 使用 customRef 实现 debounce 的示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;input v-model=&quot;keyword&quot; placeholder=&quot;搜索关键字&quot; /&gt; &lt;p&gt;&#123;&#123; keyword &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;/*customRef: 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制需求: 使用 customRef 实现 debounce 的示例*/import &#123; ref, customRef &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const keyword = useDebouncedRef(&#x27;&#x27;, 500) console.log(keyword) return &#123; keyword &#125; &#125;&#125;/*实现函数防抖的自定义ref*/function useDebouncedRef&lt;T&gt;(value: T, delay = 200) &#123; let timeout: number return customRef((track, trigger) =&gt; &#123; return &#123; get() &#123; // 告诉Vue追踪数据 track() return value &#125;, set(newValue: T) &#123; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; value = newValue // 告诉Vue去触发界面更新 trigger() &#125;, delay) &#125; &#125; &#125;)&#125;&lt;/script&gt; readonly 与 shallowReadonly readonly: 深度只读数据 获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。 只读代理是深层的：访问的任何嵌套 property 也是只读的。 shallowReadonly 浅只读数据 创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 应用场景: 在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;h3&gt;&#123;&#123; state &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; reactive, readonly, shallowReadonly &#125; from &#x27;vue&#x27;/*readonly: 深度只读数据 获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。 只读代理是深层的：访问的任何嵌套 property 也是只读的。shallowReadonly: 浅只读数据 创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换应用场景: 在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除*/export default &#123; setup() &#123; const state = reactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;) // const rState1 = readonly(state) const rState2 = shallowReadonly(state) const update = () =&gt; &#123; // rState1.a++ // error // rState1.b.c++ // error // rState2.a++ // error rState2.b.c++ &#125; return &#123; state, update &#125; &#125;&#125;&lt;/script&gt; toRaw 与 markRaw toRaw 返回由 reactive 或 readonly 方法转换成响应式代理的普通对象。 这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发界面更新。 markRaw 标记一个对象，使其永远不会转换为代理。返回对象本身 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。 当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;h2&gt;&#123;&#123; state &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;testToRaw&quot;&gt;测试toRaw&lt;/button&gt; &lt;button @click=&quot;testMarkRaw&quot;&gt;测试markRaw&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;/*toRaw: 得到reactive代理对象的目标数据对象*/import &#123; markRaw, reactive, toRaw &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const state = reactive&lt;any&gt;(&#123; name: &#x27;tom&#x27;, age: 25 &#125;) const testToRaw = () =&gt; &#123; const user = toRaw(state) user.age++ // 界面不会更新 &#125; const testMarkRaw = () =&gt; &#123; const likes = [&#x27;a&#x27;, &#x27;b&#x27;] // state.likes = likes state.likes = markRaw(likes) // likes数组就不再是响应式的了 setTimeout(() =&gt; &#123; state.likes[0] += &#x27;--&#x27; &#125;, 1000) &#125; return &#123; state, testToRaw, testMarkRaw &#125; &#125;&#125;&lt;/script&gt; 响应性语法糖(已废弃)废弃原因：最重要的是，碎片化的潜在风险。 let count = $ref(0) function myCreateRef() { return ref(0) } let count = $(myCreateRef()) const {num} =} = defineProps&lt;&gt;() 依赖注入provide 与 inject provide和inject提供依赖注入，功能类似 2.x 的provide/inject 实现跨层级组件(祖孙)间通信 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;p&gt;当前颜色: &#123;&#123; color &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;color = &#x27;red&#x27;&quot;&gt;红&lt;/button&gt; &lt;button @click=&quot;color = &#x27;yellow&#x27;&quot;&gt;黄&lt;/button&gt; &lt;button @click=&quot;color = &#x27;blue&#x27;&quot;&gt;蓝&lt;/button&gt; &lt;hr /&gt; &lt;Son /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;/*- provide` 和 `inject` 提供依赖注入，功能类似 2.x 的 `provide/inject- 实现跨层级组件(祖孙)间通信*/import Son from &#x27;./Son.vue&#x27;export default &#123; name: &#x27;ProvideInject&#x27;, components: &#123; Son &#125;, setup() &#123; const color = ref(&#x27;red&#x27;) provide(&#x27;color&#x27;, color) return &#123; color &#125; &#125;&#125;&lt;/script&gt; 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h2&gt;子组件&lt;/h2&gt; &lt;hr /&gt; &lt;GrandSon /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import GrandSon from &#x27;./GrandSon.vue&#x27;export default &#123; components: &#123; GrandSon &#125;&#125;&lt;/script&gt; 12345678910111213141516&lt;template&gt; &lt;h3 :style=&quot;&#123; color &#125;&quot;&gt;孙子组件: &#123;&#123; color &#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; inject &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const color = inject(&#x27;color&#x27;) return &#123; color &#125; &#125;&#125;&lt;/script&gt; 五大API-选项式API选项式API —— vue2所拥有的选项式API 状态选项 data props computed methods watch emits：用于声明由组件触发的自定义事件 expose：用于声明”当组件实例被父组件通过模板引用访问时”所暴露的公共属性 渲染选项 template：用于声明组件的字符串模板。如果 render 选项也同时存在于该组件中，template 将被忽略。 render：用于编程式地创建组件虚拟 DOM 树的函数 compilerOptions：用于配置组件模板在运行时的编译器选项。仅在使用完整构建版本时才有效（浏览器运行vue.js文件时才有效，可以理解为html里面引用了vue.js的脚本） 组合选项 provide：提供可以被后代组件注入的值 inject：声明来自于上层想要注入进当前组件的属性 mixins：mixins是一个包含”组件选项对象的”数组，这些选项都将被混入到当前组件的实例中 extends：将要继承的“基类”组件 五大API-内置内容内置内容 —— 指令、组件、特殊元素和特殊属性 指令 v-for：如果跟v-if一起使用时，v-if的优先级更高，但不推荐一起使用，容易造成各种混淆 v-slot：主要用途：①声明具名插槽；②期望接收props的作用域插槽。 组件 TransitionGroup：为列表中多个元素提供过度效果 KeepAlive Teleport：将插槽内容渲染到Dom的另外一个位置 Suspense：解决异步问题 Teleport(瞬移) Vue3 提供Teleport组件可将部分DOM移动到 Vue app之外的位置。比如项目中常见的Dialog组件。 ModalButton.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;button @click=&quot;modalOpen = true&quot;&gt;&lt;/button&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt; &lt;div&gt;&lt;button @click=&quot;modalOpen = false&quot;&gt;Close&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; name: &#x27;modal-button&#x27;, setup() &#123; const modalOpen = ref(false) return &#123; modalOpen &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.modal &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.modal div &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: white; width: 300px; height: 300px; padding: 5px;&#125;&lt;/style&gt; App.vue 12345678910111213141516&lt;template&gt; &lt;h2&gt;App&lt;/h2&gt; &lt;modal-button&gt;&lt;/modal-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import ModalButton from &#x27;./ModalButton.vue&#x27;export default &#123; setup() &#123; return &#123;&#125; &#125;, components: &#123; ModalButton &#125;&#125;&lt;/script&gt; Suspense(不确定的) Vue3 提供 Suspense组件，允许程序在等待异步组件时渲染兜底的内容，如 loading ，使用户体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default和fallback。Suspense确保加载完异步内容时显示默认插槽，并将fallback插槽用作加载状态。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;AsyncComp /&gt; &lt;!-- &lt;AsyncAddress/&gt; --&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;h1&gt;LOADING...&lt;/h1&gt; &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;/*异步组件 + Suspense组件*/// import AsyncComp from &#x27;./AsyncComp.vue&#x27;import AsyncAddress from &#x27;./AsyncAddress.vue&#x27;import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./AsyncComp.vue&#x27;))export default &#123; setup() &#123; return &#123;&#125; &#125;, components: &#123; AsyncComp, AsyncAddress &#125;&#125;&lt;/script&gt; AsyncComp.vue 12345678910111213141516171819202122&lt;template&gt; &lt;h2&gt;AsyncComp22&lt;/h2&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#x27;AsyncComp&#x27;, setup() &#123; // return new Promise((resolve, reject) =&gt; &#123; // setTimeout(() =&gt; &#123; // resolve(&#123; // msg: &#x27;abc&#x27; // &#125;) // &#125;, 2000) // &#125;) return &#123; msg: &#x27;abc&#x27; &#125; &#125;&#125;&lt;/script&gt; AsyncAddress.vue 123456789101112131415&lt;template&gt; &lt;h2&gt;&#123;&#123; data &#125;&#125;&lt;/h2&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;export default &#123; async setup() &#123; const result = await axios.get(&#x27;/data/address.json&#x27;) return &#123; data: result.data &#125; &#125;&#125;&lt;/script&gt; img动态图片解法1:在将asset 前面加上src 1&lt;img :src=&quot;`/src/assets/blogPhotos/$&#123;name&#125;.jpg`&quot; /&gt; 解法2：官网说：“实际上，Vite 并不需要在开发阶段处理这些代码！在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。” 1234&lt;img :src=&quot;&quot; alt=&quot;getImageUrl(name)&quot; /&gt;function getImageUrl(name) &#123; return new URL(`../assets/blogPhotos/$&#123;name&#125;.jpg`, import.meta.url).href;&#125; 状态驱动的动态 CSS12345678&lt;script setup&gt;const size = 10&lt;/script&gt;&lt;style scoped&gt;.home &#123; width: v-bind(size + &quot;px&quot;);&#125;&lt;/style&gt; 插槽选择器默认情况下，作用域样式不会影响到 &lt;slot/&gt; 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 :slotted 伪类以确切地将插槽内容作为选择器的目标。 12345678910111213141516// 父组件&lt;Child3&gt; &lt;div class=&quot;slot1&quot;&gt;我是slot传递过来的&lt;/div&gt;&lt;/Child3&gt;// 子组件里写样式&lt;style scoped&gt;:slotted(.slot1) &#123; color: red;&#125;&lt;/style&gt;// 或者直接在父组件里写样式&lt;style scoped&gt;.slot1 &#123; color: red;&#125;&lt;/style&gt; 样式穿透和全局样式样式穿透 123456789101112// vue2&lt;style scoped&gt;.a /deep/ .b &#123; /* ... */&#125;&lt;/style&gt;// vue3&lt;style scoped&gt;.a :deep(.b) &#123; /* ... */&#125; 全局样式和局部样式 1234局部样式&lt;style scoped&gt;/* local styles */&lt;/style&gt; 123456789101112全局样式：不带scope&lt;style&gt;/* global styles */&lt;/style&gt;全局样式：使用:global伪类// 创建一个.red的全局类样式&lt;style scoped&gt;:global(.red) &#123; color: red;&#125;&lt;/style&gt; 五大API-进阶API进阶API —— 渲染函数、TS工具类型和自定义渲染 渲染函数 h()：创建虚拟DOM节点 mergeProps()：合并多个props对象，用于处理【含有特定的props参数】的情况 服务端渲染 renderToString()：从 vue/server-renderer 中导出。传入一个可选的上下文对象，可以用来在渲染过程中记录额外的数据，比如：访问teleprt的内容。该上下文对象可以在组件代码里面，通过 useSSRContext 辅助函数来进行访问 TS工具类型 PropType：用于给prop标注更复杂的类型定义 ComponentCustomProperties：用于增强组件实例类型，以用来更好地支持自定义全局属性。 ComponentCustomOptions：用于扩展组件选项类型，以更好地支持自定义选项。 ComponentCustomProps：用于扩展全局可用的 TSX props，以便在TSX元素上，使用从来没有在【组件选项上】定义过的 props CSSProperties：在样式属性绑定上，允许有更多种【值的类型】。比如：我们平常只能用color: blue，那么我们可以扩展出一个 –bg-color ，最终就可以用 【‘–bg-color’: ‘blue’】来表示 自定义渲染 createRenderer()：从 @vue/runtime-core 中导出，创建一个自定渲染器，通过平台所提供的特定节点，来创建以及更改API，可以在非DOM环境中也享受到Vue核心运行时的特性。 HooksHooks实战 方式一：export default导出单一函数，导入参数，导出函数和出参 方式二：参考大崔哥的新写法(同一vue和js文件共享数据)–推荐 方式三：返璞归真，结合1和2，进化到hooks本质–强强强推荐 方式一：export default导出单一函数，导入参数，导出函数和出参 App.vue 12345678910111213&lt;template&gt; &lt;p&gt;&#123;&#123; num1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; num2 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; addNum &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;const num1 = ref(2)const num2 = ref(1)// 方式一import &#123;useAdd&#125; from &#x27;./useAdd.ts&#x27; //引入自动hook const &#123; addNum, addFn &#125; = useAdd(&#123; num1, num2 &#125;)addFn(num1.value, num2.value)&lt;/script&gt; @/service/useAdd.ts 1234567891011121314151617import &#123; ref, watch &#125; from &#x27;vue&#x27;;export const useAdd= (&#123; num1, num2 &#125;) =&gt;&#123; // 入参数 const addNum = ref(0) watch([num1, num2], ([num1, num2]) =&gt; &#123; addFn(num1, num2) &#125;) const addFn = (num1, num2) =&gt; &#123; addNum.value = num1 + num2 &#125; return &#123; // 出参 addNum, // 出函数 addFn &#125;&#125; 方式二：参考大崔哥的新写法(同一vue和js文件共享数据)–推荐 Flow.vue–渲染页面(引入index.ts) index.ts-总入口 tabs.ts–顶部tab业务 cardBLine.ts–卡片业务 dialog.ts–弹窗业务 @/view/Flow.vue–渲染页面 1234567import &#123; initAll, diaConfirm &#125; from &#x27;@/services/reviewFlow&#x27;;const tabs = reactive([]);const tab = ref();const cardBLine = ref(&#123;&#125;);const dia = ref(&#123;&#125;);initAll(&#123; tabs, tab, cardBLine, dia &#125;); @/services/index.ts-总入口 1234567import &#123; initTabs &#125; from &#x27;./tabs&#x27;;import &#123; initCardBLine &#125; from &#x27;./cardBLine&#x27;;export &#123; initDialog, diaConfirm &#125; from &#x27;./dialog&#x27;;export function initAll(params) &#123; initTabs(params.tabs, params.tab);&#125; @/services/tabs.ts–顶部tab业务 1234567891011121314151617181920212223242526import * as myApi from &#x27;@/services/myApi&#x27;;// 分解的产品线let tabs = [];let tab = &#123;&#125;;export async function initTabs(tabsReactive, tabRef) &#123; declareTag(tabsReactive, tabRef); await loadTabs(); loadTab();&#125;function declareTag(tabsReactive, tabRef) &#123; // 1.初始化-变量 tabs = tabsReactive; tab = tabRef;&#125;async function loadTabs() &#123; // 载入tabs tabs.length = 0; const res = []; res.forEach((r) =&gt; &#123; tabs.push(createTab(r)); &#125;);&#125; 方式三：返璞归真，结合1和2，进化到hooks本质–强强强推荐 @/view/Flow.vue–渲染页面 123456789101112131415&lt;script setup&gt;import &#123; userFlow &#125; from &#x27;@/services/userFlow&#x27;;const &#123;tabs,tab,cardBLine,dia,diaConfirm&#125; = userFlow()&lt;/script&gt;&lt;template&gt;&lt;Tab v-model:tab=&quot;tab&quot; :tabs=&quot;tabs&quot;&gt;&lt;/Tab&gt;&lt;CardBaseLine v-model:card=&quot;cardBLine&quot;&gt;&lt;/CardBaseLine&gt;&lt;VDialog v-model:dVis=&quot;dia.dVis&quot; v-bind=&quot;dia&quot; @oprate=&quot;diaConfirm(dia)&quot;&gt; &lt;div&gt; &lt;span&gt;转给&lt;/span&gt; &lt;VUser v-model:user=&quot;dia.dCont&quot;&gt;&lt;/VUser&gt; &lt;/div&gt; &lt;/VDialog&gt;&lt;template&gt; @/services/userFlow.ts-总入口 12345678910import &#123; useTabs &#125; from &#x27;./useTabs&#x27;;import &#123; useCardBLine &#125; from &#x27;./useCardBLine&#x27;;export &#123; userDialog &#125; from &#x27;./userDialog&#x27;;export async function userFlow() &#123; const &#123;tabs,tab&#125; =await useTabs(); const &#123;cardBLine&#125; =await useCardBLine(); const &#123;dia,diaConfirm&#125; =await userDialog(); return &#123;tabs,tab,cardBLine,dia,diaConfirm&#125;&#125; @/services/useTabs.ts–顶部tab业务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import * as myApi from &#x27;@/services/myApi&#x27;;// 分解的产品线let tabs = reactive([]);let tab = ref();export async function useTabs() &#123; async function initTabs()&#123; watchOnce( () =&gt; tab.value, (value) =&gt; &#123; // 其他操作 &#125;, ) await loadTabs(); loadTab(); &#125; async function loadTabs() &#123; // 载入tabs tabs.length = 0; const res = []; res.forEach((r) =&gt; &#123; tabs.push(createTab(r)); &#125;);&#125;function createTab(item) &#123; // 创建tab const result = &#123; label: item.pbiNameCn, value: item.pbiId, product: getProduct(item.pbiId), // 有联动查询 ...item, &#125;; return result;&#125;async function getProduct(id) &#123; const res = await myApi.baseLine_querBaseLine(); return res;&#125;function loadTab() &#123; // 载入 const i = tabs.findIndex((t) =&gt; t.showFlag === &#x27;1&#x27;); // showFlag 0是查看，1是编辑 tab.value = tabs[i === -1 ? 0 : i];&#125; initTabs() return &#123; tabs,tab &#125;&#125; @/services/useCardBLine.ts–卡片业务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import * as myApi from &#x27;@/services/myApi&#x27;;// 基线对标卡片let cardBLine = ref();export async function useCardBLine() &#123; async function initCardBLine()&#123; await loadCardBLine(); setCardBLine(); &#125; function loadCardBLine() &#123; // 2.载入 const cbData = &#123; a: 1, b: 2 &#125;; cardBLine.value = createCardBaseLine(cbData);&#125; function createCardBaseLine(cbData) &#123; return &#123; prop: &#x27;baseLine&#x27;, label: cbData.a, data: cbData.b, &#125;;&#125; function setCardBLine(result?) &#123; // 设值基线对标 let p0 = result ? result.benchmarkStatus : &#x27;&#x27;; setValue(cardBLine.value, &#x27;mark&#x27;, p0); // 未接纳 if (p0 === &#x27;DIC_MARK_STATUS_003&#x27;) &#123; const markI = cardBLine.value.findIndex((d) =&gt; d.prop === &#x27;mark&#x27;); cardBLine.value.splice(markI + 2, 1); &#125;&#125; function setValue(prop, val) &#123; // 正常设值 const c1 = cardBLine.value.find((c) =&gt; c.prop === prop); if (!c1) &#123; return; &#125; c1.value = val;&#125;function saveCardBLine() &#123; // 保存数据 const param = collectCardBLine(); myApi.baseLine_saveBaseLine(param);&#125;function collectCardBLine() &#123; // 收集数据 const benchmarkStatus = findValue(cardBLine, &#x27;mark&#x27;); return &#123; benchmarkStatus, &#125;;&#125; function findValue(card, prop) &#123; // 正常获取 return cardBLine.value.data.find((c) =&gt; c.prop === prop)?.value;&#125; async function btnToOtherHandle(cb = cardBLine.value) &#123; // 可以自己调用，或第三方调用 await myApi.flow_transfer(cb);&#125; initCardBLine() return &#123;cardBLine,btnToOtherHandle&#125;&#125; @/services/userDialog.ts–弹窗业务 12345678910111213141516171819202122232425262728293031323334353637383940414243// 弹窗信息let dia = ref();export async function userDialog() &#123; function initDialog()&#123; loadDia(); &#125; function loadDia() &#123; // 2.载入 dia.value = createDia(&#x27;transfer&#x27;);&#125;function createDia(type) &#123; const t = &#123; transfer: &#123; dVis: false, dType: &#x27;transfer&#x27;, dTitle: &#x27;转他人审批&#x27;, dClass: &#x27;transfer&#x27;, dCont: &#123; val: &#x27;&#x27;, &#125;, &#125;, &#125;; return t[type];&#125; async function btnToOther() &#123; // 转给他人审批 dia.value.dVis = true;&#125; async function diaConfirm(cardBLine) &#123; // 弹窗确认 const &#123; dType &#125; = dia.value; if (dType === &#x27;transfer&#x27;) &#123; dia.value.dVis = false; &#125;&#125; initDialog() return &#123;dia,diaConfirm&#125;&#125; 什么是HooksHooks并不是VUE特有的概念，实际上它原本被用于指代一些特定时间点会触发的勾子。而在React16之后，它被赋予了新的意义： 一系列以 use 作为开头的方法，它们提供了让你可以完全避开 class式写法，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力 1Hooks最核心的价值来自于内部的状态管理 在VUE3中，Hooks的概念结合了VUE的响应式系统，被称为组合函数。组合函数是VUE3组合式API中提供的新的逻辑复用的方案，是一类利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。 Hook规则React官方规范 Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 linter 插件来强制执行这些规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。 只在 React 函数中调用 Hook 不要在普通的 JavaScript 函数中调用 Hook。你可以： ✅ 在 React 的函数组件中调用 Hook ✅ 在自定义 Hook 中调用其他 Hook 其他规范 通常来讲，一个Hook的命名需要以use开头，比如useTimeOut，这是约定俗成的，开发者看到useXXX即可明白这是一个Hook。Hook的名称需要清楚地表明其功能。 函数必须是纯函数，没有副作用 返回值是一个函数或数据，供外部使用 Hook内部可以使用其他的Hook，组合功能 数据必须依赖于输入，不依赖于外部状态，保持数据流的明确性 在Hook内部处理错误，不要把错误抛出到外部，否则会增加hook的使用成本 Hook是单一功能的，不要给一个Hook设计过多功能。单个Hook只负责做一件事，复杂的功能可以使用多个Hook互相组合实现，如果给单个Hook增加过多功能，又会陷入过于臃肿、使用成本高、难维护的问题中 Hooks与composition ApiHooks是一种基于闭包的函数式编程思维产物，所以通常我们会在函数式风格的框架或组件中使用Hook，比如VUE的组合式API(Composition Api)。Hooks在VUE2所使用的选项式风格API中也不是不可以使用，毕竟Hook本质只是一个函数，只要hook内部所使用的api能够得到支持，我们可以在任何地方使用它们，只是可能需要额外的支持以及效果没有函数式组件中那么好，因为仍会被选项分割。 为什么要使用HookMixin/Class的局限性： 不清晰的数据来源：当使用了多个mixin/class时，哪个数据是哪个模块提供的将变得难以追寻，这将提高维护难度 命名空间冲突：来自多个class/mixin的开发者可能会注册同样的属性名，造成冲突 隐性的跨模块交流：不同的mixin/class之间可能存在某种相互作用，产生未知的后果 其实Mixin/Class的缺点反过来就是Hooks的优点： 清晰一目了然的源头：Hooks不是一个类，没有将状态、方法存放在对象中，然后通过导出对象的形式实现复用，也就不会有对象间过度耦合、干扰等问题。Hooks中的各类状态是封装在内部的，与外界隔离，仅暴露部分函数、变量，这使得其来源、功能清晰可辨且不易被干扰 没有命名冲突的问题：Hooks本质是闭包函数，内部所导出的变量、方法支持重命名，因而同一个Hook在同一个组件中可以N次使用而不冲突 精简逻辑：一个Hook开发完成后，在使用Hook时不需要关心其内部逻辑，只需知道有什么效果、如何使用即可，专注于其他核心业务逻辑，可以节省大量重复代码 pinia入门推荐使用使用composition API模式定义store 12345678910111213141516171819import &#123; ref, computed &#125; from &#x27;vue&#x27;;import &#123; defineStore &#125; from &#x27;pinia&#x27;;// 使用composition API模式定义storeexport const useCounterStoreForSetup = defineStore(&#x27;counterForSetup&#x27;, () =&gt; &#123; const count = ref&lt;number&gt;(1); const doubleCount = computed(() =&gt; count.value * 2); function increment() &#123; count.value++; &#125; return &#123; count, doubleCount, increment &#125;;&#125;);// composition API模式调用const counterStoreForSetup = useCounterStoreForSetup();// 确保解构确保后的state具有响应式，要使用storeToRefs方法const &#123; count, doubleCount &#125; = storeToRefs(counterStoreForSetup);const &#123; increment &#125; = counterStoreForSetup; VueUse是一款基于组合式API的函数集合。 指南 核心包括9种函数： 动画（Animation）—包含易于使用的过渡、超时和计时函数 浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等 组件（Component）— 为不同的组件方法提供简写 Formatters – 提供反应时间格式化功能 传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件 状态（State ）—管理用户状态（全局、本地存储、会话存储） 实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等 Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者 常用的5大函数 1.useVModel 简化了 v-model 绑定 12345678910&lt;div v-model=&quot;isPop&quot;&gt;&lt;/div&gt;import &#123; useVModels &#125; from &#x27;@vueuse/core&#x27;;const props = defineProps(&#123; isPop: &#123; default: false, &#125;&#125;)const &#123; isPop &#125; = useVModels(props, emits);const emits = defineEmits([&#x27;update:isPop&#x27;]);// 修改值isPop.value = true 2.onClickOutside 关闭模态 12345678910&lt;button @click=&quot;open = true&quot;&gt; Open Popup &lt;/button&gt; &lt;div class=&quot;popup&quot; v-if=&#x27;open&#x27;&gt; 我是弹窗 &lt;/div&gt; import &#123; onClickOutside &#125; from &#x27;@vueuse/core&#x27; const open = ref(false) // state of our popupconst popup = ref() // template refonClickOutside(popup, () =&gt; &#123; open.value = false&#125;) 3.useTransition 允许我们在一行内平滑地转换数值 步骤： 创建我们的 count ref并将其初始化为零 使用 useTransition 创建 output ref(设置持续时间和转换类型) 更改 count 的值 123456789101112131415161718&lt;template&gt; &lt;h2&gt; &lt;p&gt; Join over &lt;/p&gt; &lt;p&gt; &#123;&#123; Math.round(output) &#125;&#125;+ &lt;/p&gt; &lt;p&gt;Developers &lt;/p&gt; &lt;/h2&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; useTransition, TransitionPresets &#125; from &#x27;@vueuse/core&#x27;const source = ref()const output = useTransition(source, &#123; duration: 3000, transition: TransitionPresets.easeOutExpo,&#125;)source.value = 5000&lt;/script&gt; 4.useRefHistory useRefHistory 跟踪对Ref所做的每一个改变，并将其存储在一个数组中。这使我们能够轻松地为我们的应用程序提供撤销和重做功能。 5.useIntersectionObserver 在确定两个元素是否重叠时，Intersection Observers 非常强大。一个很好的用例是检查元素当前是否在视口中可见。 高级案例-实现switch 功能组件一般比较粗暴简单的办法是if判断，或者component动态组件。 这里我们使用render函数处理slot，动态判断插槽显示。 1234567891011121314151617181920212223242526272829303132333435363738// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &quot;vue&quot;;import VSwitch from &#x27;./components/VSwitch.vue&#x27;const name = ref(&#x27;bar&#x27;)&lt;/script&gt;&lt;template&gt; &lt;v-switch :case=&quot;name&quot;&gt; &lt;template #foo&gt; foo &lt;/template&gt; &lt;template #bar&gt; bar &lt;/template&gt; &lt;template #default&gt; default &lt;/template&gt; &lt;/v-switch&gt;&lt;/template&gt;// VSwitch.vue&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent&#125; from &#x27;vue&#x27;export default defineComponent(&#123; props:[&#x27;case&#x27;], setup(props,&#123;slots&#125;)&#123; return ()=&gt;&#123; if(slots[props.case])&#123; return slots[props.case](); &#125; if(slots[&#x27;default&#x27;])&#123; return slots[&#x27;default&#x27;]() &#125; &#125; &#125;&#125;)&lt;/script&gt;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"博客_Typora","slug":"H_工程热点_博客_Typora","date":"2022-06-25T23:33:16.000Z","updated":"2023-06-13T23:12:04.754Z","comments":true,"path":"2022/06/26/H_工程热点_博客_Typora/","link":"","permalink":"https://fuyunjinglong.github.io/2022/06/26/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%8D%9A%E5%AE%A2_Typora/","excerpt":"","text":"常用用法12345678910111213141516171819202122232425261.代码段&#123;% codeblock %&#125;&#123;% endcodeblock %&#125;2.图片&#123;% img /img/20200302_1_9.png &quot;imgPIC&#x27;alt text&#x27;&quot; %&#125;3.加粗**加粗**4.链接&#123;% link 深入理解分布式事务 http://wwwe/distributed-transaction.html [external] [title] %&#125;5.点点- 风格1- 风格26.换行符末尾两个空格表示换行7.本地图片使用服务器绝对路径/img//img/8.竖线段落使用&gt;回车即可 页面内跳转到指定位置注意：点击跳转必须是ctry+鼠标点击，才能跳转 跳转到任意位置 12[跳转到指定锚点上面](#锚点)&lt;a name=&quot;锚点&quot;&gt; &lt;/a&gt; 跳转到标题位置 1[跳转到标题](#任意标题名) 竖线段落1&gt;加空格即可 目录层级 一、 1. (1.) a.","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"尤雨溪","slug":"H_工程热点_尤雨溪","date":"2022-06-25T23:33:16.000Z","updated":"2023-07-16T03:40:13.595Z","comments":true,"path":"2022/06/26/H_工程热点_尤雨溪/","link":"","permalink":"https://fuyunjinglong.github.io/2022/06/26/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%B0%A4%E9%9B%A8%E6%BA%AA/","excerpt":"","text":"背景：AI大前端技术峰会-尤雨溪 前端框架设计理念与趋势 前端框架设计理念与趋势 开发范式开发范式要解决的问题 高度复杂的场景 大团队规模化开发 长期可维护性 要考虑的问题 API对类型系统的亲和性，如typescript,flow 逻辑拆分，整理和复用的能力,如vue2的超巨型组件，vue3的优化，屎山代码 可重构性 语法简洁度/可读性/上手成本/开发体验 近年来的代表方案 React Hooks Vue Composition API Svelte 3 Reactive Conrtrollers 基于依赖追踪的范式共同点 如：SolidJS,Vue Composition API,Enber的Starbeam 一次调用，符合JS调用直觉 自动追踪依赖，无需手动声明 引用稳定，无需useCallback 基于编译的响应式系统 如：Svelte,Vue Reactivity Transform,solid-labels React Hooks 12345678// 状态const [count,setCount] = useState(0)// 副作用userEffect(()=&gt;&#123;console.log(count)&#125;,[count])// 状态更新setCount(count + 1) 2018年发布 强大的逻辑组合复用能力 相对Class更简洁的用法 在React生态中彻底取代Class 启发一系列新范式的实现，Composition API，Svelte,SolidJS React Hooks的问题 执行原理与原生的JS心智模型冲突，即每次声明的hook都会重复加载执行 不能条件式调用 Stale Closure（过期闭包）的心智负担 必须手动声明useEffecty依赖 如何正确使用useEffect是个复杂问题 需要useMemo/useCallback等手动优化 React团队的改善 userEvent RFC改善 userCallBack的手动优化的问题，用户不需要手动缓存事件函数 新版文档对useEffect更详细的指导 React Forget通过编译时优化避免手动声明依赖-开发中 Vue Composition API 123456// 状态const count = ref(0)// 副作用watchEffect(()=&gt;console.log(count.value))// 状态更新count.value++ 基于Vue内部的响应式系统暴露更多控制权 受React Hooks启发，提供同等级的复用，但避免了Hooks的大部分问题 比Vue原本的Options API更类型友好 通过setup语法糖改善开发体验 Composition API优势 代表了“依赖追踪响应式系统” 和组件机制解耦，可在非组件场景下使用 可追溯到Knockout.js 近年有如Solid.js和Ember Starbeam这样的新实验 Vue Reactivity transform实验性阶段 123456// 状态const count = $ref(0)//使用$的宏函数标记，转换为响应式代码// 副作用watchEffect(()=&gt;console.log(count.value))// 状态更新count.value++ 在“依赖追踪响应式系统”基础上添加“编译时响应式系统” 类似Svelte的简洁语法 遵循JS语义，和类型系统无缝连接 可以同时在组件和普通TS/JS中使用 Svelte 3 123456// 状态let count = 0// 副作用$:console.log(count)// 状态更新count++ 代表了“编译时响应式系统” 通过变量的引用和赋值触发追踪和更新，用法简洁 部分设计违背原生JS语义，如美元符，标记追踪的对象 和组件上下文强耦合，只能在组件中使用 组件外需要使用额外机制，影响重构和复用 Reactive Conrtrollers Google的Lit项目提出的逻辑复用模式 基于Class和Interface的设计，理论上完全和宿主组件实现解耦 Web Components社区试图推广的标准 需要手动触发更新，语法相对繁琐 工具链前端性能杀手 webpack TypeScript 原生语言在前端工具链中的使用 esbuild（Go） SWC（Rust） Bun（Zig） Parcel2（JS/Rust hybrid） Vite（JS/Go hybrid via esbuild） napi-rs（Rust） 原生语言开发是否为常态？ 原生语言更适用于相对稳定情况，否则很难榨取最优性能 原生语言会影响可扩展性，增加社区参与门槛，影响社区发展 JS/原生混合工具链将成为常态 工具链的抽象层次 browserify/webpack/rolllup 专注于打包，抽象层次低 Parcel/Vue-CLI/CRA 专注于应用，抽象层次高 Vite CLI专注于应用，抽象层次高，方便开箱即用 API专注于上层框架，抽象层次中，方便任意定制化 运行机制纯Virtual Dom的性能瓶颈 组件更新粒度的问题，如父组件更新导致一系列所有子组件更新 diff算法效率问题，如由于js引擎太强大了，容易被忽略 内存GC压力，如频繁更新导致旧vdom和新的vdom存储内存的压力 编译时优化 Vue3:配合编译时优化的Virtual Dom，如二进制的flag埋入动态信息，进行fast parse Svelte:模板编译为命令式Dom节点生成+更新代码 Solid:模板编译为静态Dom生成+响应式绑定代码 Vue Vapor Mode 参考Solid的编译策略，目前还是实验原型阶段 仅影响生成代码和底层运行时，不影响API 显著优化运行时大小和内存占用 可在单个组件内使用(保留Virtual Dom兼容)，或全应用启动 上层框架下一代上层框架的通用工具链基础层是Vite Nuxt3 Sveltekit Shopify Hydrogen Astro Qwik FastifyDx Solid Start Laravel新默认前端方案 JS全栈数据的前后打通 Next:getStaticProps/getServerSideProps Nust:API routes+,useFetch+,Top level await Remix:loader/action,+Enhanced,HTML Form 类型的前后端打通 通过显式引入共享类型 自动基于DB schema生成类型 Nuxt 3:自动基于文件布局生成API/路由类型 JS全栈的代价 虽然数据已经渲染出html,但还需要额外发送一份数据用于Hydrate 即使在客户端没有交互的组件依然会被打包发送至客户端 Hydrate影响页面交互指标TTI 掘金夜谈-第一期尤雨溪对话Vue视频地址：尤大对话 尤对吐槽 尤对吐槽 React hooks 的缺点：心智负担，闭包陷阱，useEffect 的依赖项等等. 其实不然。 首先闭包陷阱的由来在于大家对于闭包的理解不够深刻，因此在使用部分 hooks 的时候，对于某些闭包的产生无法感知到。实际上闭包陷阱的逻辑如果成立的话，并不仅仅存在于 React hooks 中，而是存在于 JavaScript 的所有可能出现的场景。特别是匿名函数这种弱感知的场景。 useEffect 的依赖问题其实在我看来不仅不是 hooks 的缺点，反而是 hooks 的优点。useEffect 的依赖项能够帮助我们监听单一数据以驱动多个数据，于是我们就可以借助这个特性完成单数据驱动多数据，再由多数据驱动 UI 的开关思维。能够极大的简化我们的开发，提升开发效率。 Vue3尖锐问题 1.vue3 与 ts 的结合 vue3 与 ts 的结合不够完善的事情。主要是 props 的定义方式与泛型组件的问题。 尤大解释：Props 值定义确实是一个兼容性导致的包袱。但是在 下已经支持直接用 defineProps 类型声明 props 了（自动编译为对应的值声明）。 2.Vue3不支持跨端 Vue 团队没有精力去做这些事情，只有公司级别的体量才有能力去做，因为跨端的支持确实很复杂。 Vue4新变化 vue 会借鉴 solid 的编译模式。solid 是一个摈弃了虚拟 DOM，走编译型路线的框架，别的不说，他的性能是能吊打目前的 Vue 与 React。 郭辉：低代码，无代码 财务公司(金蝶)在低代码做得非常成熟，但是呢，大多数团队都做得不是很好。主要的原因在于许多场景业务逻辑比较复杂，不通用，无法抽象。也就导致了低代码的实现成为了一种愿景。 许多团队在攻克组件渲染这一层的东西，但是实际上这些都是比较简单的，不是项目的核心痛点。也就是说，郭老师觉得他们的方向走错了。 低代码仅仅只适合逻辑抽象比较简单，比较通用的场景。例如发票。业务逻辑抽象比较容易。toB 的业务逻辑是无法解决的。","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"原形原型链继承闭包","slug":"B_JS_原形原型链继承闭包","date":"2022-05-28T23:33:16.000Z","updated":"2024-03-19T23:04:09.126Z","comments":true,"path":"2022/05/29/B_JS_原形原型链继承闭包/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/29/B_JS_%E5%8E%9F%E5%BD%A2%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E9%97%AD%E5%8C%85/","excerpt":"","text":"原型、原型链、继承核心 原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层，组成原型链。 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。说白了就是一个对象可以访问其他对象的属性。 继承存在的意义就是属性共享：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性。 标准js之父在设计js原型、原型链的时候遵从以下两个准则 准则1：原型对象（即Person.prototype）的constructor指向构造函数本身 Person.prototype.constructor == Person // 准则2：实例的-proto-保存着构造函数的prototype即实例（即person01）的-proto-和原型对象指向同一个地方 person01.-proto- == Person.prototype Person.prototype是显示原形属性 person01.-proto-是隐式原形属性,对应新版google中的[[prototype]] 定义原型：proto是对象object的原形属性，所以proto叫对象的原形 原型对象：prototype是函数fn的原形属性，所以prototype叫fn的原形对象。注意原型对象中默认有一个constructor属性，指回该构造函数。 原型链：一句话就是以对象为基准，以proto为连接点，一直到Object.prototype为止的一条链条。(原型链顶层Object.prototype.-proto-=null) 三角恋关系： 官方描述 在 JavaScript 中，实例对象在读取属性时总是先检查私有属性。如果存在，则会返回私有属性值；否则就会检索 prototype 原型；如果找到同名属性，则返回 prototype 原型的属性值。 prototype 原型允许引用其他对象。如果在 prototype 原型中没有找到指定的属性，则 JavaScript 将会根据引用关系，继续检索 prototype 原型对象的 prototype 原型，以此类推。 12345678910111213141516171819202122232425262728293031323334353637// 原型var Test = function()&#123; a:111&#125;Test.prototype.b=222;Object.prototype.c=333;const test = new Test();console.log(test);console.log(test.__proto__);console.log(Test.prototype);console.log(test.__proto__===Test.prototype);//trueconsole.log(Test.prototype.__proto__===Object.prototype);//trueconsole.log(Object.prototype.__proto__);// 顶层null// 原型链test:&#123; a:111, __proto__:Test.prototype=&#123; b:222, __proto__:Object.prototype=&#123; c:333, __proto__:null &#125; &#125;&#125;// 模拟一下js引擎读取对象属性function getProperty(obj, propName) &#123; // 在对象本身查找 if (obj.hasOwnProperty(propName)) &#123; return obj[propName] &#125; else if (obj.__proto__ !== null) &#123; // 如果对象有原型，则在原型上递归查找 return getProperty(obj.__proto__, propName) &#125; else &#123; // 直到找到Object.prototype，Object.prototype.__proto__为null，返回undefined return undefined &#125;&#125; 创建对象对象的创建方式主要有两种，一种是new操作符后跟函数调用，另一种是字面量表示法。(字面量表示法可以理解为语法糖，本质还是new)。 任何一个函数都可以当做构造函数。 1234567891011121314// 惯例，构造函数应以大写字母开头function Person(name) &#123; // 函数内this指向构造的对象 // 构造一个name属性 this.name = name // 构造一个sayName方法 this.sayName = function() &#123; console.log(this.name) &#125;&#125;// 使用自定义构造函数Person创建对象let person = new Person(&#x27;logan&#x27;)person.sayName() // 输出：logan 函数对象的原型链函数都是由Function原生构造函数创建的，所以函数的__proto__属性指向Function的prototype属性。 注意一个特例：Function的proto属性指向Function.prototype 12345let fn = function() &#123;&#125;// 函数（包括原生构造函数）的原型对象为Function.prototypefn.__proto__ === Function.prototype // trueArray.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // true Foo经典原型图 分3条线路分析一清二楚： 第1条路：左上角f1,f2 第2条路：构造函数Foo 第3条路：左侧o1,o2 第4条路：原生构造函数Object和Function 第1条路：左上角f1,f2 123456// f1、f2都是通过new Foo()创建的对象，构造函数为Foo，所以有f1.__proto__ === Foo.prototype// Foo.prototype为普通对象，构造函数为Object，所以有Foo.prototype.__proto === Object.prototype// Object.prototype没有原型对象Object.prototype.__proto__ === null 第2条路：构造函数Foo 1234// Foo是个函数对象，构造函数为FunctionFoo.__proto__ === Function.prototype// Function.prototype为普通对象，构造函数为Object，所以有Function.prototype.__proto__ === Object.prototype 第3条路：左侧o1,o2 对原生构造函数Object创建的o1、o2下手： 12// o1、o2构造函数为Objecto1.__proto__ === Object.prototype 第4条路：原生构造函数Object和Function 1234// 原生构造函数也是函数对象，其构造函数为FunctionObject.__proto__ === Function.prototype// 特例Function.__proto__ === Function.prototype 举一反三instanceof操作符typeof运算符判断基本类型可以，但对引用类型无法判断(函数对象会返回function外，其他都返回object)。 关键一句话：instanceof用于检查右边变量的原型存在于左边变量的原型链上。其实它表示的是一种原型链继承的关系 MDN描述：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 1instanceof`操作符左边是一个对象，右边是一个构造函数，在左边对象的原型链上查找，直到找到右边构造函数的prototype属性就返回`true`，或者查找到顶层`null`（也就是`Object.prototype.__proto__`），就返回`false 实现思路： 首先 instanceof 左侧必须是对象, 才能找到它的原型链 instanceof 右侧必须是函数, 函数才会prototype属性 迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧 123456789101112131415161718192021222324252627282930313233// 手写instanceOf-递归版本function instanceOfMe(obj, Constructor) &#123; // obj 表示左边的对象，Constructor表示右边的构造函数 let leftP = obj.__proto__ // 取对象隐式原型 let rightP = Constructor.prototype // 取构造函数显示原型 // 到达原型链顶层还未找到则返回false if (leftP === null) &#123; return false &#125; // 对象实例的隐式原型等于构造函数显示原型则返回true if (leftP === rightP) &#123; return true &#125; // 查找原型链上一层 return instanceOfMe(obj.__proto__, Constructor)&#125;// 手写instanceOf-非递归版本function instanceOfMe(L, R) &#123; // L 表示左边的对象，R表示右边的构造函数 // 验证如果为基本数据类型，就直接返回false const baseType = [&#x27;string&#x27;, &#x27;number&#x27;,&#x27;boolean&#x27;,&#x27;undefined&#x27;,&#x27;symbol&#x27;] if(baseType.includes(typeof(L))) &#123; return false &#125; let RP = R.prototype; //取 R 的显示原型 L = L.__proto__; //取 L 的隐式原型 while(true)&#123; // 无线循环的写法（也可以使 for(;;) ） if(L === null)&#123; //找到最顶层 return false; &#125; if(L === RP)&#123; //严格相等 return true; &#125; L = L.__proto__; //没找到继续向上一层原型链查找 &#125;&#125; 可以解释令人费解的现象： 1234567891011fn instanceof Object //true// 1. fn.__proto__ === Function.prototype// 2. fn.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototypearr instanceof Object //true// 1. arr.__proto__ === Array.prototype// 2. arr.__proto__.__proto__ === Array.prototype.__proto__ === Object.prototypeObject instanceof Object // true// 1. Object.__proto__ === Function.prototype// 2. Object.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototypeFunction instanceof Function // true// Function.__proto__ === Function.prototype Object.create其实是创建对象的第三种方法，是ES5提供的，原理：将传入的对象作为原型 123456// 手写Object.createfunction createObj(proto) &#123; function F() &#123;&#125; F.prototype = proto return new F()&#125; new操作符四件事： 1.创建一个空对象 2.把该对象的__proto__属性指向Sub.prototype 3.让构造函数里的this指向新对象，然后执行构造函数， 4.返回该对象 依然来模拟实现一下： 123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)(&#x27;chen&#x27;, 18) // &#123;name: &quot;chen&quot;, age: 18&#125; Function &amp; Object 鸡蛋问题不必深究，鸡蛋问题原文 参考 深入JavaScript系列（六）：原型与原型链 深入理解javascript原型和闭包（完结） 闭包定义闭包是指有权访问另外一个函数作用域中的变量的函数。当内部函数被保存到外部时会产生闭包。 两个核心 是函数 能够访问函数作用域外的变量 三个特性(如何判断是闭包) 闭包一定具有嵌套函数 内层函数一定操作了外层函数的局部变量 外层函数,将内层函数返回到外部(即使外部函数已经返回，闭包仍能访问外部函数定义的变量) 1234567891011121314151617181920212223// 内层函数一定操作了外层函数的局部变量function updateCount()&#123; var count = 0; function getCount(val)&#123; count = val; console.log(count); &#125; return getCount; //外部函数返回&#125;var count = updateCount();count(815); //815count(816); //816// 即使外部函数已经返回，闭包仍能访问外部函数定义的变量function getOuter()&#123; var date = &#x27;815&#x27;; function getDate(str)&#123; console.log(str + date); //访问外部的date &#125; return getDate; //外部函数返回&#125;var today = getOuter();today(&#x27;今天是：&#x27;); //&quot;今天是：815&quot;today(&#x27;明天不是：&#x27;); //&quot;明天不是：815&quot; 为什么需要闭包局部变量无法共享和长久保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久保存变量，又不会造成全局污染，所有有了闭包。 闭包的作用优点： 读取函数内部的变量 让这些变量的值始终保持在内存中 方便调用上下文的局部变量，利于代码封装 缺点：滥用闭包导致内存泄漏，能不用尽量不用，及时释放内存。（闭包会加深作用域链，加长变量查找时间） 闭包的9个使用场景常用场景 实现公有变量 =&gt; 累加器 可以做缓存,存储结构 可以实现封装,属性私有化 模块化开发,防止污染全局变量 9个场景 返回值（最常用） 函数赋值 函数参数 IIFE（自执行函数） 循环赋值 getter和setter 迭代器（执行一次函数往下取一个值） 首次区分（相同的参数，函数不会重复执行） 缓存 1.返回值（最常用） 123456789//1.返回值 最常用的 function fn()&#123; var name=&quot;hello&quot;; return function()&#123; return name; &#125; &#125; var fnc = fn(); console.log(fnc())//hello 2.函数赋值 12345678910var fn2;function fn()&#123; var name=&quot;hello&quot;; //将函数赋值给fn2 fn2 = function()&#123; return name; &#125;&#125;fn()//要先执行进行赋值，console.log(fn2())//执行输出fn2 在闭包里面给fn2函数设置值，闭包的形式把name属性记忆下来，执行会输出 hello。 3.函数参数 12345678910111213function fn()&#123; var name=&quot;hello&quot;; return function callback()&#123; return name; &#125;&#125;var fn1 = fn()//执行函数将返回值（callback函数）赋值给fn1， function fn2(f)&#123; //将函数作为参数传入 console.log(f());//执行函数，并输出&#125;fn2(fn1)//执行输出fn2 用闭包返回一个函数，把此函数作为另一个函数的参数，在另一个函数里面执行这个函数，最终输出 hello 4.IIFE（自执行函数） 123456789101112(function()&#123; var name=&quot;hello&quot;; var fn1= function()&#123; return name; &#125; //直接在自执行函数里面调用fn2，将fn1作为参数传入 fn2(fn1); &#125;)() function fn2(f)&#123; //将函数作为参数传入 console.log(f());//执行函数，并输出 &#125; 直接在自执行函数里面将封装的函数fn1传给fn2，作为参数调用同样可以获得结果 hello 5.循环赋值 123456789//每秒执行1次，分别输出1-10for(var i=1;i&lt;=10;i++)&#123; (function(j)&#123; //j来接收 setTimeout(function()&#123; console.log(j); &#125;,j*1000); &#125;)(i)//i作为实参传入&#125; 如果不采用闭包的话，会有不一样的情况，可以看我自己 闭包 的文章。 6.getter和setter 12345678910111213141516171819function fn()&#123; var name=&#x27;hello&#x27; setName=function(n)&#123; name = n; &#125; getName=function()&#123; return name; &#125; //将setName，getName作为对象的属性返回 return &#123; setName:setName, getName:getName &#125; &#125; var fn1 = fn();//返回对象，属性setName和getName是两个函数 console.log(fn1.getName());//getter fn1.setName(&#x27;world&#x27;);//setter修改闭包里面的name console.log(fn1.getName());//getter 第一次输出 hello 用setter以后再输出 world ，这样做可以封装成公共方法，防止不想暴露的属性和函数暴露在外部。 7.迭代器（执行一次函数往下取一个值） 12345678910111213var arr =[&#x27;aa&#x27;,&#x27;bb&#x27;,&#x27;cc&#x27;];function incre(arr)&#123; var i=0; return function()&#123; //这个函数每次被执行都返回数组arr中 i下标对应的元素 return arr[i++] || &#x27;数组值已经遍历完&#x27;; &#125;&#125;var next = incre(arr);console.log(next());//aaconsole.log(next());//bbconsole.log(next());//ccconsole.log(next());//数组值已经遍历完 8.首次区分（相同的参数，函数不会重复执行） 12345678910111213141516171819var fn = (function()&#123; var arr=[];//用来缓存的数组 return function(val)&#123; if(arr.indexOf(val)==-1)&#123;//缓存中没有则表示需要执行 arr.push(val);//将参数push到缓存数组中 console.log(&#x27;函数被执行了&#x27;,arr); //这里写想要执行的函数 &#125;else&#123; console.log(&#x27;此次函数不需要执行&#x27;); &#125; console.log(&#x27;函数调用完打印一下，方便查看已缓存的数组：&#x27;,arr); &#125; &#125;)(); fn(10); fn(10); fn(1000); fn(200); fn(1000); 可以明显的看到首次执行的会被存起来，再次执行直接取。 9.缓存 123456789101112131415161718192021222324252627282930313233//比如求和操作，如果没有缓存，每次调用都要重复计算，采用缓存已经执行过的去查找，查找到了就直接返回，不需要重新计算 var fn=(function()&#123; var cache=&#123;&#125;;//缓存对象 var calc=function(arr)&#123;//计算函数 var sum=0; //求和 for(var i=0;i&lt;arr.length;i++)&#123; sum+=arr[i]; &#125; return sum; &#125; return function()&#123; var args = Array.prototype.slice.call(arguments,0);//arguments转换成数组 var key=args.join(&quot;,&quot;);//将args用逗号连接成字符串 var result , tSum = cache[key]; if(tSum)&#123;//如果缓存有 console.log(&#x27;从缓存中取：&#x27;,cache)//打印方便查看 result = tSum; &#125;else&#123; //重新计算，并存入缓存同时赋值给result result = cache[key]=calc(args); console.log(&#x27;存入缓存：&#x27;,cache)//打印方便查看 &#125; return result; &#125; &#125;)(); fn(1,2,3,4,5); fn(1,2,3,4,5); fn(1,2,3,4,5,6); fn(1,2,3,4,5,8); fn(1,2,3,4,5,6); 1.闭包结合匿名函数使用，如setTimeout 123456789//原生的setTimeout传递的第一个函数不能带参数 //通过闭包可以实现传参效果 function func(param)&#123; return function()&#123; alert(param) &#125; &#125; var f1 = func(1); setTimeout(f1,1000); 2.参数回调 12345678function changeSize(size)&#123; return function()&#123; document.body.style.fontSize = size + &#x27;px&#x27;; &#125;; &#125; var size12 = changeSize(12); ocument.getElementById(&#x27;size-12&#x27;).onclick = size12; 3.封装变量 1234567891011121314151617181920//用闭包定义能访问私有函数和私有变量的公有函数。 var counter = (function()&#123; var privateCounter = 0; //私有变量 function change(val)&#123; privateCounter += val; &#125; return &#123; increment:function()&#123; //三个闭包共享一个词法环境 change(1); &#125;, decrement:function()&#123; change(-1); &#125;, value:function()&#123; return privateCounter; &#125; &#125;; &#125;)();counter.increment();counter.increment();//2 闭包相关例子 闭包例子1 闭包题一个闭包题 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 奇葩的闭包面试题 1234567891011function fun(n,o) &#123; console.log(o) return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,? 这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。 可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？ 1234//答案：//a: undefined,0,0,0//b: undefined,0,1,2//c: undefined,0,1,1 JS的8种继承方案原型链继承继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototypeSubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;var instance = new SubType();console.log(instance.getSuperValue()); // true 缺点：多个实例对引用类型的操作会被篡改。 12345678910111213function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot; 借用构造函数继承使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型） 1234567891011121314function SuperType()&#123; this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];&#125;function SubType()&#123; //继承自SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.color.push(&quot;black&quot;);alert(instance1.color);//&quot;red,green,blue,black&quot;var instance2 = new SubType();alert(instance2.color);//&quot;red,green,blue&quot;复制代码 核心代码是SuperType.call(this)，创建子类实例时调用SuperType构造函数，于是SubType的每个实例都会将SuperType中的属性复制一份。 缺点： 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现复用，每个子类都有父类实例函数的副本，影响性能 组合继承组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。 123456789101112131415161718192021222324252627282930313233343536function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; // 继承属性 // 第二次调用SuperType() SuperType.call(this, name); this.age = age;&#125;// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27复制代码 缺点： 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。 第二次调用SuperType()：给instance1写入两个属性name，color。 实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。 原型式继承利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。 123456function object(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125;复制代码 object()对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。 123456789101112131415var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;复制代码 缺点： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数 另外，ES5中存在Object.create()的方法，能够代替上面的object方法。 寄生式继承核心：在原型式继承的基础上，增强对象，返回构造函数 12345678function createAnother(original)&#123; var clone = object(original); // 通过调用 object() 函数创建一个新对象 clone.sayHi = function()&#123; // 以某种方式来增强对象 alert(&quot;hi&quot;); &#125;; return clone; // 返回这个对象&#125;复制代码 函数的主要作用是为构造函数新增属性和方法，以增强函数 1234567var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot;复制代码 缺点（同原型式继承）： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数 寄生组合式继承结合借用构造函数传递参数和寄生模式实现继承 1234567891011121314151617181920212223242526272829303132333435function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本 prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性 subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型&#125;// 父类初始化实例属性和原型属性function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new SubType(&quot;xyc&quot;, 23);var instance2 = new SubType(&quot;lxy&quot;, 23);instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]复制代码 这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf() 这是最成熟的方法，也是现在库实现的方法 混入方式继承多个对象12345678910111213141516function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do something&#125;;复制代码 Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。 ES6类继承extendsextends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。 123456789101112131415161718192021222324252627282930313233343536373839404142class Rectangle &#123; // constructor constructor(height, width) &#123; this.height = height; this.width = width; &#125; // Getter get area() &#123; return this.calcArea() &#125; // Method calcArea() &#123; return this.height * this.width; &#125;&#125;const rectangle = new Rectangle(10, 20);console.log(rectangle.area);// 输出 200-----------------------------------------------------------------// 继承class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 this.name = &#x27;Square&#x27;; &#125; get area() &#123; return this.height * this.width; &#125;&#125;const square = new Square(10);console.log(square.area);// 输出 100复制代码 extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样 123456789101112131415161718192021function _inherits(subType, superType) &#123; // 创建对象，创建父类原型的一个副本 // 增强对象，弥补因重写原型而失去的默认的constructor 属性 // 指定对象，将新创建的对象赋值给子类的原型 subType.prototype = Object.create(superType &amp;&amp; superType.prototype, &#123; constructor: &#123; value: subType, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superType) &#123; Object.setPrototypeOf ? Object.setPrototypeOf(subType, superType) : subType.__proto__ = superType; &#125;&#125;复制代码 总结1、函数声明和类声明的区别 函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。 12345let p = new Rectangle(); // ReferenceErrorclass Rectangle &#123;&#125;复制代码 2、ES5继承和ES6继承的区别 ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）. ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。 《javascript高级程序设计》笔记：继承MDN之Object.create()MDN之Class 参考 JavaScript常用八种继承方案","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"Promise进阶","slug":"B_JS_Promise进阶","date":"2022-05-28T23:33:16.000Z","updated":"2023-03-20T14:20:04.187Z","comments":true,"path":"2022/05/29/B_JS_Promise进阶/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/29/B_JS_Promise%E8%BF%9B%E9%98%B6/","excerpt":"","text":"背景在Promise出现前，处理多个异步请求时，使用多层嵌套和同步处理。 带来两个问题： 嵌套调用，第一个函数的输出往往是第二个函数的输入； 处理多个异步请求并发，开发时往往需要同步请求最终的结果。 Promise解决了上述问题： 消灭嵌套调用：通过 Promise 的链式调用可以解决； 合并多个任务的请求结果：使用 Promise.all 获取合并多个任务的错误处理。 Promise是什么 Promise 是异步编程的一种解决方案。将回调函数的异步编程方法转成用relsove和reject触发事件， 用then和catch捕获成功失败的状态执行相应代码 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） 原理 Promise 也是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。 Promise/A+规范Promise 实现遵循了Promise/A+规范,官方站，官方-中文版 规范的核心有2点： Promise对象的状态不受外界影响 一旦状态改变，就不会再变 Promise对象的状态不受外界影响 1Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变 1任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） 手写Promise-核心流程!!!手写Promise/A+ 看了就会，手写Promise原理，最通俗易懂的版本！！！ 核心流程 新建Promise需要使用new关键字，那他肯定是作为面向对象的方式调用的，Promise是一个类。关于JS的面向对象更详细的解释可以看这篇文章。 我们new Promise(fn)的时候需要传一个函数进去，说明Promise的参数是一个函数 构造函数传进去的fn会收到resolve和reject两个函数，用来表示Promise成功和失败，说明构造函数里面还需要resolve和reject这两个函数，这两个函数的作用是改变Promise的状态。 根据规范，promise有pending，fulfilled，rejected三个状态，初始状态为pending，调用resolve会将其改为fulfilled，调用reject会改为rejected。 promise实例对象建好后可以调用then方法，而且是可以链式调用then方法，说明then是一个实例方法。链式调用的实现这篇有详细解释，我这里不再赘述。简单的说就是then方法也必须返回一个带then方法的对象，可以是this或者新的promise实例。 通俗易懂版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 自执行函数+三个状态+then,未处理异步和边界条件const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;function MyPromise(fn) &#123; const that = this this.state = PENDING // value 变量用于保存 resolve 或者 reject 中传入的值 this.value = null // 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 that.fulfilledCallbacks = [] that.rejectedCallbacks = [] function resolve(value) &#123; // 首先两个函数都得判断当前状态是否为等待中 if(that.state === PENDING) &#123; that.state = FULFILLED that.value = value // 遍历回调数组并执行 that.fulfilledCallbacks.map(cb=&gt;cb(that.value)) &#125; &#125; function reject(value) &#123; if(that.state === PENDING) &#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb=&gt;cb(that.value)) &#125; &#125; // 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了 try &#123; fn(resolve,reject) &#125;cach(e)&#123; reject(e) &#125;&#125;// 最后我们来实现较为复杂的 then 函数MyPromise.prototype.then = function(onFulfilled,onRejected)&#123; const that = this // 判断两个参数是否为函数类型，因为这两个参数是可选参数 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : e =&gt; throw e; // 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数 if(this.state === PENDING) &#123; this.fulfilledCallbacks.push(onFulfilled) this.rejectedCallbacks.push(onRejected) &#125; if(this.state === FULFILLED) &#123; onFulfilled(that.value) &#125; if(this.state === REJECTED) &#123; onRejected(that.value) &#125;&#125; 手写Promise-一步一步跟随图解 Promise 实现原理（一）—— 基础实现 极简步骤： 调用 then 方法，将想要在 Promise 异步操作成功时执行的 onFulfilled 放入callbacks队列，其实也就是注册回调函数，可以向观察者模式方向思考； 创建 Promise 实例时传入的函数会被赋予一个函数类型的参数，即 resolve，它接收一个参数 value，代表异步操作返回的结果，当异步操作执行成功后，会调用resolve方法，这时候其实真正执行的操作是将 callbacks 队列中的回调一一执行； 12345678910111213//极简的实现class Promise &#123; callbacks = []; constructor(fn) &#123; fn(this._resolve.bind(this)); &#125; then(onFulfilled) &#123; this.callbacks.push(onFulfilled); &#125; _resolve(value) &#123; this.callbacks.forEach(fn =&gt; fn(value)); &#125;&#125; 调用：设置定时器模拟异步的场景 1234567891011121314let p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;done&#x27;); resolve(&#x27;5秒&#x27;); &#125;, 5000);&#125;);p.then(tip =&gt; &#123; console.log(&#x27;then1&#x27;, tip);&#125;);p.then(tip =&gt; &#123; console.log(&#x27;then2&#x27;, tip);&#125;); 极简+链式调用上一版本缺点： 不能链式调用 解决：只需要在 then 中 return this 即可 12345678910111213141516171819202122232425//极简+链式调用class Promise &#123; callbacks = []; constructor(fn) &#123; fn(this._resolve.bind(this)); &#125; then(onFulfilled) &#123; this.callbacks.push(onFulfilled); return this;//看这里 &#125; _resolve(value) &#123; this.callbacks.forEach(fn =&gt; fn(value)); &#125;&#125;let p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;done&#x27;); resolve(&#x27;5秒&#x27;); &#125;, 5000);&#125;).then(tip =&gt; &#123; console.log(&#x27;then1&#x27;, tip);&#125;).then(tip =&gt; &#123; console.log(&#x27;then2&#x27;, tip);&#125;); 极简+链式调用+延迟机制上一版本缺点： 如果在 then 方法注册 onFulfilled 之前，resolve 就执行了，onFulfilled 就不会执行到了。比如 “同步执行” 打印了，但 “then1” 和 “then2” 没有打印 123456789//同步执行了resolvelet p = new Promise(resolve =&gt; &#123; console.log(&#x27;同步执行&#x27;); resolve(&#x27;同步执行&#x27;);&#125;).then(tip =&gt; &#123; console.log(&#x27;then1&#x27;, tip);&#125;).then(tip =&gt; &#123; console.log(&#x27;then2&#x27;, tip);&#125;); 解决：保证在 resolve 执行之前，then 方法已经注册完所有的回调 步骤： 在 resolve 中增加定时器，通过 setTimeout 机制，将 resolve 中执行回调的逻辑放置到JS任务队列末尾，以保证在 resolve 执行时，then方法的 onFulfilled 已经注册完成。 12345678910111213141516//极简的实现+链式调用+延迟机制class Promise &#123; callbacks = []; constructor(fn) &#123; fn(this._resolve.bind(this)); &#125; then(onFulfilled) &#123; this.callbacks.push(onFulfilled); return this; &#125; _resolve(value) &#123; setTimeout(() =&gt; &#123;//看这里 this.callbacks.forEach(fn =&gt; fn(value)); &#125;); &#125;&#125; 极简+链式调用+延迟机制+状态机制上一版本缺点： 在 resolve 执行后，再通过 then 注册上来的 onFulfilled 都没有机会执行了。我们加了延迟后，then1 和 then2 打印了，但 then3 打印不了。 1234567891011121314let p = new Promise(resolve =&gt; &#123; console.log(&#x27;同步执行&#x27;); resolve(&#x27;同步执行&#x27;);&#125;).then(tip =&gt; &#123; console.log(&#x27;then1&#x27;, tip);&#125;).then(tip =&gt; &#123; console.log(&#x27;then2&#x27;, tip);&#125;);setTimeout(() =&gt; &#123; p.then(tip =&gt; &#123; console.log(&#x27;then3&#x27;, tip); &#125;)&#125;); 解决：引入pending、fulfilled、rejected状态机制 步骤： 当增加完状态之后，原先的_resolve中的定时器可以去掉了。当reolve同步执行时，虽然callbacks为空，回调函数还没有注册上来，但没有关系，因为后面注册上来时，判断状态为fulfilled，会立即执行回调。 12345678910111213141516171819202122//极简的实现+链式调用+延迟机制+状态class Promise &#123; callbacks = []; state = &#x27;pending&#x27;;//增加状态 value = null;//保存结果 constructor(fn) &#123; fn(this._resolve.bind(this)); &#125; then(onFulfilled) &#123; if (this.state === &#x27;pending&#x27;) &#123;//在resolve之前，跟之前逻辑一样，添加到callbacks中 this.callbacks.push(onFulfilled); &#125; else &#123;//在resolve之后，直接执行回调，返回结果了 onFulfilled(this.value); &#125; return this; &#125; _resolve(value) &#123; this.state = &#x27;fulfilled&#x27;;//改变状态 this.value = value;//保存结果 this.callbacks.forEach(fn =&gt; fn(value)); &#125;&#125; 完整+链式调用上一版本缺点： then 方法中 return 了 this,所以所有的then返回的都是同一个Promise实例的值 解决：then函数中返回一个新的Promise实例 步骤： then 方法中，创建并返回了新的 Promise 实例，这是串行Promise的基础，是实现真正链式调用的根本 then 方法传入的形参 onFulfilled 以及创建新 Promise 实例时传入的 resolve 放在一起，被push到当前 Promise 的 callbacks 队列中，这是衔接当前 Promise 和后邻 Promise 的关键所在 根据规范，onFulfilled 是可以为空的，为空时不调用 onFulfilled 1234567891011121314151617181920212223242526272829303132333435//完整的实现class Promise &#123; callbacks = []; state = &#x27;pending&#x27;;//增加状态 value = null;//保存结果 constructor(fn) &#123; fn(this._resolve.bind(this)); &#125; then(onFulfilled) &#123; return new Promise(resolve =&gt; &#123; this._handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125; _handle(callback) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.callbacks.push(callback); return; &#125; //如果then中没有传递任何东西 if (!callback.onFulfilled) &#123; callback.resolve(this.value); return; &#125; var ret = callback.onFulfilled(this.value); callback.resolve(ret); &#125; _resolve(value) &#123; this.state = &#x27;fulfilled&#x27;;//改变状态 this.value = value;//保存结果 this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125;&#125; 完整+原型方法 Promise 原型方法的实现，包括 catch、finally 以及 rejected 状态等的实现。 rejected实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//完整的实现+rejectclass Promise &#123; callbacks = []; state = &#x27;pending&#x27;;//增加状态 value = null;//保存结果 constructor(fn) &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; then(onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; this._handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125; _handle(callback) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.callbacks.push(callback); return; &#125; let cb = this.state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected; if (!cb) &#123;//如果then中没有传递任何东西 cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; cb(this.value); return; &#125; let ret = cb(this.value); cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; cb(ret); &#125; _resolve(value) &#123; if (value &amp;&amp; (typeof value === &#x27;object&#x27; || typeof value === &#x27;function&#x27;)) &#123; var then = value.then; if (typeof then === &#x27;function&#x27;) &#123; then.call(value, this._resolve.bind(this), this._reject.bind(this)); return; &#125; &#125; this.state = &#x27;fulfilled&#x27;;//改变状态 this.value = value;//保存结果 this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125; _reject(error) &#123; this.state = &#x27;rejected&#x27;; this.value = error; this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125;&#125; catch、finally添加到Class上，不需要添加到构造函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Promise &#123; callbacks = []; state = &#x27;pending&#x27;;//增加状态 value = null;//保存结果 constructor(fn) &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; then(onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; this._handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125; catch(onError) &#123; return this.then(null, onError); &#125; finally(onDone) &#123; if (typeof onDone !== &#x27;function&#x27;) return this.then(); let Promise = this.constructor; return this.then( value =&gt; Promise.resolve(onDone()).then(() =&gt; value), reason =&gt; Promise.resolve(onDone()).then(() =&gt; &#123; throw reason &#125;) ); &#125; _handle(callback) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.callbacks.push(callback); return; &#125; let cb = this.state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected; if (!cb) &#123;//如果then中没有传递任何东西 cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; cb(this.value); return; &#125; let ret; try &#123; ret = cb(this.value); cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; &#125; catch (error) &#123; ret = error; cb = callback.reject &#125; finally &#123; cb(ret); &#125; &#125; _resolve(value) &#123; if (value &amp;&amp; (typeof value === &#x27;object&#x27; || typeof value === &#x27;function&#x27;)) &#123; var then = value.then; if (typeof then === &#x27;function&#x27;) &#123; then.call(value, this._resolve.bind(this), this._reject.bind(this)); return; &#125; &#125; this.state = &#x27;fulfilled&#x27;;//改变状态 this.value = value;//保存结果 this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125; _reject(error) &#123; this.state = &#x27;rejected&#x27;; this.value = error; this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125;&#125; 完整+静态方法 Promise 静态方法的实现，包括resolve、reject、all 和 race。 resolve: 123456789101112131415static resolve(value) &#123; if (value &amp;&amp; value instanceof Promise) &#123; return value; &#125; else if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; let then = value.then; return new Promise(resolve =&gt; &#123; then(resolve); &#125;); &#125; else if (value) &#123; return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125; &#125; reject: Promise.reject 与 Promise.resolve 类似，区别在于 Promise.reject 始终返回一个状态的 rejected 的 Promise 实例，而 Promise.resolve 的参数如果是一个 Promise实例的话，返回的是参数对应的 Promise 实例，所以状态不一 定。 12345678910static reject(value) &#123; if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; let then = value.then; return new Promise((resolve, reject) =&gt; &#123; then(reject); &#125;); &#125; else &#123; return new Promise((resolve, reject) =&gt; reject(value)); &#125; &#125; all: Promise.all 接收一个 Promise 实例的数组，在所有这些 Promise 的实例都 fulfilled 后，按照 Promise 实例的顺序返回相应结果的数组。 1234567891011121314151617static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let fulfilledCount = 0 const itemNum = promises.length const rets = Array.from(&#123; length: itemNum &#125;) promises.forEach((promise, index) =&gt; &#123; Promise.resolve(promise).then(result =&gt; &#123; fulfilledCount++; rets[index] = result; if (fulfilledCount === itemNum) &#123; resolve(rets); &#125; &#125;, reason =&gt; reject(reason)); &#125;) &#125;) &#125; race: Promise.race 也接收一个 Promise 实例的数组，与 Promise.all不同的是，所以返回的结果是这些 Promise 实例中最先 fulfilled 的。 1234567891011static race(promises) &#123; return new Promise(function (resolve, reject) &#123; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(function (value) &#123; return resolve(value) &#125;, function (reason) &#123; return reject(reason) &#125;) &#125; &#125;) &#125; 最终完整123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Promise 完整的实现class Promise &#123; callbacks = []; state = &#x27;pending&#x27;;//增加状态 value = null;//保存结果 constructor(fn) &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; then(onFulfilled, onRejected) &#123; return new Promise((resolve, reject) =&gt; &#123; this._handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125; catch(onError) &#123; return this.then(null, onError); &#125; finally(onDone) &#123; if (typeof onDone !== &#x27;function&#x27;) return this.then(); let Promise = this.constructor; return this.then( value =&gt; Promise.resolve(onDone()).then(() =&gt; value), reason =&gt; Promise.resolve(onDone()).then(() =&gt; &#123; throw reason &#125;) ); &#125; static resolve(value) &#123; if (value &amp;&amp; value instanceof Promise) &#123; return value; &#125; else if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; let then = value.then; return new Promise(resolve =&gt; &#123; then(resolve); &#125;); &#125; else if (value) &#123; return new Promise(resolve =&gt; resolve(value)); &#125; else &#123; return new Promise(resolve =&gt; resolve()); &#125; &#125; static reject(value) &#123; if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123; let then = value.then; return new Promise((resolve, reject) =&gt; &#123; then(reject); &#125;); &#125; else &#123; return new Promise((resolve, reject) =&gt; reject(value)); &#125; &#125; static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let fulfilledCount = 0 const itemNum = promises.length const rets = Array.from(&#123; length: itemNum &#125;) promises.forEach((promise, index) =&gt; &#123; Promise.resolve(promise).then(result =&gt; &#123; fulfilledCount++; rets[index] = result; if (fulfilledCount === itemNum) &#123; resolve(rets); &#125; &#125;, reason =&gt; reject(reason)); &#125;) &#125;) &#125; static race(promises) &#123; return new Promise(function (resolve, reject) &#123; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(function (value) &#123; return resolve(value) &#125;, function (reason) &#123; return reject(reason) &#125;) &#125; &#125;) &#125; _handle(callback) &#123; if (this.state === &#x27;pending&#x27;) &#123; this.callbacks.push(callback); return; &#125; let cb = this.state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected; if (!cb) &#123;//如果then中没有传递任何东西 cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; cb(this.value); return; &#125; let ret; try &#123; ret = cb(this.value); cb = this.state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject; &#125; catch (error) &#123; ret = error; cb = callback.reject &#125; finally &#123; cb(ret); &#125; &#125; _resolve(value) &#123; if(this.state !== &#x27;pending&#x27;) return if (value &amp;&amp; (typeof value === &#x27;object&#x27; || typeof value === &#x27;function&#x27;)) &#123; var then = value.then; if (typeof then === &#x27;function&#x27;) &#123; then.call(value, this._resolve.bind(this), this._reject.bind(this)); return; &#125; &#125; this.state = &#x27;fulfilled&#x27;;//改变状态 this.value = value;//保存结果 this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125; _reject(error) &#123; if(this.state !== &#x27;pending&#x27;) return this.state = &#x27;rejected&#x27;; this.value = error; this.callbacks.forEach(callback =&gt; this._handle(callback)); &#125;&#125; 参考 面试官：“你能手写一个 Promise 吗” 阮一峰ES6 张鑫旭-Promise.all、race和any Promise面试题Promise 必知必会（十道题） 【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理) axios cancelToken取消请求使用方式axios 如何取消一个请求提供了两种使用模式： 第一种 调用CancelToken的静态方法source 12345678const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.post(&#x27;/user/12345&#x27;, &#123; name: &#x27;new name&#x27;&#125;, &#123; cancelToken: source.token&#125;)source.cancel(&#x27;Operation canceled by the user.&#x27;); 第二种 自己实例化 1234567let cancel;axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; cancel = c; &#125;)&#125;);cancel(); 其他取消Promise的方法 例如：使用Promise.race() 1234567891011let cancelPromise = null;const p1 = new Promise(resolve,reject)&#123; cancelPromise = resolve;&#125;const p2 = axios.get(&#x27;/api/data&#x27;,&#123; params: params,&#125;);const fetchData = () =&gt; &#123; this.cancelPromise &amp;&amp; this.cancelPromise (); Promise.race(p1,p2).then(callback);&#125; 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// axios/lib/cancel/CancelToken.js&#x27;use strict&#x27;;var Cancel = require(&#x27;./Cancel&#x27;);function CancelToken(executor) &#123; if (typeof executor !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;executor must be a function.&#x27;); &#125; /** * 定义一个将来能执行取消请求的promise对象，当这个promise的状态为完成时(fullfilled), * 就会触发取消请求的操作（执行then函数）。而执行resolve就能将promise的状态置为完成状态。 * 这里把resolve赋值给resolvePromise，就是为了在这个promise外能执行resolve而改变这个promise的状态 * 注意这个promise对象被赋值给CancelToken实例的属性promise，将来定义then函数就是通过这个属性得到promise */ var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); /** * 将CancelToken实例赋值给token * 执行executor函数，将cancel方法传入executor， * cancel方法可调用resolvePromise方法，即触发取消请求的操作 */ var token = this; executor(function cancel(message) &#123; if (token.reason) &#123; // 取消已响应 返回 return; &#125; token.reason = new Cancel(message); // 这里执行的就是promise的resolve方法，改变状态 resolvePromise(token.reason); &#125;);&#125;CancelToken.prototype.throwIfRequested = function throwIfRequested() &#123; if (this.reason) &#123; throw this.reason; &#125;&#125;;// 这里可以看清楚source函数的真面目CancelToken.source = function source() &#123; var cancel; var token = new CancelToken(function executor(c) &#123; // c 就是CancelToken中给executor传入的cancel方法 cancel = c; &#125;); return &#123; token: token, cancel: cancel &#125;;&#125;;module.exports = CancelToken; CancelTokenCancelToken是一个构造函数，通过new CancelToken()得到的是一个实例对象，它只有一个属性promise, 它的值是一个能触发取消请求的Promise对象。 1token = new CancelToken(executor function) ===&gt; &#123; promise: Promise对象 &#125; 执行CancelToken函数做了两件事： 创建一个Promise对象，且将这个对象赋值给promise属性，其resolve参数被暴露出来以备外部引用。 执行executor函数，将内部定义的cancel函数作为参数传递给executor 1234567891011var token = this;var cancel = function (message) &#123; if (token.reason) &#123; // 取消已响应 返回 return; &#125; token.reason = new Cancel(message); // 这里执行的就是promise的resolve方法，改变状态 resolvePromise(token.reason);&#125;executor(cancel); CancelToken.sourceCancelToken.source是一个函数，通过源码可以看到，执行const source = CancelToken.source(),得到的是一个对象： 12345return &#123; token: token, cancel: cancel&#125;;复制代码 包含一个token对象，即CancelToken实例对象，和一个cancel函数。 因此CancelToken.source()函数的作用是生成token对象和取得cancel函数。token对象是用于配置给axios请求中的cancelToken属性，cancel函数是将来触发取消请求的函数。","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"文件上传-拖拽","slug":"B_JS_文件上传-拖拽","date":"2022-05-21T23:33:16.000Z","updated":"2023-05-23T14:05:42.020Z","comments":true,"path":"2022/05/22/B_JS_文件上传-拖拽/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/22/B_JS_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E6%8B%96%E6%8B%BD/","excerpt":"","text":"文件上传-思路前端核心是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，文件的 slice 方法可以返回原文件的某个切片 预先定义好单个切片大小，将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间. 由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序 服务端服务端负责接受前端传输的切片，并在接收到所有切片后合并所有切片 这里又引伸出两个问题 何时合并切片，即切片什么时候传输完成 如何合并切片 第一个问题需要前端配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。或者也可以额外发一个请求，主动通知服务端进行切片的合并 第二个问题，具体如何合并切片呢？这里可以使用 Nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里 talk is cheap,show me the code，接着我们用代码实现上面的思路 文件上传-案例字节跳动-请你实现一个大文件上传和断点续传 Vue 大文件上传和断点续传 前端部分上传控件首先创建选择文件的控件并监听 change 事件，另外就是上传按钮 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt; &lt;el-button @click=&quot;handleUpload&quot;&gt;upload&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; container: &#123; file: null &#125; &#125;), methods: &#123; handleFileChange(e) &#123; const [file] = e.target.files; if (!file) return; Object.assign(this.$data, this.$options.data()); this.container.file = file; &#125;, async handleUpload() &#123;&#125; &#125;&#125;;&lt;/script&gt;复制代码 请求逻辑考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求 12345678910111213141516171819202122request(&#123; url, method = &quot;post&quot;, data, headers = &#123;&#125;, requestList &#125;) &#123; return new Promise(resolve =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); Object.keys(headers).forEach(key =&gt; xhr.setRequestHeader(key, headers[key]) ); xhr.send(data); xhr.onload = e =&gt; &#123; resolve(&#123; data: e.target.response &#125;); &#125;; &#125;); &#125;复制代码 上传切片接着实现比较重要的上传功能，上传需要做两件事 对文件进行切片 将切片传输给服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div&gt; &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt; &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;+ // 切片大小+ // the chunk size+ const SIZE = 10 * 1024 * 1024; export default &#123; data: () =&gt; (&#123; container: &#123; file: null &#125;，+ data: [] &#125;), methods: &#123; request() &#123;&#125;, handleFileChange() &#123;&#125;,+ // 生成文件切片+ createFileChunk(file, size = SIZE) &#123;+ const fileChunkList = [];+ let cur = 0;+ while (cur &lt; file.size) &#123;+ fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);+ cur += size;+ &#125;+ return fileChunkList;+ &#125;,+ // 上传切片+ async uploadChunks() &#123;+ const requestList = this.data+ .map((&#123; chunk，hash &#125;) =&gt; &#123;+ const formData = new FormData();+ formData.append(&quot;chunk&quot;, chunk);+ formData.append(&quot;hash&quot;, hash);+ formData.append(&quot;filename&quot;, this.container.file.name);+ return &#123; formData &#125;;+ &#125;)+ .map((&#123; formData &#125;) =&gt;+ this.request(&#123;+ url: &quot;http://localhost:3000&quot;,+ data: formData+ &#125;)+ );+ // 并发请求+ await Promise.all(requestList); + &#125;,+ async handleUpload() &#123;+ if (!this.container.file) return;+ const fileChunkList = this.createFileChunk(this.container.file);+ this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;+ chunk: file,+ // 文件名 + 数组下标+ hash: this.container.file.name + &quot;-&quot; + index+ &#125;));+ await this.uploadChunks();+ &#125; &#125;&#125;;&lt;/script&gt;复制代码 当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片 createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回 在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片 随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 request 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片 发送合并请求使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并 前端发送额外的合并请求，服务端接受到请求时合并切片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div&gt; &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt; &lt;el-button @click=&quot;handleUpload&quot;&gt;upload&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: () =&gt; (&#123; container: &#123; file: null &#125;, data: [] &#125;), methods: &#123; request() &#123;&#125;, handleFileChange() &#123;&#125;, createFileChunk() &#123;&#125;, async uploadChunks() &#123; const requestList = this.data .map((&#123; chunk，hash &#125;) =&gt; &#123; const formData = new FormData(); formData.append(&quot;chunk&quot;, chunk); formData.append(&quot;hash&quot;, hash); formData.append(&quot;filename&quot;, this.container.file.name); return &#123; formData &#125;; &#125;) .map((&#123; formData &#125;) =&gt; this.request(&#123; url: &quot;http://localhost:3000&quot;, data: formData &#125;) ); await Promise.all(requestList);+ // 合并切片+ await this.mergeRequest(); &#125;,+ async mergeRequest() &#123;+ await this.request(&#123;+ url: &quot;http://localhost:3000/merge&quot;,+ headers: &#123;+ &quot;content-type&quot;: &quot;application/json&quot;+ &#125;,+ data: JSON.stringify(&#123;+ filename: this.container.file.name+ &#125;)+ &#125;);+ &#125;, async handleUpload() &#123;&#125; &#125;&#125;;&lt;/script&gt;复制代码 服务端部分使用 http 模块搭建一个简单服务端 123456789101112131415const http = require(&quot;http&quot;);const server = http.createServer();server.on(&quot;request&quot;, async (req, res) =&gt; &#123; res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); if (req.method === &quot;OPTIONS&quot;) &#123; res.status = 200; res.end(); return; &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;listening port 3000&quot;));复制代码 接受切片使用 multiparty 处理前端传来的 formData 在 multiparty.parse 的回调中，files 参数保存了 formData 中文件，fields 参数保存了 formData 中非文件的字段 12345678910111213141516171819202122232425262728293031323334353637383940414243const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);+ const fse = require(&quot;fs-extra&quot;);+ const multiparty = require(&quot;multiparty&quot;);const server = http.createServer();+ // 大文件存储目录+ const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;);server.on(&quot;request&quot;, async (req, res) =&gt; &#123; res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); if (req.method === &quot;OPTIONS&quot;) &#123; res.status = 200; res.end(); return; &#125;+ const multipart = new multiparty.Form();+ multipart.parse(req, async (err, fields, files) =&gt; &#123;+ if (err) &#123;+ return;+ &#125;+ const [chunk] = files.chunk;+ const [hash] = fields.hash;+ const [filename] = fields.filename;+ // 创建临时文件夹用于临时存储 chunk+ // 添加 chunkDir 前缀与文件名做区分+ const chunkDir = path.resolve(UPLOAD_DIR, &#x27;chunkDir&#x27; + filename);+ if (!fse.existsSync(chunkDir)) &#123;+ await fse.mkdirs(chunkDir);+ &#125;+ // fs-extra 的 rename 方法 windows 平台会有权限问题+ // @see https://github.com/meteor/meteor/issues/7852#issuecomment-255767835+ await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`);+ res.end(&quot;received file chunk&quot;);+ &#125;);&#125;);server.listen(3000, () =&gt; console.log(&quot;listening port 3000&quot;)); 查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename（这里换成了 fs.remove, 因为 fs-extra 的 rename 方法在 windows 平台存在权限问题） 在接受文件切片时，需要先创建临时存储切片的文件夹，以 chunkDir 作为前缀，文件名作为后缀 由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下 合并切片在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const fse = require(&quot;fs-extra&quot;);const server = http.createServer();const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;);+ const resolvePost = req =&gt;+ new Promise(resolve =&gt; &#123;+ let chunk = &quot;&quot;;+ req.on(&quot;data&quot;, data =&gt; &#123;+ chunk += data;+ &#125;);+ req.on(&quot;end&quot;, () =&gt; &#123;+ resolve(JSON.parse(chunk));+ &#125;);+ &#125;);+ // 写入文件流+ const pipeStream = (path, writeStream) =&gt;+ new Promise(resolve =&gt; &#123;+ const readStream = fse.createReadStream(path);+ readStream.on(&quot;end&quot;, () =&gt; &#123;+ fse.unlinkSync(path);+ resolve();+ &#125;);+ readStream.pipe(writeStream);+ &#125;);// 合并切片+ const mergeFileChunk = async (filePath, filename, size) =&gt; &#123;+ const chunkDir = path.resolve(UPLOAD_DIR, &#x27;chunkDir&#x27; + filename);+ const chunkPaths = await fse.readdir(chunkDir);+ // 根据切片下标进行排序+ // 否则直接读取目录的获得的顺序会错乱+ chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);+ // 并发写入文件+ await Promise.all(+ chunkPaths.map((chunkPath, index) =&gt;+ pipeStream(+ path.resolve(chunkDir, chunkPath),+ // 根据 size 在指定位置创建可写流+ fse.createWriteStream(filePath, &#123;+ start: index * size,+ &#125;)+ )+ )+ );+ // 合并后删除保存切片的目录+ fse.rmdirSync(chunkDir);+&#125;;server.on(&quot;request&quot;, async (req, res) =&gt; &#123; res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;); if (req.method === &quot;OPTIONS&quot;) &#123; res.status = 200; res.end(); return; &#125;+ if (req.url === &quot;/merge&quot;) &#123;+ const data = await resolvePost(req);+ const &#123; filename,size &#125; = data;+ const filePath = path.resolve(UPLOAD_DIR, `$&#123;filename&#125;`);+ await mergeFileChunk(filePath, filename);+ res.end(+ JSON.stringify(&#123;+ code: 0,+ message: &quot;file merged success&quot;+ &#125;)+ );+ &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;listening port 3000&quot;));复制代码 由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹 接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是上传时的文件名 随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中 值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start 控制的，目的是能够并发合并多个可读流至可写流中，这样即使并发时流的顺序不同，也能传输到正确的位置 所以还需要让前端在请求的时候提供之前设定好的 size 给服务端，服务端根据 size 指定可读流的起始位置 123456789101112 async mergeRequest() &#123; await this.request(&#123; url: &quot;http://localhost:3000/merge&quot;, headers: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, data: JSON.stringify(&#123;+ size: SIZE, filename: this.container.file.name &#125;) &#125;); &#125;, 其实也可以等上一个切片合并完后再合并下个切片，这样就不需要指定位置，但传输速度会降低，所以使用了并发合并的手段 接着只要保证每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹即可 至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能 显示上传进度条上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现单个切片的进度条 单个切片进度条XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件 12345678910111213141516171819202122232425 // xhr request(&#123; url, method = &quot;post&quot;, data, headers = &#123;&#125;,+ onProgress = e =&gt; e, requestList &#125;) &#123; return new Promise(resolve =&gt; &#123; const xhr = new XMLHttpRequest();+ xhr.upload.onprogress = onProgress; xhr.open(method, url); Object.keys(headers).forEach(key =&gt; xhr.setRequestHeader(key, headers[key]) ); xhr.send(data); xhr.onload = e =&gt; &#123; resolve(&#123; data: e.target.response &#125;); &#125;; &#125;); &#125;复制代码 由于每个切片都需要触发独立的监听事件，所以需要一个工厂函数，根据传入的切片返回不同的监听函数 在原先的前端上传逻辑中新增监听函数部分 12345678910111213141516171819202122232425262728293031323334353637 // 上传切片，同时过滤已上传的切片 async uploadChunks(uploadedList = []) &#123; const requestList = this.data+ .map((&#123; chunk,hash,index &#125;) =&gt; &#123; const formData = new FormData(); formData.append(&quot;chunk&quot;, chunk); formData.append(&quot;hash&quot;, hash); formData.append(&quot;filename&quot;, this.container.file.name);+ return &#123; formData,index &#125;; &#125;)+ .map((&#123; formData,index &#125;) =&gt; this.request(&#123; url: &quot;http://localhost:3000&quot;, data: formData，+ onProgress: this.createProgressHandler(this.data[index]), &#125;) ); await Promise.all(requestList); await this.mergeRequest(); &#125;, async handleUpload() &#123; if (!this.container.file) return; const fileChunkList = this.createFileChunk(this.container.file); this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123; chunk: file,+ index, hash: this.container.file.name + &quot;-&quot; + index+ percentage:0 &#125;)); await this.uploadChunks(); &#125; + createProgressHandler(item) &#123;+ return e =&gt; &#123;+ item.percentage = parseInt(String((e.loaded / e.total) * 100));+ &#125;;+ &#125;复制代码 每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可 总进度条将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 的计算属性 12345678910 computed: &#123; uploadPercentage() &#123; if (!this.container.file || !this.data.length) return 0; const loaded = this.data .map(item =&gt; item.size * item.percentage) .reduce((acc, cur) =&gt; acc + cur); return parseInt((loaded / this.container.file.size).toFixed(2)); &#125; &#125;复制代码 断点续传断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能 前端使用 localStorage 记录已上传的切片 hash 服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片 第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者 生成 hash无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash，所以我们修改一下 hash 的生成规则 webpack 的产物 contenthash 也是基于这个思路实现的 这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值 另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会引起 UI 的阻塞，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互 由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了importScripts 函数用于导入外部脚本，通过它导入 spark-md5 123456789101112131415161718192021222324252627282930313233343536// /public/hash.js// 导入脚本self.importScripts(&quot;/spark-md5.min.js&quot;);// 生成文件 hashself.onmessage = e =&gt; &#123; const &#123; fileChunkList &#125; = e.data; const spark = new self.SparkMD5.ArrayBuffer(); let percentage = 0; let count = 0; const loadNext = index =&gt; &#123; const reader = new FileReader(); reader.readAsArrayBuffer(fileChunkList[index].file); reader.onload = e =&gt; &#123; count++; spark.append(e.target.result); if (count === fileChunkList.length) &#123; self.postMessage(&#123; percentage: 100, hash: spark.end() &#125;); self.close(); &#125; else &#123; percentage += 100 / fileChunkList.length; self.postMessage(&#123; percentage &#125;); // calculate recursively loadNext(count); &#125; &#125;; &#125;; loadNext(0);&#125;;复制代码 在 worker 线程中，接受文件切片 fileChunkList，利用 fileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程 spark-md5 文档中要求传入所有切片并算出 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash 接着编写主线程与 worker 线程通讯的逻辑 12345678910111213141516171819202122232425262728+ // 生成文件 hash（web-worker）+ calculateHash(fileChunkList) &#123;+ return new Promise(resolve =&gt; &#123;+ // 添加 worker 属性+ this.container.worker = new Worker(&quot;/hash.js&quot;);+ this.container.worker.postMessage(&#123; fileChunkList &#125;);+ this.container.worker.onmessage = e =&gt; &#123;+ const &#123; percentage, hash &#125; = e.data;+ this.hashPercentage = percentage;+ if (hash) &#123;+ resolve(hash);+ &#125;+ &#125;;+ &#125;); &#125;, async handleUpload() &#123; if (!this.container.file) return; const fileChunkList = this.createFileChunk(this.container.file);+ this.container.hash = await this.calculateHash(fileChunkList); this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;+ fileHash: this.container.hash, chunk: file, hash: this.container.file.name + &quot;-&quot; + index, percentage:0 &#125;)); await this.uploadChunks(); &#125; 复制代码 主线程使用 postMessage 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash 加上显示计算 hash 的进度条，看起来像这样 至此前端需要将之前用文件名作为 hash 的地方改写为 worker 返回的 hash 服务端则使用固定前缀 + hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名 文件秒传在实现断点续传前先简单介绍一下文件秒传 所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功 文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可 1234567891011121314151617181920212223242526272829303132333435+ async verifyUpload(filename, fileHash) &#123;+ const &#123; data &#125; = await this.request(&#123;+ url: &quot;http://localhost:3000/verify&quot;,+ headers: &#123;+ &quot;content-type&quot;: &quot;application/json&quot;+ &#125;,+ data: JSON.stringify(&#123;+ filename,+ fileHash+ &#125;)+ &#125;);+ return JSON.parse(data);+ &#125;, async handleUpload() &#123; if (!this.container.file) return; const fileChunkList = this.createFileChunk(this.container.file); this.container.hash = await this.calculateHash(fileChunkList);+ const &#123; shouldUpload &#125; = await this.verifyUpload(+ this.container.file.name,+ this.container.hash+ );+ if (!shouldUpload) &#123;+ this.$message.success(&quot;skip upload：file upload success&quot;);+ return;+ &#125; this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123; fileHash: this.container.hash, index, hash: this.container.hash + &quot;-&quot; + index, chunk: file, percentage: 0 &#125;)); await this.uploadChunks(); &#125; 复制代码 秒传其实就是给用户看的障眼法，实质上根本没有上传 服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可 12345678910111213141516171819202122232425262728293031323334353637383940+ // 提取后缀名+ const extractExt = filename =&gt;+ filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length);const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;);const resolvePost = req =&gt; new Promise(resolve =&gt; &#123; let chunk = &quot;&quot;; req.on(&quot;data&quot;, data =&gt; &#123; chunk += data; &#125;); req.on(&quot;end&quot;, () =&gt; &#123; resolve(JSON.parse(chunk)); &#125;); &#125;);server.on(&quot;request&quot;, async (req, res) =&gt; &#123; if (req.url === &quot;/verify&quot;) &#123;+ const data = await resolvePost(req);+ const &#123; fileHash, filename &#125; = data;+ const ext = extractExt(filename);+ const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);+ if (fse.existsSync(filePath)) &#123;+ res.end(+ JSON.stringify(&#123;+ shouldUpload: false+ &#125;)+ );+ &#125; else &#123;+ res.end(+ JSON.stringify(&#123;+ shouldUpload: true+ &#125;)+ );+ &#125; &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;listening port 3000&quot;));复制代码 暂停上传讲完了生成 hash 和文件秒传，回到断点续传 断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传 原理是使用 XMLHttpRequest 的 abort 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法 12345678910111213141516171819202122232425262728293031 request(&#123; url, method = &quot;post&quot;, data, headers = &#123;&#125;, onProgress = e =&gt; e,+ requestList &#125;) &#123; return new Promise(resolve =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.upload.onprogress = onProgress; xhr.open(method, url); Object.keys(headers).forEach(key =&gt; xhr.setRequestHeader(key, headers[key]) ); xhr.send(data); xhr.onload = e =&gt; &#123;+ // 将请求成功的 xhr 从列表中删除+ if (requestList) &#123;+ const xhrIndex = requestList.findIndex(item =&gt; item === xhr);+ requestList.splice(xhrIndex, 1);+ &#125; resolve(&#123; data: e.target.response &#125;); &#125;;+ // 暴露当前 xhr 给外部+ requestList?.push(xhr); &#125;); &#125;,复制代码 这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了 每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存正在上传切片的 xhr 之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片 12345 handlePause() &#123; this.requestList.forEach(xhr =&gt; xhr?.abort()); this.requestList = [];&#125;复制代码 点击暂停按钮可以看到 xhr 都被取消了 恢复上传之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传 由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果 而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果 服务端已存在该文件，不需要再次上传 服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把已上传的文件切片返回给前端 所以我们改造一下之前文件秒传的服务端验证接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const extractExt = filename =&gt; filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length);const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;);const resolvePost = req =&gt; new Promise(resolve =&gt; &#123; let chunk = &quot;&quot;; req.on(&quot;data&quot;, data =&gt; &#123; chunk += data; &#125;); req.on(&quot;end&quot;, () =&gt; &#123; resolve(JSON.parse(chunk)); &#125;); &#125;); + // 返回已上传的所有切片名+ const createUploadedList = async fileHash =&gt;+ fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))+ ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))+ : [];server.on(&quot;request&quot;, async (req, res) =&gt; &#123; if (req.url === &quot;/verify&quot;) &#123; const data = await resolvePost(req); const &#123; fileHash, filename &#125; = data; const ext = extractExt(filename); const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`); if (fse.existsSync(filePath)) &#123; res.end( JSON.stringify(&#123; shouldUpload: false &#125;) ); &#125; else &#123; res.end( JSON.stringify(&#123; shouldUpload: true，+ uploadedList: await createUploadedList(fileHash) &#125;) ); &#125; &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;listening port 3000&quot;));复制代码 接着回到前端，前端有两个地方需要调用验证的接口 点击上传时，检查是否需要上传和已上传的切片 点击暂停后的恢复上传，返回已上传的切片 新增恢复按钮并改造原来上传切片的逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt; &lt;el-button @click=&quot;handleUpload&quot;&gt;upload&lt;/el-button&gt; &lt;el-button @click=&quot;handlePause&quot; v-if=&quot;isPaused&quot;&gt;pause&lt;/el-button&gt;+ &lt;el-button @click=&quot;handleResume&quot; v-else&gt;resume&lt;/el-button&gt; //... &lt;/div&gt;&lt;/template&gt;+ async handleResume() &#123;+ const &#123; uploadedList &#125; = await this.verifyUpload(+ this.container.file.name,+ this.container.hash+ );+ await this.uploadChunks(uploadedList); &#125;, async handleUpload() &#123; if (!this.container.file) return; const fileChunkList = this.createFileChunk(this.container.file); this.container.hash = await this.calculateHash(fileChunkList);+ const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(+ this.container.file.name,+ this.container.hash+ );+ if (!shouldUpload) &#123;+ this.$message.success(&quot;skip upload：file upload success&quot;);+ return;+ &#125; this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123; fileHash: this.container.hash, index, hash: this.container.hash + &quot;-&quot; + index, chunk: file， percentage: 0 &#125;));+ await this.uploadChunks(uploadedList); &#125;, // 上传切片，同时过滤已上传的切片+ async uploadChunks(uploadedList = []) &#123; const requestList = this.data+ .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash)) .map((&#123; chunk, hash, index &#125;) =&gt; &#123; const formData = new FormData(); formData.append(&quot;chunk&quot;, chunk); formData.append(&quot;hash&quot;, hash); formData.append(&quot;filename&quot;, this.container.file.name); formData.append(&quot;fileHash&quot;, this.container.hash); return &#123; formData, index &#125;; &#125;) .map((&#123; formData, index &#125;) =&gt; this.request(&#123; url: &quot;http://localhost:3000&quot;, data: formData, onProgress: this.createProgressHandler(this.data[index]), requestList: this.requestList &#125;) ); await Promise.all(requestList);+ // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片+ if (uploadedList.length + requestList.length === this.data.length) &#123; await this.mergeRequest();+ &#125; &#125;复制代码 这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动 到这里断点续传的功能基本完成了 进度条改进虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差 单个切片进度条由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100% 12345678910111213141516171819202122 async handleUpload() &#123; if (!this.container.file) return; const fileChunkList = this.createFileChunk(this.container.file); this.container.hash = await this.calculateHash(fileChunkList); const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload( this.container.file.name, this.container.hash ); if (!shouldUpload) &#123; this.$message.success(&quot;skip upload：file upload success&quot;); return; &#125; this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123; fileHash: this.container.hash, index, hash: this.container.hash + &quot;-&quot; + index, chunk: file,+ percentage: uploadedList.includes(index) ? 100 : 0 &#125;)); await this.uploadChunks(uploadedList); &#125;,复制代码 uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可 总进度条之前说到总进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题 点击暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有倒退的现象 当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退 解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条 这里我们使用 Vue 的监听属性 1234567891011121314151617181920 data: () =&gt; (&#123;+ fakeUploadPercentage: 0 &#125;), computed: &#123; uploadPercentage() &#123; if (!this.container.file || !this.data.length) return 0; const loaded = this.data .map(item =&gt; item.size * item.percentage) .reduce((acc, cur) =&gt; acc + cur); return parseInt((loaded / this.container.file.size).toFixed(2)); &#125; &#125;, watch: &#123;+ uploadPercentage(now) &#123;+ if (now &gt; this.fakeUploadPercentage) &#123;+ this.fakeUploadPercentage = now;+ &#125; &#125; &#125;,复制代码 当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可 至此一个大文件上传 + 断点续传的解决方案就完成了 文件上传-总结大文件上传 前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片 服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件 原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听 使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度 断点续传 使用 spark-md5 根据文件内容算出文件 hash 通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传） 通过 XMLHttpRequest 的 abort 方法暂停切片的上传 上传前服务端返回已经上传的切片名，前端跳过这些切片的上传 拖拽-张鑫旭极简JS原文 语法 1lwDrag (eleBar, options); 参数说明 eleBar Element，必需，表示可以触发拖拽的元素。 options Object，可选参数。 可选参数 options 为可选参数，支持下面这些： target Element，表示移动的目标元素，默认就是 eleBar 元素。 bounding Object | Element，拖拽范围，如果参数是对象，需要是下面这样的格式：&#123; left: 0, top: 0, bottom: 0, right: 0 &#125; 其中，无论是 left, right 还是 top, bottom 值均是相对于浏览器窗口左边缘和上边缘计算的。如果参数是 DOM 元素，则被限制的拖拽范围就是这个元素。默认值是 window，表示限制范围是整个浏览器窗口。 edgeLock Boolean，表示是否开启边缘范围限制。 onMove Function，拖拽进行中触发，支持两个参数，分别是拖拽目标元素的 left 和 top 定位值。 onEnd Function，拖拽结束的时候触发 使用说明 引入资源 1&lt;script src=&quot;./lwDrag.js&quot;&gt;&lt;/script&gt; ​ 2.执行绑定 12345&lt;script&gt; lxDrag(bar, &#123; target: box &#125;);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150lwDrag.js/*! * @description 简单的拖拽效果，兼容 IE 和 移动端，带边界判断 * 相关内容：https://www.zhangxinxu.com/wordpress/?p=683 * @author zhangxinxu(.com) * @create 2021-12-03 * @license MIT**//** * @param &#123;Element&#125; eleBar 拖拽触发元素 * @param &#123;Object&#125; options 可选参数 * @returns */var lwDrag = function (eleBar, options) &#123; if (!eleBar) &#123; return; &#125; // 默认数据 var defaults = &#123; target: eleBar, bounding: window, edgeLock: true, onMove: function () &#123;&#125;, onEnd: function () &#123;&#125; &#125;; options = options || &#123;&#125;; var params = &#123;&#125;; for (var key in defaults) &#123; if (typeof options[key] != &#x27;undefined&#x27;) &#123; params[key] = options[key]; &#125; else &#123; params[key] = defaults[key]; &#125; &#125; // 拖拽元素 var eleTarget = params.target; // 限制范围 var bounding = params.bounding; var objBounding = bounding; // 事件类型处理 var objEventType = &#123; start: &#x27;mousedown&#x27;, move: &#x27;mousemove&#x27;, end: &#x27;mouseup&#x27; &#125;; if (&#x27;ontouchstart&#x27; in document) &#123; objEventType = &#123; start: &#x27;touchstart&#x27;, move: &#x27;touchmove&#x27;, end: &#x27;touchend&#x27; &#125;; &#125; // 坐标存储数据 var store = &#123;&#125;; eleBar.addEventListener(objEventType.start, function (event) &#123; // IE 拖拽可能拖不动的处理, // 如果不考虑 IE 浏览器，pointerdown pointermove更好！ if (!window.WeakMap || typeof document.msHidden != &#x27;undefined&#x27;) &#123; event.preventDefault(); &#125; // 兼顾移动端 if (event.touches &amp;&amp; event.touches.length) &#123; event = event.touches[0]; &#125; store.y = event.pageY; store.x = event.pageX; store.isMoving = true; store.top = parseFloat(getComputedStyle(eleTarget).top) || 0; store.left = parseFloat(getComputedStyle(eleTarget).left) || 0; if (params.edgeLock === true &amp;&amp; bounding) &#123; if (bounding === window) &#123; objBounding = &#123; left: 0, top: 0, bottom: innerHeight, right: Math.min(innerWidth, document.documentElement.clientWidth) &#125;; &#125; else if (bounding.tagName) &#123; objBounding = bounding.getBoundingClientRect(); &#125; // 拖拽元素的 bounding 位置 var objBoundingTarget = eleTarget.getBoundingClientRect(); // 可移动范围 store.range = &#123; y: [objBounding.top - objBoundingTarget.top, objBounding.bottom - objBoundingTarget.bottom], x: [objBounding.left - objBoundingTarget.left, objBounding.right - objBoundingTarget.right] &#125;; &#125; &#125;); document.addEventListener(objEventType.move, function (event) &#123; if (store.isMoving) &#123; event.preventDefault(); // 兼顾移动端 if (event.touches &amp;&amp; event.touches.length) &#123; event = event.touches[0]; &#125; var distanceY = event.pageY - store.y; var distanceX = event.pageX - store.x; // 边界的判断与chuli if (params.edgeLock === true &amp;&amp; bounding) &#123; var minX= Math.min.apply(null, store.range.x); var maxX = Math.max.apply(null, store.range.x); var minY= Math.min.apply(null, store.range.y); var maxY = Math.max.apply(null, store.range.y); if (distanceX &lt; minX) &#123; distanceX = minX; &#125; else if (distanceX &gt; maxX) &#123; distanceX = maxX; &#125; if (distanceY &lt; minY) &#123; distanceY = minY; &#125; else if (distanceY &gt; maxY) &#123; distanceY = maxY; &#125; &#125; var top = store.top + distanceY; var left = store.left + distanceX; eleTarget.style.top = top + &#x27;px&#x27;; eleTarget.style.left = left + &#x27;px&#x27;; // 回调 params.onMove(left, top); &#125; &#125;, &#123; passive: false &#125;); document.addEventListener(objEventType.end, function () &#123; if (store.isMoving) &#123; store.isMoving = false; params.onEnd(); &#125; &#125;);&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748demo.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;zxxDrag 拖拽演示页面&lt;/title&gt; &lt;style&gt; .box&#123;position:absolute; left:10px; top:50px; padding:5px; background:#f0f3f9; font-size:14px; box-shadow:2px 2px 4px #666666;&#125; .main&#123;border:1px solid #a0b3d6; background:white;&#125; .bar&#123;line-height:2; background:#beceeb; border-bottom:1px solid #a0b3d6; padding: 0 10px; cursor:move;&#125; .content&#123;width:420px; height:250px; padding:10px; max-width: calc(100vw - 60px); background-color: #fff;&#125; .heading&#123;margin-top:90vh;&#125; .container&#123;outline:1px solid; max-width: 414px; height: 300px; background-color: #f5f5f5; position: relative;&#125; .target&#123;width: 100px; height: 100px; background-color: #a0b3d6; opacity: .9; position: absolute;&#125; .target:active&#123;opacity: 1;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; class=&quot;box&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div id=&quot;bar&quot; class=&quot;bar&quot;&gt;拖拽&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 内容…… &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h3 class=&quot;heading&quot;&gt;内部拖拽&lt;/h3&gt; &lt;div id=&quot;container&quot; class=&quot;container&quot;&gt; &lt;div id=&quot;target&quot; class=&quot;target&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./zxxDrag.js&quot;&gt;&lt;/script&gt; &lt;script&gt; zxxDrag(bar, &#123; target: box &#125;); zxxDrag(target, &#123; bounding: container &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖拽-原生实现Mouse事件实现拖拽在h5之前，原生实现拖拽是根据Mouse事件来实现的，需要用到以下这三个事件mousedown,mouseup,mousemove mousedown 事件在指针设备按钮按下时触发。 mouseup事件在指针设备按钮抬起时触发。 当指针设备( 通常指鼠标 )在元素上移动时, mousemove 事件被触发。 JavaScript三大家族 实现代码 原文 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;ball&quot; src=&quot;https://js.cx/clipart/ball.svg&quot; alt=&quot;&quot;&gt; &lt;script&gt; const ball=document.querySelector(&quot;#ball&quot;) ball.onmousedown = function(event) &#123; let shiftX = event.clientX - ball.getBoundingClientRect().left; let shiftY = event.clientY - ball.getBoundingClientRect().top; ball.style.position = &#x27;absolute&#x27;; ball.style.zIndex = 1000; document.body.append(ball); moveAt(event.pageX, event.pageY); // 移动现在位于坐标 (pageX, pageY) 上的球 // 将初始的偏移考虑在内 function moveAt(pageX, pageY) &#123; ball.style.left = pageX - shiftX + &#x27;px&#x27;; ball.style.top = pageY - shiftY + &#x27;px&#x27;; &#125; function onMouseMove(event) &#123; moveAt(event.pageX, event.pageY); &#125; // 在 mousemove 事件上移动球 document.addEventListener(&#x27;mousemove&#x27;, onMouseMove); // 放下球，并移除不需要的处理程序 ball.onmouseup = function() &#123; document.removeEventListener(&#x27;mousemove&#x27;, onMouseMove); ball.onmouseup = null; &#125;; &#125;; ball.ondragstart = function() &#123; return false; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML 拖放（Drag and Drop）HTML 的 drag &amp; drop 使用了 DOM event model 以及从mouse events 继承而来的 drag events 。一个典型的drag操作是这样开始的：用户用鼠标选中一个可拖动的（draggable）元素，移动鼠标到一个可放置的（droppable）元素，然后释放鼠标。 在操作期间，会触发一些事件类型，有一些事件类型可能会被多次触发（比如drag 和 dragover 事件类型） drag: 拖拽源 drop：拖拽源最终放置的目标 DataTransfer 对象：退拽对象用来传递的媒介，使用一般为Event.dataTransfer。 draggable 属性：就是标签元素要设置draggable=true ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上 ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 ondragend 事件：当拖拽完成后触发的事件，此事件作用在被拖曳元素上 Event.preventDefault()方法：阻止默认的些事件方法等执行。在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。另外，如果是从其他应用软件或是文件中拖东西进来，尤其是图片的时候，默认的动作是显示这个图片或是相关信息，并不是真的执行drop。此时需要用用document的ondragover事件把它直接干掉。Event.effectAllowed 属性：就是拖拽的效果。 1&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; font: 16px Arial, Helvetica, sans-serif; &#125; li &#123; width:200px; height: 40px; text-align: center; line-height: 40px; border:1px dashed #cccccc; cursor: pointer; user-select: none; background-color: white; list-style: none; &#125; .more &#123; border-top: 1px dotted rgb(196, 196, 196); font-size: 12px; padding-top: 10px; &#125; .more, .more a &#123; color: rgb(96, 96, 96); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li draggable=&quot;true&quot; ondragend=&quot;dragEnd()&quot; ondragover=&quot;dragOver(event)&quot; ondragstart=&quot;dragStart(event)&quot; &gt; Apples &lt;/li&gt; &lt;li draggable=&quot;true&quot; ondragend=&quot;dragEnd()&quot; ondragover=&quot;dragOver(event)&quot; ondragstart=&quot;dragStart(event)&quot; &gt; Oranges &lt;/li&gt; &lt;li draggable=&quot;true&quot; ondragend=&quot;dragEnd()&quot; ondragover=&quot;dragOver(event)&quot; ondragstart=&quot;dragStart(event)&quot; &gt; Bananas &lt;/li&gt; &lt;li draggable=&quot;true&quot; ondragend=&quot;dragEnd()&quot; ondragover=&quot;dragOver(event)&quot; ondragstart=&quot;dragStart(event)&quot; &gt; Strawberries &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var selected; const li = document.createElement(&quot;li&quot;); function dragOver(e) &#123; // 向前拖拽 向后拖拽 // 拖动目标(drop)是不是在拖拽源(drag)的前面 if (isBefore(selected, e.target))&#123; e.target.parentNode.insertBefore(selected, e.target); &#125;else &#123;e.target.parentNode.insertBefore(selected, e.target.nextSibling);&#125; &#125; function dragEnd() &#123; selected = null; &#125; function dragStart(e) &#123; selected = e.target; console.log(selected) &#125; function isBefore(el1, el2) &#123; var cur; if (el2.parentNode === el1.parentNode) &#123; for (cur = el1.previousSibling; cur; cur = cur.previousSibling) &#123; if (cur === el2) return true; &#125; &#125; else return false; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"SSR服务端渲染","slug":"D_框架_SSR服务端渲染","date":"2022-05-18T23:33:16.000Z","updated":"2023-06-13T23:12:04.754Z","comments":true,"path":"2022/05/19/D_框架_SSR服务端渲染/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/19/D_%E6%A1%86%E6%9E%B6_SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/","excerpt":"","text":"渲染的客户端与服务端 六种前端渲染模式客户端逻辑越重，初始化需要执行的 JS 越多，首屏性能就越慢，因而出现了更多的渲染模式探索。 Google开发者大会对于前端渲染的介绍 CSRCSR（Client-side rendering），即客户端渲染，是指用 JS 直接在浏览器里渲染页面，包括数据请求、视图模板、路由在内的所有逻辑都在客户端处理. 渲染流程如下图： P.S.其中出现的 FCP 与 TTI 是两个重要的性能指标： FCP（First Contentful Paint）：用户所请求的内容在屏幕上可见的时间点 TTI（Time To Interactive）：页面可交互的时间点 主要缺陷在于随着应用程序的更新迭代，客户端所要执行 JS 代码量越来越多，前置的第三方类库/框架、polyfill 等都会在一定程度上拖慢首屏性能，在（中低端）移动设备上尤为明显 Code splitting、lazy-load等优化措施能够缓解一部分，但优化空间相对有限，无助于从根本上解决问题 此时，只有改变渲染模式才能创造更多的可能性。 简而言之，SSR强在首屏渲染。而CSR强在用户和页面多交互的场景。 SSR前言SSR（Server-Side Rendering）前后端分层之前很长的一段时间里都是以服务端渲染为主（JSP、PHP），在服务端生成完整的 HTML 页面： 省去了客户端二次请求数据的网络开销，以及渲染视图模板的性能负担。与 CSR 相比，其 FCP、TTI 通常会更快： P.S.另一方面，服务端的网络环境要优于客户端，内部服务器之间通信路径也更短 因为页面逻辑（包括即时数据请求）和模板渲染工作都放在服务端完成，减少了客户端的 JS 代码量，流式文档解析（streaming document parsing）等浏览器优化机制也能发挥其作用，在低端设备和弱网情况下表现更好。但在服务器上生成页面同样需要时间，会导致页面内容响应时间（TTFB, Time to First Byte）变慢 一种办法是可以通过流式 SSR、组件级缓存、模板化、HTML 缓存等技术来进一步优化 另一种办法是继续在渲染模式上探索，采用静态渲染（Static Rendering） SSR 的困境 SSR 那么优秀，但是为什么却没能成为 Web 主流的开发模式呢，我想这是因为构建 SSR 应用并不容易： 但当你开始开发一个 SSR 应用时，就已经不在是一个简单的前端开发工程师了，而将被迫成为全栈工程师。交付产物从原来的 JS Bundle 变成了 Node 应用，随之而来的是，需要选型一个 Node 框架，搭建一个 Node 应用，并且应对性能开销、保障应用稳定性等等。 其次，还需要考虑如何让现有的前端代码跑到 Server 端上，虽然类似 React 这些主流的框架都提供了 Server 端渲染的能力，但是，不同端上渲染原理和执行环境的差异，会导致编码上的很多差异，比如在 Node 端调用了 window 变量，那么就会报错了，同样的 Hooks 之类的异步更新机制在 Server 端也不适用。 最后，当你完成应用的开发，还需要考虑这些问题：如何部署环境、如何负载均衡、如何应对服务器宕机、如何应对用户请求峰值等等 因此，虽然 SSR 在性能上完胜 CSR ，但却因为其高昂的开发和维护成本，使人们转而投向 CSR 的怀抱。 三大框架 React、Vue和Angular分别对应Next、Nuxt和Nest Static Rendering将生成 HTML 页面的工作放到编译时，而不必在请求带来时动态完成。为每个 URL 预先单独生成 HTML 文件，并进一步借助CDN加速访问： P.S.SSR 第一部分的 Server Rendering 渲染工作变成了 Streaming 传递静态 HTML 文件 静态渲染也并非完美，其关键问题在于“静态”： 需要为每个 URL 单独生成一份 HTML 文件：对于无法预知所有可能的 URL，或者存在大量不同页面的网站，静态渲染就不那么容易，甚至根本不可行 只适用于偏静态内容：对于动态的、个性化的内容作用不大 另外，还有个与静态渲染相似的概念，叫预渲染（Prerendering） Prerendering主要区别在于，静态渲染得到的页面已经是可交互的，无需在客户端额外执行大量 JS 代码，而预渲染必须经客户端渲染才真正可交互： 也就是说，禁用 JS 后，静态渲染的页面几乎不受影响，而预渲染的页面将只剩下超链接之类的基本功能 RehydrationRehydration： “启动”客户端上的JavaScript视图，以便它们重用服务器渲染的HTML的DOM树和数据。 Rehydration 模式将 CSR 与 SSR 结合起来了，服务端渲染出基本内容后，在客户端进行二次渲染（Rehydration）： 注意bundle.js仍然是全量的 CSR 代码，这些代码执行完毕页面才真正可交互。因此，这种模式下，FP（First Paint）虽然有所提升，但 TTI（Time To Interactive）可能会变慢，因为在客户端二次渲染完成之前，页面无法响应用户输入（被 JS 代码执行阻塞了） 对于二次渲染造成交互无法响应的问题，可能的优化方向是增量渲染（例如React Fiber），以及渐进式渲染/部分渲染 Trisomorphic Rendering如果把Service Worker也考虑进来的话，还有一种涉及三方的渲染模式： SSR + CSR + ServiceWorker rendering = Trisomorphic Rendering 首先通过流式 SSR 渲染初始页面，接着由 Service Worker 根据路由规则，借助 SSR 渲染出目标 HTML 页面： 主要优势在于能够跨三方共享模板渲染和路由控制逻辑： 总结 SSR参考 SSR的利与弊 2020 SSR落地开花的三大机遇 两大优势性能 与 CSR（Client-side rendering）模式相比： 网络链路 省去了客户端二次请求数据的网络传输开销 服务端的网络环境要优于客户端，内部服务器之间通信路径也更短 内容呈现 首屏加载时间（FCP）更快 浏览器内容解析优化机制能够发挥作用 可访问性 对人：古老、特殊的用户设备，比如禁用了 JavaScript 对机器人：爬虫程序等，典型的，搜索引擎SEO、爬虫 六大难题难题 1：如何利用存量 CSR 代码实现同构为了降级、复用、降低迁移成本等目的，通常会采用一套 JavaScript 代码跨客户端、服务端运行的同构方式来实现 SSR，然而，要让现有的 CSR 代码在服务端跑起来，先要解决诸多问题。 客户端依赖：分为 API 依赖和数据依赖两种，比如window/document之类的 JS API、设备相关数据信息（屏幕宽高、字体大小等） 生命周期差异：例如 React 中，componentDidMount在服务端不执行 异步操作不执行：服务端组件渲染过程是同步的，setTimeout、Promise之类的都等不了 依赖库的适配：React、Redux、Dva 等等，甚至还有第三方库等不确定能否跑在 universal 环境，是否需要跨环境共享状态，以状态管理层为例，SSR 要求其 store 必须是可序列化的 两边共享状态：每一份需要共享的状态都要考虑（服务端）如何传递、（客户端）如何接收 难题 2：服务的稳定性和性能要求与客户端程序相比，服务端程序对稳定性和性能的要求严苛得多，例如： 稳定性：异常崩溃、死循环 性能：内存/CPU 资源占用、响应速度（网络传输距离等都要考虑在内） 高可用的 SSR 服务却绝非易事，如何应对大流量/高并发，如何识别故障，如何降级/快速恢复，哪些环节需要加缓存，缓存如何更新。 难题 3：配套设施的建设SSR 最核心的部分是渲染服务，但除此之外还要考虑： 本地开发套件（校验 + 构建 + 预览/HMR + 调试） 发布流程（版本管理） 难题 4：钱的问题引入 SSR 渲染服务，实际上是在网络结构上加了一层节点，而大流量所过之处，每一层都是钱： 难题 5：hydration 的性能损耗客户端接到 SSR 响应之后，为了支持（基于 JavaScript 的）交互功能，仍然需要创建出组件树，与 SSR 渲染的 HTML 关联起来，并绑定相关的 DOM 事件，让页面变得可交互，这个过程称为 hydration。 hydration 所需加载、执行的 JavaScript 代码不见得比 CSR 模式少多少，这部分工作在客户端执行，受限于用户设备的性能，在较差的设备下可能会造成可感知的不可交互时间： CSR：可交互但是没有数据（还在异步请求数据，可能会持续很长） SSR：有数据但是不可交互（拉到 JS 后开始 hydrate 的过程，能看到内容但是不可交互，一般不会持续很长） 难题 6：数据请求服务端同步渲染要求先发请求，拿到数据后才开始渲染组件，那么面临 3 个问题： 数据依赖要从业务组件中剥离出来 缺失客户端公参（包括 cookie 等客户端会默认带上的 header 信息） 两边数据协议不同：服务端可能有更高效的通信方式，比如 RPC 目前主流的 CSR 模式下，数据依赖与业务组件存在紧耦合，要由服务端发起的数据请求全都掺杂在组件生命周期函数中，剥离数据依赖意味着需要同时改造 CSR 代码。公参、数据协议等差异对代码复用、可维护性也提出了一些新的挑战。 三大机遇第一大机遇：Serverless 无服务器计算（serverless computing）将服务器相关的配置管理工作统统交给云供应商去做，以减轻用户管理云资源的负担 对云计算用户而言，Serverless 服务能够（自动）弹性伸缩而无需显式预配资源，不仅免去了云资源的管理负担，还能够按使用情况计费，这一特点在很大程度上解决了“难题 4：钱的问题”：引入 SSR 渲染服务，实际上是在网络结构上加了一层节点，而大流量所过之处，每一层都是钱。将组件渲染逻辑从客户端改到服务器执行，势必会增加成本，但有望通过 Serverless 将个中成本降到最低。 另一方面，Serverless Computing的关键是 FaaS（Function as a Service），由云函数提供常规计算能力：直接运行后端代码，而无需考虑服务器等计算资源以及服务的扩展性、稳定性等问题，甚至连日志、监控、报警等配套设施也都开箱即用 也就是说，喂给 FaaS 一个 JavaScript 函数，就能上线一个高可用的服务，无需操心如何承载大流量（几万 QPS）、如何保障服务稳定可靠……听起来有些跨时代是么，实际上，AWS Lambda、阿里云 FC、腾讯云 SCF 都已经是成熟的商业产品 无状态的模板渲染工作尤其适合用云函数（输入 React/Vue 组件，输出 HTML）来完成，“难题 2：服务的稳定性和性能要求”最关键的后端专业性问题迎刃而解，SSR 面临的技术难题从一个高可用的组件渲染服务缩小到了一个 JavaScript 函数中：与客户端程序相比，服务端程序对稳定性和性能的要求严苛得多。 FaaS 基础设施解决了大部分的性能问题和可用性问题，函数内的稳定性问题可通过纯前端手段解决，至于剩下的响应速度、缓存/缓存更新问题，则需要引入另一个云计算概念——边缘计算。 边缘计算 所谓的边缘计算，就是将计算和数据存储分布到离用户更近的（CDN）节点（或者叫边缘服务器，Edge server）上，节省带宽的同时更快响应用户请求 像传统 CDN 通过缩短静态内容与最终用户之间的物理距离来加速资源访问，同时减少了应用服务器的负载一样，支持边缘计算的 CDN 允许将云函数部署到边缘节点中，加速服务响应，同时依托 CDN 轻松控制缓存策略，甚至能够实现动静分离的边缘流式渲染（ESR）。 第二大机遇：low-code如果说 FaaS 解决了 SSR 落地最核心的服务可用性问题，给 SSR 插上了双翼，那么low-code则是让 SSR 得以冲向天际的助飞跑道 因为low-code 几乎解决了其余的所有难题： 难题 1：如何利用存量 CSR 代码实现同构 难题 2：服务的稳定性和性能要求 难题 3：配套设施的建设 难题 4：钱的问题 难题 5：hydration 的性能损耗 难题 6：数据请求 难题 1：如何利用存量 CSR 代码实现同构 首先，low-code 模式不同于源码开发，现有的 CSR 代码无法直接迁移到 low-code 平台上来，其次，low-code 配置化的开发模式提供了天然的细粒度逻辑拆分和完整的精细控制力，体现在： 细粒度逻辑拆分：各个生命周期函数独立配置 完整的精细控制力：依赖库、生命周期、异步操作、共享状态严格受控，low-code 平台全权控制所填代码的编译时、运行时环境 总之，low-code 轻松解决了源码开发模式下棘手的如何约束写法、如何管控不确定性的问题。 难题 3：配套设施的建设 SSR 最核心的部分是渲染服务，但除此之外还要考虑： 本地开发套件（校验 + 构建 + 预览/HMR + 调试） 发布流程（版本管理） 一整套的工程设施，在 SSR 模式下都需要重新考虑 这些配套设施是 SSR 要解决的问题，low-code 也面临同样的问题，因此，SSR 能够在一定程度上复用 low-code 提供的在线研发链路支持，只对其部分环节进行扩展，降低配套设施建设的成本 难题 5：hydration 的性能损耗 组件作为一层抽象，在提供模块化开发、组件复用等工程价值的同时，也带来了一些问题。典型的，交互逻辑与组件渲染机制绑定在了一起，这是 SSR 需要 hydration 的根本原因： 客户端接到 SSR 响应之后，为了支持（基于 JavaScript 的）交互功能，仍然需要创建出组件树，与 SSR 渲染的 HTML 关联起来，并绑定相关的 DOM 事件，让页面变得可交互，这个过程称为 hydration 也就是说，只要仍然依赖组件这层抽象，hydration 的性能损耗就无可避免。在源码开发模式下，组件无可替代，因为没有与之等价的抽象描述形式。然而，在 low-code 模式下，其输出产物（配置数据）也是一种抽象描述形式，如果能够具有与组件同等的表达力，就完全有可能去掉组件这层抽象，不必再背负 hydration 的性能损耗 另一方面，对于无交互（纯静态展示）、弱交互（静态展示带埋点/跳转）的偏静态场景，low-code 平台也能准确地识别出来，避免不必要的 hydration。 难题 6：数据请求 服务端同步渲染要求先发请求，拿到数据后才开始渲染组件，那么面临 3 个问题： 数据依赖要从业务组件中剥离出来 缺失客户端公参（包括 cookie 等客户端会默认带上的 header 信息） 两边数据协议不同：服务端可能有更高效的通信方式，比如 RPC low-code 开发模式下，数据依赖以配置化的形式录入，天然剥离，客户端公参、数据协议等均可通过 low-code 平台来配置，比如配 HTTP、RPC 两套协议，按环境自动选用。 第三大机遇：5G 网络环境移动时代早期，离线 H5 是业界最佳实践，因为在线页面意味着秒级的加载时间，离线页面有着巨大的加载速度优势 但随着网络环境的发展，离线页面的加载速度优势已经不再是决定性因素（小程序的大爆发足以说明问题），在线页面的动态化特性备受关注，（SSR 无能为力的）离线场景越来越少，SSR 的用武之地越来越多 Vue-SSR实战Vue_SSR服务端渲染Demopackage.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;name&quot;: &quot;ssr1&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;express&quot;: &quot;^4.17.1&quot;, &quot;vue&quot;: &quot;^2.6.12&quot;, &quot;vue-router&quot;: &quot;^3.4.6&quot;, &quot;vue-server-renderer&quot;: &quot;^2.6.12&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;root&quot;: true, &quot;env&quot;: &#123; &quot;node&quot;: true &#125;, &quot;extends&quot;: [ &quot;plugin:vue/essential&quot;, &quot;eslint:recommended&quot; ], &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;babel-eslint&quot; &#125;, &quot;rules&quot;: &#123;&#125; &#125;, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not dead&quot; ]&#125; index.template.html 123456789101112&lt;html&gt; &lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; &#123;&#123;&#123; meta &#125;&#125;&#125; &lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/body&gt;&lt;/html&gt; 一、简单的Vue实例渲染成html字符串，不再加载Vue.js等文件 12345678910111213141516171819202122// 第 1 步：创建一个 Vue 实例，注意这里没有elconst Vue = require(&#x27;vue&#x27;);const app = new Vue(&#123; data: &#123; hello: &#x27;Hello World&#x27;, &#125;, template: `&lt;div&gt;&lt;h1&gt;&#123;&#123;hello&#125;&#125;&lt;/h1&gt;&lt;/div&gt;`,&#125;);// 第 2 步：创建一个 renderer,用于将客户端的Vue实例与服务端数据混合处理const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer();// 第 3 步：renderer将 Vue 实例渲染为 HTML，并返回给前端页面renderer .renderToString(app) .then(html =&gt; &#123; console.log(html); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;);//结果标记为服务端渲染 &lt;div data-server-rendered=&quot;true&quot;&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/div&gt; 二、简单的Vue实例指定模板文件，并传递context上下文变量渲染成html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Vue = require(&#x27;vue&#x27;);//读取需要渲染的模板文件const template = require(&#x27;fs&#x27;).readFileSync(&#x27;./index.template.html&#x27;, &#x27;utf-8&#x27;);//服务端renderer支持引入模板文件const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer(&#123; template,&#125;);//上下文变量，供renderer进行读取写入变量const context = &#123; title: &#x27;vue ssr&#x27;, meta: ` &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt; `,&#125;;const app = new Vue(&#123; data: &#123; hello2: &#x27;Hello World222222222&#x27;, &#125;, //此处会替换模板文件标记的 &lt;!--vue-ssr-outlet--&gt;位置 template: `&lt;div&gt;&lt;h1&gt;&#123;&#123;hello2&#125;&#125;&lt;/h1&gt;&lt;/div&gt;`,&#125;);//服务端renderer支持引入上下文变量renderer .renderToString(app, context) .then(html =&gt; &#123; console.log(html); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;);//结果为：/*&lt;html&gt; &lt;head&gt; &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt; &lt;title&gt;vue ssr&lt;/title&gt; &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt; &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div data-server-rendered=&quot;true&quot;&gt;&lt;h1&gt;Hello World222222222&lt;/h1&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;*/ 三、简单的Vue实例通过express模块渲染成html并在页面显示 123456789101112131415161718192021222324252627282930313233343536373839const Vue = require(&#x27;vue&#x27;);const server = require(&#x27;express&#x27;)();const template = require(&#x27;fs&#x27;).readFileSync(&#x27;./index.template.html&#x27;, &#x27;utf-8&#x27;);const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer(&#123; template,&#125;);const context = &#123; title: &#x27;vue ssr&#x27;, meta: ` &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt; `,&#125;;server.get(&#x27;*&#x27;, (req, res) =&gt; &#123; const app = new Vue(&#123; data: &#123; url: req.url, &#125;, template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`, &#125;); renderer.renderToString(app, context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end(&#x27;Internal Server Error&#x27;); return; &#125; res.end(html); &#125;);&#125;);server.listen(8080, () =&gt; &#123; console.log(&#x27;服务启动成功&#x27;);&#125;);//浏览器地址栏输入http://localhost:8080/PageRenderingCase 四、简单的Vue实例结合router路由渲染页面，切换路由也是服务端处理返回html文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const server = require(&#x27;express&#x27;)();//读取数据和需要填充到&lt;!--vue-ssr-outlet--&gt;占位符的内容const createApp = require(&#x27;./app.js&#x27;);const template = require(&#x27;fs&#x27;).readFileSync(&#x27;./index.template.html&#x27;, &#x27;utf-8&#x27;);const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer(&#123; template,&#125;);const context = &#123; title: &#x27;vue ssr&#x27;, meta: ` &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keyword&quot; content=&quot;vue,ssr&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;vue srr demo&quot;&gt; `,&#125;;const getData = function() &#123; return new Promise((reslove, reject) =&gt; &#123; let str = &#x27;this is a async data!&#x27;; reslove(str); &#125;);&#125;;server.get(&#x27;*&#x27;, async (req, res) =&gt; &#123; let appServer; try &#123; const ctx = &#123; url: req.url, &#125;; // 调用接口获取数据 // 数据传递 ctx.propsData = &#x27;this is a data from props!&#x27;; ctx.asyncData = await getData(); appServer = await new Promise((reslove, reject) =&gt; &#123; console.log(req.url); let &#123; app, router &#125; = createApp(ctx); router.push(req.url); // router回调函数 // 当所有异步请求完成之后就会触发 //服务端匹配路由，匹配到则返回给客户端 router.onReady(() =&gt; &#123; let matchedComponents = router.getMatchedComponents(); console.log(matchedComponents); if (!matchedComponents.length) &#123; return reject(&#123; code: 404, &#125;); &#125; reslove(app); &#125;, reject); &#125;); &#125; catch (error) &#123; console.log(error); &#125; renderer.renderToString(appServer, context, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end(&#x27;Internal Server Error&#x27;); return; &#125; res.end(html); &#125;);&#125;);server.listen(8080, () =&gt; &#123; console.log(&#x27;服务启动成功 http://127.0.0.1:8080&#x27;);&#125;); 其他文件 app.js 12345678910111213141516171819202122232425262728293031323334const Vue = require(&#x27;vue&#x27;);const createRouter = require(&#x27;./router&#x27;);module.exports = context =&gt; &#123; const router = createRouter(); const app = new Vue(&#123; router, data: &#123; message: &#x27;Hello,Vue SSR!&#x27;, propsData: context.propsData, asyncData: context.asyncData, &#125;, template: ` &lt;div&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123;asyncData&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;propsData&#125;&#125;&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/&quot;&gt;home&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/about&quot;&gt;about&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125;); return &#123; app, router, &#125;;&#125;; router.js 123456789101112131415161718192021222324252627282930313233const vueRouter = require(&#x27;vue-router&#x27;);const Vue = require(&#x27;vue&#x27;);Vue.use(vueRouter);module.exports = () =&gt; &#123; return new vueRouter(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/&#x27;, component: &#123; template: `&lt;h1&gt;this is home page&lt;/h1&gt;`, &#125;, name: &#x27;home&#x27;, &#125;, &#123; path: &#x27;/about&#x27;, component: &#123; template: `&lt;h1&gt;this is about page&lt;/h1&gt;`, &#125;, name: &#x27;about&#x27;, &#125;, &#123; path: &#x27;/about1&#x27;, component: &#123; template: `&lt;h1&gt;this is about1 page&lt;/h1&gt;`, &#125;, name: &#x27;about1&#x27;, &#125;, ], &#125;);&#125;; Vue_SSR自定义打包后，核心是生产客户端文件vue-ssr-client-manifest.json和服务端vue-ssr-server-bundle.json，然后访问地址栏。Nuxt解决方案本质也是这个逻辑。 编译脚本为： 12345678&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;build:client&quot;: &quot;vue-cli-service build&quot;, &quot;build:server&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build&quot;, &quot;build:win&quot;: &quot;npm run build:server &amp;&amp; move dist\\\\vue-ssr-server-bundle.json bundle &amp;&amp; npm run build:client &amp;&amp; move bundle dist\\\\vue-ssr-server-bundle.json &amp;&amp; move dist\\\\index.html . &amp;&amp; node server.js&quot;&#125; vue.config.js：配置打包编译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const VueSSRServerPlugin = require(&#x27;vue-server-renderer/server-plugin&#x27;);const VueSSRClientPlugin = require(&#x27;vue-server-renderer/client-plugin&#x27;);const nodeExternals = require(&#x27;webpack-node-externals&#x27;);const merge = require(&#x27;lodash.merge&#x27;);const TARGET_NODE = process.env.WEBPACK_TARGET === &#x27;node&#x27;;const target = TARGET_NODE ? &#x27;server&#x27; : &#x27;client&#x27;;module.exports = &#123; configureWebpack: () =&gt; (&#123; // 将 entry 指向应用程序的 server / client 文件 entry: `./src/entry-$&#123;target&#125;.js`, // 对 bundle renderer 提供 source map 支持 devtool: &#x27;source-map&#x27;, target: TARGET_NODE ? &#x27;node&#x27; : &#x27;web&#x27;, node: TARGET_NODE ? undefined : false, output: &#123; libraryTarget: TARGET_NODE ? &#x27;commonjs2&#x27; : undefined, &#125;, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应用程序依赖模块。可以使服务器构建速度更快， // 并生成较小的 bundle 文件。 // externals: nodeExternals(&#123; // // 不要外置化 webpack 需要处理的依赖模块。 // // 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件， // // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单 // whitelist: [/\\.css$/] // &#125;), optimization: &#123; splitChunks: &#123; chunks: &#x27;async&#x27;, minSize: 30000, minChunks: 2, maxAsyncRequests: 5, maxInitialRequests: 3, &#125;, &#125;, plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()], &#125;), chainWebpack: config =&gt; &#123; config.module .rule(&#x27;vue&#x27;) .use(&#x27;vue-loader&#x27;) .tap(options =&gt; &#123; merge(options, &#123; optimizeSSR: false, &#125;); &#125;); &#125;, // css不要分割打包 css: &#123; extract: false, &#125;,&#125;; entry-client.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; createApp &#125; from &#x27;./main&#x27;;const &#123; app, router, store &#125; = createApp();if (window.__INITIAL_STATE__) &#123; //window.__INITIAL_STATE__全局数据，保存了后台返回的数据 store.replaceState(window.__INITIAL_STATE__);&#125;router.onReady(() =&gt; &#123; // 添加路由钩子函数，用于处理 asyncData. // 在初始路由 resolve 后执行， // 以便我们不会二次预取(double-fetch)已有的数据。 // 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。 router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to); const prevMatched = router.getMatchedComponents(from); // 我们只关心非预渲染的组件 // 所以我们对比它们，找出两个匹配列表的差异组件 let diffed = false; const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = prevMatched[i] !== c); &#125;); console.log(activated); if (!activated.length) &#123; return next(); &#125; // 这里如果有加载指示器 (loading indicator)，就触发 Promise.all( activated.map(c =&gt; &#123; if (c.asyncData) &#123; return c.asyncData(&#123; store, route: to &#125;); &#125; &#125;) ) .then(() =&gt; &#123; // 停止加载指示器(loading indicator) next(); &#125;) .catch(next); &#125;); app.$mount(&#x27;#app&#x27;);&#125;); entry-server.js 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createApp &#125; from &#x27;./main&#x27;;export default context =&gt; &#123; console.log(context); return new Promise((resolve, reject) =&gt; &#123; const &#123; app, router, store &#125; = createApp(); router.push(context.url); router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents(); if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;); &#125; console.log(matchedComponents); // 对所有匹配的路由组件调用 `asyncData()` Promise.all( matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute, &#125;); &#125; &#125;) ) .then(() =&gt; &#123; // 在所有预取钩子(preFetch hook) resolve 后， // 我们的 store 现在已经填充入渲染应用程序所需的状态。 // 当我们将状态附加到上下文， // 并且 `template` 选项用于 renderer 时， // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 console.log(store.state); context.state = store.state; resolve(app); &#125;) .catch(reject); &#125;, reject); &#125;);&#125;; server.js：启动服务，访问编译后文件的部署页面 1234567891011121314151617181920212223242526272829303132333435const serverBundle = require(&#x27;./dist/vue-ssr-server-bundle.json&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const server = express();// 渲染打包后的结果const template = fs.readFileSync(&#x27;./index.template.html&#x27;, &#x27;utf-8&#x27;);// 客户端的manifest.jsonconst clientManifest = require(&#x27;./dist/vue-ssr-client-manifest.json&#x27;);const renderer = require(&#x27;vue-server-renderer&#x27;).createBundleRenderer(serverBundle, &#123; template, clientManifest, // 渲染的时候， 可以找到客户端的js文件, 自动引入到html中&#125;);//引入静态文件 否则运行报错server.use(express.static(path.resolve(__dirname, &#x27;./dist&#x27;)));server.get(&#x27;*&#x27;, (req, res) =&gt; &#123; const context = &#123; title: &#x27;ssr demo&#x27;, url: req.url, &#125;; renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; console.log(err); res.status(500).end(&#x27;Internal Server Error&#x27;); return; &#125; res.end(html); &#125;);&#125;);server.listen(8080, () =&gt; &#123; console.log(&#x27;已监听 localhost:8080&#x27;);&#125;); Nuxt框架基本原理 nuxt 前端路由沿用了history模式，通过history.pushState 更改url，进而局部渲染组件（history router的实现思路是：监听页面中和路由有关的a标签点击事件，阻止默认的跳转行为，然后调用history.pushState()方法，让浏览器记住路由，然后手动更新相应视图。同时为了监听用户手点击浏览器的前进后退按钮，还需要监听popstate事件，动态的修改相应视图) Nuxt基本流程 浏览器访问url 执行store中操作，发起请求数据等 执行中间件，包括读取nuxt.config.js,匹配layout布局，匹配路由和组件 动态路由检测，如_id.vue文件等 加载异步数据，取回数据，asyncData(),fetch() 页面渲染 Nuxt路由 基本路由，动态路由(_id.vue,page/123),嵌套路由，动态嵌套路由 Vuex 状态树 Nuxt.js 会尝试找到 src 目录（默认是应用根目录）下的 store 目录，如果该目录有多个文件存在，则自动进行合并 SEO排名定义 SEO（Search Engine Optimization），中文翻译为“搜索引擎优化”，从本质上来说，其实就是如何迎合搜索引擎的规则，使得网站在搜索结果中能有更好的排名。比如一个PDA行业网站，当用户输入“PDA数据采集器”，在没有进行SEO优化的情况下，也许这个网站排在第2页或者第3页之后，通过用户行为分析，我们得知，用户在搜索的时候，基本80%左右的用户在浏览完第一页之后就会放弃继续浏览，这样对一个公司来说，如何让你的网站排在尽可能靠前的位置，获得更多流量，就意味着能有更多展示公司产品和品牌的机会。简单一句话，SEO就是让网站，在搜索引擎自然排序中能尽量排在靠前的位置。 参考 SEO禅专注SEO优化 台湾加强网站SEO","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"中台是什么","slug":"H_工程热点_中台是什么","date":"2022-05-16T23:33:16.000Z","updated":"2023-03-07T12:22:28.275Z","comments":true,"path":"2022/05/17/H_工程热点_中台是什么/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/17/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"123在有些人眼里：中台就是技术平台，像微服务开发框架、Devops平台、PaaS平台，容器云之类的，人们都叫它“技术中台”。在有些人眼里：中台就是微服务业务平台，像最常见的什么用户中心，订单中心，各种微服务集散地，人们都叫它“业务中台”。在有些人眼里：中台应该是组织的事情，在释放潜能：类似于企业内部资源调度中心和内部创新孵化组织，人们叫它“组织中台”。 中台是因为公司业务在发展到某一阶段时，遇到瓶颈与障碍后，为解决实际问题而提出的解决方案。 “中台”，其实是为前台而生的平台，它存在的唯一目的就是更好的服务前台规模化创新，进而更好的服务用户，使企业真正做到自身能力与用户需求的持续对接* 中台三个特征： 敏捷 业务需求变化快，变更以天甚至更短的频率计算，一个单体大型应用，庞大的开发团队对单一应用的变更变得越来越困难。将大应用变为多个小的应用组合，才能适应外部的快速变化，实现业务的敏捷。 解耦 随着业务的发展，业务系统之间的交互通常会变得越来越复杂。一个功能的修改可能会影响很多方面。只有将需要大量交互的功能独立，从应用中拆解出来，这样可以使得应用之间耦合度大幅下降。 复用 一些公共的能力通过复用，大大提高了开发效率，避免了重复建设。同时使得数据和流程可以集中得以管理和优化。 中台三个层面： 业务层面，数据层面和技术底层。 业务中台 业务服务将业务的公共需求组合成服务，比如电商公司，客户，商品，物流，支付就是公共需要，比如汽车制造商，用户，车辆，订单，交付都是公共需求。将这些公共业务组合成统一的业务服务，供各个业务单元使用。 数据中台 数据服务数据时代，业务中越来越依赖于数据，包含：数据的收集，数据处理，数据算法和分析，报表，以及数据的治理。 技术中台 基础服务通常是底层的服务，面向技术。这些底层技术包括：安全认证，权限管理，流程引擎，门户，消息，通知等等。这些组件通常与业务关联度不大，属于每个应用都需要使用的功能。 01 为什么需要中台？一个是13年马云参观supercell，然后在15年确定了阿里的中台战略；另一个是华为的中台战略转型，也就是那句著名的“让听得见炮火的人指挥战斗”。 中台的产生，并非完全是自顶向下的战略设计，也并非是为了追随某种行业风口，而是随着公司业务高速发展、组织不断膨胀的过程中暴露的种种问题需要被解决。 公司发展到规模后，大约会是两类问题“重复造轮子”和“烟囱式架构”： 一类是，许多业务需求或功能需求高度类似、通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设，导致复用性低、效率低、产研资源浪费、用户体验不统一。 另一类是，早期业务发展过程中，为了解决一些当下的业务问题，垂直的、个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑也非常多，这样导致在新业务、新市场的拓展过程中，系统没法直接复用，甚至没法快速迭代。 02 中台能解决什么问题？很多公司的中台业务，实际业务发展到一定阶段，进入一个瓶颈之后，为了能够应对接下来的问题，才一点一点从内部开始推动解决之前的问题。 中台作为一种产品设计思路，或者系统架构思路，并不受限于公司的规模，理论上讲，任何一家即将或者正在面临业务高速增长的状态时，都很值得利用和借鉴中台的思路，将目前业务当中大量可复用的功能和场景进行梳理，为业务的高速增长做好准备。 03 中台产品经理的挑战一方面，是思维的差异。 很多产品经理并不是从一开始就从事中台相关的事宜，也不是一开始就有中台这样的定位。更多情况下，他们是从前台业务部门，或者以业务为导向的产研部门转型到中台产研部门。 这时，其实要面临很大的思维方式、做事方法的转变。 在业务部门或者以业务为导向的产研部门，最核心的目的就是达成业务目标，要求你速度足够快、功能高效地解决当下的业务问题，当前业务发展的效率是最关键的。 对于中台产品经理来说，必须思考的问题是，这个功能在现在或者将来能满足多少业务场景？如果将来有新的业务出现，是不是能够复用？或者说，需要做多大的调整才可以复用？甚至于，这个功能有没有可能对外输出，提供SaaS化的服务。 另一方面，是环境的变化。 他们可能会将大量的精力耗散于不同部门之间的沟通协调，反复对同一个需求进行确认，很长时间没有明显突破。这个时候，就要求中台产品经理有很强的沟通、协调和协作能力。 并且，因为他们接下来要做的解决方案，是要服务于多个业务。这个时候，需要中台产品经理有很强的逻辑思考能力，看到不同需求之间的共性需求，并提炼出一个产品化的解决方案。 既需要沟通协作的软技能，又需要逻辑抽象的硬思考，这可能才是中台产品经理最有挑战的地方。 小结： 一方面，需要极强的逻辑思维和战略分析能力，能够看到业务当中的关键流程，理解业务接下来的发展方向，并将其转化为产品功能，与研发一起实现。另一方面，又需要极强的沟通和交流能力，能够在与多个业务线，需求、背景、想法各不相同的相关方一起，推动完成相关功能的实现。 04 中台的本质 中台的意图：让业务更好的进行创新、试错，同时大大降低新业务研发成本。 中台的理论基础：前台只是一层皮（这层皮也不仅仅是前端，还可以包括后面的前台领域系统），基础设施只是一套没血肉的骨架，位于中间的看不见的血肉才是软件系统的核心，如果这些血肉每次都要重建，那么将严重阻碍新业务创新、试错的速度。 中台的方法论：和平台方法论并无差异——抽象通用能力+开放设计，这两者比例多大，不好说，这里也不想耍流氓那样用个二八定律去糊弄大家，相信不同的业务场景这个比例多少会有些不同。 中台的本质：四个字——系统复用。复用也分层次，也有复用程度之分，通过抽象出各种配置来支撑定制化这件事的本质也是复用——复用配置系统。 中台的实施原则：专注领域复用能力建设、配置大于研发。这个点看似很简单，但是极具艺术性，配置如何做到化繁为简很关键，如果发现配置复杂度比研发还大，那就瞎了。 05.阿里“大中台、小前台”战略的成与败阿里中台建设之路2016 ATF 阿里技术论坛,负责人玄难阐释了淘宝经历13年的发展: 2003年淘宝事业部成立，推进以淘宝为中心的电商系统。 2008年，从淘宝事业部中抽出了一拨人，成立了天猫（最初期也叫淘宝商城）。天猫瞬间变火，业务话语权飙升，于是晋升成了天猫事业部，与淘宝事业部并驾齐驱。但是由于主要的技术团队都还是淘宝的，所以你懂的，很多公司毛病之一——屁股意识太强，所以天猫的需求优先级总是比不过淘宝自身的。天猫业务团队自然就不爽了。另外，到这个时候，天猫和淘宝的大部分业务系统都是各自建设的，但都是由淘系研发团队负责。 2009年，共享业务事业部应运而生。领导层发现上述的问题后，决定成立一个与淘宝事业部、天猫事业部平级的事业部，用来处理他们的公共业务。这么看起来似乎很棒，但却带来了另一个问题，共享业务事业部自身没有前台业务，自然话语权比较小，所以逐渐演变成一个两头受气、吃力不讨好的角色。纵使研发天天加班，也填满不了铺天盖地的需求。 2010年，基于共享业务搭建的聚划算前台取得了喜人的成绩，从此说话腰杆子都直了。当时集团就要求1688、淘宝、天猫要想上聚划算，必须通过共享业务事业部。目前，阿里集团超过25个业务单元（如淘宝、天猫、聚划算、去啊等）都是基于这个共享业务事业部上构建的。整体架构如下图所示： 2015年年底，集团“大中台，小前台”战略正式启用。逍遥子张勇在邮件里写道：“构建符合DT时代的更创新灵活的‘大中台、小前台’组织机制和业务机制：作为前台的一线业务会更敏捷，更快速适应瞬息万变的市场；中台将集合整个集团的运营数据能力、产品技术能力，对各前台业务形成强力支撑”。 尝到了共享业务事业部的甜头后，加上前往超级细胞获得的灵感，集团大胆的走出了激进的一步——构建集团中台，纳入更多的BU。此时的整个中台的大致结构如下： 其中玄难负责业务中台事业群，致力于构建和推行整个集团的业务中台。 2019年，玄难离职创业，方向为电商中台。坊间一个比较靠谱的说法是：2015年阿里制订了一个15~18的三年中台战略，但到19年还没有任何建树，所以中台大将玄难不得不引咎辞职。 2019年阿里组织架构又进行了调整[9]，如下图所示，中台的影子已悄然不见，取而代之的是出现了很多能力型BU和基础基建，这标志着中台回归本质化——复用，既然是复用，自然是被复用的能力型BU躺在下面，面客业务性BU在上面各自发展。 至今，官方和小道消息都没有具体中台有没有做成的消息，说没有做成吧，淘系电商业务平台（也可以叫中台）确实支撑了好多BU。但是支撑归支撑，要是中台做不大，前台做不小，可能还是达不到管理层的目标。 笔者猜测，由于管理层过度的理想化，导致技术实施时困难重重，毕竟复用性并不是想做多大就可以做多大的，支撑的业务模式越多，抽象出来的通用复用性就越底层。这就达不到小前台的效果，前台还是需要一定规模的研发团队，事实证明，目前阿里的各个BU仍然各自都有着大量的研发团队 阿里中台战略败点分析该部分没有什么参考文献，全部为个人的观点。笔者做软件设计和研发已有12年，作为一名架构师和码农，个人最怕的就是自己因为害怕走出舒适区而陷入“极端陷阱”。 这是一个笔者自己发现和定义的现象：很多时候，绝大多数人会认定一个死理，难以自拔，而究其本质是一旦大脑好不容易发现了某种理解可行时，不想再接受更多的反例，不愿意再去用第一性原则慢慢推导，个人认为这也是一种不想走出舒适区的表现。 陷入极端陷阱后引发的问题是，当时你以一个高层领导的身份急着去拍了一个方案，实际上还有很多细节没想明白，这样大概率的结果就是项目烂尾。 两个致命问题 (1) 中台应当分门别类，因地制宜，全局中台并不适合大集团 阿里集团业务繁杂度远高于超级细胞，中台范围应当细化，不适全局中台。治理小区和治理国家固然有一些类似的点和方法论，但是问题规模变大后，很多小规模下的方法也会变得不再适用，这是一个广泛被认可的观点。 超级细胞的业务范围很专一，就是手游，所以它可以很容易就做成游戏工厂。放到阿里这样的大集团，业务种类繁杂，性质大相径庭，何必强融？像淘宝、一淘、天猫，这些其实换汤不换药，那么即便没有中台战略，架构师也知道很多业务逻辑可以复用，要说阿里架构师没有超级细胞的架构师懂？怎么可能。 参考[7]中提到的第三阶段其实已经在考虑通过搭建业务平台来建设通用业务能力。而管理层想通过打造一个统一的万能中台来支撑所有集团业务前台（参考图8），是未经深度思考的表现，从超级细胞小公司到阿里大集团，业务复杂度规模急剧增大，怎么能照搬模式呢。 正如没有一个架构师可以在新问题上做出百分之一百与实际匹配的架构一样，也不会有一个统一的万能中台能在保证开闭原则的基础上适配所有业务。 总结来说，阿里集团业务繁杂，不能把BU当做前台来构建大中台，每个BU就是一个独立的公司，有着自己独立的业务，根本“小”不了。而为各个BU做的那些通用的东西也是具有局限性的，只能帮助上层BU节省部分研发成本。 过度贪求高度复用，会陷入“强求陷进”——把不该抽象的东西硬是抽象到了一起，结果就是系统的复杂度并没有降低，而是从多个地方搬到了一个地方。因此，管理层想要的“全集团大中台、小前台”，是一种理想主义，注定难以实现。 (2) 全局中台带来的新问题——依赖单点和热点 按上文的理解，中台战略的实际意义更大的是在于提醒所有BU，要尽量的增强能力复用，为BU业务创新营造一个高效低成本的环境。而如果我们把一家大集团的所有主要业务系统都放到一个事业部去管理，就会产生一个新的问题——单点甚至是热点现象。 每个BU甚至业务线都各自有KPI，如果某个BU发现中台无法支撑自己的场景（因为总会有没考虑的情况），那么势必要求中台团队做支撑，需求一多，还得排队，这和BU寻求自身的生存和发展势必是矛盾的。 所以，复用能力涉及的业务范围越大，单点问题就越是严重，单点变热点的概率也就越大。即便中台事业部做的再大，哪怕为每个BU都搞一个小团队去支持，由于所背的KPI和汇报关系并不在所支撑的BU，实践起来总是会存在信息断层。 合理的复用是不会产生热点的，因为正确的抽象聚焦是的领域内的业务，设计思路会无差别的对待所有用户，要么一个用户都没法用，要么所有用户都可以用（无故障的情况下）。 就好比数据库一样，任何一款数据库都不会关注数据的业务属性，电商的数据能存，金融的数据必然也能存。引入数据库就是一种数据存取能力复用——数据库属于基础设施，复用性是必要的。 阿里中台战略的成功之处时至今日，中台的理念已经深入所有互联网人的心，阿里集团各个BU也在打着自己的中台算盘。全局大中台虽未建成，单各个事业部都开始在研发中试着使用中台思维去思考自己的研发体系。中台的理念一定是没错的，只是要因地制宜，切忌一刀切。 早期，大家只会思考基础设施的复用性，产品如各种中间件等，现在大家开始关心另外一个问题了——这个业务能不能做成一个通用能力；又或者，会先问问其他同学——集团是不是有这样的业务能力可以复用过来？这就是一种良性的影响。 中台，未必要大。前台，未必就小。能避免低水平重复性劳动的研发体系，就是可以被称为优秀的研发模式。 企业如何建设适合自己的中台1 中台建设的通用步骤(1) 定义需要快速变化、试错的前台业务（业务线、产品线） 如果您都无法清晰的定义自己的业务线，那么可以先内部脑暴一下。先基于现有的业务线讨论，再继续讨论未来可能发展的业务线。 (2) 领域分析和模块划分 架构师在充分了解了每个业务线后，梳理出每个业务线所需要的业务领域块。这对架构师的要求很高，纯粹的业务架构师可能无法胜任，但是可以参与讨论。 纯业务架构师可能对研发细节欠缺考虑，从而做出形而上无法落地的复用设计。 (3) 识别业务线共性并归类 架构师进行前台业务线归类。通过上文的讨论我们知道中台的本质是复用性设计，那么业务线分类就是把可以大程度进行复用业务逻辑的业务线放到一起。这部分需要资深架构师参与，毕竟这很大程度上是一个经验活。有些不该放到一类的业务线应当分开，比如金融业务和电商业务大相径庭，硬是搞一个团队同时维护两套系统，甚至揉在一个系统里，结果是不会太好的。 (4) 画出领域模块（能力）对齐图 由2、3步骤可以画出一个各业务线所需的领域能力图。把名字相同(或者类似)的领域能力对齐，如下图所示大致的内容为： (5) 严格遵循开闭原则，从底至上的去实施 针对我们上文找出的存在复用可能性的领域（每一列里颜色相同的领域块），架构师需要识别出其边界和专注解决的问题，最后安排不同的产研团队去实施。各个领域块的研发团队在实施时应当尽可能的抽象公共业务逻辑，并且将无法通用的环节做成开放式的。只要按照这个思想创建的系统，即便没有配置后台，上层业务系统对接也是极其轻松的。这里推荐另一篇笔者的文章浅谈微服务体系中的分层设计和领域划分，它讲述的就是一种搭建通用大后端的系统架构，从柔性的定义来看，这也是中台——它可以支撑新业务应用快速研发。在完成了通用能力的搭建后，我们还可以为每个通用能力去构建配置后台，这样可以更快的给前台应用研发提速，配置优于研发带来的好处就是不需要走研发流程就可以完成一定的定制逻辑。 从底而上是要求我们优先实现那些被广泛依赖和公用的通用领域能力，然后再去实现被依赖较少的那些通用领域能力，最后基于这些能力可能还会继续抽象出一些更具有具体业务含义的领域能力。比如资源库存中心搭建好之后，还可以基于它去搭建商品库存中心。这样不仅可以实现效能最优化，也可以避免由于上层抽象不合理带来的重构成本。想象一下，如果我们先竖烟囱，再去抽象他们的公共部分，是不是会带来巨大的重构成本和重构风险。 2 万能工厂要不得“一个强大的集中的流程定制配置后台”是不是企业中台必须要有的部分？个人理解不是必须的，因为互联网业务复杂度规模很大，涉及各种细节，花大代价去整合一个这样的流程配置中台对中小型公司来说是不可取的。前两年阿里内部很火的NBF、TMF框架[10]，可以快速的通过配置和少量研发帮助阿里集团内的其他BU搭建业务项目，说的神乎其神，除了一两个用来打广告的案例之外，真实用的BU并不多，文献[11]对应的知乎回答中也有表达类似看法的。为什么？笔者的答案是“极端陷阱”，只要路子够极端，必定会遇到新的问题，在这一点上，苍天饶过谁？本以为只要把“开闭原则”用到极致，提供通用配置之外，允许需求方编写很多插件接口实现定制化业务，就可以解决任何问题，其实不然。由于要保证灵活和个性化，配置会呈爆炸式增长，多到理解它学习它使用它的成本也到了一个不小的量级，这时候大部分研发会想——还不如我写代码了。而且一旦遇到某些功能不满足业务需要，业务也不想迁就，那么还得依赖这样一个框架去发起新的迭代，这是业务方不想看到的。代码是一种逻辑语言，本质上和配置一样，只是为了保证代码的正确性，需要经过合理的研发环节，比如研发、自测、测试、灰度、上线验证等，这才是让我们抵触研发的根本原因；而一旦配置复杂了，笔者认为结果是一样的，一套配置实例仍然需要经过一定的验证流程才能上线，而为这样的一套大型配置系统去编写在线测试机制，又是一大坨工作量。 所以笔者建议，中台的建设应当围绕单一职责的领域能力去构建，单一能力又可以提供一些简单配置来实现定制化使用（就像一款款的中间件那样），比如我们只需要申请好支付账号和密钥，就可以在系统里集成支付宝了。在这些可以复用的系统能力至上，我们再去定制化构建自己的前台业务系统。如果前台产品明确的话，我们甚至可以搭建自己的产品工厂，专门生产某一商业模式下的产品。这些产品也代表了小前台中的更小前台，也可以反应框定范围内业务模式的不同，业务们也是可以基于这个工厂去玩不同的花样的，只是这样的工厂不能用来生产其他商业模式的产品。反过来说，本来就没啥关系，为啥要管别的商业模式呢？管的越多，工厂本身越复杂，越耽误事，折射到现实中，一般一个工厂只会生产某一种类的产品，但是产品系列可以有多个。折射到超级细胞，它的那套游戏工厂，生产游戏自然没问题，非得让它生产贷款产品，这得多无聊。所以号称自己可以快速搭建某行业任何业务系统的“万能工厂”，多半是陷入了“极端陷阱”，最后只能是舍本逐末，庸人自扰。记得《最强大脑第七季》的某一场比赛，娄云皓对宋佳昌，单位时间内根据解开的“异形谜盘”数量来得分，娄云皓选择了低阶的盘面，而宋佳昌选择的是高阶的盘面，最后娄云皓大获全胜。这个例子告诉我们，过于追求更大复杂度的成功，很可能陷入自己跟自己过不去的尴尬境地。笔者不否认理论上是存在一套全能的系统，仅通过配置就可以完成各类电商的业务系统定制，但也别忘了，当配置足够复杂时，也许写写代码更容易解决问题，毕竟底层通用能力有的话，已经可以极大的提高研发效率了。从这个角度看，低代码平台是有意义的，而无代码平台很可能是一种舍本逐末的解决方案。 中台建设的本质是复用能力建设，能力系统建设应当聚焦某一领域，切实的去解决众多前台业务的某一类复杂性子问题，并封装出简洁的接口提供给前台业务开发使用。万能工厂的做法不可取，这种方法的本质是简单问题复杂化，分布式前台业务的集中式抽象，若是前台业务逻辑本身就相似，那么不用系统工厂也能做的很通用；若是差异很大的前台业务，用了系统工厂可能更难如期交付。举个例子，一个稍经通用设计的商品中心，从日用百货，到飞机大炮，再到房产基金都可以卖！何必去搞一个万能电商工厂，根据所卖的货物不同而生成一套新的电商系统呢？如果担心很多定制化个性化的逻辑无处表达，那就做好基础能力建设，然后一个小团队就可以基于这些通用能力去快速构建出新的电商系统了。笔者有信心，这种方式比搞一个万能电商工厂来的更加现实和经济 各大互联网中台实施现状具体内容参考文献[12]。笔者看完的感受是：广观各大互联网中台建设，都是打着中台的幌子在进行复用性设计战略实施，而且他们的战略实施都有个规律，都是从稳固底部做起，从下至上[12]。似乎只有大阿厂是锚定了一个理想化终态从上至下的大搞特搞的。从腾讯中台定义来看就知道阿厂中台大而泛了，腾讯都是建设了具体的内容中台、用户中台等，而阿厂上来就是业务中台、数据中台和技术中台。不过随着2019年组织结构调整，”大中台、小前台“战略已经无人提及了，提出中台的阿里正在像行业理解的中台前进！这就好比老师跟学生说了某个知识，结果学生理解到了精髓，而老师却曲解了知识本意。互联网业务参差不齐、细节差异大，很难像超级细胞那样搞个超级中台工厂，业务随便来配置一下就可以生成一个新的业务前台了。不如从基础能力复用性做起，建设好通用基础业务领域能力，其他的个性化前台业务还是需要各自的研发团队负责。从本质上看，全局中台没有意义，但能想的很清楚的领域能力一定要提供出来，比如用户、物流、支付、营销、数据管理等，能减轻多少上层的负担是多少，不必逞强。另外，前台业务的研发团队是需要保留的，他们需要基于全局的通用基础能力去构建属于自己业务的“小”中台。 中台由中台能力组成，具体表现为一个个领域系统，叫不叫中台不重要，重要的是这个领域的服务能力是复用的。 总结火极一时的阿里”大中台、小前台“战略折射出的是高层管理者在初尝复用技术的甜头后引发的一系列创造性思考，表明企业的管理者正开始思考自身研发体系的科学性和可持续性。中台的提出是粗犷研发转向精益研发的重要里程碑，就像冷兵器时代早期打仗靠堆人，后面慢慢的演化出高效用兵的兵法。很难想象如果没有中台思想的提出，还有多少公司要陷入研发滚雪球、竖烟囱的状态并且管理层还认为就应该是这样，业务催着要交付产品，研发毫无机会去思考复用性，大家都为着短期的利益做着极端的取舍：前台业务需求第一，不管合不合理，先怼上去，烟囱先竖起来。中台战略，就像是一场革命，革掉了“唯短期利益主义”，当然我们也要避免走入另外一个极端——唯远期利益，这种情况下可能死的更快，对应了过度设计。适合企业的优秀研发架构的实现没有一条黄金定律，架构师和技术TL需要担起这个识别复用点的责任。最后引用一段超级细胞一位开发同学在受采访时说的话[13]：I feel like when you’re chasing short-term goals, you can end up stepping on your own toes —— Seth Allison。 1翻译为：我认为当你追寻短期利益时，你最终会踩到自己的脚趾。文中寓意为超级细胞认为每一款游戏都会运营个20-30年，每次更新变更的内容都会经过充分的讨论。笔者相信，这样的团队在打造自己的游戏研发平台时，注定也会去追求了一个中长期的目标，围绕这个目标小步快跑。 参考“中台”到底是什么？ 大中台的黄粱一梦和复用性设计的繁荣盛世 [浅谈双十一背后的支付宝LDC架构和其CAP分析](","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"TCP的网络拆包粘包","slug":"F_计算机网络_TCP的网络拆包粘包","date":"2022-05-16T23:33:16.000Z","updated":"2022-12-11T10:00:26.740Z","comments":true,"path":"2022/05/17/F_计算机网络_TCP的网络拆包粘包/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/17/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_TCP%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85/","excerpt":"","text":"什么是粘包、拆包由于TCP传输协议是面向字节流的传输协议，没有消息保护边界，所以发送方发送的多个数据包，接收方应用层不知如何区分，可能会被当成一个包来处理，这就是粘包；或者，发送方将一个打包分成多个小包发送，而接收方将它们当成多个包进行处理，这就是拆包。 TCP传输的四种情况： 客户端向服务器发送了两个包，两个数据包之间互不影响，这是正常的，我们不需要管； 客户端向服务器发送了两个包，但是两个包被并在了一起，当作一个包发送，这就是发生了粘包现象，服务器可能会将它们当成一个数据包处理； 客户端向服务器发送了两个包D1和D2，但是D2的一部分与D1合并在了一起，发生了粘包，而D2另一部分被单独发送，也就是说D2被拆分成了两个小包，发生了拆包现象； 第四种情况和第三种类似，只是顺序反了一下，D1发生了拆包，而D1的后半部分与D2发生了粘包； 以下几种情况： 正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包； 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送； 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送； 拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。 粘包发生的原因（1）套接字缓冲区 应用层需要发送数据时，假设是基于TCP发送，则会将数据交给TCP套接字。数据被放入套接字发送缓存中，由于各种原因，往往不会立即发送，比如数据来的太快，还来不及发送。这就导致在发送缓存中，可能存在多个不同的数据包的字节并排在一起。当TCP需要发送数据时，会从发送缓存中读取一段字节，封装成TCP报文段发送出去，而读取的这些字节，可能属于多个数据包。 在接收端，TCP接收到的数据也会被放入套接字的接收缓冲区中，再由应用层进行读取。但是，应用层可能并不会立即读取缓冲区中的数据，或者来不及读取，此时就会造成多个数据包同时在缓冲区中。因为没有划定边界，所以应用层也无法将它们拆分开来，而是一同读取，这就会造成粘包。 （2）Nagle算法 TCP的发送方每次发送报文段，都希望能包含尽量多的字节，这样可以最大限度的利用网络带宽。假设发送方需要要向接收方发送一个字节的数据，经过运输层和网络层的封装后，将会为这一个字节加上40个字节的首部，这是一种非常浪费的情况，而Nagle算法正是为了减少这种情况。 Nagle算法是基本原则就是：在任意时刻，只能有一个未被确认的小段报文。未被确认就是已经发送，但是还没有接收到ACK的报文段，而小段报文指的是没有达到网络最大传输单元的报文段。使用Nagle算法时，会尽量地将一些小段凑成一个大段进行发送，而这就导致了粘包现象的发生。 拆包发生的原因（1）最大报文段长度MSS、最大传输单元MTU MSS表示一个TCP报文段能够承载数据的最大字节数，而MTU则是网络传输种能够接受的报文的最大长度。这两个概念说明网络传输中，每个报文能够承载的数据是有限的。TCP为了能将数据发送出去，且每个报文中的数据不超过MSS，会将一个大的数据包分为多个小段，为每个段加上首部后逐一发送，而这就造成了拆包。比如说，对于一张图片，一般都需要拆分成多个段进行发送。 （2）TCP滑动窗口 TCP采用了流水线的传输机制，而流水线传输中通过维护一个窗口来限制数据的发送，也可以叫做一个区间。只有序号落在窗口中的那些字节，才允许被发送。而窗口是动态变化的，它受到网络拥塞情况以及接收方缓冲区剩余空间的限制。如果当前要发送的数据包的长度，大于窗口中的剩余空间，那这个数据包就会被拆分，先发送一部分，这样也就造成了拆包。 如何解决拆包粘包解决拆包/粘包的唯一方法：定义应用层的通信协议 TCP可以保证完整，并且按序地接收字节，但是并不会帮忙拆分多个包的字节，真正做这个工作的是应用层的协议，应用层负责解决粘包和拆包。 消息长度固定每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。 12345+----+------+------+---+----+| AB | CDEF | GHIJ | K | LM |+----+------+------+---+----+ 假设我们的固定长度为 4 字节，那么如上所示的 5 条数据一共需要发送 4 个报文： 12345+------+------+------+------+| ABCD | EFGH | IJKL | M000 |+------+------+------+------+ 消息定长法使用非常简单，但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用。 特定分隔符既然接收方无法区分消息的边界，那么我们可以在每次发送报文的尾部加上特定分隔符，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符 \\n 按行解析，即可得到 AB、CDEF、GHIJ、K、LM 五条原始报文。 12345+-------------------------+| AB\\nCDEF\\nGHIJ\\nK\\nLM\\n |+-------------------------+ 由于在发送报文时尾部需要添加特定分隔符，所以对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。否则可能出现错误的消息拆分。比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。特定分隔符法在消息协议足够简单的场景下比较高效，例如大名鼎鼎的 Redis 在通信过程中采用的就是换行分隔符。 消息长度 + 消息内容1234567消息头 消息体+--------+----------+| Length | Content |+--------+----------+ 消息长度 + 消息内容是项目开发中最常用的一种协议，如上展示了该协议的基本格式。消息头中存放消息的总长度，例如使用 4 字节的 int 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 Len，然后紧接着读取长度为 Len 的字节数据，该数据即判定为一个完整的数据报文。依然以上述提到的原始字节数据为例，使用该协议进行编码后的结果如下所示： 12345+-----+-------+-------+----+-----+| 2AB | 4CDEF | 4GHIJ | 1K | 2LM |+-----+-------+-------+----+-----+ 消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。 为什么UDP没有粘包？粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。 Netty对粘包和拆包问题的处理Netty对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如： LineBasedFrameDecoder：以行为单位进行数据包的解码； DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码； FixedLengthFrameDecoder：以固定长度进行数据包的解码； LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）； 参考[计算机网络——浅析TCP粘包，拆包发生的原因以及解决方式](","categories":[{"name":"F_计算机网络","slug":"F-计算机网络","permalink":"https://fuyunjinglong.github.io/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"职业规划","slug":"Z_业务和面经_职业规划","date":"2022-05-12T23:33:16.000Z","updated":"2024-06-01T12:01:32.700Z","comments":true,"path":"2022/05/13/Z_业务和面经_职业规划/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/13/Z_%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F_%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/","excerpt":"","text":"学习路线(包括前端)大黑书有一个共同点就是厚、并且很适合盖泡面。哪有人开始打牌的时候就出王炸的呢 前端架构师亲述：前端工程师成长之路的 N 问 及 回答 前言 掌握基本的编程概念和语言：在开始学习前端开发之前，需要学习基本的编程概念和语言，例如HTML、CSS和JavaScript。建议您先学习HTML和CSS，因为这两种语言是构建网站和应用程序的基础。然后，再学习JavaScript，因为它是使网站和应用程序更具交互性和动态性的关键语言。 学习前端开发框架和库：学习一些流行的前端开发框架和库，例如React、Angular和Vue.js等，可以帮助您更快速地构建现代化的网站和应用程序。这些框架和库不仅可以提高您的工作效率，还可以增强您的前端开发技能。 练习编写代码：编写代码是学习前端开发的最佳方法。您可以使用在线编程平台，例如CodePen和JSFiddle等，创建自己的项目，并尝试实现不同的功能和特性。参与开源项目也是一个很好的方式，可以帮助您学习如何与其他开发者协作，并了解最佳实践和流程。 学习如何进行测试和调试：在学习前端开发时，测试和调试是非常重要的。学习如何使用浏览器的开发者工具和调试工具，以及如何编写单元测试和集成测试等，可以帮助您更好地调试和优化代码。 持续学习新技术和趋势：前端开发是一个不断发展的领域，新的技术和趋势层出不穷。因此，您需要不断学习新的技术和趋势，以保持自己的竞争力。您可以通过参加线上/线下的培训、参与社区和论坛等方式来学习新技术和趋势。 发展自己的设计能力：在前端开发中，设计能力是非常重要的。您需要了解基本的设计原则和技巧，例如配色、排版和用户体验等。您可以通过学习基本的设计知识和使用设计工具来提高自己的设计能力。 建立自己的项目：最后，建议您尝试建立自己的项目。这可以帮助您将所学的知识应用到实际项目中，并且可以提高自己的经验和技能。您可以选择一个自己感兴 学习套路 简单-快速使用(书籍入手 ) 中等-提高效率(视频) 困难-回本溯源(源码) 如何成为一个优秀的人1234567891011121314151.要顾全的大局 不要为了自己的一点私心去做事，大家嘴上不说但都看的到。多了大局去考虑，领导就喜欢这样的人，也愿意提拔爱顾大局的人。2.做事不古板 在团队里随时都能发生应急事件，遵守规则制度是应该的。但不可事事太古板，要懂得随机应变，有了处理好应急事件的能力。3.不逃避责任 在发生事故的时候，不要逃避责任，更不要给自己找垫背的。优秀的人才都是能够承担责任的，事故不可能总有，也不可能总没有，如果次次都选择逃避，还怎么做优秀 人物。4.愿意帮助每个队员 收拢人心很要，你能力再强，别人又为什么要选你呢，那是因为你身上有闪光点。而对队员来说，你对大家给予的真诚帮助，就能帮你赢得一大片人心。5.取长补短 这也是最重要的一条，你拥有了别人不会的技术，又是团队必须具备的技术。你就成了技术骨干了，多去学习别的长处，将自身的短处补齐。 关于学习今年最大的感触就是 过度忙碌使你落后。 一个人的学习热情总是有时限的，总会在一段时间过后消耗殆尽，如何平时工作过度忙碌，那么学习热情也会下降，这个时限也会缩短，太过忙碌，有空时就想娱乐一下，最终导致本来有空学习的时候不会学习了。 最可怕的是：在一个公司没日没夜的干了几年，没有留一点学习时间给自己。几年之后倒是对公司越来越 “忠诚” 了，但忙碌的工作同时也导致了没有时间更新知识，使得自己已经落后了，连跳槽的能力和勇气都失去了。 过度忙碌会导致没有时间学习和更新自己的知识，尤其在这个高速发展的时代。 很容易带来如下问题： 缺乏学习导致工作能力没有提升，而面对的问题却变得日益复杂。 技术和业务上没有更大的领先优势，只能被动紧紧追赶。 反过来上面这些问题会导致你更加繁忙，进而更没有时间提高自己的技术技能，很快就形成了一个恶性循环，并最终成为井底之蛙。 今年差点就进入了那个状态了，再忙也要留一点时间给自己，充实一下自己，更新一下自己的知识库 学习障碍： 没重视过正则，觉得没必要专门花时间学习，用的时候才发现书到用时方恨少； 没系统学习过正则，只简单地使用过部分功能，自然也就不清楚正则流派及工作原理等内容了； 没找到正确的方法去学习和记忆，导致学了之后很快就忘了。 通过一个课程，用尽可能通俗易懂的方式，系统化地给你梳理和讲解正则的知识点 12如果你有一个问题，你想到可以用正则来解决，那么你有两个问题了。Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. 这句话流传在程序员中间，给人一种感觉，就是正则是很难掌握和利用好的工具。也正因如此，很多程序员并不愿意去学正则表达式，心里可能是这么想的：我在工作中用到正则的时候并不多啊，要用的时候搜一下就好了啊，为什么还要专门花时间和精力学它呢？ 但我觉得，真实的情况可能是这样的：不是工作中用不到，而是当你不熟悉一个技能的时候，遇到问题时根本不会考虑它 。比如我们要删除掉文本中的所有数字，不知道正则的话，你可能会想到从 0 到 9 这样一个个替换，操作 10 次，但如果知道正则，那么只需要替换一次就可以搞定这个问题。 我当时到底是怎么学会正则的？说实话，我那会儿根本没想什么，纯粹出于干一行爱一行的朴素想法。要用得多，就找书来，哪怕是囫囵吞枣，也要一鼓作气看完。我一直觉得，真正值得学的东西，没有什么平滑学习曲线。在前面的阶段，你总得狠下心来，过了一个又一个坎儿，然后才能有一马平川。 大前端趋势大前端包括：传统的web应用开发(低代码、微前端)，跨客户端(客户端，桌面端，车载，小程序)，跨服务(NodeJs等后端服务工具链)三大类。 汇总 前端趋势热度榜单 2022技术人的百宝黑皮书 三大之传统的web应用开发(低代码、微前端)一、低代码技术 围绕无码，底码构建可视化搭建能力，提升研发效率。 在今年的几次技术大会上（阿里云栖大会，前端早早聊，掘金大会，架构师峰会）等很多大会上都聊到了低代码和无代码技术。 先来区分一下 no-code、low-code、pro-code： no-code：自己编程给自己用，给用户的感觉就是一个软件。因此，平台不会给自己定位成一个“编程工具”。主要是通过图形化的操作来降低学习曲线，类似 PPT、Excel 等。在垂直领域的特定场景中，才能做到好用。 low-code：编程给其他人用，通过降低专业难度，让运营人员（CitizenDeveloper）也参与进来。平台评估好预制的场景和需求，减少从头写代码的成本，一定程度上可以通过图形化的方式满足业务诉求。 pro-code：日常软件开发过程中的手写代码，可以通过逻辑和模块复用来进行提效。 区分了概念之后，还需要考虑面向的用户。不同的用户对应着不同的解决方案。用户大致分为三类：前端开发人员、后台开发人员、产品运营人员。 一般模式 物料选择区+画布+物料属性编辑器 AWS的Amplify云服务 提供了Amplify Studio在线平台，将Figma的UI设计直接导入，转化为前端可读的React组件代码 阿里Imgcook能力 设计稿智能生成代码,代码可用率79%，研发效率提升68% 组件识别能力：自动识别合理DOM嵌套结构，相对定位布局等 可视化编辑:支持组件样式、属性值修改，支持拖拉拽 代码生成:支持不同类型代码导出，react、vue、Rax 京东DECO能力 设计稿一键生成多端代码，京东凹凸实验室2020年发起的Deco智能代码项目，实现将Sketch/Photoshop等设计稿解析并直接生成代码。 （1）为什么要做低代码？ 基于目前可视化和模型驱动理念，结合当下大前端跨端体验的融合技术以及云原生的支持，通过低代码的方案可以大幅度降低业务交付的成本，为业务提供一种全新的开发范式。而且，可视化搭建去完成业务可以让产品和运营人员（CitizenDeveloper）参与进来，可以极大得释放软件开发者的人力瓶颈，也进一步促进了技术和业务的深度合作。 （2）低代码应该具备哪些核心能力？ 基础物料的搭建和接入是保证业务可视化的基础。无论是行业的开源组件，还是团队自定义的基础组件，搭建平台都应该无缝地进行预期内的接入和控制。这是因为，从业务长期迭代的角度来看，最耗费人力的一定是最频繁的业务组件。解决定制化的组件和接入组件由此成为低代码平台长期需要解决的最核心问题。 编排能力就是页面排版和对逻辑编排。无论是特定场景的页面的组件逻辑，还是用户自定义的交互（包括用户行为的服务端能力支持）都应该通过逻辑编排能力进行支持。大部分的页面搭建工作都是在桌面端完成的，但是页面渲染的产物可能是多种形式的，比如：PCWeb、H5Web、小程序，那么在搭建运行时的实时可视化和搭建完成的多端适配和多场景适配，这样就解决了跨技术栈和跨端问题。 虽然是 low-code 的设计方案，但还是希望输出的代码是可以进行二次开发的，因此最好能 pro-code 与 low-code 互相转换。编程产物分为初级产物、中间产物和最终产物。产物的丰富程度，直接决定了平台的可复用性和灵活性。无论是基于低代码开发和源码的混合开发，还是基于低代码平台的二次开发，都是 low-code 平台需要考虑的事情。 运行时能力也非常重要，对开发者来说是一个强大的编辑器引擎，可以方便快速接入各类组件和中间件。而对于运营人员（CitizenDeveloper）来说同样也很重要，针对不同的产品和业务场景，需要定制基础业务模版和和业务配置，方便他们快速地进行差异化的功能设计。 协作能力和数据分析能力就不言自明了。低代码平台的核心就是降低对专业性的要求。因此，使用者无论是谁，都应该有更高的效率提升。而数据统计和分析是所有平台都应该具备的基础能力，这里就不详细描述了。 那么，整理了核心能力如下：基础资料的搭建、基础资料的接入、业务编排能力、界面渲染能力、代码转换能力以及运行时能力、协作能力和数据分析能力。 为什么说 low-code 是恰逢其时呢？因为无论是跨端和跨平台领域的强大适配能力，还是大前端工程体系的有力支撑，都已经将低代码领域的价值逐步推到人们面前，低代码是业务发展和技术探索的必然选择。 二、微前端 独立开发，独立运行，独立部署。不限制技术栈，自由组合业务。 微前端核心要解决的10个问题 JS沙箱重要：子应用之间互不影响，包括全局变量和事件等 CSS隔离重要：子应用之间样式互不影响 父子应用通讯重要：子应用如何调父应用方法，父应用如何下发状态 子应用并行：多个微前端如何同时存在 子应用嵌套：如何嵌套微前端 预加载：空闲时加载子应用资源 公共依赖加载：大部分子应用都用到的资源 按需加载：切换页面才加载相应的html,css,js Config Entry:配置每个应用的JS和CSS Html Entry:简化开发者使用，但把解析消耗留给了用户 开源类型 项目 核心实现逻辑 社区主导 single-spa 中心路由基座式架构 阿里主导 qiankun/icestark 中心路由基座式架构 字节主导 Garfish 中心路由基座式架构 京东主导 MicroApp web Components 欢聚时代主导 EMP webpack5(Module Federation) 三大之跨客户端(客户端，桌面端，车载，小程序)排名有先后：Flutter,React Native,cordova,Ionic 移动端跨平台三大难题：性能，动态性，一致性。其中性能最关键。 Flutter能接近Native的性能体验，同时配有高效的开发套件，BAT均基于Flutter做二次封装，适配自身业务。 Flutter和React Native方案比较 Flutter 一次编写，到处运行 Dart(Framework) Platform Channel(C++ Engine) Native Plugins（iOS/Android） 统一图形引擎，UI控件提供iOS和Android风格 Native平台差异在Channel抹平，需额外开发 三端开发无法避免，三种框架/语言/环境切换 React Native 一次学习，到处编写 JavaScript(Framework) JSI(JSCore) Native API(iOS/Android) JS/DOM最终转为Native原生组件 Native平台差集封装JS后暴露给开发者 学习成本无法避免，同一种语言调用两端API 小程序 Taro,Uni-app是当前主流的开源跨端解决方案 三大之跨服务(NodeJs等后端服务工具链)NodeJs应用框架：造轮子变少，TS变多，使用企业级框架变多。 Koa.js和Express.js为最常见框架，其他的有Egg.js,Nest.js,Midway.js,Next.js Serverless 它是基于Serverless重塑前端应用研发模式 在BFF架构下，将BFF的运维成本释放掉，由以往的BFF server的多应用级转向Faas服务的函数级一体化，前端不再关系服务器等运维工作，专注业务。 比如：华为云的icejs的一体化工程设计 WASM 一种Web前端技术，价值在于方便引入python,c/c++,Rust等丰富的生态 增强功能，效果和接近Native APP的使用体验 提供控制逻辑代码执行性能，ts 使用建议： 尽量将纯的计算逻辑，放在WASM 涉及JS交互的，会损失性能 BFF模式 BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。 BFF 的几个优点： 关注点分离——前端需求将与后端关注点分离，便于维护。 更容易维护和修改 API——客户端应用程序对 API 结构了解较少，这将使其对 API 中的更改更有弹性。 更好的前端错误处理——大部分时间，服务器错误对前端用户是没有意义的。BFF 可以映射出需要显示给用户的错误，而不是直接返回服务器错误，这将改善用户体验。 多种设备类型可以并行调用后端——当浏览器向 BFF 发出请求时，移动设备也可以这样做。这将有助于更快地获得相应服务的响应。 更好的安全性——某些敏感信息可以被隐藏，并且在向前端返回响应时可以忽略不必要的数据。这种抽象将使攻击者更难以应用程序为目标。 共享组件的团队所有权——应用程序的不同部分可以由不同的团队轻松处理。前端团队可以共享客户端应用程序及其底层资源消耗层的所有权，从而提高开发速度。下图显示了团队划分 BFF 的例子。 在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。 1.演进过程:单端调用基础服务 传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的高耦合就决定了这一点。 2.演进过程:多端直接调用基础服务 如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。 3.演进过程:多端共用一个BFF 针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了分离，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。 这种设计方式同样存在一定的问题，虽然基础服务与BFF进行了分离，我们只需要在BFF层面进行业务判断处理，但是多个端共用一个BFF，也会导致代码编写复杂度增高、代码可阅读性降低、多端业务耦合。 4.演进过程:每个端提供一个BFF 如果我们为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。 这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响 小结 在微服务架构设计中，BFF起到了一个业务聚合的关键作用，可以 通过openfeign、restTemplate调用基础服务来获取数据，将获取到的数据进行组装返回结果对象，BFF解决了业务场景问题，也同样带来了一些问题，如下所示： 响应时间延迟（服务如果是内网之间访问，延迟时间较低） 编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码） 业务异常处理（统一格式化业务异常的返回内容） 分布式事务（微服务的通病） 2021年 TypeScript 持续升温，依旧保持着高速成长的状态，未来的潜力不可限量； 通过项目分布的情况，明显能看到 React 生态圈&gt;&gt; Vue 生态圈&gt;&gt; Angular 生态圈； 伴随着 WebAssembly 核心规范成为浏览器的标准，继 HTML、CSS 和 JS 之后，像 C/C++、Rust、Go 等语言编写的高性能模块也在浏览器上运行。相信在不久的将来，Web 应用的桌面客户端化，也将成为一种趋势； Strapi 位列 Nodejs 相关领域的第三名侧面反应了低代码的趋势还在持续升温，各家都在研制自己的低代码平台来提升开发效率； JS Framework 相关的领域，Next.js 超越 Nest 成为了今年的冠军。在强大的 React 体系的影响下，业务越来越多的人选择使用同构和直出的方案来构建 Web 应用； Serverless Framework 也进入了前 Top100，虽然排名不高，但是已经开始慢慢展示出了可持续发展的势头。对于一个被厂商裹挟的技术而言，这一切来之不易； 大前端生态系统已经逐步完善，前端工程化逐步完善，DevOps 已经走向了系统化的发展方向，前端技术已经进入深水区； 由于直播行业的火热，以及疫情的影响，音视频领域在过去的一年也有着蓬勃的发展。在前端领域 WebRTC 的技术在持续升温 TypeScript 爆发增长 三大框架 React 当先 WASM即WebAssembly展露头角 Low-Code 全栈开发持续深耕，从 DevOps 到 NoOps，再到serverless WebRTC 持续升温。音视频两大领域：一类是 RTC，它主要用于满足多人会议中的低延时互动；另一类是流媒体直播/点播，主要满足于对延时要求不大的高并发低成本场景 参考 2021 年大前端技术趋势解读 2022年 移动端能力放大 小程序生态的崛起 跨端能力的增强，比较知名的就是Taro PC桌面端入侵，以NW.js和Electron为代表的前端技术 工程师的五个等级 开创一个产业 能设计和实现别人不能做出的产品 能独立设计和实现产品，并且市场上获得成功 能指导和带领其他人一同完成更有影响力的工作 能独立解决问题，完成工程工作 一、低代码 二. 工程平台 字节今年开源了modernjs ， 号称现代Web 工程体系，方向是没错，目前开源的只是一套CLI工具。背后的工程平台才是真正的价值和核心。所以做前端工程平台，前后端一体化，治理整个研发链路，避免割裂，整合所有前端资源（配置化，微前端，研发工具，低代码，WebIDE, 工程平台）才是未来大的趋势。 三. 一体化框架 早期阶段，前端充斥着大量的工具，打包工具webpack ，gulp ， 框架脚手架， babel ，less ，ts等等。 后来出现nextjs, umi 等这些工具，来将这些零碎的前端工具整合在一起，形成一套构建打包方案。包括后来出现modernjs , BlitzJS等后期之秀，在此之上甚将GraphQL ，Serverless, Prisma(ORM) 都集成进来，形成前后端一体化框架也称为全栈框架，这将会是22年，乃至今后很多年都面临的趋势。 四. 包管理 npm的包管理一直让人头痛，持续浪费磁盘空间，扁平化的依赖，复杂的算法逻辑，不够高效也不简洁。所以我们需要一种monorepo管理包的方式。22年我认为pnpm 或 rush 会让一大批仓库从 lerna，npm ，yarn workspace 等其他的方案迁移过来。Monorepo 将成为前端标配。ESM将持续推进，老的标准慢慢废弃。ESM的推进，将对微前端带来一波利好。微前端后面单独再讲。 五. 构建工具 随着vite,snowpack持续发力，vite等为代表的bundless工具，有望成为最好和最快的前端构建工具。目前Webpack只能通过增加一些小特性来巩固自己的地位，比如webpack5增加了filesystem cache，但是webpack慢的名声已经在外了，不过本质上这事儿跟慢不慢也没必然关系。大家都在为esm和bundless做准备。所以bundless才是大势所趋。 rust给前端构建又带来一针强心剂。 SWC用于替代传统的babel (SWC is 20x faster than Babel on a single thread and 70x faster on four cores.)，下半年很多前端构建工具都有人在用 rust 重写，比如parcel 作者发布了用 rust 写的 parcel-css，速度约是 cssnano 的 120 倍。facebook的rome也正在用rust重新，它的野心更大，在甚至想替代Babel, ESLint, webpack, Prettier, Jest 等工具，并且提供一套完整的 js toolchain，包括 compiler，linter 等 。而且WebAssembly是与rust搭配的最佳组合。而且rust语言极高的性能和安全性，会越来越受青睐。 参考 2022前端未来发展趋势 程序员副业副业方向1、有技术的程序员 有的中小公司会找业内的技术专家，解决某个技术问题，又或许是针对开发需求组织的团队内训，包括一些程序员培训机构，也会邀请技术专家参与课程研发，都是为你的技能付费。 并且做得好还可以打造个人IP，把自己越卖越贵，直接上升N个档次。 2、有资源的程序员 有机会有能力接项目来做，一方面在工作中积累了人脉和资源，另一方面自己可以组织或整合一个兼职的小团队。 所以善待身边的人，说不定下个单子就是他开给你的！ 3、有个人见解的程序员 写技术博客，做自媒体，做短视频，分享工作经验，拆解技能……走自媒体路线，有独特个性的人会更吃香，更有甚者可以卖课、卖书，吃流量，赚稿费。 副业平台记住： 个人的，别想着在这种线上平台接单赚钱，线上平台能接到单赚钱的，都是专门成立了外包小公司的团队。 线上接单我5年前就不玩了，当时猪八戒很火，很多程序员上面接单，但是发现付出与收获不成正比， 作为程序员线上接单不是好路子，最好是自己开发一个产品(比如小程序)，靠产品赚钱，这个钱赚的又舒服又锻炼自己成为老板 做视频聚合资源app，一个月1w没问题，纯赚，容易进局子，版权问题 线上接单这种挣得比较少，价格透明，竞争大。最好的是善待周围的人，扩大交际圈，说不定哪天给你介绍一单，跨行业的容易挣信息不对称的💰，利润大。 1、程序员客栈 国内领先的程序员自由远程工作平台，这行的应该都知道吧。灵活度高，比较自由，单子比较多，个人推荐！ 2、英选 平台以定制开发外包服务为主，也是外包项目平台。它的项目管理方面是特色，阶段确认和及时反馈较好。 3、Devnors 国外的一个互联网软件定制开发与软件外包开发服务平台，英语好的朋友可以看看，它比较有意思的是平台用的是区块链技术支付。要是能接上国外的单，那还是香的！ 4、开源众包 上面的项目以众包为主。接包方质量较好，它的协助开发工具比较完善。也是比较常见的一个网站。 杂文前端工程师的价值如何最大化-Scott亲笔信几个话题：职业思考、新人成长、技术栈规划、框架设计、技术驱动、技术管理、团队建设。 原文 职业思考 前端行业中有相当部分童鞋不是计算机专业出身，或者学历文凭没有优势，又或者经过培训班而来，甚至是其他工种半路转过来，临门的一脚踩下去可能进入了一个灾难性的公司，进入了一个无法成长的团队。这在职业生涯早期会是一个致命的门坎，要知道技术成长的阶段可以放到 6 年 8 年的长度来看，是否会成为一个独当一面且足够资深的专家或者架构师，在职业早期的思考、选择和规划非常关键。一步走错可能就很难补救，这也是生存阶段、诱惑阶段、证明阶段、实现阶段其中的生存阶段，在文章中我用自己的 8 年多前端经历，现身说法给大家演示了我在各个阶段中的挣扎，焦虑，思考和最终的破局，以及我对于自己走过弯路的重新认知。 针对职业思考，我们总结了这两篇文章： 《职业思考：如何看待创业公司与成长型前端团队》 《职场瓶颈：2~4 年前端走出离职困境与舒适区》 新人成长 新人成长包括团队融入是一个老生常谈的话题，然而在这个上面是最多的同学栽跟头的地方。有的缺少方法，有的是缺少方向，有的是缺乏具体的规划和执行方式，有的仅仅是团队没有技术氛围。每个人的原因不尽相同，无论哪种，有没有可能摆脱物理外界环境，寻求到适合自己的成长路径呢，上图是小菜前端在 2017 年到 2018 年团队成员的技术成长情况，红星星越多成长越大，那么这些同学身上都具备什么特点呢，在文章中我们会举一些案例来分析。 针对新人成长，我们总结了这三篇文章： 《新人成长：新人如何快速融入技术实力强的前端团队》 《新人成长：新人在前端团队如何快速成长为技术骨干》 《学习方法：如何在工作内外获得持续的技术成长》 技术栈规划 前端学不动了是这两年很多同学半调侃半吐槽的声音，放到一个公司一个团队里面，针对新生事物我们应该怎么选择跟进呢，怎么保持一定的节奏来让团队既不行业中掉队，从而影响每个同学的技术更新速度，又不让公司因为技术栈变化太剧烈而无法偿还技术债务甚至影响业务发展呢。上图是小菜过去 4 年的主要技术栈演进过程，也有很惊险的时候，但整体还是比较平稳有序，这就是需要有一些具体的方法论来指导团队，这些套路我们也会在文章中有更详细的 case 来进行分析探讨。 针对技术栈规划，我们总结了这四篇文章： 《技术栈：如何让团队规划技术栈得到有效落地》 《技术栈：为什么 Node 是前端团队的核心技术栈》 《技术栈：小菜前端的技术栈是如何规划和演进的》 《技术栈：2015~2019 小菜 4 年技术栈进化回顾》 框架设计 造轮子是前端团队盛行的做法，有的团队造了好轮子还会开源，而有的团队内部会重复造轮子造成了一定的资源浪费，小菜一直到了四年的年末，才开始形成我们几个端的框架，那么如何在自己的组织内看待轮子这件事，以及如果真要面向不同的端环境设计或者来定制出满足业务的框架呢，我们会有几篇文章分别来深度探讨我们做这件事时候的所思所想。 针对框架设计，我们总结了这四篇文章： 《框架设计：如何基于 Egg 设计 Node 的服务框架》 《框架设计：PC 端单页多页框架如何设计与落地》 《框架设计：RN 端的框架如何设计与落地》 《框架设计：小程序框架与组件化如何选型定制》 技术驱动 枯燥的业务和臃肿的流程是工程师职业的杀手，但偏离了业务的技术又会成为无根之花，很难继续生长，这也是很多资深的工程师，包括团队管理者面临的难题，小菜曾经也有过非常痛苦的时期，我们深知当技术也业务没有发挥最佳组合价值时候，团队之间的碰撞和技术与业务的对抗，甚至像上图中，前后端团队中都会出现一些有合作成本的领域，因此我们花费了相当的心力来促成技术驱动业务这件事，并且有的富有成效，也有个别可圈可点，关于这些过程和我们的思考会在文章中详细剖析给大家。 针对技术驱动，我们总结了这四篇文章： 《技术驱动：如何让工程师的技术价值最大化》 《技术驱动：前后端的协同效率从哪些方面发力推进》 《技术驱动：业务与部门的大盘数据可视化底层技术》 《技术驱动：量产数据报表的工具服务如何搭建》 技术管理 对于一个工程师，即便他是走纯研发路线，最后成为纯技术专家成为架构师，他也依然要面对技术管理的事情，只不过管理分为强管理和弱管理，通常纯研发团队和架构组会属于弱管理，管理依然是一项必备技能，尤其对于带团队的技术 TL。小菜前端团队在飞速壮大，如上图规划，这个过程中会经历几个关键的阶段，前面用 4 年时间从最初的几个人到现在的近 20 个人，管理上面有很多的思考和总结，观察的视角主要来自于 Scott 的亲身经历，现身说法来为大家分享如果带领一个更小的团队，比如 10 人规模以内的团队，可以从哪些方面着手以及需要具备哪些能力，这些能力如何训练。 针对技术管理，我们总结了这一篇文章： 《技术管理：如何带领管理少于 10 人的前端小团队》 团队建设 技术研发实力是团队的血脉，而团队文化就是团队的性格和灵魂，一味强调研发实现忽略文化，会让团队双目无神变成行尸走肉一样无趣的团队，反之亦不行，这两者存在一定程度的交叉互助，也需要一定的平衡，但具体到团队的文化建设，不像技术一样，可以切换框架立竿见影，它是一个虚的并且很长久性的课题，需要长年累月的建设，需要每一个童鞋的深度配合，小菜在这一块刚刚走过不到 2 年，还没有看到非常理想的结果，但整体的趋势在不断的变好，特别是在团队的影响力和研发氛围这块，那么我们也会以团队为例，结合理论来探讨下团队建设中有哪些务虚和务实的事情可以尝试。 针对团队建设，我们总结了这两篇文章： 《团队建设：创业公司技术团队的文化与氛围如何建设》 《团队建设：创业公司技术团队的影响力如何打造》 关于公务员的思考问题1：武汉是一个大城市，相比一般小县城，有以下优势和劣势： 优势： 经济发展水平高：武汉是湖北省的省会，也是中部地区的重要城市，拥有较为完善的产业体系和发达的经济。相比小县城，武汉的经济发展水平更高，就业机会更多。 文化氛围浓厚：武汉是一个历史悠久的城市，有着丰富的文化底蕴和独特的文化氛围。武汉有许多著名的文化景点和历史遗迹，如黄鹤楼、古琴台、汉口江滩等，这些都是小县城所没有的。 生活便利：武汉是一个大城市，拥有完善的基础设施和便利的生活服务。相比小县城，武汉的医疗、教育、交通等方面更加发达，居民的生活质量更高。 劣势： 交通拥堵：武汉是一个大城市，交通压力较大，尤其是高峰期，交通拥堵现象比较严重。相比小县城，武汉的交通状况更为复杂，需要花费更多的时间和精力。 空气质量差：由于武汉是一个工业城市，空气质量相对较差，尤其是冬季和雾霾天气，空气污染问题比较严重。相比小县城，武汉的环境质量更差。 生活成本高：武汉是一个大城市，生活成本相对较高，尤其是房价和物价方面。相比小县城，武汉的生活成本更高，需要花费更多的钱。 问题2：父母公务员对孩子的影响主要有以下几个方面： 教育环境：公务员家庭通常注重教育，重视孩子的学习和成长，提供更好的教育环境和资源，这对孩子的成长有积极的影响。 社会关系：公务员家庭通常有更广泛的社会关系，这对孩子的人际交往和社交能力的培养有一定的帮助。 安全稳定：公务员家庭通常有较为稳定的收入和职业，这对孩子的成长环境和生活条件都有一定的保障。 压力和期望：公务员家庭通常对孩子的期望较高，希望孩子能够继承父母的优秀品质和成就，这可能会给孩子带来一定的压力。 总的来说，父母公务员对孩子的影响是多方面的，既有积极的方面，也有一些潜在的负面影响。但是，这些影响并不是绝对的，还要考虑具体的家庭情况和孩子的个性特点。 问题3：中国公务员的待遇 薪资待遇：公务员的薪资待遇相对较高，一般比同等学历的企业员工要高。 福利待遇：公务员享有较好的福利待遇，包括医疗保险、养老保险、住房公积金等。 工作稳定性：公务员的工作相对稳定，一般不会出现裁员等情况。 职业发展：公务员的职业发展空间相对较大，可以通过考试晋升到更高级别的职位。 需要注意的是，公务员的工作压力较大，工作时间也相对较长，同时需要承担一定的责任和义务。 一般来说，公务员晋升的年龄限制如下： 初次录用的公务员，一般要求年龄在35周岁以下； 普通公务员晋升为副科级干部，一般要求年龄在45周岁以下； 副科级干部晋升为正科级干部，一般要求年龄在50周岁以下； 正科级干部晋升为副县级干部，一般要求年龄在55周岁以下； 副县级干部晋升为正县级干部，一般要求年龄在60周岁以下。 公务员的缺陷和劣势可能包括以下几点： 薪资相对较低：公务员的薪资相对于同等学历和工作经验的民营企业员工来说较低，尤其是在一些发展较快的行业和地区。 晋升机会较少：公务员的晋升机会相对较少，晋升的速度也比较慢，这可能会影响到个人的职业发展。 工作压力大：公务员的工作压力也比较大，尤其是在一些重要的岗位上，需要承担较大的责任和压力。 工作环境相对单一：公务员的工作环境相对较为单一，缺乏多样性和挑战性，可能会导致工作的单调性和乏味性。 工作稳定性较高：虽然公务员的薪资相对较低，但是工作稳定性较高，相对于民营企业来说更加稳定和安全。 总的来说，公务员的缺陷和劣势与个人的职业发展和价值观有关，需要根据自身情况进行权衡和选择。 问题4：放弃程序员高薪，专职去考取国家公务员，合适吗 这个问题的答案取决于你的个人情况和目标。如果你对公务员职业有浓厚的兴趣，并且相信这是你实现自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。 在做出这个决定之前，你需要考虑以下几个因素： 薪资：一般来说，程序员的薪资比国家公务员高。如果你更看重薪资，那么选择程序员工作可能更适合你。 工作内容：程序员工作需要具备一定的技术能力和创造力，需要不断学习和更新知识。而国家公务员的工作内容相对稳定，需要具备一定的组织协调和管理能力。如果你更喜欢挑战和创造，那么选择程序员工作可能更适合你。 工作环境：程序员工作一般在IT公司或科技企业中，工作环境比较自由，注重创新和团队合作。而国家公务员的工作环境相对稳定，注重规范和纪律。如果你更喜欢自由和创新，那么选择程序员工作可能更适合你。 职业发展：程序员工作有很多不同的职业发展路径，可以成为技术专家、项目经理、创业者等。而国家公务员的职业发展路径相对单一，主要是晋升到更高级别的公务员。如果你更看重职业发展和多元化选择，那么选择程序员工作可能更适合你。 综上所述，如果你认为公务员职业是符合自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。 这个问题的答案取决于个人的价值观和职业规划。如果你认为成为国家公务员是实现个人价值和职业规划的最佳途径，那么这个决定就是合适的。但是，需要注意的是，放弃高薪的程序员职业，转而成为国家公务员，可能会对个人的经济状况产生影响。因此，在做出这个决定之前，需要仔细考虑自己的职业规划和生活需求，并做好充分的准备。 这是一个非常棘手的问题，需要你自己权衡利弊并做出决定。首先，你需要考虑自己的职业兴趣和发展方向，如果你对公务员这个职业没有兴趣，那么转行可能会让你感到不满和失落。其次，你需要考虑你和女朋友的关系，如果你们的感情很深，你可以考虑妥协，但是如果你们的感情并不牢固，你需要好好考虑是否值得为了她的要求而放弃自己的职业发展。最后，你需要考虑你们未来孩子的教育和成长，公务员这个职业相对稳定，但是也有一定的局限性，你需要好好权衡。 总之，这是一个需要你自己做出决定的问题，你需要考虑自己的职业兴趣、个人发展、感情关系和未来孩子的教育等多个方面，做出最合适的决定。 前端工程师出路 无论你想做什么事情，首先都要以开放积极的心态去面对，而不是打定了一个主意后就立马埋头苦干，在做之前先倾听其他人的意见，看看是否有更好的解决思路，或者是否已经有人做过类似的事情，不要重复造轮子。 技术架构 技术选型，预见未来，比如是否有跨端需求，提前选择跨端框架 可维护性、可复用性、可测试性 降本增效 目录自动生成，参考 egg.js（提效） 低代码运营页面自动搭建（提效降本） 快捷键工具 自动化测试工具 批量处理国际化（提效） nodejs-translate react-intl 以及 I18N-loader 业务场景 大文件批量断点续传及优化 微应用模板、组件库和脚手架（提交） SSO 登录，CAS 异步流程控制 技术驱动业务 主动推进项目 和后端约定接口规范 推荐适合当前场景的技术 提出建设性的需求 样式：美观、统一 性能：首屏性能 交互&amp;体验：简单高效 多端兼容 砍除不合理的需求 实现成本，可行性分析 替代方案 开发周期 需求优先级 开发排期 Rust 浅谈 Rust 前端应用开发 在浏览器端运行的编程语言主要有两种： JavaScript WebAssembly:原理就是将 Rust 编译成 WebAssembly ，然后在浏览器端运行","categories":[{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"权限认证和权限认证","slug":"D_框架_权限认证和权限认证","date":"2022-05-12T22:33:16.000Z","updated":"2023-06-13T14:34:50.294Z","comments":true,"path":"2022/05/13/D_框架_权限认证和权限认证/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/13/D_%E6%A1%86%E6%9E%B6_%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/","excerpt":"","text":"术语认证 认证(Identification) 是指根据声明者所特有的识别信息，确认声明者的身份。 授权 授权(Authorization)： 在信息安全领域是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便对资源的相关操作。 鉴权 鉴权(Authentication) 在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。 若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。 权限控制 权限控制(Access/Permission Control) 将可执行的操作定义为权限列表，然后判断操作是否允许/禁止 对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。 认证、授权、鉴权和权限控制的关系？ 它们有先后的依赖关系：认证—&gt;授权—&gt;鉴权—&gt;权限控制 权限认证鉴权-Session-CookieSession-Cookie 认证是利用服务端的 Session（会话）和 浏览器（客户端） 的 Cookie 来实现的前后端通信认证模式。 Session-Cookie认证流程图 认证流程 客户端： 向服务器发送登录信息用户名/密码来请求登录校验； 服务器： 验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 session_id(通常称为 sid)，并在响应头 Set-Cookie 中设置这个唯一标识符； 客户端： 收到服务器的响应后会解析响应头，并自动将 sid 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息； 服务器： 接收客户端请求时会去解析请求头 Cookie 中的 sid，然后根据这个 sid 去找服务端保存的该客户端的 sid，然后判断该请求是否合法 优点 Cookie 简单易用 Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理 只需要后端操作即可，前端可以无感等进行操作； 缺点 依赖 Cookie，一旦用户在浏览器端禁用 Cookie，那么就 GG 思密达了； 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）； Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能； 对移动端的支持性不友好； 鉴权-Token 为了解决Session 的维护和存储问题，才有了Token。 Token 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。 一般 Token 的组成 uid (用户唯一的身份标识) + time (当前时间的时间戳) + sign (签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串) Token 的认证流程图 认证流程 客户端： 输入用户名和密码请求登录校验； 服务器： 收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端； 客户端： 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中； 客户端发送请求： 向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端； 服务器： 收到请求，然后从客户端请求取出Token包含的用户信息，查库验证 优点 服务端无状态化、可扩展性好： Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态 支持 APP 移动端设备； 安全性好： 有效避免 CSRF 攻击（因为不需要 Cookie） 支持跨程序调用： 因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题 缺点 配合： 需要前后端配合处理； 占带宽： 正常情况下比 sid 更大，消耗更多流量，挤占更多宽带 性能问题： 需要访问数据库或远程服务进行权限校验，对 Token 加解密等操作，会更耗性能； 有效期短： 为了避免 Token 被盗用，一般 Token 的有效期会设置的较短，所以就有了 Refresh Token； Refresh Token 业务接口用来鉴权的 Token，我们称之为 Access Token。但过短的有效期会造成 Access Token 经常过期，过期后怎么办呢？ 方案有2种： 刷新 Access Token，让用户重新登录获取新 Token 再来一个 Token，一个专门生成 Access Token 的 Token，我们称为 Refresh Token 定义 Access Token： 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活； Refresh Token： 用来获取 Access Token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 Session 一样处理； Refresh Token 的认证流程图 认证流程： 客户端： 输入用户名和密码请求登录校验； 服务端： 收到请求，验证用户名与密码；验证成功后，服务端会签发一个 Access Token 和 Refresh Token 并返回给客户端； 客户端： 把 Access Token 和 Refresh Token 存储在本地； 客户端发送请求： 请求数据时，携带 Access Token 传输给服务端； 服务端： 验证 Access Token 有效：正常返回数据 验证 Access Token 过期：拒绝请求 客户端 ( Access Token 已过期) ： 则重新传输 Refresh Token 给服务端； 服务端 ( Access Token 已过期) ： 验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端； 客户端： 重新携带新的 Access Token 请求接口； Token 和 Session-Cookie 的区别 Token 更像是 Session-Cookie 的升级改良版 存储地不同： Session 一般是存储在服务端；Token 是无状态的，一般由前端存储； 安全性不同： Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击； 支持性不同： Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。 鉴权-JWTToken每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；所以有了JWT。 JWT 是 Auth0 提出的通过 对 JSON 进行加密签名来实现授权验证的方案； JWT 的组成 三部分组成：Header 头部、 Payload 负载和Signature 签名 Header 头部 typ：代表 Token 的类型，这里使用的是 JWT 类型； alg：使用的 Hash 算法，例如 HMAC SHA256 或 RSA. Payload 负载 它包含一些声明 Claim (实体的描述，通常是一个 User 信息，还包括一些其他的元数据) ，用来存放实际需要传递的数据 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 Signature 签名 Signature 部分是对前两部分的签名，防止数据篡改。 指定一个密钥（secret）,然后使用 Header 里面指定的签名算法（默认是 HMAC SHA256）产生签名。 JWT 的认证流程图 优点 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况； JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数 缺点 加密问题： JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 到期问题： 由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 前端常用的JWT库 使用 express：express-jwt 使用 koa：koa-jwt 鉴权-SSO单点登录前面解决了在同域下的客户端/服务端认证系统中，通过客户端携带凭证，可以维持一段时间内的登录状态。但一个大型系统里可能包含 n 多子系统，用户在操作不同的系统时，需要多次登录，很麻烦，单点登录（SSO)解决了这个问题。 同域下的 SSO（主域名相同）当网站存在两个相同主域名下的贴吧子系统 media.mybj123.com 和网盘子系统 pan.mybj123.com 时，以下为他们实现 SSO 的步骤： 客户端： 用户访问某个子系统时（例如 media.mybj123.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录； 服务端： 登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .baidu.com ； 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了； 以上流程本质是鉴权-Session-Cookie 跨域下的 SSO（主域名不同）比如天猫 和 淘宝的互相登录访问，采用了CAS（Central Authentication Service）中央授权服务。 单点登录下的 CAS 认证流程图 认证流程： 客户端： 开始访问系统 A； 系统 A： 发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com/login?redir… CAS 认证服务： 发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。 客户端： 输入用户名密码进行 CAS 系统认证； CAS 认证服务： 校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso. com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：www.taobao.com?token=ST-345678） 系统 A： 拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源； 客户端： 开始访问系统 B； 系统 B： 发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC； CAS 认证服务： CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ; 系统 B： 拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~ 注意点： 如图中流程所示，我们发现 CAS 认证服务 在签发的 授权令牌 ST 后，直接重定向，这样其实是比较容易容易被窃取，那么我们需要在系统 A 或者系统 B 在向 CAS 验证成功 (如图中的第 14 步和第 11 步) 后，再生成另一个新的验证 Token 返回给客户端保存； CAS 一般提供四个接口： /login：登录接口，用于登录到中央授权服务 /logout：登出接口，用于从中央授权服务中登出 /validate：用于验证用户是否登录中央授权服务 /serviceValidate：用于让各个 Service 验证用户是否登录中央授权服务 CAS 生成的票据： TGT（Ticket Grangting Ticket） ：TGT 是 CAS 为用户签发的 登录票据，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。 TGC：Ticket Granting Cookie： CAS Server 生成TGT放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionId），以 Cookie 形式放到浏览器端，是 CAS Server 用来明确用户身份的凭证。 ST（Service Ticket） ：ST 是 CAS 为用户签发的访问某个 Service 的票据。 鉴权-OAuth 2.0通过第三方的 QQ 或者 微信登录，这就用到了 OAuth 。 OAuth 是一个开放标准，允许用户授权第三方网站 (CSDN、思否等) 访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站； 常见的提供 OAuth 认证服务的厂商： 支付宝、QQ、微信、微博 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（Token），用来代替密码，供第三方应用使用。 OAuth 2.0 颁发令牌一共分成四种授权模式 （Authorization Grant） 无论哪个模式都拥有三个必要角色：客户端、授权服务器、资源服务器，有的还有用户（资源拥有者） 1.授权码模式 授权码（Authorization Code Grant) 方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。 这种方式是最常用的流程，安全性也最高，它适用于那些有后端服务的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。 一句话概括：客户端换取授权码，客户端使用授权码换token，客户端使用token访问资源 2.隐藏式模式（Implicit Grant） 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。OAuth2.0 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。 一句话概括：客户端让用户登录授权服务器换token，客户端使用token访问资源。 3.用户名密码式模式（Password Credentials Grant） 如果你高度信任某个应用，OAuth 2.0 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 一句话概括：用户在客户端提交账号密码换token，客户端使用token访问资源。 4.客户端模式（Client Credentials Grant） 客户端模式指客户端以自己的名义，而不是以用户的名义，向授权服务器 进行认证。 主要适用于没有前端的命令行应用。 一句话概括：客户端使用自己的标识换token，客户端使用token访问资源。 鉴权-唯一登录我想要实现用户只能在一个设备上登录，禁止用户重复登录。 唯一登录流程图 认证流程： 用户在客户端 A 操作： 输入账号请求登录接口； 后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态； 客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token； 用户在客户端 B 操作： 突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的； 只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token； 鉴权-QR Code扫码登录二维码为 QR Code，QR 全称 Quick Response。扫码登录需要三端 (PC端、手机端、服务端) 来进行配合才能达到登录。 扫码登录的认证流程图 认证流程： 待扫码阶段： PC端：打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求； 服务端：服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 PC 端的设备信息 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。 PC 端：收到二维码 ID 之后，将二维码 ID 以 二维码的形式 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。如果移动端未扫描，那么一段时间后二维码会自动失效。 已扫码待确认阶段： 手机端：打开手机端对应已登录的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。 服务端：收到手机端发来的请求后，会将 Token 与二维码 ID 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。 已确认阶段： 手机端：收到确认信息后，点击确认按钮，移动端携带上一步中获取的 临时 Token 发送给服务端校验； 服务端：服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 正式的 Token，后续 PC 端就是持有这个 Token 访问服务端。 PC端：轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。 小结 Session-Cookie 适用于一般中大型的网站（移动端 APP 除外）； Token 和 JWT 都适用于市面上大部分的企业型网站，JWT 效能会优于 Token； 单点登录 适用于子系统较多的大型企业网站； OAuth 2.0适用于需要快速注册用户型的网站； 扫码登录 适用于已完成部署了三端的企业； 参考前端与后端鉴权方案有哪些？看这篇就够了 权限控制接口权限使用axios请求拦截器实现 按钮权限使用自定义指令实现 页面菜单权限我们没有去某个页面的导航菜单，实际上就是没有去那个页面的权限了，所以说页面权限的实际就是菜单权限。 获取菜单权限列表，动态递归生成菜单 路由权限 使用Router.beforeEach来判断 获取路由权限列表，借助route.add() 动态生成路由表 参考 面试官：Vue要做权限管理该怎么做 如何用 Vue实现前端权限控制 前端面试必备——权限控制 vue权限路由实现方式总结","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"Vite","slug":"H_工程热点_Vite","date":"2022-05-11T22:33:16.000Z","updated":"2023-07-16T10:12:51.146Z","comments":true,"path":"2022/05/12/H_工程热点_Vite/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_Vite/","excerpt":"","text":"模板全宇宙入口 awesome-vite Vite是什么？参考 Vite官网 esbuild官图 vite 下一代前端开发与构建工具 Vite介绍及实现原理&lt;超详细、纯干货！&gt; 深入理解Vite核心原理 Vite（法语是 “快”）是新一代的前端构建工具。你可以把它理解为一个开箱即用的开发服务器 + 打包工具的组合，但是更轻更快。Vite 利用浏览器原生的 ES 模块支持和用编译到原生的语言开发的工具（如 esbuild）来提供一个快速且现代的开发体验。开箱即用如CSS预处理、html预处理、异步加载、分包、压缩、HMR。 Vite由两个主要部分组成： dev server：利用浏览器的ESM能力来提供源文件，具有丰富的内置功能并具有高效的HMR 生产构建：生产环境利用Rollup来构建代码，提供指令用来优化构建过程 Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。 Vite的主要特性 优点： 快速的冷启动: 采用No Bundle和esbuild预构建，速度远快于Webpack 高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载，增加缓存策略 真正的按需加载: 基于浏览器ESM的支持，实现真正的按需加载 缺点 生态：目前Vite的生态不如Webapck，不过我觉得生态也只是时间上的问题。 生产环境由于esbuild对css和代码分割不友好使用Rollup进行打包 主流构建工具对比构建工具:用来让我们不再做机械重复的事情，解放我们的双手的。 构建工具指能自动对代码执行检验、转换、压缩等功能的工具。常见功能包括：代码转换、代码打包、代码压缩、HMR、代码检验。构建工具也随着前端技术的发展，从Browserify、Gulp到Parcel，从Webpack到Rollup，一直到最近比较火的面向非打包的Snowpack和Vite。 在早期开发过程中。有很多令我们不爽的地方 js是弱类型 手动维护依赖很麻烦 浏览器的兼容性 没有热更新 于是 前端构建工具应运而生。构建工具可以帮助我们做以下工作 代码检查 代码压缩，混淆 依赖分析，打包 语言编译(比如ts转化js,scss转化css) 前端的构建工具有很多。比如 Grunt Gulp FIS3 Webpack Rollup Parcel snowpack vite Browserify 预编译模块化方案（文件打包工具） Browserify基于流方式干净灵活 遵循commonJS规范打包JS 可引入插件打包CSS等其他资源（非原生能力） Gulp 基于流的自动化构建工具（工程化） 配置复杂度高，偏向编程式，需要定义task处理构建 支持监听读写文件 可搭配Browserify等模块化工具来使用 Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目 12345678910111213141516171819202122232425262728293031var gulp = require(&#x27;gulp&#x27;); var jshint = require(&#x27;gulp-jshint&#x27;); var concat = require(&#x27;gulp-concat&#x27;); var rename = require(&#x27;gulp-rename&#x27;); var uglify = require(&#x27;gulp-uglify&#x27;); // Lint JS gulp.task(&#x27;lint&#x27;, function() &#123; return gulp.src(&#x27;src/*.js&#x27;) .pipe(jshint()) .pipe(jshint.reporter(&#x27;default&#x27;)); &#125;); // Concat &amp; Minify JS gulp.task(&#x27;minify&#x27;, function()&#123; return gulp.src(&#x27;src/*.js&#x27;) .pipe(concat(&#x27;all.js&#x27;)) .pipe(gulp.dest(&#x27;dist&#x27;)) .pipe(rename(&#x27;all.min.js&#x27;)) .pipe(uglify()) .pipe(gulp.dest(&#x27;dist&#x27;)); &#125;); // Watch Our Files gulp.task(&#x27;watch&#x27;, function() &#123; gulp.watch(&#x27;src/*.js&#x27;, [&#x27;lint&#x27;, &#x27;minify&#x27;]); &#125;); // Default gulp.task(&#x27;default&#x27;, [&#x27;lint&#x27;, &#x27;minify&#x27;, &#x27;watch&#x27;]);复制代码 gulp的执行是从上倒下的执行一个个任务。然后文件内容通过管道。进行传递。如果你想了解更多gulp的知识，可以去gulp官网 Parcel 极速打包（工程化：极速0配置） 零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等） 以html入口，自动检测和打包依赖 不支持SourceMap 无法Tree-shaking Webpack 预编译模块化方案（工程化：大而全） 通过配置文件达到一站式配置 loader进行资源转换，功能全面（css+js+icon+front） 插件丰富，灵活扩展 社群庞大 大型项目构建慢 webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。 接下来我们看看Webpack的工作原理图 webpack打包流程主要5步： 查找入口文件 从webpack的配置文件中查找entry的配置，从而找到入口文件 分析依赖关系 接到入口文件之后，从入口文件出发，分析入口文件中依赖了哪些文件，并且这些依赖的文件中还可能依赖别的文件，就这么递归的找下去。 模块函数 找到依赖中的所有文件，把这些文件转化成模块的函数，为了方便后面webpack进行调用 打包 打包完毕的文件可以产出到配置文件的output指定路径里，生成一个bundle 启动服务 node创建本地服务器并启动静态页面 Rollup 基于ES6打包（模块打包工具） Tree-shaking 打包文件小且干净，执行效率更高 更专注于JS打包 Snowpack 基于ESM运行时编译（工程化：ESM运行时） 无需递归循环依赖组装依赖树 默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等） 目前打包的困境在目前的工作中,我们主要利用webpack+vue(webpack+react)进行项目开发。然而，当我们构建越来越大型的应用的时候，打包工具需要处理的javascript代码量也呈指数级增长。在大型项目中包含几百甚至几千个模块的情况也越来越多。我们开始遇到性能瓶颈，使用javascript的工具通常需要很长的时间,才能启动开发服务器 这是我工作中的一个真实项目, 项目不大，但是启动服务器的时间花了30s。这作为一个讲究效率的程序员肯定是无法忍受的 当项目越来越大，项目的hmr热更新速度越来越慢。有时候甚至改动一个字段，页面几十秒之后才会进行热更新。 为什么产生这种问题？ 其实这和webpack打包的原理有关系，我们前面其实已经大概了解webpack的主要工作流，这里就不在详细讲解 启动服务器慢，是因为在每次服务器启动之前。webpack需要执行一系列的事情。找模块间的依赖,将各个模块进行合并，生成一个build,存入内存中，最后在启动服务器。所以速度上随着项目的增加，速度会越来越慢 webpack的hmr。当你改动一个文件的时候，Webpack 的热更新会以当前修改的文件为入口重新 build 打包，所有涉及到的依赖也都会被重新加载一次。所以速度也随着项目的增加而降低(后面会写一遍文章专门介绍webpack的hmr的实现) 为何不用 ESBuild 打包？ 虽然 esbuild 快得惊人，并且已经是一个在构建库方面比较出色的工具，但一些针对构建 应用 的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面。就目前来说，Rollup 在应用打包方面更加成熟和灵活。尽管如此，当未来这些功能稳定后，我们也不排除使用 esbuild 作为生产构建器的可能。 ViteESM ESM是JavaScript提出的官方标准化模块系统，不同于之前的CJS，AMD，CMD等等，ESM提供了更原生以及更动态的模块加载方案，最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行import，动态引入我们需要的模块，而不是把所有模块打包在一起。 ESM执行分为3步： 构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录 实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。 运行：运行代码，将内存空间填充 从上面实例化的过程可以看出，ESM使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。而CJS采用的是值拷贝，即所有导出值都是拷贝值。 Esbuild Vite底层使用Esbuild实现对.“ts、jsx、.“js代码文件的转化，所以先看下什么是es-build。 Esbuild是一个JavaScript“ Bundler打包和压缩工具，它提供了与Webpack、Rollup等工具相似的资源打包能力。可以将JavaScript 和TypeScript代码打包分发在网页上运行。但其打包速度却是其他工具的 10～100 倍。 esbuild总共提供了四个函数：transform、build、buildSync、Service Vite &#86;&#105;&#x74;&#x65;&#64;&#x32;&#46;&#48;&#x2e;&#51; &#x57;&#x65;&#98;&#x70;&#x61;&#x63;&#x6b;&#x40;&#53;&#46;&#x32;&#x34;&#46;&#50; &#83;&#x6e;&#x6f;&#119;&#x70;&#97;&#99;&#107;&#x40;&#x33;&#46;&#x30;&#46;&#x31;&#x33; 支持Vue2 非官方支持 支持：vue-loader@^15.0.0 非官方支持 支持Vue3 支持 支持：vue-loader@^16.0.0 支持 支持Typescript 支持：ESbuild （默认无类型检查） 支持：ts-loader 支持 支持CSS预处理器 支持 支持 部分支持：官方仅提供了Sass和Postcss，且存在未解决BUG 开发环境 no-bundle native ESM（CJS → ESM） bundle（CJS/UMD/ESM） no-bundle native ESM（CJS → ESM） HMR 支持 支持 支持 生产环境 Rollup Webpack Webpack, Rollup, or ESbuild vite和webpack编译过后文件的区别 VS WebapckWebpack是近年来使用量最大，同时社区最完善的前端打包构建工具，新出的5.x版本对构建细节进行了优化，在部分场景下打包速度提升明显。Webpack在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，Webpack则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。 Vite相比于Webpack而言，没有打包的过程，而是直接启动了一个开发服务器devServer。Vite劫持浏览器的HTTP请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。所以编译速度很快。 VS SnowPackSnowpack 首次提出利用浏览器原生ESM能力的打包工具，其理念就是减少或避免整个bundle的打包。默认在 dev 和 production 环境都使用 unbundle 的方式来部署应用。但是它的构建时却是交给用户自己选择，整体的打包体验显得有点支离破碎。 而 Vite 直接整合了 Rollup，为用户提供了完善、开箱即用的解决方案，并且由于这些集成，也方便扩展更多的高级功能。 两者较大的区别是在需要bundle打包的时候Vite 使用 Rollup 内置配置，而 Snowpack 通过其他插件将其委托给 Parcel/``webpack。 Vite原理Bundle-Based Dev Server(webpack)首先来说它们都有一个对应的 js 入口，然后通过入口 js 进行扫描应用的子模块，当这些模块被解析的时候，当然一些动态的模块也会被解析，当这些模块被 bundle 之后，它会把这些 bundlejs 注入到 html 当中，然后才会启动 dev server，等待页面的访问。从这之中我们就能看到整个过程存在的一些问题。首先他会找到整个应用所依赖的所有模块，这也正是导致我们项目变大之后启动就会变的很卡的一个主要原因。虽然有很多模块都是动态加载的，但是要进行对应的 chunk 到 bundle 的操作，其实并不是真正意义上的动态加载。其必须等待所有模块构建完成，即使是分片的模块也需要构建。 Native ESM based dev server(vite) ESM 是 es6 提出的概念，也就是可以原生支持 import，当然你得在 script 标签上增加一个 type=’moudle’的属性。当你 import 某一个模块的时候，浏览器会发一个对应的请求。具体去看看ES Modules的规范 1234&lt;script type=&quot;module&quot;&gt; import &#123; createApp &#125; from &#x27;./main.js‘ createApp()&lt;/script&gt; vite在开发环境启动时只需要启动两个Server，一个用于页面加载，一个用于HMR的Websocket。当浏览器发出原生的ESM请求，Server收到请求只需要编译当前文件后返回给浏览器，不需要管理依赖。 vite的工作流和冷启动 首先是启动一个静态资源服务器 找到项目的入口，开始加载入口文件 当声明一个 script 标签类型为 module 时，浏览器就会像服务器发起一个GET Vite 通过劫持浏览器劫持浏览器劫持浏览器的这些请求，并在后端进行相应的处理，将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器。 从上面的分析可知: vite主要做了以下事情 启动了一个静态资源服务器 只需要在浏览器请求源码时进行转换并按需提供源码 vite整个过程中没有对文件进行打包编译，至于其他加载的工作就交给了浏览器,所以其运行速度比原始的webpack开发编译速度快出许多。 vite的hmr热更新Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。 服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。 客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。 vite的按需加载为什么说vite才是真正的按需加载呢？难道webpack不是真正的按需加载吗？ 如果你想知道，那么你可以看看去看看webpack的原理，这里我简单介绍一下 webpack其实在开始构建打包的时候，还是对所有的文件进行一次打包构建，只是在webpack遇到 import( * ) 这种语法的时候,会另外生成一个chunk; 只有在合适的时候去加载import中的内容 从上面的分析可以知道。不管我们这段import的代码何时执行，我们对需要对它进行一定的打包 但是vite不一样，只有在你真正的需要加载的时候，浏览器才会发送import请求，去请求文件中的内容，所以才说vite才是真正的按需加载 Vite的请求拦截Vite 的基本实现原理，就是启动一个 koa 服务器拦截由浏览器请求 ESM的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM的格式返回给客户端。 Vite插件•@vitejs/plugin-vue / @vite-plugin-vue2 &gt;Vue3/Vue2支持 •@vitejs/plugin-vue-jsx &gt;提供 Vue 3 JSX 支持 •@vitejs/plugin-legacy &gt;为打包后的文件提供传统浏览器兼容性支持 开发一个自己的Vite插件 本质：编写基于Vite或Rollup的钩子函数。命名一般为vite-plugin- 前缀，rollup-plugin-前缀 插件钩子函数(普通字体为Rollup钩子，加粗为Vite钩子) 配置阶段：config、configResolved、configureServer 构建启动：options、buildStart 转换阶段：resolveId、load、transform；handleHotUpdate、transformIndexHtml 构建结束：buildEnd、closeBundle 12345678910111213141516171819202122232425262728293031323334353637383940414243export default function myPlugin() &#123; return &#123; name: &#x27;my-plugin&#x27;, // 插件名称 enforce: &#x27;pre&#x27;, //调整插件被执行顺序 apply: &quot;build | serve&quot;, // 指定插件应用情景 options(options) &#123; //服务器启动时被调用 &#125;, buildStart(options) &#123; //服务器启动时被调用 &#125;, resolveId(id) &#123; //每个传入请求时被调用 &#125;, load(id) &#123; //定义一个自定义加载器,对代码需要使用特性编译器解析可以使用 &#125;, transform(src, id) &#123; //这个钩子可以对解析后的代码进行加工处理 &#125;, buildEnd(error) &#123; //服务器关闭时被调用 &#125;, closeBundle() &#123; //这个是最终执行的钩子，可以用于清理等工作 &#125;, config(config, env) &#123; //在被解析之前修改 Vite 配置。 &#125;, configResolved(config) &#123; //在解析 Vite 配置后调用。 &#125;, configureServer(server) &#123; //用于配置开发服务器的钩子。 &#125;, transformIndexHtml(html, ctx) &#123; //转换 index.html 的专用钩子。 &#125;, handleHotUpdate(ctx) &#123; //执行自定义 HMR 更新处理。 &#125; &#125;&#125; 插件执行顺序 -Alias -带有 enforce: ‘pre’ 的用户插件 -Vite 核心插件 -没有 enforce 值的用户插件 -Vite 构建用的插件 -带有 enforce: ‘post’ 的用户插件 -Vite 后置构建插件（最小化，manifest，报告） Vite性能优化记一次Vite打包优化 三部曲： Network 分析 Lighthouse 分析 Bundle 分析","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"低代码微前端","slug":"H_工程热点_低代码微前端","date":"2022-05-11T22:33:16.000Z","updated":"2024-03-09T03:46:59.345Z","comments":true,"path":"2022/05/12/H_工程热点_低代码微前端/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BE%AE%E5%89%8D%E7%AB%AF/","excerpt":"","text":"大纲低代码Microsoft Power Apps、Mendix、OutSystems、Bubble、Appian 微前端single-spa、qiankun、Piral、Mosaic、","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"移动端框架","slug":"I_移动端框架","date":"2022-05-11T22:33:16.000Z","updated":"2024-06-01T12:07:15.235Z","comments":true,"path":"2022/05/12/I_移动端框架/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/12/I_%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/","excerpt":"","text":"大纲跨端APP跨端APP：Flutter、React Native、UniApp Dart Flutter入门实战基础视频教程-video Flutter从入门到进阶 实战携程网App-video-mk SpringBoot+Uniapp实战开发全新仿抖音短视频App-video-mk React Native从入门到实战 打造高质量上线App-video-mk React Native+TypeScript仿喜马拉雅开发App-video-mk 小程序WXML原生、UniApp、taro支持vue Taro3+Mysql+Express开发企业级出行全栈项目 -video 掌握Taro多端框架 快速上手小程序/H5开发-video 扫码点餐微信小程序云开发，uniapp，vue，nodejs带后台管理-video SpringBoot2.X + Vue + UniAPP，全栈开发医疗小程序-video-mk 微信公众号WeRoBot、Flask-WeChat、Tornado-WeRoBot、django-weixin 微信公众号开发课程-video 一个完整 HTML5 页面的展示要经历浏览器控件的加载、解析和渲染三大过程，性能消耗要比原生开发增加 N 个数量级。 前言 移动开发的最佳 React Native 替代方案 思辨：移动开发的未来在哪？ 跨平台、跨端 跨平台：指跨操作系统 跨端：指跨web,ios,android,iot设备 移动开发细分领域 混合开发和跨平台框架 Framework和Kernel 逆向安全 音视频 移动Web 嵌入式 个人的一些思考 1.AIGC+移动端 2023年的AIGC的火热空前绝后，它带来的影响是非常深远的，甚至能够变革整个互联网行业，很多产品可能将会以新的思路去重构和延伸，这里面就会产生相应的在移动端和AIGC结合相关产品和业务，公司层面也会有相应的投入意愿，这也许会给我们带来新的机会。 2.元宇宙：VR/AR/XR 元宇宙虽然被炒概念，一直不温不火的，但这里面涉及的技术是比较前沿的，在游戏领域跟元宇宙的结合，如果能找到愿意投入企业，未尝不是一个不错的方向。 3.IoT物联网 万物互联方向，比如智能家居，智能创新硬件产品，类似小米IoT相关的产品，智能手环、扫地机器人等等。这里面也有庞大的市场需求，另外软硬件结合对开发人员要求更高，更接近底层。 4.新能源车载系统 新能源车的其中一个核心就是智能中控，比如特斯拉的中控系统是Linux，比亚迪还有蔚小理和大多数造车新势力用的是Android系统，这里面也有很多车载系统应用的需求，也是很多人都求职热门方向。 5.音视频技术领域 当下流行的短视频，涉及到的核心就是音视频技术，有这方面的技术积累的同学应该也能获得不错的发展机会，而且这方面的人才相对而言比较稀缺。 6.跨平台技术 从企业降本的角度，未来可能会更倾向招聘懂跨平台开发的，希望能统一技术栈能够实现多端发布的能力。比如Flutter、React Native、UniApp等。 7.鸿蒙OS应用开发 国产替代是个很深远的话题，卡脖子问题现在越演越烈，从软件产业我们跟漂亮国还存在很多差距，我们能够正视这些差距并且迎头突围是一个非常值得敬佩和骄傲的事情。鸿蒙OS有望成为第一个完全去Android化的操作系统，Mate60系列手机产品我认为是一个标志性里程碑，我们不谈什么遥遥领先，我相信华为一定会越来越好，鸿蒙OS应用开发也是我觉得有较好前景的方向。 发展史 WebApp:PWA Hybrid APP:Cordova，Ionic,VasSonic 语言编译转换:Xamarin 原生渲染：React,Native,Weex,Dcloud 自渲染：Flutter 还有一个笼统划分：Web 容器时代，泛 Web 容器时代，自绘引擎时代 Web 容器时代：基于 Web 相关技术通过浏览器组件来实现界面及功能，典型的框架包括 Cordova(PhoneGap)、Ionic 和微信小程序。 泛 Web 容器时代：采用类 Web 标准进行开发，但在运行时把绘制和渲染交由原生系统接管的技术，代表框架有 React Native、Weex 和快应用，广义的还包括天猫的 Virtual View 等。 自绘引擎时代：自带渲染引擎，客户端仅提供一块画布即可获得从业务逻辑到功能呈现的多端高度一致的渲染体验。Flutter，是为数不多的代表。 WebApp:PWAWeb App 是指基于 Web 的应用，运行于网络和标准浏览器上，相当于一个网页然后加一个 App 的壳。主要采用的是原生应用内嵌浏览器控件 WebView（iOS 为 UIWebView 或 WKWebView，Android 为 WebView）的方式进行 HTML5 页面渲染，并定义 HTML5 与原生代码交互协议，将部分原生系统能力暴露给 HTML5，从而扩展 HTML5 的边界。 性能低，操作体验不好 无法调用原生 API，很多功能无法实现， 依赖于网络，网速慢时体验很差，并且没有离线功能，优化不好的话会消耗流量 只能做为一个临时的入口，用户留存率低 PWA是web App的进化型，PWA（Progressive Web App，渐进式增强 Web 应用）。它不是一门技术，而是一个概念，他的意思就是使用多种技术来增强 Web App 的功能 PWA 的主要的能力就是离线、推送、桌面访问，可以说 PWA 赋予 Web App 原生的体验，但是 PWA 一直不温不火的原因主要有以下几点： 用 Service Worker + HTTPS +Cache Api + indexedDB 等一系列 web 技术实现离线加载和缓存 实现了推送和通知 可以直接添加到手机的桌面上 使用 Service Worker 可以进行后台同步 游览器对 PWA 技术支持还不够全面， 不是每一款游览器都能 100% 的支持 PWA 国内一些手机厂商对 Android 系统各种魔改，对 PWA 的兼容性不好，甚至不支持 PWA 平台的竞争，iOS 对 PWA 的支持力度远远低于 Android，所以 PWA 在 iOS 上的体验打了折扣。PWA 面对类似的微信小程序和快应用的竞争中，并没有优势 Hybrid APP:Cordova，Ionic,VasSonicHTML5 + 原生来进行混合开发，这就是 Hybrid。 Cordova 优点 缺点 跨平台，开发简单，学习成本低 WebView性能低下时，用户体验差，反应慢 框架多，插件多，可自定义插件 国外的框架，中文文档资源少 发展最早，社区资源丰富 调试不方便，既不像原生那种调试，也不像纯web那种热重载式的调试 相同代码通过编译就能跑在各平台，大大提高了多平台开发的效率 App store相关政策存在风险？ Ionic Ionic是一个开源的移动应用程序开发框架，它可以轻松地使用web技术构建高质量的跨平台的移动应用。 VasSonic 腾讯开发的产品，专注于提升页面首屏加载速度，完美支持静态直出页面和动态直出页面，兼容离线包等方案 语言编译转换:XamarinXamarin 是一个开放源代码平台，用于通过 .NET 构建适用于 iOS、Android 和 Windows 的新式高性能应用程序。 Xamarin 是一个抽象层，可管理共享代码与基础平台代码的通信。 Xamarin 在提供便利（如内存分配和垃圾回收）的托管环境中运行。 原生渲染：React Native,Weex,DcloudReact Native React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架,支持iOS和安卓. 优点 缺点 复用了 React 的思想，有利于前端开发者涉足移动端。 做不到 Write once, Run everywhere 能够利用 JavaScript 动态更新的特性，快速迭代。 不能做到完全屏蔽 iOS 端或 Android 的细节 相比于原生平台，开发速度更快，相比于 Hybrid 框架，性能更好。 由于 Objective-C 与 JavaScript 之间切换存在固定的时间开销，所以性能必定不及原生 Weex Weex是alibaba于2015年推出的一款跨平台开发框架,支持Android、iOS 和 Web。目前支持Vue.js 和 Rax框架的完善开发。 优点 缺点 国内团队开发，中文文档齐全 动画实现、API丰富程度及事件机制上略逊于RN Vue作为前端开发语言，学习成本低 不支持横竖屏切换 与RN不同，Weex的框架较轻 阿里将其捐赠给Apache，后续维护频率低（KPI产品） Dcloud（uni-app） uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。 uni-app是双渲染引擎，在 App端内置了一个webview和一个基于 weex 改进的原生渲染引擎，提供了原生渲染能力。 在App端： 如果使用vue页面，则使用webview渲染 如果使用nvue页面(native vue的缩写)，则使用原生渲染 自渲染：FlutterFlutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。 类型 Cordova Xamarin React Native Weex Uniapp Flutter 性能 低 高 较高 中 高 高 上手难度 容易 较高 较高 容易 容易 中 核心 JavaScript .NET React Weex vue Dart 框架轻重 轻 较重 较重 较轻 轻 重 特点 适合单页面 适合开发整体App 适合开发整体App 适合单页面 适合开发整体App 适合开发整体App 社区 活跃度较低 活跃度低 活跃度高，Facebook维护 活跃度中，目前托管apache 活跃度高，Dcloud维护 活跃度高，Google维护 支持平平台实现 JS 引擎解释执行JS代码 JS 引擎解释执行JS代码 JS 引擎解释执行JS代码 JS 引擎解释执行JS代码 JS 引擎解释执行JS代码 Dart 代码编译成目标机器码 适应性 Web开发学习成本低 .NET C#工程师开发 Web开发学习成本低 Web开发学习成本低 Web开发学习成本低 Java、C++、C#、开发学习成本低 其他小程序 小程序开发本质上还是前端 HTML + CSS + JS 那一套逻辑，它基于 WebView 和微信自己定义的一套 JS/WXML/WXSS/JSON 来开发和渲染页面。 在 iOS 上，小程序的 JavaScript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 iOS 8+； 在 Android 上，小程序的 JavaScript 代码是通过 X5 JSCore 来解析，是由 X5 基于 Mobile Chrome 53/57 内核来渲染的； 在 开发工具上， 小程序的 JavaScript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的。 编程语言编程语言分为两大阵营: 解释型 - 需要解释器提供“实时翻译”。如 python、JavaScript、Dart 编译型 - 需要预编译，执行效率高，但跨平台能力差。如 C/C++、Java、Dart","categories":[{"name":"I_移动端","slug":"I-移动端","permalink":"https://fuyunjinglong.github.io/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[]},{"title":"Flutter","slug":"I_移动端_Flutter","date":"2022-05-09T22:33:16.000Z","updated":"2024-06-01T11:56:44.434Z","comments":true,"path":"2022/05/10/I_移动端_Flutter/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/10/I_%E7%A7%BB%E5%8A%A8%E7%AB%AF_Flutter/","excerpt":"","text":"1.Flutter是什么? Flutter官网 Flutter是一款移动应用程序SDK，一份代码可以同时生成iOS和Android两个高性能、高保真的应用程序。 Flutter诞生过程： 2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。 2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。 2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。 2.Flutter优势 提高开发效率 同一份代码开发iOS和Android 用更少的代码做更多的事情 轻松迭代 在应用程序运行时更改代码并重新加载（通过热重载） 修复崩溃并继续从应用程序停止的地方进行调试 创建美观，高度定制的用户体验 受益于使用Flutter框架提供的丰富的Material Design和Cupertino（iOS风格）的widget 实现定制、美观、品牌驱动的设计，而不受原生控件的限制 3.核心模块 Flutter包括一个现代的响应式框架、一个2D渲染引擎、现成的widget和开发工具。 跨平台自绘引擎Flutter与其他用于构建App的大多数框架不同，因为Flutter既不使用WebView，也不使用平台（Android、iOS等）的原生控件。相反，Flutter使用自己的高性能渲染引擎来绘制Widget。这样不仅可以保证在Android和iOS平台上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎，值得一提的是，由于Android系统已经内置了Skia，所以Flutter在打包APK（Android应用安装包）时，不需要再将Skia打入APK中，但iOS系统并未内置Skia，所以构建iPA时，也必须将Skia一起打包，这也是为什么Flutter APP的Android应用安装包比iOS应用安装包小的主要原因。 高性能Flutter采用GPU渲染技术，Flutter编写的应用是可以达到120fps（每秒传输帧数），这也就是说，它完全可以胜任游戏的制作，而我们常说的RN的性能只能达到60fps，这也算是Flutter的一个超高竞争力，官方宣称Flutter甚至会超过原生性能。 Flutter高性能主要靠两点来保证： 首先，Flutter App采用Dart语言开发，Dart在JIT（即时编译）模式下，速度与JavaScript基本持平；而且Dart还支持AOT（提前编译）模式，当以AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。 其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样通过JavaScriptCore在JavaScript和原生之间进行通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程中往往都会引起布局发生变化，所以JavaScript需要和原生之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 为什么Flutter采用Dart语言开发？ 为什么 Flutter 选择了 Dart 语言 介绍两个概念：JIT和AOT。 目前，程序主要有两种运行方式：静态编译和动态解释。 静态编译：静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT（Ahead of time）即“提前编译”； 动态解释：动态解释的程序是在执行中一句一句边翻译边运行的，通常将这种类型称为JIT（Just-in-time）即“即时编译”。 AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、Python等，事实上，所有脚本语言都支持JIT模式。但值得一提的是JIT和AOT指的是程序运行方式，它们和编程语言并非强关联，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码，然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。 Dart和JavaScript比较： 开发效率高 基于JIT的快速开发周期：Flutter在开发阶段采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；（Dart运行时支持） 基于AOT的发布包：Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能，而JavaScript则不具有这个能力。（编译器支持） 高性能 Flutter旨在提供流畅、高保真的UI体验。为了实现这一点，Flutter需要能够在每个动画帧中运行大量的代码，这意味着需要一种既能提供高性能的语言，又不会出现丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效的处理琐碎任务的内存分配器将显得十分重要，如果Dart语言缺乏此功能，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好了，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，但对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，就是它的一个重要优势。 Dart团队的支持 由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所诉：“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初使用Dart时，该语言并没有提供生成原生二进制文件的工具链（工具链对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。” 4.一切皆为widgetWidget是Flutter应用程序用户界面的基本构建块。每个Widget都是用户界面一部分的不可变声明。 与其他将视图、控制器、布局和其他属性分离的框架不同，Flutter具有一致的统一对象模型：widget。 Widget可以被定义为: 一个结构元素（如按钮或菜单） 一个文本样式元素（如字体或颜色方案） 布局的一个方面（如填充） 等等… 5.Flutter与React Native、Weex比较React Native、Weex等一直存在一个问题，就是性能跟原生App存在很大的差异 原生app苹果2008年发布iOS，Google 2009年发布Android，它们的SDK是基于两种不同的编程语言Objective-C 和 Jave.现在又有了Swift和Kotlin。 WebViews最早的跨平台方案是基于JaveScript 和 WebView的，像PhoneGap、Cordova、Ionic等。 React NativeRN不仅桥接系统服务，也将系统UI也桥接到了JaveScript中，这样写出来的UI最终也会渲染成原生的控件。 FlutterFlutter使用Dart语言开发，Dart可以被编译（AOT）成不同平台的本地代码，让Flutter可以直接和平台通讯而不需要一个中间的桥接过程，从而提高了性能。 参考Flutter学习仓库 Github Flutter源码仓库 Flutter中文网","categories":[{"name":"I_移动端","slug":"I-移动端","permalink":"https://fuyunjinglong.github.io/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[]},{"title":"ES6-10新特性","slug":"B_JS_ES6-10新特性","date":"2022-05-04T22:33:16.000Z","updated":"2024-05-13T23:15:31.931Z","comments":true,"path":"2022/05/05/B_JS_ES6-10新特性/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/05/B_JS_ES6-10%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"大纲 JavaScript ES(6-11)全版本语法 ES新特性ES7新特性 Array.prototype.includes() Array.prototype.includes() 查询给定字符串是否包含一个字符 ES8新特性 Async/Await Object.values()，Object.entries() Async/Await 这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。 Object.values()，Object.entries() 作为遍历一个对象的补充手段，供for…of循环使用 ES9新特性 for await of for await of for of方法能够遍历具有Symbol.iterator接口的同步迭代器数据，但是不能遍历异步迭代器。 for await of可以用来遍历具有Symbol.asyncIterator方法的数据结构，也就是异步迭代器，且会等待前一个成员的状态改变后才会遍历到下一个成员，相当于async函数内部的await。 ES10新特性 Array.prototype.flat() String.trimStart 和 String.trimEnd Array.prototype.flat() 将多维数组打平，flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 1newArray = arr.flat(depth) // depth是指定要提取嵌套数组的结构深度，默认值为 1 String.trimStart 和 String.trimEnd 移除开头和结尾的空格。 trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。 trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。 ES2020新特性 可选链操作符 空位合并操作符 Promise.allSettled 可选链操作符 12let nestedProp = obj &amp;&amp; obj.first &amp;&amp; obj.first.second;let nestedProp = obj?.first?.second; 空位合并操作符 空位合并操作符，用 ?? 表示 123let c = a ? a : b // 方式1let c = a || b // 方式2缺点：它都会覆盖所有的假值，如a(0, &#x27;&#x27;, false)，这些值可能是在某些情况下有效的输入，但会执行b 12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b; Promise.allSettled 使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是reject,这会导致页面中该三个区域数据全都无法出来，这个状况我们是无法接受。 Promise.allSettled跟Promise.all类似, 其参数接受一个Promise的数组, 返回一个新的Promise, 唯一的不同在于, 它不会进行短路, 也就是说当Promise全部处理完成后,我们可以拿到每个Promise的状态, 而不管是否处理成功。 ES2021/ES12新特性候选提案 String.prototype.replaceAll() Promise.any 逻辑运算符和赋值表达式 数值分隔符 WeakRef and Finalizers Promise.any Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise。 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 箭头函数与普通函数区别参考 ES6 - 箭头函数、箭头函数与普通函数的区别 区别： 语法更加简洁、清晰 箭头函数不会创建自己的this 箭头函数继承而来的this指向在定义时指定后，永远不变 .call()/.apply()/.bind()无法改变箭头函数中this的指向 箭头函数不能作为构造函数使用 箭头函数没有自己的arguments 箭头函数没有原型prototype 箭头函数不能用作Generator函数，不能使用yeild关键字 扩展运算符 替代apply方法，一般在函数调用时处理参数 剩余参数(rest运算符)，主要针对函数形参 数据连接、合并 数组和对象的拷贝 字符串转数组 替代apply方法，一般在函数调用时处理参数 12345678function addFun(x, y, z) &#123; return x + y + z;&#125;var args = [1, 2, 3];// 用apply方法直接传递数组addFun.apply(null, args);// 替代apply的扩展运算符addFun(...args); 剩余参数(rest运算符)，主要针对函数形参 123function(argA, ...args)&#123; //&#125; 数据连接、合并 1234// ES5 合并var es5Arr = arr1.concat(arr2);// ES6 合并var es6Arr = [...arr1, ...arr2]; 数组和对象的拷贝 12var arr1 = [1, 2, 3];var arr2 = [...arr1]; 字符串转数组 12345var str = &#x27;hello&#x27;;// ES5 处理方式var es5Arr = str.split(&#x27;&#x27;);// ES6 处理方式var es6Arr = [...str]; 链判断运算符ES2020引入了链判断运算符 ?. 来简化这个操作： 1const firstName = message?.body?.user?.firstName || &#x27;default&#x27;; let暂时性死区定义 let 暂时性死区详解 1注意：let和const声明定义的变量作用在当前执行上下文的词法环境中。变量在他们的词法环境被初始化的时候被创建，但是在变量的词法绑定被执行前他们不能被以任何形式被访问。以带有初始化器的词法绑定形式定义的变量，在词法绑定被执行的时候用他的初始化器的赋值表达式的计算结果来赋值，而不是在变量被创建的时候赋值。如果一个let声明的词法绑定没有初始化器，那么这个变量在初始化绑定被执行的时候会被用undefined赋值。 ES6规定，let/const 命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。*这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。* 一、作用域 作用域 (scope) 可以被理解为是标识符（变量）在程序中的可见性范围。 作用域类型 动态作用域：动态作用域是在代码运行时确定的，关注函数从何处调用。javascript 并不具有动态作用域，但是this机制某种程度上很像动态作用域。 静态作用域：静态作用域在函数定义时决定了，关注函数在何处声明。静态作用域又叫词法作用域，JS就是静态作用域。 作用域种类 ES2015 / ES6出现之前，作用域分为函数作用域和全局作用域，es6增加了块级作用域。 作用域链 访问变量时，如果当前作用域没有，会一级一级往上找，一直到全局作用域，这就是作用域链。 作用域链延长 大部分情况下，作用域链有多长主要看它当前嵌套的层数，但是有些语句可以在作用域链的前端临时增加一个变量对象，这个变量对象在代码执行完后移除，这就是作用域延长了。 能够导致作用域延长的语句有两种:try...catch的catch块和with语句。 二、变量提升 变量声明的提升是以变量所处的第一层词法作用域为“单位”的，即全局作用域中声明的变量会提升至全局最顶层，函数内声明的变量只会提升至该函数作用域最顶层。 说变量完全不提升是不准确的。只是 let 和 const 所在的块级作用域变量提升后的行为跟var不一样，var是读到一个undefined，而块级作用域的提升行为是会制造一个暂时性死区。 三、函数提升 有了上面变量提升的说明，函数提升理解起来就比较容易了，但较之变量提升，函数的提升还是有区别的。即：函数提升只会提升函数声明，而不会提升函数表达式。 12345678910console.log(foo1) // [Function: foo1]foo1() // foo1console.log(foo2) // undefinedfoo2() // TypeError: foo2 is not a functionfunction foo1 () &#123; console.log(&quot;foo1&quot;)&#125;var foo2 = function () &#123; console.log(&quot;foo2&quot;)&#125; // foo2在这里是一个函数表达式且不会被提升 以上代码中，函数 foo1 是一个函数声明，在执行前会预解析，所以会提升至全局作用域，输出函数本身。但是foo2 是一个表达式，是在执行阶段才进行的赋值操作，所以不能预解析。 小结var 和 let、const 总结一下var 和 let、const的区别： var变量会进行申明提前，在赋值前可以访问到这个变量，值是undefined。 块级作用域也有“变量提升”，但是行为跟var不一样，块级作用域里面的“变量提升”会形成“暂时性死区”，在申明前访问会直接报错。 var 定义的变量可以反复去定义，let 和 const 不可以 var 定义的变量在循环过程中无法保存，let 和 const 可以 const 不能在 for 循环中定义，对于for...in和for...of循环是没问题的 var声明的变量会挂载到 window 全局对象上，let 和 const 不会 for 循环中的 var 、let 与 const 区别 var具有函数作用域，因此在for循环内定义的迭代变量会渗透到for循环外面。根据事件循环机制，先执行同步再异步，当5次循环结束后，i的值为5，i渗透到for循环外部 let声明的迭代变量i不能渗透到for循环外面，因此可以认为是，声明了5个块级作用域。可以认为每个for都是独立的作用域块。 1&#123;let i = 0;setTimeout(()=&gt;console.log(i),0);&#125; 1234567891011//使用var声明for循环中的迭代变量for(var i = 0;i &lt; 5;++ i)&#123;setTimeout(()=&gt;console.log(i),0);&#125;// 5,5,5,5,5//使用let声明for循环中的迭代变量for(let i = 0;i &lt; 5;++ i)&#123;setTimeout(()=&gt;console.log(i),0);&#125;// 0,1,2,3,4 声明变量的六种方法 ES5 只有两种声明变量的方法：var 和 function 。 ES6 除了添加 let 和 const 命令。 还有两种声明变量的方法：import 命令和 class 命令。 数组的扩展reduce累加器 var total = [ 0, 1, 2, 3 ].reduce(( acc, cur ) =&gt; { return acc + cur }, 0); every一假即假 const flag=[ 0, 1, 2, 3 ].every(ele=&gt; { return ele&gt;3 }); some一真即真 const flag=[ 0, 1, 2, 3 ].some(ele=&gt; { return ele&gt;3 }); SetSet 本身是一个构造函数，用来生成 Set 数据结构。Set 对象允许你存储任何类型的值，但是成员的值都是唯一的，没有重复的值。 Set 中的特殊值 Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复 undefined 与 undefined 是恒等的，所以不重复 NaN 与 NaN 是不恒等的，但是在 Set 中认为 NaN 与 NaN 相等，所有只能存在一个，不重复。 Set 实例对象的方法 add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。 delete(value)：删除某个值，删除成功返回 true，否则返回 false。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回键值对的遍历器。 forEach()：使用回调函数遍历每个成员。 Array 和 Set 对比 Array 的 indexOf 方法比 Set 的 has 方法效率低下 Set 不含有重复值（可以利用这个特性实现对一个数组的去重） Set 通过 delete 方法删除某个值，而 Array 只能通过 splice。两者的使用方便程度前者更优 Array 的很多新方法 map、filter、some、every 等是 Set 没有的（但是通过两者可以互相转换来使用） Set 的应用 1、Array.from 方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5])const array = Array.from(items) 2、数组去重 1234// 去除数组的重复成员;[...new Set(array)]Array.from(new Set(array))复制代码 3、数组的 map 和 filter 方法也可以间接用于 Set 123456let set = new Set([1, 2, 3])set = new Set([...set].map((x) =&gt; x * 2))// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5])set = new Set([...set].filter((x) =&gt; x % 2 == 0))// 返回Set结构：&#123;2, 4&#125; 4、实现并集 (Union)、交集 (Intersect) 和差集 1234567891011let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b])// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter((x) =&gt; b.has(x)))// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter((x) =&gt; !b.has(x)))// Set &#123;1&#125; weakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。 成员都是数组和类似数组的对象，若调用 add() 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。 123const b = [1, 2, [1, 2]]new WeakSet(b) // Uncaught TypeError: Invalid value used in weak set复制代码 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。 WeakSet 不可迭代，因此不能被用在 for-of 等循环中。 WeakSet 没有 size 属性。 MapMap 中存储的是 key-value 形式的键值对, 其中的 key 和 value 可以是任何类型的 Map 和 Object 的区别 Object 对象有原型， 也就是说他有默认的 key 值在对象上面， 除非我们使用 Object.create(null)创建一个没有原型的对象； 在 Object 对象中， 只能把 String 和 Symbol 作为 key 值， 但是在 Map 中，key 值可以是任何基本类型(String, Number, Boolean, undefined, NaN….)，或者对象(Map, Set, Object, Function , Symbol , null….); 通过 Map 中的 size 属性， 可以很方便地获取到 Map 长度， 要获取 Object 的长度， 你只能手动计算 Map 对象的方法 set(key, val): 向 Map 中添加新元素 get(key): 通过键值查找特定的数值并返回 has(key): 判断 Map 对象中是否有 Key 所对应的值，有返回 true，否则返回 false delete(key): 通过键值从 Map 中移除对应的数据 clear(): 将这个 Map 中的所有元素删除 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 数据类型转化 Map 转为数组 123let map = new Map()let arr = [...map]复制代码 数组转为 Map 12Map: map = new Map(arr)复制代码 Map 转为对象 12345let obj = &#123;&#125;for (let [k, v] of map) &#123; obj[k] = v&#125;复制代码 对象转为 Map 123for( let k of Object.keys(obj)）&#123; map.set(k,obj[k])&#125; Map的应用 Map 会保留所有元素的顺序, 是在基于可迭代的基础上构建的，如果考虑到元素迭代或顺序保留或键值类型丰富的情况下都可以使用。 下面摘抄自 vue3 源码中依赖收集的核心实现 12345678910111213let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; let dep = depsMap.get(key) if (!dep) &#123; depsMap.set(key, (dep = new Set())) &#125; if (!dep.has(activeEffect)) &#123; dep.add(activeEffect) activeEffect.deps.push(dep) ... &#125; WeakMap WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的 不能遍历，方法有 get、set、has、delete Set、WeakSet 、Map、WeakMap 比较Set 是一种叫做集合的数据结构(ES6新增的) 成员唯一、无序且不重复 [value, value]，键值与键名是一致的（或者说只有键值，没有键名） 允许储存任何类型的唯一值，无论是原始值或者是对象引用 可以遍历，方法有：add、delete、has、clear WeakSet 成员都是对象 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏 不能遍历，方法有 add、delete、has Map 是一种类似于字典的数据结构，本质上是键值对的集合 可以遍历，可以跟各种数据格式转换 操作方法有:set、get、has、delete、clear WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的 不能遍历，方法有 get、set、has、delete weakset 和 weakmap ES6 考虑到防止内存泄漏，推出了两种新的数据结构： weakset 和 weakmap 。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。 1const wm = new WeakMap()const element = document.getElementById(&#x27;example&#x27;) vm.set(element, &#x27;something&#x27;) vm.get(element) 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。 注册监听事件的 listener 对象很适合用 WeakMap 来实现。 123456// 代码1ele.addEventListener(&#x27;click&#x27;, handler, false)// 代码2const listener = new WeakMap() listener.set(ele, handler) ele.addEventListener(&#x27;click&#x27;, listener.get(ele), false) 代码 2 比起代码 1 的好处是：由于监听函数是放在 WeakMap 里面，一旦 dom 对象 ele 消失，与它绑定的监听函数 handler 也会自动消失。 小结： Set、Map、WeakSet、WeakMap、都是一种集合的数据结构 Set 和 WeakSet 是一种值-值的集合，且元素唯一不重复 Map 和 WeakMap 是一种键-值对的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型。 Set 和 Map可遍历，WeakSet 和 WeakMap不可遍历 WeakSet 和 WeakMap 键名所指向的对象，不计入垃圾回收机制 SymbolES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 基本数据类型有6种：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。 123456789// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false// 有参数的情况var s1 = Symbol(&quot;foo&quot;);var s2 = Symbol(&quot;foo&quot;);s1 === s2 // false 1)应用场景1：使用Symbol来作为对象属性名(key) 123456789const PROP_NAME = Symbol()const PROP_AGE = Symbol()let obj = &#123; [PROP_NAME]: &quot;一斤代码&quot;&#125;obj[PROP_AGE] = 18obj[PROP_NAME] // &#x27;一斤代码&#x27;obj[PROP_AGE] // 18 Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外。 1234567891011121314let obj = &#123; [Symbol(&#x27;name&#x27;)]: &#x27;一斤代码&#x27;, age: 18, title: &#x27;Engineer&#x27;&#125;Object.keys(obj) // [&#x27;age&#x27;, &#x27;title&#x27;]for (let p in obj) &#123; console.log(p) // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;&#125;Object.getOwnPropertyNames(obj) // [&#x27;age&#x27;, &#x27;title&#x27;]JSON.stringify(obj) // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125; 还是会有一些专门针对Symbol的API 12345// 使用Object的APIObject.getOwnPropertySymbols(obj) // [Symbol(name)]// 使用新增的反射APIReflect.ownKeys(obj) // [Symbol(name), &#x27;age&#x27;, &#x27;title&#x27;] 2)应用场景2：使用Symbol来替代常量 12345678910111213141516171819const TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol()function handleFileResource(resource) &#123; switch(resource.type) &#123; case TYPE_AUDIO: playAudio(resource) break case TYPE_VIDEO: playVideo(resource) break case TYPE_IMAGE: previewImage(resource) break default: throw new Error(&#x27;Unknown type of resource&#x27;) &#125;&#125; 3)应用场景3：使用Symbol定义类的私有属性/方法 在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。 而有了Symbol以及模块化机制，类的私有属性和方法才变成可能。例如： 123456789101112131415a.jsconst PASSWORD = Symbol()class Login &#123; constructor(username, password) &#123; this.username = username this[PASSWORD] = password &#125; checkPassword(pwd) &#123; return this[PASSWORD] === pwd &#125;&#125;export default Login 12345678910b.jsimport Login from &#x27;./a&#x27;const login = new Login(&#x27;admin&#x27;, &#x27;123456&#x27;)login.checkPassword(&#x27;admin&#x27;) // truelogin.PASSWORD // oh!no!login[PASSWORD] // oh!no!login[&quot;PASSWORD&quot;] // oh!no! 4)Symbol.for()，Symbol.keyFor() Symbol.for机制有点类似于单例模式，首先在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。和直接的Symbol就点不同了。 1234var s1 = Symbol.for(&#x27;foo&#x27;);var s2 = Symbol.for(&#x27;foo&#x27;);s1 === s2 // true Symbol.keyFor方法返回一个已登记的Symbol类型值的key。实质就是检测该Symbol是否已创建 12345var s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;var s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined Iterator迭代器说Iterator迭代器的原因是，为后面async/await的文章做铺垫，因为我async/await是由Generator+Promise共同构成，而其中的Generator就是依赖于迭代器Iterator。 一、定义 Iterator迭代器就是为了解决这个问题，它提供统一的接口，为不同的数据结构提供统一的访问机制。(目前Map、Set、Array支持Iterator)。常用的for...of就是依赖与Iterator迭代器。 核心： Iterator迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制 使得数据结构的成员能够按某种次序排列，并逐个被访问 123456789101112131415161718// 阮一峰 ECMAScript 6 入门// 模拟next方法返回值var it = makeIterator([&#x27;a&#x27;, &#x27;b&#x27;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125; &#125; &#125;&#125; 上面的makeIterator函数，它就是一个迭代器生成函数，作用就是返回一个迭代器对象。对数组执行这个函数，就会返回该数组的迭代器对象it。 通过调用next函数，返回value和done两个属性；value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法；当done为true时，即遍历完成。 二、Iterator规范 迭代器对象it包含一个next() 方法，调用next()方法，返回两个属性：布尔值done和值value，value的类型无限制。 要成为可迭代对象， 一个对象必须实现@@iterator方法。这意味着对象（或者它原型链上的某个对象）必须有一个键为@@iterator的属性，可通过常量 Symbol.iterator 访问该属性。 1234567891011121314151617181920let myIterable = &#123; a: 1, b: 2, c: 3&#125;myIterable[Symbol.iterator] = function() &#123; let self = this; let arr = Object.keys(self); let index = 0; return &#123; next() &#123; return index &lt; arr.length ? &#123;value: self[arr[index++]], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;var it = myIterable[Symbol.iterator]();it.next();for(const i of myIterable) &#123; console.log(i);&#125; 将myIterable对象添加Symbol.iterator属性，同时在返回的next方法中，添加两个属性，既让它成为了一个可迭代对象。 关键：包含一个next()方法，两个属性：done和value；定义一个对象的Symbol.iterator属性 三、Iterator和Generator Generator和Promise一样，都是提供异步编程解决方案。 Generator函数本质就是一个普通函数，但有2个特征： function关键字与函数名之间有一个星号* 函数内部使用yield表达式，定义不同的内部状态 1234567891011121314function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; Generator函数执行后，会返回一个Iterator对象。在Generator中的yield表达式，yield会记住当前代码运行的状态和位置，等在调用这串代码的时候会依次往后走。 Iterator（迭代器）就是一个可迭代的对象，而Generator（生成器）使用了yield或者生成器表达式，生成iterator对象，用一种方便的方法实现了iterator，在for循环取数据或使用next()取数据. 小结：Generator（生成器）可以理解为是对Iterator（迭代器）的一种实现 四、Iterator应用 Generator（生成器）就是其中最典型的一个应用，当然还有其他，例如：Map、Set、Array等原生具备Iterator（迭代器），支持for...of循环。 Obejct实现Iterator接口 Object对象虽然不支持Iterator（迭代器），但我们可以使用Generator（生成器）进行包装。 123456789let obj = &#123;a: 1, b: 2, c: 3&#125;function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, &#x27;-&gt;&#x27;, value);&#125; 参考 弄懂!!ES6中的Iterator迭代器 Generator函数是什么Generator 是ES6引入的新语法，Generator是一个可以暂停和继续执行的函数。Generator函数是将函数分步骤阻塞 ，只有主动调用next() 才能进行下一步 。 简单的用法，可以当做一个Iterator来用，进行一些遍历操作。复杂一些的用法，他可以在内部保存一些状态，成为一个状态机。 123Generator 基本语法包含两部分：函数名前要加一个星号；函数内部用 yield 关键字返回值。yield，表达式本身没有返回值，或者说总是返回undefined。next，方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function * foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var b = foo(5); b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125; b.next(13) // &#123; value:42, done:true &#125; async函数是什么asyns函数是Generator函数的语法糖。 相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。 但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的。 async 对应的是 * 。 await 对应的是 yield 。 async/await 自动进行了 Generator 的流程控制。 为什么Async/Await更好？ 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。 错误处理：Async/Await 让 try/catch 可以同时处理同步和异步错误。 for in、for of、forEach的比较1.for…of与for…in的区别 for…in遍历对象(当前对象及其原型上的)属性名称，遍历简单数组的索引值。主要用于遍历对象。 for…of只能用于可迭代对象，遍历对象(当前对象上的)属性值，遍历可迭代数组的元素。主要用于遍历迭代对象。 2.forEach 跳出当前循环：使用return 12345arr.forEach((a, i) =&gt; &#123; if (i === 2) &#123; return &#125;&#125;) 跳出全部循环：需要throw抛异常 12345678try &#123; arr.forEach((a, i) =&gt; &#123; if (i === 2) &#123; throw new Error() &#125; &#125;)&#125; catch (e) &#123;&#125; 3.for…of ES6提出的语句，在可迭代对象（Array，Map，Set，String，TypedArray，arguments）上创建一个迭代循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//遍历数组let array = [10,20];for(let val of array)&#123; console.log(val);&#125;// 10// 20//遍历字符串let str = &quot;bo&quot;;for(let val of str)&#123; console.log(val);&#125;// &quot;b&quot;// &quot;o&quot;//遍历maplet map = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);for(let entry of map)&#123; console.log(entry);&#125;// [&quot;a&quot;, 1]// [&quot;b&quot;, 2]// [&quot;c&quot;, 3]for(let [key,value] of map)&#123; console.log(value);&#125;// 1// 2// 3//遍历setlet set = new Set([1,1,2,2,3,3]);for(let value of set)&#123; console.log(value);&#125;// 1// 2// 3//遍历DOMlet divs = document.querySelectorAll(&quot;div&quot;);for(let div of divs)&#123; div.className = &quot;red&quot;;&#125;//遍历生成器function* fibonacci()&#123; let [prev,curr] = [0,1]; for(;;)&#123; [prev,curr] = [curr,curr+prev]; yield curr; &#125;&#125;for(let n of fibonacci())&#123; if(n&gt;1000) break; console.log(n);&#125; 4.for…in for…in 语句以任意顺序遍历一个对象的可枚举属性的属性名。所有可枚举属性和从它原型继承而来的可枚举属性，因此如果想要仅迭代对象本身的属性，要结合hasOwnProperty（）来使用 12345678910111213var obj = &#123;a:1, b:2, c:3&#125;;for(var prop in obj)&#123; console.log(prop);&#125;//a//b//cvar obj= &#123;a:1,[Symbol(&#x27;level&#x27;)]:2&#125;Reflect.ownKeys(obj) // 遍历所有属性，包括Symbol ES5和ES6之默认值的区别 ？ES5 使用三目运算符判断 123function doSomething (name) &#123; name = name === undefined ? &#x27;default name&#x27; : name&#125; ES6 普通值入参，直接赋值默认值 对象入参，fun({a}={}),使用空对象 针对必填参数，可添加函数 123456function requireParams () &#123; throw new Error(&#x27;required params&#x27;)&#125;function doSomething (name = requireParams(), age = 18) &#123; // do something&#125; ES5和ES6之继承的区别 ？ ES5的继承通过寄生组合式继承来实现。ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。 ES6 的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。 ES5 寄生组合式继承 ES5的继承，实质上是先创造子类的实例对象this，然后再将父类的方法添加到子类（this）上面。 所以， es5的写法不能继承原生构造函数（比如Array、Number等） 因为es5的继承是先创造子类的实例对象this，再将父类原型的属性和方法重写到子类上，因为没法访问父类的内部属性，导致es5的继承方式无法继原生的构造函数。 ES6 extend继承 参考 廖雪峰的原型继承 ES6类以及继承的实现原理 ES6下babel如何编译Class ES6的继承机制完全不同，实质上是先创造父类的实例对象this，并将父类的属性和方法放到this上（前提是通过super函数调用），然后再用子类的构造函数修改this。 所以， es6允许继承构造函数生成子类。因为es6是先创建父类的实例对象this，然后再用子类的构造函数修饰，所以子类就可以继承父类的所有属性和方法。因此class可以继承并自定义原生构造函数的子类。extends不仅可以用来继承类，还能用来继承原生构造函数，因此也就可以在原生数据结构的基础上，构造自定义的数据结构。 ES6继承核心源码 bable编译Class文件后的代码： 123456789101112var Child = function(_Parent) &#123; _inherits(Child, _Parent);// 核心 function Child(name, age) &#123; _classCallCheck(this, Child); // 调用父类的 constructor(name) var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name)); _this.age = age; return _this; &#125; return Child;&#125;(Parent); 其中核心是_inherits： 1234567891011function _inherits(subClass, superClass) &#123; // extend 的继承目标必须是函数或者是 null if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123; throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); &#125; // 代码1，类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); // 代码2，设置子类的 __proto__ 属性指向父类 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125; _inherits通俗理解： 代码1：保证了c instanceof Parent是true,Child的实例可以访问到父类的属性，包括内部属性，以及原型属性。 代码2：子类能访问到父类的静态方法 12345678910111213// 代码1翻译下就是function F()&#123;&#125;F.prototype = superClass.prototypesubClass.prototype = new F()subClass.prototype.constructor = subClass简写为一行代码是：subClass.prototype.__proto__ = superClass.prototype// 代码2翻译下就是：function A()&#123;&#125;var a = new A()a.__proto__ = A.prototype// a是一个实例，A.prototype是构造方法的原型。通过这种方式，那么a就可以访问A.prototype上面的方法。// 那把 subClass类比成 a，superClass类比成A.prototype，那是不是subClass可以直接访问 superClass的静态属性，静态方法了。 Module模块化语法注意：导入导出均可使用as别名 参考 「万字进阶」深入浅出 Commonjs 和 Es Module 深入 CommonJs 与 ES6 Module 「Node.js系列」深入浅出Node模块化开发——CommonJS规范 123456789101112131415161718192021/** * 导出 */export * from &#x27;module&#x27;; //重定向导出 不包括 module内的defaultexport &#123; name1, name2, ..., nameN &#125; from &#x27;module&#x27;; // 重定向命名导出export &#123; import1 as name1, import2 as name2, ..., nameN &#125; from &#x27;module&#x27;; // 重定向重命名导出export &#123; name1, name2, …, nameN &#125;; // 与之前声明的变量名绑定 命名导出export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;; // 重命名导出export let name1 = &#x27;name1&#x27;; // 声明命名导出 或者 var, const，function， function*, classexport default expression; // 默认导出export default function () &#123; ... &#125; // 或者 function*, classexport default function name1() &#123; ... &#125; // 或者 function*, class/** * 导入 */import defaultExport from &quot;module&quot;; // 默认导入import &#123; a, b, c &#125; from &quot;module&quot;; //解构导入import defaultExport, &#123; a, b, c as newC &#125; from &quot;module&quot;; //混合导入import * as name from &quot;module&quot;; //混合导入var promise = import(&quot;module&quot;); //动态导入(异步导入) 一、exports 1.命名导出（Named exports） 每一个需要导出的数据类型都要有一个name，**引入的时候都需要&#123;&#125;*。除非使用命名空间引入，才不需要{} 123456789101112131415//------ lib0.js ------const sqrt = Math.sqrt;function square(x) &#123; return x * x;&#125;export &#123;sqrt, square&#125;//同时导出多个方法export &#123;sqrt as sqrtOut, square as squareOut&#125;//同时也支持别名导出或者//------ lib0.js ------export const sqrt = Math.sqrt;//单独导出export const square = ()=&gt;&#123;xx&#125;//单独导出-----------------------------------------------------------------------------------//------ main.js ------import &#123; sqrt, square &#125; from &#x27;lib0&#x27;; import &#123; sqrt, square &#125; from &#x27;lib1&#x27;; 2.默认导出（Default exports） 默认导出就不需要name了，但是一个js文件中只能有一个export default，引入的时候不需要&#123;&#125; 相当于默认导出了一个名称为default的数据类型 123456789101112131415161718//------ lib0.js ------const sqrt = Math.sqrt;const square = ()=&gt;&#123;xx&#125;export default sqrt //单独导出或//------ lib1.js ------const sqrt = Math.sqrt;const square = ()=&gt;&#123;xx&#125;export default &#123;sqrt,square&#125; //导出多个方法-----------------------------------------------------------------------------------//------ main.js ------import sqrt from &#x27;lib0&#x27;;或import lib from &#x27;lib1&#x27;;lib.sqrt等价于import &#123; default as lib &#125; from &#x27;./lib1&#x27;;lib.sqrt 二、import 1.别名引入（Aliasing named imports） 123456789//------ lib0.js ------export const sqrt = Math.sqrt;//单独导出//------ lib1.js ------const sqrt = Math.sqrt;export default sqrt //单独导出---------------------------------------------------------------------------------//------ main.js ------import &#123;sqrt as sqrt0&#125; from &#x27;lib0&#x27;;//非defaultimport sqrt from &#x27;lib1&#x27;;//default 2.命名空间引入（Namespace imports） 当从每个模块需要引入的方法很多的时候，别名引入显得十分繁琐 1234567//------ lib0.js ------export const sqrt = Math.sqrt;//单独导出export const square = ()=&gt;&#123;xx&#125;//单独导出------------------------------------------------------------------------------------//------ main.js ------import * as coreLib0 from &#x27;lib0&#x27;;coreLib0.sqrt//优雅 三、最佳实践 1.Combinations exports (混合导出) 混合导出是 Named exports 和 Default exports 组合导出。 混合导出后，默认导入一定放在命名导入前面； 1234567891011//------ lib0.js ------export const sqrt = Math.sqrt;//单独导出const square = ()=&gt;&#123;xx&#125;export default &#123;square&#125;---------------------------------------------------------------// index.jsimport defaultlib0, &#123; sqrt &#125; from &#x27;lib0&#x27;;defaultlib0.square;sqrtimport defaultlib0, * as all from &#x27;lib0&#x27;;all.default.square;all.sqrt注意：&#123;&#125;大括号和*不能同时存在 2.Module Redirects (中转模块导出) 创建单个模块，集中多个模块的多个导出。使用 export from 语法实现 1234export &#123; hostname, hostname2 &#125; from &#x27;./env&#x27;; // 域名export &#123; Api &#125; from &#x27;./api&#x27;; // 接口apiexport &#123; default as config &#125; from &#x27;./config&#x27;; // 配置export &#123; default as httpAxios &#125; from &#x27;./axios&#x27;; // 请求函数 其他如： 1234export * from &#x27;lib&#x27;; // 没有设置 export defaultexport * as myFunc2 from &#x27;myFunc&#x27;; // 【ES2021】没有设置 export defaultimport &#123; default as function1, function2 &#125; from &#x27;bar.js&#x27;;export &#123; function1, function2 &#125;; 12// Empty import (for modules with side effects)import &#x27;./lib0&#x27;; 参考ES6、ES7、ES8、ES9、ES10新特性","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"JavaScript","slug":"E_数据结构_JavaScript","date":"2022-05-04T22:33:16.000Z","updated":"2024-09-03T23:28:51.721Z","comments":true,"path":"2022/05/05/E_数据结构_JavaScript/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/05/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_JavaScript/","excerpt":"","text":"大纲 JS数据结构与算法(函数式)-coderwhy-video JS数据结构与算法(es6)-coderwhy-video 数据结构与算法-千峰教育kript-video 数据结构与算法专题课-珠峰-video JavaScript数据结构工具 JavaScript 数据结构与算法之美 - 十大经典排序算法 类的封装React的class和hooks的区别 function是面向过程编程，class是面向对象编程。 React的Hooks是React 16.8版本中引入的新特性，它们可以让我们在不使用Class组件的情况下管理状态和其他React特性。相比于Class组件，Hooks可以更好地解决组件之间共享状态和逻辑的问题。使用Hooks可以提供了一种新的、更简单的方式来管理组件状态和逻辑。同时，使用Hooks还可以避免Class组件中的一些常见问题，如this绑定、生命周期函数过于复杂等。 Hooks优点 1.简化代码：Hooks可以让我们更好地抽象和组合组件逻辑，从而使代码更加简单。 2.更好的可测试性：使用Hooks可以使组件更加可测试，因为我们可以更容易地测试组件的各个部分。 3.更好的性能：使用Hooks可以使React更高效，因为它们可以避免在组件渲染时进行不必要的操作。 Class优点 1.更好的兼容性：Class组件是React最早引入的一种组件类型，因此它们在React的生态系统中有更广泛的应用和更好的兼容性。 2.生命周期：Class组件具有生命周期方法，这些方法可以在组件的不同阶段执行特定的操作。这使得Class组件更加灵活，可以用于处理一些复杂的场景。 3.更好的TypeScript支持：TypeScript对Class组件的支持比Hooks更好，因为它们有更严格的类型定义。 4.更好的可读性：Class组件的代码结构更加清晰明了，更容易理解和调试。 类封装的实现方式 连React都有限使用hooks,我们也有限使用es5写法 es5通过构造函数实现类 es6通过class关键字实现类 1234567891011121314//es5通过构造函数实现类的功能。 function Person(name,age)&#123; this.name = name, this.age = age &#125; this.say = function()&#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); &#125; Person.prototype.say2 = function()&#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); &#125; const p1 = new Person(&quot;jerry&quot;,21); console.log(p1); p1.say(); 12345678910111213// es6通过class关键字实现类class Person&#123; constructor(name,age)&#123; this.name = name, this.age = age &#125; say()&#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); &#125; &#125; const p2 = new Person(&quot;tom&quot;,22); console.log(typeof(Person)); p2.say(); 两者区别： 类的声明没有提升、和函数是不同的 同一个类不能被重复定义（’Identifier ‘XXX’ has already been declared’），而函数则是下面的会覆盖上一个函数 类也可以看作构造函数的一个语法糖 (函数式)-coderwhy王红元-推荐 笔记 字符串1.字符串-判断是否为回文 1234567891011121314151617181920212223// 方法1，允许使用reversefunction isPalindromicStr(str) &#123; return str == str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);&#125;// 方法12，不允许使用reversefunction isPalindromicStr(str)&#123; if(!str.length)&#123; return true &#125; str = str.toLowerCase().split(&#x27;&#x27;); let start =0; let end = str.length-1; while(start&lt;end)&#123; if(str[start]===str[end])&#123; start++; end--; &#125;else&#123; return false &#125; &#125; return true&#125; 2.字符串-去重 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;script &gt;// 借助json实现 function removeDuplicateChar(str)&#123; let result =[]; let json =&#123;&#125; for(let i =0;i&lt;str.length;i++)&#123; let char = str[i] if(!json[char])&#123; result.push(char); json[char] = true &#125; &#125; return result.join(&#x27;&#x27;);&#125;// 借助filter实现function removeDuplicateChar1(str)&#123; let result = Array.prototype.filter.call(str,function(char,index,arr)&#123; return arr.indexOf(char) === index; &#125;) return result.join(&#x27;&#x27;);&#125;// set实现function removeDuplicateChar2(str)&#123; let set = new Set(str.split(&#x27;&#x27;)); return [...set].join(&#x27;&#x27;)&#125;alert(removeDuplicateChar2(&#x27;abac&#x27;)) &lt;/script&gt;&lt;/html&gt; 3.输出字符串中次数最多的字符和次数 123456789101112131415161718192021function findMostFrequentChar(str) &#123; if (typeof str !== &#x27;string&#x27;) &#123; return &#x27;输入必须是字符串。&#x27;; &#125; if (str.length === 0) &#123; return &#x27;字符串不能为空！&#x27;; &#125; const occurrenceMap = new Map(); for (const char of str) &#123; occurrenceMap.set(char, (occurrenceMap.get(char) || 0) + 1); &#125; let maxChar = &#123; char: &#x27;&#x27;, occur: -Infinity &#125;; for (const [char, occur] of occurrenceMap) &#123; if (occur &gt; maxChar.occur) &#123; maxChar = &#123; char, occur &#125;; &#125; &#125; return `出现次数最多的字符是 &quot;$&#123;maxChar.char&#125;&quot;，出现次数为 $&#123;maxChar.occur&#125; 次。`;&#125;console.log(findMostFrequentChar(&quot;Hello&quot;)); // 输出：出现次数最多的字符是 &quot;l&quot;，出现次数为 2 次。 4.字符串逆序输出 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;script &gt;// 方法1:借助数组的reversefunction reverseString(str) &#123; return str.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125;// 方法2：借助字符串的charAt()function reverseString2(str) &#123; let res = &#x27;&#x27;; for(let i =str.length-1;i&gt;=0;i--)&#123; res += str.charAt(i); &#125; return res;&#125;// 方法3：借助递归function reverseString3(str,pos,res) &#123; // str原始字符串，pos字符串的最后一个索引值，res返回值 if(pos &lt;0)&#123; return res; &#125; res += str.charAt(pos); pos--; return reverseString3(str,pos,res)&#125;// 方法4：借助slice将字符串转为数组function reverseString4(str) &#123; let arr = Array.prototype.slice.call(str); return arr.reverse().join(&quot;&quot;);&#125;alert(reverseString4(&#x27;abcd&#x27;)) &lt;/script&gt;&lt;/html&gt; 数组1.一维数组转为二维数组 12345678910function convertTo2DArray(arr, chunkSize) &#123; var result = []; for (var i = 0; i &lt; arr.length; i += chunkSize) &#123; result.push(arr.slice(i, i + chunkSize)); &#125; return result;&#125; var inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // [[1, 2, 3], [4, 5, 6], [7, 8, 9]] var outputArray = convertTo2DArray(inputArray, 3); 2.数组扁平化 12[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] //这是一个拥有3个元素的数组，是一个一维数组（不存在数组嵌套）。` `[[&#x27;a&#x27;,&#x27;b&#x27;],[&#x27;c&#x27;,&#x27;d&#x27;],[&#x27;e&#x27;,&#x27;f&#x27;]] 从整体上看是一个数组，但是其中的元素又是数组，即数组中嵌套数组，这就是二维数组 以此类推····· [&#39;a&#39;,[&#39;b&#39;,[&#39;c&#39;]]]//3维数组 [&#39;a&#39;,[&#39;b&#39;,[&#39;c&#39;,[.....]]]]//n维数组 数组扁平化就是把多维数组转化成一维数组 es6提供的新方法 flat(depth) reduce方法 利用扩展运算符 split和toString共同处理 正则和 JSON方法共同处理 for循环 while循环 es6提供的新方法 flat(depth) 无需知道数组的维度，直接将目标数组变成1维数组。 depth的值设置为Infinity。 12let a = [1,[2,3,[4,[5]]]]; a.flat(Infinity); // [1,2,3,4,5] a是4维数组 reduce方法 第一个参数就是就是处理扁平化的箭头函数第二个参数是一个空数组，也是作为遍历的开始 123456var arr1 = [1, 2, [3], [1, 2, 3, [4, [2, 3, 4]]]];function flatten(arr) &#123; return arr.reduce((res,next) =&gt;&#123; return res.concat(Array.isArray(next)? flatten(next) : next); &#125;,[]); &#125; 利用扩展运算符 12345678function flatten(arr) &#123; // 只要arr数组中还存在数组元素，循环就继续进行 while (arr.some(item =&gt; Array.isArray(item))) &#123; // 展开数组，拼接空数组 arr = [].concat(...arr) &#125; return arr&#125; split和toString共同处理 1234function flatten(arr) &#123; // toString()方法把数组转换为1,2,3,4,5 return arr.toString().split(&quot;,&quot;)&#125; 正则和 JSON方法共同处理 1234567function flatten(arr) &#123; let str = JSON.stringify(arr); // 过滤所有的中中括号 str = str.replace(/(\\[|\\])/g, &#x27;&#x27;); str = &#x27;[&#x27; + str + &#x27;]&#x27;; return JSON.parse(str); &#125; for循环 1234567891011121314var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]]; function flatten(arr) &#123; var res = []; for (let i = 0, length = arr.length; i &lt; length; i++) &#123; if (Array.isArray(arr[i])) &#123; res = res.concat(flatten(arr[i])); //concat 并不会改变原数组 //res.push(...flatten(arr[i])); //扩展运算符 &#125; else &#123; res.push(arr[i]); &#125; &#125; return res; &#125; flatten(arr1); //[1, 2, 3, 1, 2, 3, 4, 2, 3, 4] while循环 123456789var arr1 = [1, 2, [3], [1, 2, 3, [4, [2, 3, 4]]]];function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); //arr = Array.prototype.concat.apply([],arr); &#125; return arr; &#125; flatten(arr1); //[1, 2, 3, 1, 2, 3, 4, 2, 3, 4] 3.树转扁平数组 12345678910111213141516171819202122232425262728293031var data = [&#123; name: &#x27;a&#x27;, id: 101, children: [&#123; name: &#x27;bb&#x27;, id: 101101, children: [] &#125;, &#123; name: &#x27;bb&#x27;, id: 101102, children: [&#123; name: &#x27;101102101&#x27;, id: 101102101, children: [] &#125;] &#125; ] &#125;];// 递归调用var idArr = []function getId(treeData, arr) &#123; data.forEach(ele =&gt; &#123; idArr.push(ele.id) // 判断有子元素,并且子元素的长度大于0就再次调用自身 if (ele.children &amp;&amp; ele.children.length &gt; 0) &#123; getId(ele.children, arr) &#125; &#125;) &#125;getId(data, idArr) 4.扁平数组转树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596let arr = [ &#123;id: 1, name: &#x27;部门1&#x27;, pid: 0&#125;, &#123;id: 2, name: &#x27;部门2&#x27;, pid: 1&#125;, &#123;id: 3, name: &#x27;部门3&#x27;, pid: 1&#125;, &#123;id: 4, name: &#x27;部门4&#x27;, pid: 3&#125;, &#123;id: 5, name: &#x27;部门5&#x27;, pid: 4&#125;,]/** * 0.不考虑性能实现，递归遍历查找 */ const getChildren0 = (data, result, pid) =&gt; &#123; for (const item of data) &#123; if (item.pid === pid) &#123; const newItem = &#123;...item, children: []&#125;; result.push(newItem); getChildren0(data, newItem.children, item.id); &#125; &#125;&#125;/** * 1.不用递归，也能搞定 * 主要思路是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储 */const getChildren1 = (items)=&gt;&#123; const result = []; // 存放结果集 const itemMap = &#123;&#125;; // // 先转成map存储 for (const item of items) &#123; itemMap[item.id] = &#123;...item, children: []&#125; &#125; for (const item of items) &#123; const id = item.id; const pid = item.pid; const treeItem = itemMap[id]; if (pid === 0) &#123; result.push(treeItem); &#125; else &#123; if (!itemMap[pid]) &#123; itemMap[pid] = &#123; children: [], &#125; &#125; itemMap[pid].children.push(treeItem) &#125; &#125; return result;&#125;/** * 2.最优性能 * 主要思路也是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储。 * 不同点在遍历的时候即做Map存储,有找对应关系。性能会更好。 */ const getChildren2 = (items)=&gt;&#123; const result = []; // 存放结果集 const itemMap = &#123;&#125;; // for (const item of items) &#123; const id = item.id; const pid = item.pid; if (!itemMap[id]) &#123; itemMap[id] = &#123; children: [], &#125; &#125; itemMap[id] = &#123; ...item, children: itemMap[id][&#x27;children&#x27;] &#125; const treeItem = itemMap[id]; if (pid === 0) &#123; result.push(treeItem); &#125; else &#123; if (!itemMap[pid]) &#123; itemMap[pid] = &#123; children: [], &#125; &#125; itemMap[pid].children.push(treeItem) &#125; &#125; return result;&#125;const arrayToTree = (data, pid) =&gt; &#123; let result = [];// getChildren0(data, result, pid) // result = getChildren1(data) result = getChildren2(data) return result;&#125; 栈1.实现栈有两种常用方式 数组 链表 数组实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;栈&lt;/h1&gt;&lt;/body&gt;&lt;script &gt;function Stack()&#123; this.item =[] // 这种写法会在所有实例对象中添加函数，不推荐 this.push = function(el)&#123; this.item.push(el) &#125; // 这种写法只在原型上添加函数，节省内存，推荐 Stack.prototype.push=function(el)&#123; this.item.push(el) &#125; Stack.prototype.pop=function(el)&#123; return this.item.pop() &#125; Stack.prototype.peek=function(el)&#123; return this.item[this.item.length-1] &#125; Stack.prototype.isEmpty=function(el)&#123; return this.item.length===0 &#125; Stack.prototype.size=function(el)&#123; return this.item.length &#125; Stack.prototype.toString=function(el)&#123; return this.item.reduce((pre,cur)=&gt;pre+cur+&#x27;&#x27;,&#x27;&#x27;) &#125;&#125;let a = new Stack()a.push(1)a.push(2)console.log(a.toString()) &lt;/script&gt;&lt;/html&gt; 2.栈的作用 js中基本数据类型存储栈内存中 js执行时有执行栈,事件循环中将以次执行执行栈中的回调 3.栈的应用 3.1用栈实现十进制转二进制 123456789101112131415161718192021&lt;html&gt;&lt;script &gt;function dec2bin(decNumber)&#123; // 定义栈对象,Stack是前文声明的对象 let stack = new Stack(); // 循环操作 while(decNumber&gt;0)&#123; // 获取余数，入栈(算法：第一次的余数对应二进制的第一位) stack.push(decNumber%2); // 向下取整，继续循环 decNumber = Math.floor(decNumber/2); &#125; let res=&#x27;&#x27;; while(!stack.isEmpty())&#123; res+=stack.pop() &#125; return res&#125;alert(dec2bin(2)) &lt;/script&gt;&lt;/html&gt; 链表队列1.实现队列方式： 数组-简单但效率低 链表-复杂但效率高 数组实现 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;script &gt;function Queue()&#123; this.item =[] // 入队，这种写法只在原型上添加函数，节省内存，推荐 Queue.prototype.enqueue=function(el)&#123; this.item.push(el) &#125; // 出队 Queue.prototype.dequeue=function(el)&#123; return this.item.shift() &#125; // 查看队列头部元素 Queue.prototype.font=function(el)&#123; return this.item[0] &#125; Queue.prototype.isEmpty=function(el)&#123; return this.item.length===0 &#125; Queue.prototype.size=function(el)&#123; return this.item.length &#125; Queue.prototype.toString=function(el)&#123; return this.item.reduce((pre,cur)=&gt;pre+cur+&#x27;&#x27;,&#x27;&#x27;) &#125;&#125;let queue = new Queue()queue.enqueue(1)queue.enqueue(2)alert(queue.toString()) &lt;/script&gt;&lt;/html&gt; 2.队列的作用 所有先进先出的场景 打印队列、线程队列等 js 异步中的任务队列 一个leetcode题 第933题 3.队列的应用 3.1击鼓传花升级版 123456789101112131415161718192021&lt;html&gt;&lt;script &gt;// 击鼓传花的升级版：每数到第n个人就淘汰，循环往复，最后剩下的人就是冠军function passGame(arr,n)&#123; let queue = new Queue(); arr.forEach(a =&gt; &#123; queue.enqueue(a) &#125;); while(queue.size()&gt;1)&#123; for(let i=0;i&lt;n-1;i++)&#123; // 轮询到不是第n个人，直接先出队再入队 queue.enqueue(queue.dequeue()) &#125; // 第n个人出队淘汰 queue.dequeue() &#125; alert(&#x27;最后的冠军是：&#x27;+queue.font())&#125;passGame([&#x27;lw&#x27;,&#x27;mm&#x27;,&#x27;aj&#x27;],2) &lt;/script&gt;&lt;/html&gt; 优先级队列1.什么是优先级队列 定义：它会自动根据元素的优先级将其插入到合适的位置。当你从 PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队。 2.优先级队列的应用 数据压缩：赫夫曼编码算法； 最短路径算法：Dijkstra 算法； 最小生成树算法：Prim 算法； 任务调度器：根据优先级执行系统任务； 事件驱动仿真：顾客排队算法； 排序问题：查找第 k 个最小元素。 3.实现优先级队列 三种方案实现优先级队列： 数组（顺序存储）实现优先队列：入队操作直接插入到数组队尾，时间复杂度为 O(1)。出队操作需要遍历整个数组，找到优先级最高的元素，返回并删除该元素，时间复杂度为 O*(*n)。 链表（链式存储）实现优先队列：链表中的元素按照优先级排序，入队操作需要为待插入元素创建节点，并在链表中找到合适的插入位置，时间复杂度为 O*(*n)。出队操作直接返回链表队头元素，并删除队头元素，时间复杂度为 O(1)。 二叉堆结构实现优先队列：构建一个二叉堆结构，二叉堆按照优先级进行排序。入队操作就是将元素插入到二叉堆中合适位置，时间复杂度为 (log⁡2)O(log2n)。出队操作则返回二叉堆中优先级最大节点并删除，时间复杂度也是 O*(logn)。 3.1数组实现优先级队列 12345678910111213141516171819202122232425262728293031323334// MinPriorityQueue Implementationclass PriorityQueue &#123; constructor() &#123; this.values = []; &#125; enqueue(node, priority) &#123; var flag = false; for (let i = 0; i &lt; this.values.length; i++) &#123; if (this.values[i].priority &gt; priority) &#123; this.values.splice(i, 0, &#123; node, priority &#125;); flag = true; break; &#125; &#125; if (!flag) &#123; this.values.push(&#123; node, priority &#125;); &#125; &#125; dequeue() &#123; return this.values.shift(); &#125; size() &#123; return this.values.length; &#125;&#125;// Example Usagevar a = new PriorityQueue();a.enqueue(10, 1);a.enqueue(1, 0);a.enqueue(8, 2); 链表1.链表特点 每个元素（通常称为节点）包含两个部分：存储的数据和指向下一个节点的链接 不必连续空间 与数组的比较： 内存不必连续，充分利用内存，内存动态管理 必须不必确定大小，大小可无限延伸 插入和删除数据，可达到O(1),效率高 2.实现链表常见操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;html&gt;&lt;script &gt;function LinkList()&#123; // 内部类 function Node(data)&#123; this.data =data; this.next = null &#125; // 属性 this.head = null; this.length = 0; // 添加节点 LinkList.prototype.append=function(data)&#123; let node = new Node(data); if(this.length === 0)&#123; this.head = node; &#125;else&#123; // 遍历，找到链表的最后一个节点 let curNode = this.head; while(curNode.next)&#123; curNode = curNode.next &#125; curNode.next = node; &#125; this.length+=1; &#125; // 打印 LinkList.prototype.toString=function(data)&#123; let curNode = this.head; let str=&#x27;&#x27;; while(curNode)&#123; str += &#x27;,&#x27;+curNode.data; curNode = curNode.next; &#125; return str.slice(1);// 把第一个逗号去掉 &#125; // 指定位置插入元素 LinkList.prototype.insert=function(position,data)&#123; if(position&lt;0||position&gt;this.length)&#123; return false; &#125; let node = new Node(data); if(position === 0)&#123; // 插入的是第一个元素：换头，先换后再换前 node.next = this.head; this.head = node; &#125;else&#123; // 中间插入 let index =0; let curNode = this.head; let preNode = null; while(index++&lt;position)&#123; preNode = curNode; curNode = curNode.next; &#125; node.next = curNode; preNode.next = node; &#125; this.length+=1; return true; &#125; // 获取第i个元素 LinkList.prototype.get=function(position)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return null; let index =0; let curNode = this.head; while(index++&lt;position)&#123; curNode=curNode.next; &#125; return curNode.data; &#125; // 获取元素位置 LinkList.prototype.indexOf=function(data)&#123; let index =0; let curNode = this.head; // 开始查找 while(curNode)&#123; // 找到即返回索引值 if(curNode.data===data)&#123; return index; &#125; curNode=curNode.next; index++; &#125; // 找到了最后 return -1; &#125; // 更新元素 LinkList.prototype.update=function(position,data)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return false; let index =0; let curNode = this.head; while(index++&lt;position)&#123; curNode=curNode.next; &#125; curNode.data = data; return true &#125; // 从指定位置删除元素，类似插入元素 LinkList.prototype.removeAt=function(position)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return false; if(position === 0)&#123; // 删除的是第一个元素：换头，先换后再换前 this.head = this.head.next &#125;else&#123; // 中间删除 let index =0; let curNode = this.head; let preNode = null; while(index++&lt;position)&#123; // 循环查找 preNode = curNode; curNode = curNode.next; &#125; // 前一个节点的next,指向当前节点的next preNode.next = curNode.next; &#125; this.length--; &#125; // 删除元素 LinkList.prototype.removeAt=function(data)&#123; const index = this.indexOf(data); return this.removeAt(index) &#125; // 是否为空 LinkList.prototype.isEmpty=function()&#123; return this.length===0; &#125; // 链表大小 LinkList.prototype.size=function()&#123; return this.length; &#125;&#125;let linkList = new LinkList();linkList.append(&#x27;abc&#x27;);linkList.append(&#x27;edf&#x27;);// linkList.insert(0,&#x27;123&#x27;)// linkList.removeAt(0)alert(linkList.size()) &lt;/script&gt;&lt;/html&gt; 双向链表1.链表特点 2.实现双向链表常见操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;html&gt;&lt;script &gt;function DoubleLinkList()&#123; // 内部类 function Node(data)&#123; this.data =data; this.prev = null; this.next = null; &#125; // 属性 this.head = null; this.tail = null; this.length = 0; // 添加节点 DoubleLinkList.prototype.append=function(data)&#123; let newNode = new Node(data) // 判断是否添加的是第一个节点 if(this.length == 0)&#123; this.head = newNode &#125;else&#123; this.tail.next = newNode newNode.prev = this.tail &#125; this.tail = newNode this.length += 1 &#125; // 2.将链表转为字符串 DoubleLinkList.prototype.toString=function()&#123; // 默认是从前往后遍历 return this.backWardString() &#125; // 2.1 forwardString向前遍历转为字符串 DoubleLinkList.prototype.forwardString=function()&#123; let curNode = this.tail; let res=&#x27;&#x27;; while(curNode)&#123; res+=curNode.data+&#x27;,&#x27;; curNode = curNode.prev; &#125; return res; &#125; // 2.2 backWardString向后遍历转为字符串 DoubleLinkList.prototype.backWardString=function()&#123; let curNode = this.head; let res=&#x27;&#x27;; while(curNode)&#123; res+=curNode.data+&#x27;,&#x27;; curNode = curNode.next; &#125; return res; &#125; // 指定位置插入元素 DoubleLinkList.prototype.insert=function(position,data)&#123; if(position&lt;0||position&gt;this.length)&#123; return false; &#125; let node = new Node(data); // 1.链表为空时，直接首尾节点替换 if(this.length===0)&#123; this.head = node; this.tail = node; &#125;else&#123; // 2.链表不为空 if(position === 0)&#123; // 2.1插入的是第一个元素：换头，先换后再换前 this.head.prev = node;// 旧节点的pre指向新节点 node.next = this.head;// 新节点的next指向旧节点 this.head = node;// 头结点执行新节点 &#125;else if(position===this.length)&#123; // 2.2插入的是最后一个元素 node.prev = this.tail; this.tail.next = node; this.tail = node; &#125;else&#123; // 2.3中间插入 let index =0; let curNode = this.head; while(index++&lt;position)&#123; curNode = curNode.next; &#125; node.next = curNode; node.prev = curNode.prev; curNode.prev.next = node; curNode.prev = node; &#125; &#125; this.length+=1; return true; &#125; // 获取第i个元素 DoubleLinkList.prototype.get=function(position)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return null; let index =0; let curNode = this.head; while(index++&lt;position)&#123; curNode=curNode.next; &#125; return curNode.data; &#125; // 获取元素位置 DoubleLinkList.prototype.indexOf=function(data)&#123; let index =0; let curNode = this.head; // 开始查找 while(curNode)&#123; // 找到即返回索引值 if(curNode.data===data)&#123; return index; &#125; curNode=curNode.next; index++; &#125; // 找到了最后 return -1; &#125; // 更新元素 DoubleLinkList.prototype.update=function(position,data)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return false; let index =0; let curNode = this.head; while(index++&lt;position)&#123; curNode=curNode.next; &#125; curNode.data = data; return true &#125; // 从指定位置删除元素，类似插入元素 DoubleLinkList.prototype.removeAt=function(position)&#123; // 越界判断 if(position&lt;0||position&gt;=this.length) return false; if(position === 0)&#123; // 删除的是第一个元素：换头，先换后再换前 this.head = this.head.next &#125;else&#123; // 中间删除 let index =0; let curNode = this.head; let preNode = null; while(index++&lt;position)&#123; // 循环查找 preNode = curNode; curNode = curNode.next; &#125; // 前一个节点的next,指向当前节点的next preNode.next = curNode.next; &#125; this.length--; &#125; // 删除元素 DoubleLinkList.prototype.removeAt=function(data)&#123; const index = this.indexOf(data); return this.removeAt(index) &#125; // 是否为空 DoubleLinkList.prototype.isEmpty=function()&#123; return this.length===0; &#125; // 链表大小 DoubleLinkList.prototype.size=function()&#123; return this.length; &#125;&#125;// 测试代码let doubleLinkList = new DoubleLinkList();doubleLinkList.append(&#x27;abc&#x27;);doubleLinkList.append(&#x27;edf&#x27;);// alert(doubleLinkList.backWardString())// alert(doubleLinkList.forwardString())doubleLinkList.insert(0,&#x27;aaa&#x27;)doubleLinkList.insert(3,&#x27;bbb&#x27;)doubleLinkList.insert(1,&#x27;ccc&#x27;)alert(doubleLinkList) &lt;/script&gt;&lt;/html&gt; (es6)-coderwhy王红元初级算法两个变量交换 临时变量 一次加，两次减 复用对象 利用数组 一行代码 ES6 的解构赋值 123456789101112131415161718192021// 临时变量var t; t = a; a = b; b = t;// 一次加，两次减a = a + b; b = a - b; a = a - b;// 复用对象a = &#123; a: b, b: a &#125;; b = a.b; a = a.a;// 利用数组a = [a, b]; b = a[0]; a = a[1];// 一行代码a = [b, b = a][0];// ES6 的解构赋值[a,b]=[b,a] js 实现斐波那契数列定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2) 解法： 解法1：递归 解法2：动态规划 解法1：递归 1234567function f(n) &#123; if (n === 1 || n === 2)&#123; return 1; &#125; else &#123; return f(n-1) + f(n-2); &#125;&#125; 解法2：动态规划 1234567891011function f(n) &#123; let n1 = 1, n2 = 1, sum = 1; for(let i = 3; i &lt;= n; i += 1) &#123; sum = n1 + n2; n1 = n2; // 往后移动一位数 n2 = sum &#125; return sum&#125; 随机生成指定长度的字符串解法：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。 12345678function randomString(n) &#123; let str = &#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;; let tmp = &#x27;&#x27;,i = 0,l = str.length; for (i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.floor(Math.random() * l)); &#125; return tmp;&#125; 数组去重 ES6 的 Set 扩展运算符（…） 对象数组方法去重 ES6 的 Set 123function dedupe(array) &#123; return Array.from(new Set(array)); &#125; 扩展运算符（…） 12let arr = [1, 2, 3, 3];let unique = [...new Set(arr)]; 对象数组方法去重 1234567891011function sort(arr)&#123; let obj = &#123;&#125;; let newArr = []; for(let i = 0; i &lt; arr.length; i++)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = 1; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 递归求和1-100 12345678function add(num1,num2)&#123; let num = num1+num2; if(num2+1&gt;100)&#123; return num &#125;else&#123; return add(num,num2+1) &#125;&#125;","categories":[{"name":"E_数据结构","slug":"E-数据结构","permalink":"https://fuyunjinglong.github.io/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"前端系统架构设计","slug":"H_工程热点_前端架构设计","date":"2022-05-04T22:33:16.000Z","updated":"2024-02-28T23:17:30.916Z","comments":true,"path":"2022/05/05/H_工程热点_前端架构设计/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/05/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"参考 大型项目前端架构浅谈 架构演进前言大公司如何部署前端项目 随着业务的不断发展，业务架构也越来越复杂。传统的功能被拆分成不同的模块，出现了中间件、中台等概念。代理服务、负载均衡、数据库分表、异地容灾、缓存、CDN、消息队列、安全防护等技术应用越来越广泛，增加了Web开发和运维的复杂度。 客户端的形态越来越多，除了Web之外iOS、Android等其他场景也出现在Web服务的客户端场景。 较早的关系型数据库MySQL、PostgreSQL等已经不能满足需求，出现了Redis/Memcached缓存数据库等一类满足特定需求的数据库。 为了满足特定的业务需求，出现了Lucene/Solr/Elasticsearch搜索应用服务器，Kafka/RabbitMQ/ZeroMQ消息系统，Spark计算引擎，Hive数据仓库平台等不同的基础架构。 中间件 中间件是独立的软件程序，用于管理计算资源和网络通信。常用的功能有过滤IP、合并接口、合并端口、路由、权限校验、负载均衡、反向代理等。 分布式 随着数据量的不断提高，单台设备难以承载这样的访问量，同时不同功能也被拆分到不同的应用中，于是出现了提高业务复用及整合的分布式服务框架(RPC)。 云服务 云计算诞生之前，大部分计算资源是处于“裸金属”状态的物理机，运维人员选择对应规格的硬件，建设机房的 IDC 网络，完成服务的提供，投入硬件基础建设和维护的成本很高。云服务出现之后，使用者可以直接购买云主机，基础设施由供应商管理，这种方式也被称作 IaaS (Infrastructure-as-a-Service) 。 随着架构的继续发展，应用的运行更加细粒度，部署环境容器化，各个功能拆成微服务或是Serverless的架构。 1.Serverless Serverless 架构由两部分组成，即 Faas (Function-as-a-Service) 和 BaaS (Backend-as-a-Service) 。 FaaS是运行平台，用户上传需要执行的逻辑函数如一些定时任务、数据处理任务等到云函数平台，配置执行条件触发器、路由等等，就可以通过云平台完成函数的执行。 BaaS包含了后端服务组件，它基于 API 完成第三方服务，主要是数据库、对象存储、消息队列、日志服务等等。 2.微服务 微服务起源于2005年Peter Rodgers博士在云端运算博览会提出的微Web服务 (Micro-Web-Service)，根本思想类似于Unix的管道设计理念。2014年，由Martin Fowler与 James Lewis共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯 (HTTP API) 。 微服务是一种应用于组件设计和部署架构的软件架构风格。它利用模块化的方式组合出复杂的大型应用程序： 各个服务功能内聚，实现与接口分离。 各个服务高度自治、相互解耦，可以独立进行部署、版本控制和容量伸缩。 各个服务之间通过 API 的方式进行通信。 各个服务拥有独立的状态，并且只能通过服务本身来对其进行访问。 随着微服务技术的不断发展，这种思想也被应用到了前端。2018年，第一个微前端工具single-spa出现在github。而后出现了基于single-spa的框架qiankun。 3.API网关 API网关是一个服务器，客户端只需要使用简单的访问方式，统一访问API网关，由API网关来代理对后端服务的访问，同时由于服务治理特性统一放到API网关上面，服务治理特性的变更可以做到对客户端透明，一定程度上实现了服务治理等基础特性和业务服务的解耦，服务治理特性的升级也比较容易实现。 CI/CD 持续集成 (Continuous Integration, CI) 是让开发人员将工作集成到共享分支中的过程。频繁的集成有助于解决隔离，减少每次提交的大小，以降低合并冲突的可能性。 持续交付 (Continuous Deployment, CD) 是持续集成的扩展，它将构建从集成测试套件部署到预生产环境。这使得它可以直接在类生产环境中评估每个构建，因此开发人员可以在无需增加任何工作量的情况下，验证bug修复或者测试新特性。 常用指标响应时间 系统响应时间，是计算机对用户的输入或请求作出反应的时间 。响应时间和时间片的大小有关，一般情况是：时间片越短，响应时间越快。 并发数 同时访问服务器站点的连接数。 并发：一个处理器同时处理多个任务。逻辑上的同时发生，你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭。 并行：多个处理器或者是多核的处理器同时处理多个不同的任务。物理上的同时发生。你吃饭吃到一半，电话来了，你一边打电话一边吃饭 吞吐量 指的就是单位时间内，系统处理的请求数量。 TPS（每秒的事务数），HPS（每秒的HTTP请求数），QPS（每秒的查询数）等等。性能一般通过缓存来解决。 分布式与集群定义简单理解 分布式是以缩短单个任务的执行时间来提升效率的 集群则是通过提高单位时间内执行的任务数来提升效率 如果一个任务由10个子任务组成，每个子任务单独执行需1小时，则在一台服务器上执行改任务需10小时。 采用分布式方案，提供10台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是Hadoop的Map/Reduce分布式计算模型） 而采用集群方案，同样提供10台服务器，每台服务器都能独立处理这个任务。假设有10个任务同时到达，10个服务器将同时工作，10小后，10个任务同时完成，这样，整身来看，还是1小时内完成一个任务！ 分布式：不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题 集群：同一个业务部署在多台机器上，提高系统可用性 区别与联系 分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。 分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。 举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一台去完成。 而分布式，从窄意上理解，也跟集群差不多， 但是它的组织比较松散，不像集群，有一个组织性，一台服务器垮了，其它的服务器可以顶上来。 分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务就不可访问了。 集群两大关键特性 可扩展性－－集群的性能不限于单一的服务实体，新的服务实体可以动态地加入到集群，从而增强集群的性能。 高可用性－－集群通过服务实体冗余使客户端免于轻易遇到out of service的警告。在集群中，同样的服务可以由多个服务实体提供。如果一个服务实体失败了，另一个服务实体会接管失败的服务实体。集群提供的从一个出 错的服务实体恢复到另一个服务实体的功能增强了应用的可用性。 两大能力 负载均衡－－负载均衡能把任务比较均衡地分布到集群环境下的计算和网络资源。 错误恢复－－由于某种原因，执行某个任务的资源出现故障，另一服务实体中执行同一任务的资源接着完成任务。这种由于一个实体中的资源不能工作，另一个实体中的资源透明的继续完成任务的过程叫错误恢复。 集群分类 Linux集群主要分成三大类(高可用集群， 负载均衡集群，科学计算集群) 1.高可用集群(High Availability Cluster) 常见的就是2个节点做成的HA集群，有很多通俗的不科学的名称，比如”双机热备”，”双机互备”，”双机”。 高可用集群解决的是保障用户的应用程序持续对外提供服务的能力。 2.负载均衡集群(Load Balance Cluster) 负载均衡系统：集群中所有的节点都处于活动状态，它们分摊系统的工作负载。一般Web服务器集群、数据库集群和应用服务器集群都属于这种类型。 负载均衡集群一般用于相应网络请求的网页服务器，数据库服务器。这种集群可以在接到请求时，检查接受请求较少，不繁忙的服务器，并把请求转到这些服务器上。从检查其他服务器状态这一点上看，负载均衡和容错集群很接近，不同之处是数量上更多。 3.科学计算集群(High Performance Computing Cluster) 高性能计算(High Perfermance Computing)集群，简称HPC集群。这类集群致力于提供单个计算机所不能提供的强大的计算能力。 具体包括： 高可用集群(普通两节点双机热备，多节点HA集群，RAC, shared, share-nothing集群等) 负载均衡集群(LVS等….) 高性能科学计算集群(Beowulf 类集群….) 分布式大白话讲 小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。 为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群。 Linux服务端最大并发数 C10K问题和C10M问题 在2000年初的时候，全球互联网的规模并不大，但是当时就已经提出了C10K问题，所谓C10K就是单机1w并发问题，虽然现在不觉得是个难题了，但是这在当初是很有远见和挑战的问题。 五元组 这样的话，就可以基本认为：理论最大并发数 = 服务端唯一五元组数。 Linux的端口号是2字节大小的short类型，总计2^16个端口，除去一些系统占用的端口，可用端口确实只剩下64000多了","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"面经","slug":"Z_业务和面经_面经","date":"2022-05-04T00:33:16.000Z","updated":"2023-06-11T12:55:27.661Z","comments":true,"path":"2022/05/04/Z_业务和面经_面经/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/04/Z_%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F_%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"面经任职要求字节跳动 1、本科及以上学历，扎实的计算机基础和前端基础；2、熟练掌握React/Vue等大型前端框架，理解底层原理，能够灵活运用；3、了解跨客户端/全栈 其中的一种技术体系，理解相关底层原理；4、熟悉前端工程化相关及原理，具备良好的架构设计和工程设计能力；5、有全栈实践，熟悉 Node/Python/Go 加分；6、有跨端开发经验（React Native/Weex/Flutter）加分；7、有Web游戏开发或引擎开发，音视频相关实践经验加分。 基本套路 个人介绍 项目体现：负责什么，推动了什么，解决什么，实现什么 亮点：你能做到的各种牛事！（各种能力都是，但是要在简历或者说面试上体现出来的），即动手能力、解决问题能力、学习能力 沟通反应，基础知识覆盖90% 原则：要么没有明显缺点，要么有一个显著的亮点 HR面试常问 为什么考虑换工作：从职业发展考虑 个人未来规划，以后的发展城市：为了评估你的稳定性的 有什么优势：该吹得吹 如何自我解决问题：先独自解决，百度，掘金，再和同事讨论… 对加班的看法：不排斥，但是不希望无效加班 期望薪资：如果很想去这家公司且手里没有offer，建议报一个适中的涨幅30%,如果面试表现还可以，可以多报.如果手里有offer，那不用怕，往多了报.最好不低于30%. 多久能入职:如果是离职的话，可以说1周内.如果是在职，就说考虑到离职流程和工作交接，不好评估，大概2周。 潜规则： 薪水要求高一点录取概率就大一点 初入行：8K到12K1年到2年：10K到15K3年到5年：13K到22K5年以上：18K以上 自己要自信，面试官只是比你早到公司 老板是人精，谈理想时，别虚伪，要坦诚 选择大于努力的前提是先足够的努力才会有选择 人生苦短，绝不将就，必须去自己真心想去的公司 我们喜欢什么样的面试者 基础扎实 从多年的经验看，那些发展好的同学都具备扎实的基础知识 比如只懂 jQuery 不懂 JavaScript 是不行的哦 如果了解计算机基础会更好，因为我们将面临很多非前端技术的问题 主动思考 被动完成任务的同学在这里进步会很慢 你需要有自己的想法，而不是仅仅完成任务 爱学习 前端领域知识淘汰速度很快，所以最好能经常学习和接触新东西 有深度 遇到问题时多研究背后深层次的原因，而不是想办法先绕过去 比如追踪某个 Bug 一直了解它本质的原因 有视野 创新往往来自于不同学科的交集，如果你了解的领域越多，就越有可能有新想法 遇到问题如何解决去不断地从文档的字里行间查看，并结合源码一步一步地去跟踪，去尝试解决这个问题。但有时候确实超出了我的能力范围，那么我就会把我的问题提炼成一个小 demo，到 StackOverflow，github 去问，或者问一些同样用这个轮子的作者，甚至干脆去 issue 里问作者 你的项目亮点是什么？做个页面就是亮点？面试官想从你的项目里了解你学习前端的思路，项目没有高低的，只要不是一个静态页面就行。不会框架的话，用js自己封装的一些有价值的插件，就github上那种人家也做过的，你弄过来搞懂了，也算有价值的，最重要的是言之有物。 你的项目难点？逻辑部分 缓存、懒加载、组件or路由级别的代码分割，还有一些节流、防抖、竞态请求等，pwa和http2等 业务逻辑很复杂而且多变 前端逻辑复杂度主要在于数据 + UI + 交互的实现，就比如一个简单的多 tab 页的功能，可以用 CSS 实现、用 JS 实现。 垂直领域解决方案 比如富文本内容发布业务需求，光是一个富文本编辑器就很复杂，要实现各种功能和兼容性 离职原因回答离职三部曲： 列出离职原因，包括薪水太少、文化不合、工作地点、晋升机制 文化是一个好切入点，工作热情，对良好文化渴望，肯定公司文化 回答原因，尽量让考官不再有其他问题。如：｢前公司的管理層認為公司的營運建立於成效，對此我非常認同，但是以文化的角度來看，要能保持一定的成效，我認為應該要以員工工作時是否能快樂為主。因此我想要尋找一個可以提供這種環境的公司，從貴公司的文化中，看得出來這也是你們非常在乎的一點。」 具体原因： 1、追求更好的事业发展 1、公司组织架构调整，新的岗位和个人职业发展不匹配2、换行业，公司所在的行业发展前景出现问题/自己想3、换城市，为家庭/对象/自己4、遇到瓶颈，挑战自己【适合在一家公司待了两三年及以上的人】6、猎头推荐的职位挺吸引人的，想尝试一下7、公司拖欠工资，公司倒闭了 1、没有成就感：当我已想尽办法都无法改变目前环境、局面、观念等的时候，我会因无所突破而离职。 2、企业发展较慢：当我在企业呆了较长时间，而因企业发展较慢，使我无法吸收新的养分或获得发展机会的时候，我会选择离职。。 3、个人成长问题：当我所处位置横向与纵向发展空间都不大的时候，我会因难以突破而离职。。 4、职业规划问题：在企业中无法实现我个人的职业生涯计划时，我会选择离职。 5、理念问题：当我的理念与企业理念差距较大，又无法有效融合的时候，我会选择离职。 谈薪-先出价者输切记不要先出价，这也是HR会直接问你期望薪资的原因，泄露低价就会被对方处处拿捏。你可以装糊涂，看我的演技。哎呀，我好久没出来面试了，咱们也是第一家，我也不太清楚现在是啥行情呀，咱们这个岗位的薪资范围是多少呀。或者是直接反问，咱们这个岗位的薪酬结构，年终奖股票，工作强度等细节，以及岗位薪资的范围。 这样就有两种结局：一个是HR会给你一个薪资范围，我们直接基于这个数字来判断是否符合预期。第二个是HR也是个老司机，也一样打太极回来，那就没办法了。 首先你得知道你到底值多少钱，这个数字你说了不算，市场说了算。我建议大家每个季度没事就面试几次，不吐工作，就图和面试官学习技术 外加上和HR谈谈钱，你就时刻知道自己的身价，然后加上你合理的涨幅，在高出10%左右的留给对方砍价，报出去也是可以的。 如果对方爽快答应，直接入职，如果不合理，也不要怂，直接礼貌且坚定的告诉对方，我很认可贵公司的发展前景，但是现在这个offer的薪资和我的预期还是有一些差距，看能否给到XX呢，我个人的发展方向和这个岗位的匹配度非常高，我相信入职以后我也一定能够带来符合这个薪资的作用，或者是你有其他特殊的优势，比如如果是Vue岗位，你给Vue贡献过代码等等 还有很多其他的谈判原则，比如坚决不接收对方的第一次开价，以降价换取成交是条走向灭亡之路,学会装作意外和不情愿，要防止红鲱鱼糖衣炮弹的攻击等等技巧，大家感兴趣可以去读这两本书 未来职业规划希望给开源项目做贡献 互联网公司黑名单程序员找工作黑名单 Resume准备阶段 个人信息 专业技能 工作经历 项目经历 社区贡献 个人信息 必备：姓名 电话 邮箱。 年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。 可以放 github 链接，前提是有内容。 专业技能 表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。 内容不要太多，3、5 条即可。 太基础的不要写，例如会用 vscode、lodash。 工作经历 如实写。 写明公司，职位，入职离职时间即可，多写无益。 如果有空窗期，如实写明即可。 项目经历 写 2-4 个具有说服力的项目（不要什么项目都写，没用）。 项目名称，项目描述，技术栈，个人角色。 社区贡献 有博客或者开源作品，会让你更有竞争力。 切记：需要真的有内容，不可临时抱佛脚。 项目层次 PC: toC 项目，主要为重客户端状态较为复杂的项目，以前端主要形态为卖点的产品，比如文档类，表格类，API调试类，思维导图类，笔记类。可将该类项目放在首位。另外，还有电商类、股票类等。或者官网。 RN(react native)/Electron/Browser-Extension: 手机应用、桌面应用、浏览器插件等跨端能力 Mobile/小程序: 移动端 Web 项目 Admin: 后台管理系统 Node: BFF 类项目，或者 Node.js 的纯后端项目 Infra: 在公司内部所做的基础建设，比如 Package 的发包，组件库的建设，脚手架的编写，公司公共能力抽象为私有库之类。甚至是 lint/type 等 dot 文件的规则建立 注意点 界面不能太花哨，简洁明了即可。 注意用词，“精通”“熟练”等慎用，可用“熟悉”。 不可造假，会被拉入黑名单。 过时技术栈不要写，比如 jQuery/Bootstrap 项目难点，项目亮点，合并集中描述 不要写和自己工作经验不符的内容，比如工作五年了，简历还都是熟悉 HTML，CSS 了解、熟悉、掌握、精通四个等级，一般不建议写精通 不要光秃秃地写一句“熟悉数据结构与算法”,比如我熟悉十大排序中的快排、归并、堆排 级别 初级：基础的编码能力和思维 中级：熟练使用基础，独立完成任务 高级:通过封装、优化手段，提升小组效率 资深高级：工程化 专家:大前端体系架构 投递阶段分2阶段 试水阶段，投递其它城市岗位此时可一周面试一到两次，在面试中完善八股文以及简历，用时三周左右。脱产者可一周面试两到三次。若有 offer，可选择价高者接收一个，方便为正式面试议价。 一定要投可线上面试的公司 一定不要投中大厂，容易弄花简历 正式阶段，投递心仪公司岗位，或托人内推。此时态度要虚心，诚恳，提前花费一个小时了解其公司（或业务线）业务、商业模式、产品形态，以及公司所需的技术栈等。在 Boss 直聘或邮件投递简历时，可发表一些对技术栈匹配，业务感兴趣且强烈加入的意愿。 邮件投递 尊敬的米哈游公司人力资源部： 我是一个热爱米哈游游戏的前端工程师，特别喜欢原神这款游戏，已经玩了两年。在这两年里，我对原神的设计、游戏体验、以及技术实现等方面有了深入的了解，对这款游戏充满了热爱和敬仰。 因此，我强烈想加入米哈游公司，一起打造更好的原神。我相信，我的专业知识和技能可以为米哈游公司的发展做出贡献，同时，我也期待能够在这里得到成长和提高。 我拥有丰富的游戏开发经验，熟悉游戏引擎、美术设计、以及游戏编程等方面的技能。我对游戏设计和开发有着独特的见解，并能够灵活地运用到实际工作中。同时，我也具备出色的团队合作精神和良好的沟通能力，可以与团队成员高效协作，完成共同的目标。 如果米哈游公司有合适的职位空缺，我表示愿意投递我的简历并参加面试。随附的附件中包含了我的详细简历和作品集，希望能给您带来更多的了解。如果需要更多的信息或证明，我随时准备提供。 我对加入米哈游公司充满了热忱和期待，相信我能够成为您们团队中的一员，为原神的发展做出更多的贡献。 谢谢您的耐心阅读，期待您的回复。 此致 敬礼！ 山月 面试阶段不要裸辞 不要裸辞 不要裸辞 面试时间 公司会议室面试。不过对心理素质要求极高。 约到晚八点面试。可早点下班在家中面试，如家里较远无法赶回去，可在公司会议室面试。甚至订一个公司附近的钟点房，进行面试。 离职原因年终季度奖全部取消，公司业务停滞，无上升空间，于是主动出来，并放弃 N+1，来寻求更好的机会。 自我介绍时间1-3min,准备几个亮点，不要背简历 自己的经历和优势。 自己做过的项目中的难点，怎么思考和解决的。 自己的重大业绩，突破性成果，包括工作和学习。 对面试的公司的理解和认识，如果有独特的理解肯定会加分。 比赛成绩，国内排名，开源项目。","categories":[{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"axios技巧","slug":"D_框架_axios技巧","date":"2022-05-03T22:33:16.000Z","updated":"2023-06-11T13:07:05.425Z","comments":true,"path":"2022/05/04/D_框架_axios技巧/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/04/D_%E6%A1%86%E6%9E%B6_axios%E6%8A%80%E5%B7%A7/","excerpt":"","text":"基本使用 安装axios npm install axios --save 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import axios from &#x27;axios&#x27;//创建axios的一个实例 var instance = axios.create(&#123; baseURL:&#x27;http://localhost:8080/&#x27;,//接口统一域名 timeout: 6000 //设置超时&#125;) //------------------- 一、请求拦截器 忽略instance.interceptors.request.use(function (config) &#123; return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;); //----------------- 二、响应拦截器 忽略instance.interceptors.response.use(function (response) &#123; return response.data;&#125;, function (error) &#123; // 对响应错误做点什么 console.log(&#x27;拦截器报错&#x27;); return Promise.reject(error);&#125;); /** * 使用es6的export default导出了一个函数，导出的函数代替axios去帮我们请求数据， * 函数的参数及返回值如下： * @param &#123;String&#125; method 请求的方法：get、post、delete、put * @param &#123;String&#125; url 请求的url: * @param &#123;Object&#125; data 请求的参数 * @returns &#123;Promise&#125; 返回一个promise对象，其实就相当于axios请求数据的返回值 */export default function (method, url, data = null) &#123; method = method.toLowerCase(); if (method == &#x27;post&#x27;) &#123; return instance.post(url, data) &#125; else if (method == &#x27;get&#x27;) &#123; return instance.get(url, &#123; params: data &#125;) &#125; else if (method == &#x27;delete&#x27;) &#123; return instance.delete(url, &#123; params: data &#125;) &#125;else if(method == &#x27;put&#x27;)&#123; return instance.put(url,data) &#125;else&#123; console.error(&#x27;未知的method&#x27;+method) return false &#125;&#125; 取消请求 1234567891011121314151617181920// 方式一const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(&#x27;xxxx&#x27;, &#123; cancelToken: source.token&#125;)// 取消请求 (请求原因是可选的)source.cancel(&#x27;主动取消请求&#x27;);// 方式二const CancelToken = axios.CancelToken;let cancel;axios.get(&#x27;xxxx&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; cancel = c; &#125;)&#125;);cancel(&#x27;主动取消请求&#x27;); axios是什么axios是一个基于promise的http库，可以用在浏览器和node.js的环境中；本质上也是对原生xhr的封装，只不过它是promise的实现版本，符合最新的ES规范。 特性： 从浏览器中创建 XMLHttpRequests，或者从 node.js创建 http 请求。即axios可以在浏览器上和服务器上都可以发起请求。axios还是属于xhr，因此需要实现一个ajax或基于http 支持 Promise API 拦截请求和响应转换请求数据和响应数据 取消请求 自动转换JSON 数据 客户端支持防御 XSRF 缺点1.不支持jsonp,需要自己封装2.基于xhr实现，所以无法在service worker,web worker中使用 实现简易的axiosAxios构造函数，核心代码为request 123456789101112131415161718class Axios &#123; constructor() &#123; &#125; request(config) &#123; return new Promise(resolve =&gt; &#123; const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config; // 发送ajax请求 const xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.onload = function() &#123; console.log(xhr.responseText) resolve(xhr.responseText); &#125; xhr.send(data); &#125;) &#125;&#125; 导出axios实例 123456789101112131415161718// 最终导出axios的方法，即实例的request方法function CreateAxiosFn() &#123; let axios = new Axios(); let req = axios.request.bind(axios); return req;&#125;// 得到最后的全局变量axioslet axios = CreateAxiosFn();module.exports = function bind(fn, thisArg) &#123; return function wrap() &#123; var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i]; &#125; return fn.apply(thisArg, args); &#125;;&#125;; 实现下axios.method() 12345678910111213141516171819202122// 定义get,post...方法，挂在到Axios原型上const methodsArr = [&#x27;get&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, &#x27;options&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;post&#x27;];methodsArr.forEach(met =&gt; &#123; Axios.prototype[met] = function() &#123; console.log(&#x27;执行&#x27;+met+&#x27;方法&#x27;); // 处理单个方法 if ([&#x27;get&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, &#x27;options&#x27;].includes(met)) &#123; // 2个参数(url[, config]) return this.request(&#123; method: met, url: arguments[0], ...arguments[1] || &#123;&#125; &#125;) &#125; else &#123; // 3个参数(url[,data[,config]]) return this.request(&#123; method: met, url: arguments[0], data: arguments[1] || &#123;&#125;, ...arguments[2] || &#123;&#125; &#125;) &#125; &#125;&#125;) 将Axios.prototype上的方法搬运到request上 1234567891011121314工具类，实现将b方法混入到a，并且修改this指向const utils = &#123; extend(a,b, context) &#123; for(let key in b) &#123; if (b.hasOwnProperty(key)) &#123; if (typeof b[key] === &#x27;function&#x27;) &#123; a[key] = b[key].bind(context); &#125; else &#123; a[key] = b[key] &#125; &#125; &#125; &#125;&#125; 修改导出的方法 1234567function CreateAxiosFn() &#123; let axios = new Axios(); let req = axios.request.bind(axios); // 增加代码 utils.extend(req, Axios.prototype, axios) return req;&#125; 构建拦截器的构造函数 123456789101112class InterceptorsManage &#123; constructor() &#123; this.handlers = []; &#125; use(fullfield, rejected) &#123; this.handlers.push(&#123; fullfield, rejected &#125;) &#125;&#125; 实现axios.interceptors.response.use和axios.interceptors.request.use 123456789101112class Axios &#123; constructor() &#123; // 新增代码 this.interceptors = &#123; request: new InterceptorsManage, response: new InterceptorsManage &#125; &#125; request(config) &#123; ... &#125;&#125; 把Axios上的方法和属性搬到request 将b的属性内容复制给a 此时将Axios原型上的方法复制到req中 最后把axios实例复制给req形成一个真正的req 12345678910function CreateAxiosFn() &#123; let axios = new Axios(); // req 绑定axios的默认数据 req，最后返回函数。即将Axios原型方法上的request方法绑定在context的上下文中 let req = axios.request.bind(axios); // 混入方法，复制Axios的原型到扩展到实例中，即处理axios的request方法，使之拥有get,post...方法 utils.extend(req, Axios.prototype, axios) // 将Axios的属性扩展到实例上 utils.extend(req, axios) return req;&#125; 现在request也有了interceptors对象，在发送请求的时候，会先获取request拦截器的handlers的方法来执行。 首先将执行ajax的请求封装成一个方法 1234567891011121314151617request(config) &#123; this.sendAjax(config)&#125;sendAjax(config)&#123; return new Promise(resolve =&gt; &#123; const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config; // 发送ajax请求 console.log(config); const xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.onload = function() &#123; console.log(xhr.responseText) resolve(xhr.responseText); &#125;; xhr.send(data); &#125;)&#125; 封装handlers中的回调 123456789101112131415161718192021request(config) &#123; // 拦截器和请求组装队列 let chain = [this.sendAjax.bind(this), undefined] // 成对出现的，失败回调暂时不处理 // 请求拦截 this.interceptors.request.handlers.forEach(interceptor =&gt; &#123; chain.unshift(interceptor.fullfield, interceptor.rejected) &#125;) // 响应拦截 this.interceptors.response.handlers.forEach(interceptor =&gt; &#123; chain.push(interceptor.fullfield, interceptor.rejected) &#125;) // 执行队列，每次执行一对，并给promise赋最新的值 let promise = Promise.resolve(config); while(chain.length &gt; 0) &#123; promise = promise.then(chain.shift(), chain.shift()) &#125; return promise;&#125; 完毕 源码分析axios的配置共分为3种，全局配置、实例配置、请求配置；这三个配置和我们进行的操作息息相关 实现入口文件为axios.js 合并请求配置和实例配置 规整化请求方法信息 收集请求拦截器和响应拦截器 进行发送请求 返回当前的promise 1234567891011121314151617181920212223242526272829303132333435363738function createInstance(defaultConfig) &#123; var context = new Axios(defaultConfig); // instance指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用 // Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用 var instance = bind(Axios.prototype.request, context); // 把Axios.prototype上的方法扩展到instance对象上， // 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context utils.extend(instance, Axios.prototype, context); // Copy context to instance // 把context对象上的自身属性和方法扩展到instance上 // 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性 // 这样，instance 就有了 defaults、interceptors 属性。 utils.extend(instance, context); return instance;&#125;// Create the default instance to be exported 创建一个由默认配置生成的axios实例var axios = createInstance(defaults);// Factory for creating new instances 扩展axios.create工厂函数，内部也是 createInstanceaxios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;// Expose all/spreadaxios.all = function all(promises) &#123; return Promise.all(promises);&#125;;axios.spread = function spread(callback) &#123; return function wrap(arr) &#123; return callback.apply(null, arr); &#125;;&#125;;module.exports = axios; 主要核心是 Axios.prototype.request 12345678910111213141516171819202122232425262728293031323334353637383940Axios.prototype.request = function request(config) &#123; // Allow for axios(&#x27;example/url&#x27;[, config]) a la fetch API // 判断 config 参数是否是 字符串，如果是则认为第一个参数是 URL，第二个参数是真正的config if (typeof config === &#x27;string&#x27;) &#123; config = arguments[1] || &#123;&#125;; // 把 url 放置到 config 对象中，便于之后的 mergeConfig config.url = arguments[0]; &#125; else &#123; // 如果 config 参数是否是 字符串，则整体都当做config config = config || &#123;&#125;; &#125; // 合并默认配置和传入的配置 config = mergeConfig(this.defaults, config); // 设置请求方法 config.method = config.method ? config.method.toLowerCase() : &#x27;get&#x27;; /* something... 此部分会在后续拦截器单独讲述 */&#125;;// 在 Axios 原型上挂载 &#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27; 且不传参的请求方法，实现内部也是 requestutils.forEach([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27;], function forEachMethodNoData(method) &#123; Axios.prototype[method] = function(url, config) &#123; return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url &#125;)); &#125;;&#125;);// 在 Axios 原型上挂载 &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27; 且传参的请求方法，实现内部同样也是 requestutils.forEach([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function forEachMethodWithData(method) &#123; Axios.prototype[method] = function(url, data, config) &#123; return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;); 从源码中，可以看到优先级：默认配置对象default &lt; method:get &lt; Axios的实例属性this.default &lt; request参数。 配置合并主要在/lib/core/mergeConfig.js中进行，mergeConfig中主要涉及到三个主要key值的合并； valueFromConfig2Keys 是在请求的时候要进行添加的项目内容 mergeDeepPropertiesKeys 需要神拷贝的key,比如headers、proxy等（主要是对象） defaultToConfig2Keys 浅拷贝字符串 合并的规则如下： 进行key遍历，如果config2中某个key存在内容，则取config2的内容 三个key遍历完成后，进行属性的合并，因为config2中有些属性是我们自己自定义设置的，将自定义的设置增加到config中 重点看看request方法 12345678910111213141516171819202122232425262728Axios.prototype.request = function request(config) &#123; /* 先是 mergeConfig ... 等，不再阐述 */ // Hook up interceptors middleware 创建拦截器链. dispatchRequest 是重中之重，后续重点 var chain = [dispatchRequest, undefined]; // push各个拦截器方法 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; // 请求拦截器逆序 注意此处的 forEach 是自定义的拦截器的forEach方法 chain.unshift(interceptor.fulfilled, interceptor.rejected); &#125;); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; // 响应拦截器顺序 注意此处的 forEach 是自定义的拦截器的forEach方法 chain.push(interceptor.fulfilled, interceptor.rejected); &#125;); // 初始化一个promise对象，状态为resolved，接收到的参数为已经处理合并过的config对象 var promise = Promise.resolve(config); // 循环拦截器的链 while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); // 每一次向外弹出拦截器 &#125; // 返回 promise return promise;&#125;; InterceptorManager构造函数 123456789101112131415161718192021222324252627282930// 拦截器的初始化 其实就是一组钩子函数function InterceptorManager() &#123; this.handlers = [];&#125;// 调用拦截器实例的use时就是往钩子函数中push方法InterceptorManager.prototype.use = function use(fulfilled, rejected) &#123; this.handlers.push(&#123; fulfilled: fulfilled, rejected: rejected &#125;); return this.handlers.length - 1;&#125;;// 拦截器是可以取消的，根据use的时候返回的ID，把某一个拦截器方法置为null// 不能用 splice 或者 slice 的原因是 删除之后 id 就会变化，导致之后的顺序或者是操作不可控InterceptorManager.prototype.eject = function eject(id) &#123; if (this.handlers[id]) &#123; this.handlers[id] = null; &#125;&#125;;// 这就是在 Axios的request方法中 中循环拦截器的方法 forEach 循环执行钩子函数InterceptorManager.prototype.forEach = function forEach(fn) &#123; utils.forEach(this.handlers, function forEachHandler(h) &#123; if (h !== null) &#123; fn(h); &#125; &#125;);&#125; 请求拦截器方法是被 unshift到拦截器中，响应拦截器是被push到拦截器中的。最终它们会拼接上一个叫dispatchRequest的方法被后续的 promise 顺序执行。 axios是如何实现取消请求的，实现文件在CancelToken.js 123456789101112131415161718192021222324252627282930313233343536function CancelToken(executor) &#123; if (typeof executor !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;executor must be a function.&#x27;); &#125; // 在 CancelToken 上定义一个 pending 状态的 promise ，将 resolve 回调赋值给外部变量 resolvePromise var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); var token = this; // 立即执行 传入的 executor函数，将真实的 cancel 方法通过参数传递出去。 // 一旦调用就执行 resolvePromise 即前面的 promise 的 resolve，就更改promise的状态为 resolve。 // 那么xhr中定义的 CancelToken.promise.then方法就会执行, 从而xhr内部会取消请求 executor(function cancel(message) &#123; // 判断请求是否已经取消过，避免多次执行 if (token.reason) &#123; return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason); &#125;);&#125;CancelToken.source = function source() &#123; // source 方法就是返回了一个 CancelToken 实例，与直接使用 new CancelToken 是一样的操作 var cancel; var token = new CancelToken(function executor(c) &#123; cancel = c; &#125;); // 返回创建的 CancelToken 实例以及取消方法 return &#123; token: token, cancel: cancel &#125;;&#125;; 实际上取消请求的操作是在 xhr.js 中也有响应的配合的 12345678910if (config.cancelToken) &#123; config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; // 取消请求 request.abort(); reject(cancel); &#125;);&#125; Fetch网络请求及xhr、ajax、axiosFetch是什么fetch是一个低层次的API,等效原生的XHR即XmlHttpRequest。 优点 语法简洁，更加语义化 基于标准Promise实现，支持async/await 更加底层，提供丰富API(request,response) 脱离了XHR，是ES规范新的实现方式，更符合es6语法 缺点 fetch只对网络请求报错，对404,400,500都不报错 返回值被promise包裹了2层 fetch默认不会携带cookie，不能原生监测请求的进度 常用写法1234fetch(&#x27;https://api.github.com/users/ruanyf&#x27;) .then(response =&gt; response.json()) .then(json =&gt; console.log(json)) .catch(err =&gt; console.log(&#x27;Request Failed&#x27;, err)); 123456789async function getJSON() &#123; let url = &#x27;https://api.github.com/users/ruanyf&#x27;; try &#123; let response = await fetch(url); return await response.json(); &#125; catch (error) &#123; console.log(&#x27;Request Failed&#x27;, error); &#125;&#125; fetch完整配置参数12345678910111213141516const response = fetch(url, &#123; method: &quot;GET&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;text/plain;charset=UTF-8&quot; &#125;, body: undefined, referrer: &quot;about:client&quot;, referrerPolicy: &quot;no-referrer-when-downgrade&quot;, mode: &quot;cors&quot;, credentials: &quot;same-origin&quot;, cache: &quot;default&quot;, redirect: &quot;follow&quot;, integrity: &quot;&quot;, keepalive: false, signal: undefined&#125;); cache cache属性指定如何处理缓存。可能的取值如下： default：默认值，先在缓存里面寻找匹配的请求。 no-store：直接请求远程服务器，并且不更新缓存。 reload：直接请求远程服务器，并且更新缓存。 no-cache：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。 force-cache：缓存优先，只有不存在缓存的情况下，才请求远程服务器。 only-if-cached：只检查缓存，如果缓存里面不存在，将返回504错误。 mode mode属性指定请求的模式。可能的取值如下： cors：默认值，允许跨域请求。 same-origin：只允许同源请求。 no-cors：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求。 credentials credentials属性指定是否发送 Cookie。可能的取值如下： same-origin：默认值，同源请求时发送 Cookie，跨域请求时不发送。 include：不管同源请求，还是跨域请求，一律发送 Cookie。 omit：一律不发送。 signal signal属性指定一个 AbortSignal 实例，用于取消fetch()请求，详见下一节。 keepalive keepalive属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。 一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用keepalive属性，数据可能无法发送，因为浏览器已经把页面卸载了。 1234567window.onunload = function() &#123;fetch(&#x27;/analytics&#x27;, &#123;method: &#x27;POST&#x27;,body: &quot;statistics&quot;,keepalive: true&#125;);&#125;; axios取消请求方式1：AbortController 从 v0.22.0 开始，Axios 支持以 fetch API 方式—— AbortController 取消请求： 12345678const controller = new AbortController();// 取消重复请求controller.signal &amp;&amp; controller.abort();axios.get(&#x27;/foo/bar&#x27;, &#123; signal: controller.signal&#125;).then(function(response) &#123; //...&#125;); 方式2：CancelToken 通过传递一个 executor 函数到 CancelToken 的构造函数来创建一个 cancel token：。 此 API 从 v0.22.0 开始已被弃用，不应在新项目中使用。 12345678910const CancelToken = axios.CancelToken;let cancel;// 取消重复请求cancel &amp;&amp; cancel();axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;); 其他xhr、ajax、axiosXMLHttpRequest对象 现代浏览器，最开始与服务器交换数据，都是通过XMLHttpRequest对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。 优点： 不重新加载页面的情况下更新网页 在页面已加载后从服务器请求/接收数据 在后台向服务器发送数据。 缺点： 使用起来也比较繁琐，需要设置很多值。 早期的IE浏览器有自己的实现，这样需要写兼容代码。 jQuery ajax 为了更快捷的操作DOM，并且规避一些浏览器兼容问题，产生了jQuery。它里面的AJAX请求也兼容了各浏览器，可以有简单易用的方法$.get，$.post。简单点说，就是对XMLHttpRequest对象的封装。 优点： 对原生XHR的封装，做了兼容处理，简化了使用。 增加了对JSONP的支持，可以简单处理部分跨域。 缺点： 如果有多个请求，并且有依赖关系的话，容易形成回调地狱。 本身是针对MVC的编程，不符合现在前端MVVM的浪潮。 ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。 axios Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。 优点： 从浏览器中创建XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 缺点： 只持现代代浏览器. 参考阮一峰—fetch API","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"OSI网络模型","slug":"F_计算机网络_OSI网络模型","date":"2022-05-03T22:33:16.000Z","updated":"2023-03-05T08:35:11.099Z","comments":true,"path":"2022/05/04/F_计算机网络_OSI网络模型/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/04/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"OSI模型定义 开放式系统互联模型(Open System Interconnection Model） 第七层：应用层 应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3.HTML.等。 第六层：表达层 表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。 第五层：会话层 会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。 第四层：传输层 传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。 第三层：网络层 网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络数据。例如:互联网协议（IP）等。 第二层：数据链路层： 数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。 分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。 第一层：物理层 物理层（Physical Layer）在局部局域网上传送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。 OSI七层和TCP/IP四层的关系OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。 OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 应用层(Application) 应用层 HTTP、TFTP、FTP、NFS、SMTP 表示层(Presentation) 应用层 Telnet、Rlogin、SNMP、Gopher 会话层(Session) 应用层 SMTP、DNS 传输层(Transport) 传输层 TCP、UDP 网络层(Network) 网络层 IP、ICMP、ARP、RARP、AKP、UUCP 数据链路层(Data Link) 数据链路层 FDDI、Ethernet、Arpanet、PDN 物理层(Physical) 数据链路层 IEEE802.1A IEEE802.2到IEEE802.11 OSI七层和TCP/IP的区别 OSI（开放系统互联）则是一个模型；TCP/IP他是一个协议簇 OSi则指定了哪个功能是属于哪一层；TCP/IP是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能 模型的对比示意图 TCP/IP协议族主机到网络层它负责监视数据在主机和网络之间的交换，事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层 网络互连层网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。 传输层在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。 应用层TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。 应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。 TCP/IP报文格式 IP报文格式IP协议是TCP/IP协议族中最为核心的协议。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。 在局域网环境，IP协议往往被封装在以太网帧中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如下图所示： 分析： 版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。 报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。 服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。 当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。 实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。 总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。 标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。 标志位字段：占3比特。标志一份数据报是否要求分段。 段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据包开始的位置. 生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。 协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。 头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。 源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。 可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。 TCP数据段格式TCP是一种可靠的、面向连接的字节流服务。源主机在传送数据前需要先和目标主机建立连接。然后，在此连接上，被编号的数据段按序收发。同时，要求对每个数据段进行确认，保证了可靠性。 如果在指定的时间内没有收到目标主机对所发数据段的确认，源主机将再次发送该数据段。 分析： 源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。 顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。 确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。 头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。 标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文段交给应用层。 RST：重建连接。 SYN：发起一个连接。FIN：释放一个连接。 窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。 TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。 紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。 UDP数据段格式UDP是一种不可靠的、无连接的数据报服务。源主机在传送数据前不需要和目标主机建立连接。数据被冠以源、目标端口号等UDP报头字段后直接发往目的主机。这时，每个数据段的可靠性依靠上层协议来保证。在传送数据较少、较小的情况下，UDP比TCP更加高效。 分析： 源、目标端口号字段：占16比特,作用与TCP数据段中的端口号字段相同,用来标识源端和目标端的应用进程。 长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。 校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。 套接字在每个TCP、UDP数据段中都包含源端口和目标端口字段。有时，我们把一个IP地址和一个端口号合称为一个套接字（Socket），而一个套接字对（Socket pair）可以唯一地确定互连网络中每个TCP连接的双方（客户IP地址、客户端口号、服务器IP地址、服务器端口号）。 注意：不同的应用层协议可能基于不同的传输层协议，如FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。同时，有些应用层协议占用了两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供域名解析服务，在TCP的53端口提供DNS区域文件传输服务。","categories":[{"name":"F_计算机网络","slug":"F-计算机网络","permalink":"https://fuyunjinglong.github.io/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"测试","slug":"H_工程热点_测试","date":"2022-05-03T22:33:16.000Z","updated":"2024-06-01T10:21:34.140Z","comments":true,"path":"2022/05/04/H_工程热点_测试/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/04/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E6%B5%8B%E8%AF%95/","excerpt":"","text":"基本概念单元测试的上下文就是存在于「敏捷」当中。敏捷为的是更快地交付有价值的可工作的软件。为此，它有一个指标来度量这个「更快」，那就是 lead time，它度量的是一个 idea 从提出被验证，到最终上生产环境面对用户的时间。显然，这个时间越短，软件获得反馈的时间就越短，对价值的验证就越快发生。 前言 我从不觉得自己是一个好的程序员，甚至可能连合格都谈不上，不过在内心深处我却渴望着在编程这件事上获得成功。 可惜每次审视自己写的暂且称之为代码的东西，都会有挫折感，想重构却又感觉盘根错节，难以下手;想重写却又感觉自己好不容易写出来的，也花了不少心思，就这样丢弃心有不甘。 也曾思考过如何才能写好代码，有段时间觉得只有严格符合编程规范的代码才是好代码进而如同遵守戒律一样地字字斟酌，还有段时间觉得只有用上设计模式才能称之优秀代码进而非模式不用，一切套用模式。不过这些都没有让我走出开发的迷雾，永远是加不完的班，修不完的bug。 先测试后开发，小步迭代，持续集成。 测试先行，其实讲的是需求边界，测试不是漫无目的而是精确计算成本的一项活动。测试从何而来，从需求来，需求推演出测试，也规划出产品边界，不能反映需求的测试是一种浪费，因此引申出开发需要讲求适当。开发是一项功利性的活动，永远都在追求盈利，而测试就一条红线，一旦跨过就意味着亏损。 小步迭代，“让子弹飞”中有句话很经典:步子要一步一步迈，一步迈大了，咔，容易扯着蛋。代码堆叠的后遗症是复杂，复杂到没人愿意触碰，且不停地咒骂这代码有多烂，这是步子迈太大的真实写照。TDD讲求的小步迭代是写完一个测试再去写完一个实现，每个实现都是通过测试的，如此累加小胜为大胜，最后所有代码的收尾也不过是让最后一个测试通过而已，就是这样简单。 重构，这是我最喜欢的部分，为啥？因为这里面所有的活动都会要求你去思考，且看上去都像是让你的代码向着大师级代码前进。漂亮的代码并不是堆砌各种技巧，而是在正确的时间，正确的地点做正确的事，重构很容易实现这个目标。重构是一件让人一旦开始就会欲罢不能的事，会让开发者在整个开发阶段都能够不停地去思考、实践再思考，直到无法再添加或删除一个字母。 持续集成，你终究是需要交付产品的，产品就是客户需要的价值，就如同厨师终究会端出客人点的大餐一样，没有哪个厨师是把所有食材罗列着呈现给你的，而是混合在一起，蒸煮炖烧，有些食材需要先处理，这样吃起来才软硬适中，而有些则是最后下锅，这样吃起来才鲜嫩多汁，厨师就是这样一步步将食材集成起来，每一步的处理都是可用都是有价值的，都是为后续进行的铺垫。软件开发也一样，持续集成就要保证每一次的完成都是有价值都可以为后续提供支撑。 TDD是一个很好的思维框架，如果非要教人一个思维框架的话就得教TDD， 不然人会瞎碰，不思考，不总结，不结果导向，靠灵感编程，凭直觉设计，撞大运修bug。最糟糕的是因为没有好的习惯 会接二连三的发生灵异现象。同一道题，习惯不好的人做，总能做出无数种新问题来。而且问题套问题，给他解决要浪费 我半天时间，如果他学会了TDD出的错只在最近一个引入的变化里，就好纠正多了。甚至他自己都能纠正。 TDD重要的不是测试代码本身，是解决问题的思维，也许可以泛化，哪怕没测试，如果能够做到快速验证，反馈，价值的 稳定叠加，有足够信心，也未尝不可。也许你会说测试可以cover功能，那么如果只有这一点的话，我更喜欢BDD (behavior-driven development)，因为这具有用户最终的使用价值。如果你说快速定位bug，我们我更倾向于BDD (bug-driven development，自创的)。这写都是TDD的结果导致的好处所在，而价值反馈思维才是实现TDD背后原理。 TDD驱使我们以结果导向，使得我们简单设计(并不是无设计)，日常重构我们的代码库，注重交付价值流稳定叠加。 以下几种情况可以不写单元测试： 业务部门不需要频繁上线，并且我有足够的人力来覆盖手工测试 不在意代码腐化，并且我也不做重构 不在意代码质量，好几个没有测试保护的 if-else 裸奔也不在话下，脑不好还做什么程序员 确有快速部署的需求，但我们不 care 质量问题，出回归问题就修 除此之外，你就需要写单元测试。如果你想随时整理重构代码，那么你需要写单元测试；如果你想有自动化的测试套件来帮你快速验证提交的完整性，那么你需要写单元测试。 测试分类 静态测试：在编写代码逻辑阶段时进行报错提示。(代表库: ESLint、Flow、TypeScript) 单元测试Unit：在奖杯模型中, 单元测试的职责是对一些边界情况或者特定的算法进行测试。(代表库: Jest、Mocha) 集成测试Integration：模拟用户的行为进行测试，对网络请求、获取数据库的数据等依赖第三方环境的行为进行 Mock。（代表库: Jest、react-testing-library、Vue Testing Library 等） 端到端测试E2E：模拟用户在真实环境上操作行为（包括网络请求、获取数据库数据等）的测试。（代表库: Cypress） 其它的功能测试、UI 测试、界面测试只是它们中里面的一种。 前端测试一共有哪几种？ 前端测试 选择测试框架A.远古测试框架 Jest 是一个“零配置”的前端测试工具，具有诸如模拟和代码覆盖之类的开箱即用特性 我们团队对采用 JEST 做前端测试的结果非常满意。它提供了一种“零配置”的开发体验，并具备诸多开箱即用的功能，比如 Mock 和代码覆盖率等。你不仅可以将此测试框架应用于 React.js 应用程序，也可以应用于其他 JavaScript 框架。Jest 经常被炒作的功能之一是用户界面的快照测试。快照测试可以作为测试金字塔上层一个很好的补充，但请记住，单元测试仍然是坚实的基础。 Jest几大好处： Fast 天下武功，唯快不破。确实很快，虽然实测下来跟 Mocha 新版本还是慢了些，以后找个机会再测一次。 Opinionated 不需要你做出选择和配置，就能提供所有的东西，比如 Mock（干掉 Sinon）、Test Runner（干掉 Karma）、Matcher（干掉 Chai）、Test Coverage（内置 istanbul） Watch Mode 守护模式。非常注重开发者体验，能够在编码的时候帮助我们快速获得测试结果的反馈。 Snapshot Testing 快照测试。这是值得争议的一点，前文也提到过会专门开个 issue 来讨论，在此不再赘述。 测试框架比较： Jest Jest 基于 Jasmine, 做了大量修改并添加了很多特性，同样开箱即用，但异步测试支持良好。 Jest === Mocha + Chai + Sinon + mockserver + istanbul Mocha Mocha 是生态最好，使用最广泛的单测框架，但是他需要较多的配置来实现它的高扩展性。 Ava Ava 是更轻量高效简单的单测框架，但是自身不够稳定，并发运行文件多的时候会撑爆 CPU。 Jasmine Jasmine 是单测框架的“元老”，开箱即用，但是异步测试支持较弱。 Karma Karma 能在真实的浏览器中测试，强大适配器，可配置其他单测框架，一般会配合 Mocha 或 Jasmine 等一起使用。 每个框架都有自己的优缺点，没有最好的框架，只有最适合的框架。 Vue和React 的默认测试框架是 Jest，Augular 的默认测试框架就是 Karma + Jasmine B.现代测试框架 vitest Jest Cypress WebdriverIO Web Test Runner uvu Jest Jest 通过为大多数 JavaScript 项目提供开箱即用的支持、舒适的 API（it 和 expect）以及大多数设置所需的完整测试功能（快照、模拟和覆盖率），在测试框架领域占据了主导地位。 Cypress Cypress 是基于浏览器的测试工具，是 Vitest 的补充工具之一。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。 Cypress 是著名的端到端测试工具，他们最新的组件测试运行器 对测试 Vite 组件有很好的支持，是测试任何在浏览器中渲染的东西的理想选择。 基于浏览器运行测试的框架，例如 Cypress, WebdriverIO 和 Web Test Runner，会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。 Cypress 的测试更加专注于确定元素是否可见，是否可以访问和交互。 WebdriverIO WebdriverIO 类似于 Cypress，一个基于浏览器的替代测试运行器和 Vitest 的补充工具。它可以用作端到端测试工具以及测试 web 组件。它甚至在底层使用了 Vitest 的组件，例如对于组件测试中的 mocking and stubing。 WebdriverIO 具有与 Cypress 相同的优点，允许你在真实浏览器中测试逻辑。然而，它使用实际的 web 标准进行自动化，在运行 Cypress 测试时克服了一些权衡和限制。此外，它还允许你在移动设备上运行测试，使你可以在更多环境中测试应用程序。 Web Test Runner @web/test-runner 在无头浏览器中进行测试，提供与你的 Web 应用程序相同的运行环境，而不需要模拟浏览器的 API 和 DOM。虽然没有像 Cypress 那样显示用于单步执行测试的 UI，但也使得我们可以使用 devtools 在浏览器中进行调试。 uvu uvu 是一个适用于 Node.js 和浏览器的测试运行器。 参考 Vue 应用单元测试的策略与实践 01 - 前言和目标 测试框架比较 TDD个人推荐： 建议开发功能函数库使用 TDD 方案； 建议开发业务系统使用 BDD 方案； TDD与BDD TDD:侧重点偏向开发，通过测试用例来规范约束开发者编写出质量更高、bug更少的代码 BDD:侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。 定义TDD （Test Driven Development）TDD 专指 UTDD（Unit Test Driven Development），即 「单元测试驱动开发」。 误解 TDD = XP 的测试优先原则 + 重构，认为 TDD 只是通过单元测试来推动代码的编写，然后通过重构来优化程序的内部结构。这很容易被理解成只需要先写单元测试就可以驱动出高质量的代码 Kent Beck：“测试驱动开发不是一种测试技术。它是一种分析技术、设计技术，更是一种组织所有开发活动的技术”。 分析技术： 体现在对问题域的分析，当问题还没有被分解成一个个可操作的任务时，分析技术就派上用场，例如需求分析、任务拆分和任务规划等，《实例化需求》这本书可以给予一定的帮助作用。 设计技术： 测试驱动代码的设计和功能的实现，然后驱动代码的再设计和重构，在持续细微的反馈中改善代码。 组织所有开发活动的技术： TDD 很好地组织了测试、开发和重构活动，但又不仅限于此，比如实施 TDD 的前置活动包括需求分析、任务拆分和规划活动，这使得 TDD 具有非常好的扩展性。 TDD原则两条规则： 仅在自动测试失败时才编写新代码 消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化 第一条规则指每次只编写刚刚好使测试通过的代码，并且只在测试运行失败的时候才编写新的代码，因为每次增加的代码少，即使有问题定位起来也非常快。 第二条规则指在自动化测试的支撑下，通过重构环节消除代码的坏味道来避免代码日渐腐烂，为接下来编码打造一个舒适的环境 TDD口号 不可运行——写一个功能最小完备的单元测试，并使得该单元测试编译失败。 可运行——快速编写刚刚好使测试通过的代码，不需要考虑太多，甚至可以使用一些不合理的方法。 重构——消除刚刚编码过程引入的重复设计，优化设计结构。 TDD好处 控制编程过程中的忧虑感：当感觉压力越大，就越不想去做足够多的测试，对代码越不自信 把控编程过程中的反馈与决策之间的差距 如果我做了一周的规划，并且量化成一个个可操作的任务写到 to-do list，然后使用测试驱动编码，把完成的任务像这样划掉，那么我的工作目标将变得非常清晰，因为我明确工期，明确待办事项，明确难点，可以在持续细微的反馈中有意识地做一些适当的调整，比如添加新的任务，删除冗余的测试；还有一点更加让人振奋，我可以知道我大概什么时候可以完工。项目经理对软件开发进度可以更精确的把握。 TDD的难点 缺乏软件质量意识 缺乏一定程度的程序设计能力，很难设计出高内聚低耦合、意图清晰的结构和代码。 缺乏分析需求并进行任务分解和规划的能力，很容易在还没开始 TDD 的时候就被打乱了节奏。 缺乏合适的测试环境和测试规范。 测试优先的习惯难以养成。 重构手法不熟练。 参考 测试驱动开发（TDD）总结——原理篇 三角法 推行TDD的思考——张逸 TDD(测试驱动开发)培训录-破狼 TDD-JEST官网 TDD-VueVue测试策略 架构层级 测试内容 测试策略 解释 action 层 1. 是否获取了正确的参数 2. 是否正确地调用了 API 3. 是否使用了正确的返回值存取回 Vuex 中 4. 业务分支逻辑 5. 异常逻辑 这五个业务点建议 100% 覆盖 这个层级主要包含前述 5 大方面的业务逻辑，进行测试很有重构价值 mutation 层 是否正确完成计算 有逻辑的 mutation 要求 100%覆盖率 这个层级输入输出明确，又包含业务计算，非常适合单元测试 getter 层 是否正确完成计算 有逻辑的 getter 要求 100%覆盖率 这个层级输入输出明确，又包含业务计算，非常适合单元测试 component 层 是否渲染了正确的组件 1. 组件的分支渲染逻辑要求 100%覆盖 2. 交互事件的调用参数一般要求 100%覆盖 3. 连接 vuex store 的容器组件不测 4.渲染出来的UI不测 这个层级最为复杂，还是以「代价最低，收益最高」为指导原则进行 UI 层 组件是否渲染了正确的样式 1. 纯 UI 不测 2. CSS 不测 这个层级以我目前理解来说测试较难稳定，成本又较高 utils 层 各种辅助工具函数 没有副作用的必须 100% 覆盖 Component 层，遵循以上的两测两不测原则 展示型业务组件 容器型业务组件 通用 UI 组件 功能型组件 Vue Test Utils Vue测试实战 Vue Test Utils实战 使用 TDD 开发组件 — Notification 【element3-开发日记】手摸手教你重写 Button 组件 测试解决方案落地单元测试从 Jest 到 Karma+Mocha+Chai引子：Jest 的运行环境是 JSDOM，一个伪 DOM 引擎。JSDOM 不能理解 DOM 的布局，尺寸，样式，以及浏览器的高级 API，例如 ResizeObserver，matchMedia()。我们无法在代码中避免使用它们，于是只能去 Mock 很多东西。结果，我们欺骗了我们自己写的测试。即使你达成了 100% 测试覆盖，所有测试用例都通过，还是会怀疑代码是否在真实环境中会出错…更不要提浏览器兼容性测试了。 Karma 是 Google 开发的测试运行工具。当人们无法忍受太多 Mock，他们通常会转投 Karma 然后发现它真香！你不需要再 Mock 浏览器的特性，便可获得更真实的测试结果，甚至能做浏览器兼容性测试。更重要的是，从 Jest 到 Karma 的迁移并不难。 Karma 不能单独使用。你至少需要一个测试框架（例如 Mocha）和一个断言库（例如 Chai）。 两种工具集对比 Karma 系 Jest 系 测试运行环境 Test Runtime Chrome/Firefox/Safari/Edge/IE JSDOM + Node.js 代码转译器 Transpiler TypeScript TypeScript 测试运行工具 Test Runner Karma Jest 测试框架 Test Framework Mocha/Jasmine Jest 断言库 Assertion Library Chai/Expect.js Jest React 测试工具 React Test Utility Enzyme/React-Testing-Library Enzyme/React-Testing-Library 鱼与熊掌单元测试和集成测试选择： *简而言之，如果你是想踏出测试的第一步，或者想为大型项目配备足以快速上手的框架，建议使用 Jest。想要灵活性高可扩展性好，那就用 Mocha。想再简单点，就用 Ava。想做底层的测试，用 tape。* UI测试选择： 简而言之，如果你想立刻着手在多个运行环境下尝试下功能测试，想要一个 all-in-one 的工具，试试 TestCafe。如果你希望测试流程完整，还有强大的社区支持。WebdriverIO 是个不错的选择。 *如果不需要测试跨浏览器的支持性，推荐使用 Puppeteer。如果你的应用没有复杂的界面和交互逻辑，比如一个全是表单和导航的系统。换言之，是相对较容易测试de的场景。可以使用 headless 浏览器工具，比如 Casper，高效完成测试。*","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"代理-设备","slug":"F_计算机网络_代理-设备","date":"2022-05-02T23:33:16.000Z","updated":"2023-05-23T14:40:26.078Z","comments":true,"path":"2022/05/03/F_计算机网络_代理-设备/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/03/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BB%A3%E7%90%86-%E8%AE%BE%E5%A4%87/","excerpt":"","text":"代理正向代理正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。 比如访问外国网站技术，其用到的就是代理技术。这个过程其实和租房子很像。 正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。 作用： 突破访问限制 提高访问速度:通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区 隐藏客户端真实IP 反向代理反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 比如：二房东 反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。 作用： 隐藏服务器真实IP 负载均衡:根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上 提高访问速度:对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度. 提供安全保障:反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等. 正向与反向的区别： 1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。 2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。 3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。 4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。 负载均衡Load balancing，即负载均衡，是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。它将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案 OSI七层模型： 负载均衡是要在网络传输中做文章的 最常用的是四层和七层负载均衡。 四层负载均衡 ：F5、LVS等 四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。 七层负载均衡 ：nginx、apache等 七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。 一、常用负载均衡算法 负载均衡算法可以分为两类：静态负载均衡算法和动态负载均衡算法。 （1）静态负载均衡算法包括：轮询，比率，优先权，算法分配 轮询（Round Robin）：顺序循环将请求一次顺序循环地连接每个服务器。当其中某个服务器发生第2到第7 层的故障，BIG-IP 就把其从顺序循环队列中拿出，不参加下一次的轮询，直到其恢复正常。 比率（Ratio）：给每个服务器分配一个加权值为比例，根椐这个比例，把用户的请求分配到每个服务器。当其中某个服务器发生第二到第7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配, 直到其恢复正常。 优先权（Priority）：给所有服务器分组,给每个组定义优先权，BIG-IP 用户的请求，分配给优先级最高的服务器组（在同一组内，采用轮询或比率算法，分配用户的请求）；当最高优先级中所有服务器出现故障，BIG-IP 才将请求送给次优先级的服务器组。这种方式，实际为用户提供一种热备份的方式。 算法分配：一般采用散列算法，通过客户端带来的某个标识经过一个标准化的散列函数进行打散分摊。 （2）动态负载均衡算法包括: 最少连接数,最快响应速度，观察方法，预测法，动态性能分配，动态服务器补充，服务质量，服务类型，规则模式。 最少的连接方式（Least Connection）：传递新的连接给那些进行最少连接处理的服务器。当其中某个服务器发生第二到第7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配, 直到其恢复正常。 最快模式（Fastest）：传递连接给那些响应最快的服务器。当其中某个服务器发生第二到第7 层的故障，BIG-IP 就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 观察模式（Observed）：连接数目和响应时间以这两项的最佳平衡为依据为新的请求选择服务器。当其中某个服务器发生第二到第7 层的故障，BIG-IP就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 预测模式（Predictive）：BIG-IP利用收集到的服务器当前的性能指标，进行预测分析，选择一台服务器在下一个时间片内，其性能将达到最佳的服务器相应用户的请求。(被BIG-IP 进行检测) 动态性能分配(Dynamic Ratio-APM)：BIG-IP 收集到的应用程序和应用服务器的各项性能参数，动态调整流量分配。 动态服务器补充(Dynamic Server Act.)：当主服务器群中因故障导致数量减少时，动态地将备份服务器补充至主服务器群。 服务质量(QoS）：按不同的优先级对数据流进行分配。 服务类型(ToS)：按不同的服务类型（在Type of Field中标识）负载均衡对数据流进行分配。 规则模式：针对不同的数据流设置导向规则，用户可自行。 二、健康探测 如果节点属于“不可用”的状态的话，需要将这个节点临时从待选取列表中移除，以提高可用性。一般常用的「健康探测」方式有3种。 HTTP探测：使用Get/Post的方式请求服务端的某个固定的URL，判断返回的内容是否符合预期。一般使用Http状态码、response中的内容来判断。 TCP探测：基于Tcp的三次握手机制来探测指定的IP + 端口。最佳实践可以借鉴阿里云的SLB机制。 UDP探测：可能有部分应用使用的UDP协议。在此协议下可以通过报文来进行探测指定的IP + 端口。结果的判定方式是：在服务端没有返回任何信息的情况下，默认正常状态。否则会返回一个ICMP的报错信息。 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。 静态资源交给nginx处理，动态资源给tomcat. DNS一、定义 。。。.三级域名.二级域名.一级域名 DNS 是域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库。 DNS域名服务器分为三级，从上到下分别是 一级为根域名服务器（Root DNS Server），全球有13个，如.com .net .cn 二级为顶级域名服务器（gTLD、ccTLD、New gTLD）。gTLD国际顶级域名(如.com/.net/.org)，ccTLD国家和地区顶级域名(中国是.cn域名，日本是.jp)，New gTLD新顶级域名(如.xyz/.top/.red/.help) 三级为本地域名服务器（Local DNS Server），一般是运营商的DNS 二、DNS解析原理 简单流程 (1)我们在用chrome浏览器的时候，其实会先去浏览器的dns缓存里查询，dns缓存中没有，再去调用gethostbyname函数 (2)gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，如果没找到再去DNS服务器上查 大致流程 解析流程就是分级查询 先在本机的DNS里头查，如果有就直接返回了 本机DNS里头发现没有，就去根服务器里查。 本机的DNS接到又会向com域的DNS服务器发送查询消息。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器 详细流程0 1） 浏览器缓存 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 2） 系统缓存 当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP； 3） 路由器缓存 当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存； 4） ISP（互联网服务提供商）DNS缓存 当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；5） 根域名服务器 当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器； 6） 顶级域名服务器 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器； 7） 主域名服务器 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录； 8）保存结果至缓存 本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。 详细流程1 1、用户请求通过浏览器输入要访问网站的地址，例如：www.51cto.com。浏览器会在自己的缓存中查找URL对应IP地址。如果之前访问过，保存了这个URL对应IP地址的缓存，那么就直接访问IP地址。如果没有缓存，进入到第2步。 2、通过计算机本地的Host文件配置，可以设置URL和IP地址的映射关系。比如windows下是通过C:windwossystem32driveretchosts文件来设置的，linux中则是/etc/named.confg文件。这里查找本地的Host文件，看是有IP地址的缓存。如果在文件中依旧没有找到映射关系，进入第3步。 3、请求Local DNS Server，通过本地运营商获取URL和IP的映射关系。如果在校园网，DNS服务器就在学校，如果是小区网络，DNS服务器是运营商提供的。总之这个服务器在物理位置上离发起请求的计算机比较近。Local DNS Server缓存了大量的DNS解析结果。由于它的性能较好，物理上的距离又比较近，它通常会在很短的时间内返回指定域名的解析结果。80%的DNS解析需求在这一步就满足了。如果在这一步还是没有完成DNS解析，进入第4步 4、通过Root DNS Server进行解析，ROOT DNS Server会根据请求的URL 返回给Local DNS Server顶级域名服务器的地址。例如：查询的是”.com”的域名，就查询 gTL对应的域名服务器的地址。 5、返回顶级域名服务器的地址以后，访问对应的顶级域名服务器（gTLD、ccTLD、New gTLD），并且返回Name Server服务器地址。这个Name Server就是网站注册的域名服务器，上面包含了网站URL和IP的对应信息。例如你在某个域名服务提供商申请的域名，这个域名就由他们的服务器来解析。这个Name Server是由域名提供商维护的。 6、Name Server会把指定域名的A记录或者CNAME返回给Local DNS Server，并且设置一个TTL。 123A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。CNAME：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。服务商从方便维护的角度，一般也建议用户使用CNAME记录绑定域名的。如果主机使用了双线IP，显然使用CNAME也要方便一些。TTL（Time To Live）：也就是设置这个DNS解析在Local DNS Server上面的过期时间。超过了这个过期时间，URL和IP的映射就会被删除，需要获取还要请求Name Server。 7、如果此时获取的是A记录，那么就可以直接访问网站的IP了。但是通常来说大型的网站都会返回CNAME，然后将其传给GTM Server。 123GTM（Global Traffic Manager的简写）即全局流量管理，基于网宿智能DNS、分布式监控体系，实现实时故障切换及全球负载均衡，保障应用服务的持续高可用性。传给GTM的目的就是希望通过GTM的负载均衡机制，帮助用户找到最适合自己的服务器IP。也就是离自己最近，性能最好，服务器状态最健康的。而且大多数的网站会做CDN缓存，此时就更需要使用GTM帮你找到网络节点中适合你的CDN缓存服务器。 8、找到CDN缓存服务器以后，可以直接从服务器上面获取一些静态资源，例如：HTML、CSS、JS和图片。但是一些动态资源，例如商品信息，订单信息，需要通过第9步。 9、对于没有缓存的动态资源需要从应用服务器获取，在应用服务器与互联网之间通常有一层负载均衡器负责反向代理。有它路由到应用服务器上 三、DNS上用UDP还是TCP协议 区域传送用TCP协议 DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 这种情况下，使用TCP协议。 因为TCP协议可靠性好啊！你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？ 域名解析用UDP协议 因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。 CDN介绍 内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度。 应用范围 加速网站的访问 实现跨运营商、跨地域的全网覆盖 保障网站安全 异地备援 节约成本 让你更专注业务本身 2.实现跨运营商、跨地域的全网覆盖 互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。 3.保障网站安全 CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。 4.异地备援 当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。 5.节约成本 投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。 6.专注业务本身 CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。 核心流程 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。 CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。 CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址： 根据用户 IP 地址，判断哪一台服务器距用户最近； 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容； 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。 全局负载均衡设备把服务器的 IP 地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。 淘宝CDN架构 淘宝整个图片的访问链路有三级缓存（客户端本地、CDN L1、CDN L2），所有图片都持久化的存储到OSS中。真正处理图片的是img-picasso系统，它的功能比较复杂，包括从OSS读取文件，对图片尺寸进行缩放，编解码，所以机器成本比较高。 CDN的缓存分成2级，合理的分配L1和L2的比例，一方面，可以通过一致性hash的手段，在同等资源的情况下，缓存更多内容，提升整体缓存命中率；另一方面，可以平衡计算和IO，充分利用不同配置的机器的能力。 用户访问图片的过程如下：（1）用户通过手机淘宝来搜索商品或者查看宝贝详情。（2）详情/搜索/推荐通过调用商品中心返回商品的图片URL。（3）客户端本地如果有该图片的缓存，则直接渲染图片，否则执行下一步。（4）从CDN L1回源图片，如果L1有该图片的缓存，则客户端渲染图片，同时缓存到本地，如果L1没有缓存，则执行下一步。（5）从CDN L2回源图片，如果L2有该图片的缓存，则客户端渲染图片，同时CDN L1及客户端缓存图片内容，如果CDN L2没有缓存该图片，则执行下一步。（6）从图片空间回源图片，图片空间会从OSS拉取图片源文件，按要求进行尺寸缩放，然后执行编解码，返回客户端能够支持的图片内容，之后客户端就可以渲染图片，同时CDN的L1、L2以及客户端都会缓存图片内容。 频繁换图带来的问题 2个问题 （1）CDN及手机淘宝原本缓存的图片内容失效了，用户访问图片会全部回源到img-picasso。（2）由于更改了商品的字段，交易的核心应用（购物车和商品中心）的缓存也失效了，用户浏览及购物时，对商品的访问会走到db。 源站img-picasso处理图片，以及查询商品DB，都是非常消耗资源的。CDN及商品的缓存命中率降低后，对源站img-picsasso以及db会产生巨大的压力。 拿CDN缓存为例，简单计算一下，CDN平时的命中率是98%，假设命中率降低1个点，对源站的压力就会增加1/3（原本承担2%的流量，现在需要承担3%的流量），意味着img-picasso需要扩容1/3。如果全网一半的图片都同时变化，cdn的命中率降到50%，对img-picasso的访问量就会增加25倍，这个扩容成本肯定没法接受。 2个解决方案 （1）改图保持图片URL不变，可以避免商品链路的缓存失效。（2）在访问高峰到来之前，提前预热图片到CDN，可以避免CDN缓存失效对源站的压力。 换图方案落地 图片内容发生变化时，执行下面2个操作：（1）更新OSS内容：使用新的图片内容替换OSS中老的图片内容（2）刷新CDN缓存：清除CDN之前缓存的图片内容 这样，用户再次访问图片时，发现CDN没有缓存，就会回源到img-picasso，从OSS拉取新的图片内容。由于图片URL没有变化，就不必去更新商品中心的图片链接，这样商品链路的缓存可以保持不变。在真正实施这个方案的过程中，遇到了几个问题 1.OSS三地同步 淘宝的图片空间，承载了淘系所有图片的上下行稳定性保障，为了保障高可用，一份资源会存储到三地OSS。图片上传时，默认只上传一地，利用OSS的能力，自动同步到另外两地。 但是使用URL不变方案，CDN缓存已经清除完成后，如果另外2地的OSS还未同步完成，用户访问后，就会回源到旧的图片内容，发现图片内容没有变化。 针对该问题，我们将异步同步OSS软链的模式，改成三地同步建软链，三地都返回成功后，再去清除CDN缓存，这就保证了用户访问的图片一定是最新的内容。 2.图片尺寸收敛 同一张商品图片会用于不同的场景坑位展现，不同的坑位对图片的尺寸有不同的要求。为此，图片空间提供了一项功能，可以方便的生成不同尺寸的缩率图。只需要访问图片时，给图片增加不同的后缀，img-picasso源站就可以按要求进行图片进行缩放。由于历史原因，之前对缩放的尺寸种类没有限制，导致CDN上的图片后缀格式多达2400种+，TOP6格式覆盖率46%，TOP15格式覆盖率64%。这意味着，一张图片，在cdn上最多可能有2400+个不同的url，当图片内容变化后，要把这些缓存全部清掉，才能保证所有用户看到的图片都是新内容。 最后把2000多种格式收敛到6种主要格式，CDN清除缓存才变得可行 3.多副本清除CDN缓存 通过图片尺寸收敛，每张图片只需要清除6个不同的url就可以了，那能不能进一步提升刷新效率呢？为此，阿里云CDN为我们提供了多副本刷新的解决方案：每种不同后缀的图片，作为图片的一个副本，在CDN的swift层增加一层KV结构，存储url和不同副本的映射关系，清除缓存时，可以通过该结构找到所有副本，实现快速清除所有副本。这样，每张图片，我们只需要调用一次CDN清除缓存接口就可以了，极大提升了CDN缓存刷新效率 4.图片域名收敛 淘系的图片域名有300多种，主要有下面2个原因：（1）图片完整的链接太长，所以存储时经常只存最后一段，业务自己来拼域名，很多业务就自己申请了一个图片域名来拼。（2）PC时代，浏览器对同一域名下的并发请求数是有限制的，不同浏览器不一样，一般6个左右。 为了突破该限制，一些业务就会申请多个域名，随机的拼不同的域名。前面我们讲过，CDN的缓存是跟域名绑定的，不管是缓存命中还是缓存清除，都只能针对一个域名。我们显然不可能改一张图，就去对300个域名调用CDN刷新。于是我们考虑对图片域名进行收敛，使得用户对图片的访问都路由到同一个域名，我们希望将所有的图片访问统一收敛到http://picasso.alicdn.com，具体实现方式如下：（1）对于手淘和猫客客户端，图片访问都收口在图片库，我们推进图片库进行改造，符合一定规则的url，统一收敛到http://picasso.alicdn.com，实现了域名的一刀切。（2）对于PC浏览器端，就比较麻烦了，没有统一收口的地方。我们只能退而求其次，针对访问最多的6大域名，在cdn上配置域名转发规则，重定向到picasso域名。 通过这种方式，我们实现了全网99%以上的图片访问流量都路由到picasso域名，图片内容发生变化时，通过清除picasso域名的cdn缓存，就能保证基本所有的场景都能看到新的图片内容。 解決：客户端及浏览器缓存落地 通过多副本和图片域名收敛，cdn的缓存问题得到了解决。但在cdn之上，用户图片访问首先是来自客户端或者浏览器，这里也会有一层缓存。大家知道，浏览器的缓存都遵循标准的http max-age协议，指定该header后，到了时间图片就会失效，访问到新的图片。所以我们可以在源站img-picasso回源给cdn时，添加max-age协议头，值为1分钟，cdn会原封不动的透给浏览器，这样浏览器就可以实现1分钟内图片缓存失效，重新到cdn拉新的图片资源。对于手机淘宝客户端，我们在原有的LRU缓存机制之上，另外支持标准的http协议。这样，手机淘宝也实现了1分钟内图片缓存失效。 提前预热CDN图片 通过改图保持图片URL不变，我们解决了改图对商品链路缓存的影响。但是，图片变化时，虽然URL没有变，但我们清除了CDN缓存，导致用户访问时还是会回源到img-picasso源站，所以对图片源站的压力依然存在。 我们发现，商品的价格变化大部分发生在大促节奏变化的时刻，基于这个特点，我们通过提前合成图片，提前预热到CDN，可以实现图片切换瞬间生效，同时对源站没有压力。 具体方案如下：（1）提前合成多波段图片：我们知道大促期间商家集中换图的时间点后，按这些时间点把图片的展示分成多个波段，每个波段图片提前合成，并提前将图片URL写入到商品中心扩展结构中。（2）图片访问路由：营销系统根据配置的大促氛围切换计划，告诉鹿班图片二方包，当前是哪个波段，鹿班根据当前波段及场景，返回正确的图片URL给各个场景。（3）图片渲染：各个场景拿到图片URL后，结合自身的业务逻辑，决定是否要展现该图片。（4）CDN图片预热：为了避免图片集中切换时，把源站击垮，我们会在集中切换前把这些冷图片内容预热到CDN。（5）波段内图片变化：提前合成各个波段图片后，商家可能会临时发券/改价，导致商品价格再次变化，对于这类换图需求，为了避免更新商品中心的图片URL，我们通过本文上一章节刷CDN缓存的方式实现。 其他 其实，CDN本身就是一种DNS劫持，只不过是良性的。 不同于黑客强制DNS把域名解析到自己的钓鱼IP上，CDN则是让DNS主动配合，把域名解析到临近的服务器上。 劫持通常分为两类： 域名劫持，又称DNS劫持，通常是指域名指向到非正常IP（恶意IP），该恶意IP通过反向代理的方式，在能返回网页正常内容的情况，可能插入恶意代码、监听网民访问、劫持敏感信息等操作。通常验证一个域名是否被劫持的方法是PING一个域名，如果发现PING出来的IP不是您的服务器真实IP，则可以确定被劫持了（当然如果使用了知道创宇云安全等安全加速平台，得到的IP为平台IP，并非劫持） 数据劫持，通常由电信运营商中某些员工等勾结犯罪分子，在公网中进行数据支持，插入，此类情况极隐蔽，不会改变用户域名解析IP，而是直接数据流经运营商宽带时在网页中挺入内容，此类情况，建议网页启用HTTPS加密，可以解决这一问题（通信是加密的，运营商无法插入恶意内容） 高仿、洗流量：CDN 可以通过分流 ，洗掉来自Dos 大部分的攻击 。 参考 阿里淘宝CDN方案 Nginx简介Nginx是一个高性能静态HTTP服务器、反向代理服务器、虚拟主机(正向代理)，也是一个 IMAP/POP3/SMTP 代理 服务器 Nginx 专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，最大能支持 50000 个并发连接数。 Nginx 还支持热部署，它的使用特别容易，几乎可以做到 7x24 小时不间断运行。 Nginx 的网站用户有：百度、淘宝、京东、腾讯、新浪、网易等。 特点 第一，它可以支持 5W 高并发连接; 第二，内存消耗少; 第三，成本低。 1、热部署我个人觉得这个很不错。在master管理进程与worker工作进程的分离设计，使的Nginx具有热部署的功能，那么在7×24小时不间断服务的前提下，升级Nginx的可执行文件。也可以在不停止服务的情况下修改配置文件，更换日志文件等功能。 2、可以高并发连接这是一个很重要的一个特性！在这一个互联网快速发展， 互联网用户数量不断增加， 一些大公司、网站都需要面对高并发请求，如果有一个能够在峰值顶住10万以上并发请求的Server，肯定会得到大家的青睐。理论上，Nginx支持的并发连接上限取决于你的内存，10万远未封顶。 3、低的内存消耗在一般的情况下，10000个非活跃的HTTP Keep-Alive 连接在Nginx中仅消耗2.5M的内存，这也是Nginx支持高并发连接的基础。 4、处理响应请求很快在正常的情况下，单次请求会得到更快的响应。在高峰期，Nginx可以比其他的Web服务器更快的响应请求。 5、具有很高的可靠性Nginx是一个高可靠性的Web服务器，这也是我们为什么选择Nginx的基本条件，现在很多的网站都在使用Nginx，足以说明Nginx的可靠性。高可靠性来自其核心框架代码的优秀设计、模块设计的简单性；并且这些模块都非常的稳定。 四大作用 静态HTTP服务器 虚拟主机(正向代理) 反向代理 负债均衡 静态HTTP服务器 Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。 为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。 123456server &#123; listen 80; # 端口号 location / &#123; root /usr/share/nginx/html; # 静态文件路径 &#125; &#125; 虚拟主机(正向代理) 有的网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。 例如将www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。 正向代理来进行上网等功能。 1234567891011121314151617181920server &#123; listen 80 default_server; server_name _; return 444; # 过滤其他域名的请求，返回444状态码 &#125; server &#123; listen 80; server_name www.aaa.com; # www.aaa.com域名 location / &#123; proxy_pass http://localhost:8080; # 对应端口号8080 &#125; &#125; server &#123; listen80; server_name www.bbb.com; # www.bbb.com域名 location / &#123; proxy_pass http://localhost:8081; # 对应端口号8081 &#125; &#125; 在服务器8080和8081分别开了一个应用，客户端通过不同的域名访问，根据server_name可以反向代理到对应的应用服务器。 虚拟主机的原理是通过HTTP请求头中的Host是否匹配server_name来实现的。 另外，server_name配置还可以过滤有人恶意将某些域名指向你的主机服务器。 反向代理 客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。 123456server &#123; listen 80; location / &#123; proxy_pass http://192.168.20.1:8080; # 应用服务器HTTP地址 &#125; &#125; 负载均衡 当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。 Nginx可以通过反向代理来实现负载均衡。 1234567891011121314151617181920212223242526272829upstream myserver &#123; server 192.167.4.32:5000; server 192.168.4.32:8080; &#125; server &#123; listen 80; #监听端口 server_name 192.168.4.32; #监听地址 location / &#123; root html; #html目录 index index.html index.htm; #设置默认页 proxy_pass http://myserver; #请求转向 myserver 定义的服务器列表 &#125;&#125; upstream myserver &#123; server 192.167.4.32:5000; server 192.168.4.32:8080; &#125; server &#123; listen 80; #监听端口 server_name 192.168.4.32; #监听地址 location / &#123; root html; #html目录 index index.html index.htm; #设置默认页 proxy_pass http://myserver; #请求转向 myserver 定义的服务器列表 &#125;&#125; 常用的4种nginx负载均衡算法1.轮询 轮询是默认的方式，每个请求按时间顺序逐一分配到不同的后端服务器上。如果后台服务器上某一台宕机了，它可以自动剔除。 缺点：可靠性低和负载分配不均衡。适用于图片服务器和静态页面服务器集群。 2. 加权轮询（wight） 指定轮询的几率，wight和访问比率成正比，用于后台服务器性能不均匀的情况。 1234upstream linuxidc&#123; server 10.0.0.77 weight=5; server 10.0.0.88 weight=10; &#125;复制代码 3. ip_hash 根据每个请求的ip的hash结果分配，因此每个固定ip能访问到同一个后端服务器，可以解决session问题。 12345upstream favresin&#123; ip_hash; server 10.0.0.10:8080; server 10.0.0.11:8080; &#125;复制代码 4. fair（第三方） 按照后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345 upstream favresin&#123; server 10.0.0.10:8080; server 10.0.0.11:8080; fair; &#125;复制代码 5. url_hash（第三方） 按照访问url的hash结果来分配请求，每个固定的url访问同一个后端服务器。如果后端服务器是缓存时效率高。 12345678 upstream resinserver&#123; server 10.0.0.10:7777; server 10.0.0.11:8888; hash $request_uri; hash_method crc32; &#125;例：在upstream中加入hash语句，hash_method是使用的hash算法。复制代码 在upstream模块中，可以通过server命令指定后端服务器的IP地址和端口，同时还可以设置每台后端服务器在负载均衡调度中的状态， upstream参数解析 upstream可以为每个设备设置状态值 down：表示当前的server暂时不参与负载 weight：默认为1，wight越大，负载的权重越大。 max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误。 fail_timeout：max_fails此失败后，暂停的时间。 backup：其他所有非backup机器宕或者忙的时候，请求backup的机器。 示例： 123456789tips:upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 ip_hash; server 192.0.0.1:8090 weight=5 max_fails=3 fail_timeout=20s; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125;复制代码 常见的几种负载均衡算法1、轮询法 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。 2、加权轮询法 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。 3、随机法 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多， 其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。 4、加权随机法 与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。 5、哈希算法 普通哈希：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。 一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。一致性hash算法就是把每台server分成v个虚拟节点，再把所有虚拟节点（n*v）随机分配到一致性哈希的圆环上，这样所有的用户从自己圆环上的位置顺时针往下取到第一个vnode就是自己所属的节点。当此节点存在故障时，再顺时针取下一个作为替代节点 6、最小连接数法 最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前 积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。 7、IP地址散列 通过管理发送方IP和目的地IP地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。 8、URL散列 通过管理客户端请求URL信息的散列，将发送至相同URL的请求转发至同一服务器的算法。 四层和七层负载均衡四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。 七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。 软硬件 1）四层的负载均衡就是基于IP+端口的负载均衡： 对应的负载均衡器称为四层交换机（L4 switch），主要分析IP层及TCP/UDP层，实现四层负载均衡。此种负载均衡器不理解应用协议（如HTTP/FTP/MySQL等等）。 实现四层负载均衡的软件有： F5：硬件负载均衡器，功能很好，但是成本很高。 lvs：重量级的四层负载软件 nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活 haproxy：模拟四层转发，较灵活 2）七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡 对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议。 实现七层负载均衡的软件有： haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移； nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多； apache：功能较差 Mysql proxy：功能尚可。 总的来说，一般是lvs做4层负载；nginx做7层负载；haproxy比较灵活，4层和7层负载均衡都能做。 技术原理上的区别： 所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。 所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。 具体实现： （1）目前负载均衡系统有Nginx、LVS、F5，即： Nginx是软件的7层负载均衡， LVS是内核的4层负载均衡， F5是硬件的4层负载均衡。 （2）软件和硬件的区别在于性能，硬件远远高于软件，即： Nginx的性能是万级的，一般的Linux服务器上安装一个Nginx能达到每秒5万并发请求； 而F5的性能能达到百万级，从200万每秒到800万每秒都有，不过价格很贵。 （3）4层和7层的区别在于协议和灵活性，即： Nginx是7层的，它支持HTTP等协议， 而LVS和F5是4层协议，它们和协议无关，几乎所有应用都可以做。 高可用 为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。 参考 从原理到实战，彻底搞懂 Nginx！入门篇 从原理到实战，彻底搞懂 Nginx！中级篇 设备集线器（HUB）集线器起到了一个将网线集结起来的作用，实现最初级的网络互通。集线器是通过网线直接传送数据的，我们说他工作在物理层。 类似网吧的CS精英。 第1层（物理层）上运行 交换机集线器会广播所有消息，但我只需要告知某人消息，这就需要交换机 将资料从A的电脑传送到C的电脑中，而不让小B、小D和小E收到。也就是说，这台设备解决了冲突的问题，实现了任意两台电脑间的互联，大大地提升了网络间的传输速度，我们把它叫做交换机。由于交换机是根据网口地址传送信息，比网线直接传送多了一个步骤，我们也说交换机工作在数据链路层。 第2层（数据链路层）运行 路由器其他村也想加入进来，路由器就出现了。路由器上有 WAN 口和 LAN 接口，而交换机没有这些接口。 第3层（网络层）上运行 猫猫的学名叫调制解调器，它的作用是将数字信号（电脑想要发送的信息）转换成模拟信号（网线中的电流脉冲）从而使信息在网线中传输。 目前的家用路由器一般都是路由猫，即路由器兼顾了猫和简单交换机的功能。 小结 用快递解释： 数据帧：快递 二层MAC地址:你的身份证号，全球唯一 三层IP地址:你的当前的住宅地址，你随时可能会搬去其他地址住 额外的规则:一个住宅地址只能住一个人，否则会导致收发快递不正常 交换机：给你派件的快递员，但是只认身份证号的数字(MAC)，不认地址上的中文(IP) 路由器：物流公司的集散中心，占有一个身份证号(MAC)，同时占有一个住宅地址(IP) 载波：运输快递的火车/飞机/船 猫：将快递装上/卸下火车/飞机/船的地方","categories":[{"name":"F_计算机网络","slug":"F-计算机网络","permalink":"https://fuyunjinglong.github.io/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Hexo原理","slug":"H_工程热点_博客_Hexo原理","date":"2022-05-02T22:33:16.000Z","updated":"2023-03-07T12:22:17.775Z","comments":true,"path":"2022/05/03/H_工程热点_博客_Hexo原理/","link":"","permalink":"https://fuyunjinglong.github.io/2022/05/03/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%8D%9A%E5%AE%A2_Hexo%E5%8E%9F%E7%90%86/","excerpt":"","text":"介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章。 123456789├── node_modules： #依赖包-安装插件及所需nodejs模块。├── public #最终网页信息。即存放被解析markdown、html文件。├── scaffolds #模板文件夹。即当您新建文章时，根据 scaffold生成文件。├── source #资源文件夹。即存放用户资源。| └── _posts #博客文章目录。└── themes #存放主题。Hexo根据主题生成静态页面。├── _config.yml #网站的配置信息。标题、网站名称等。├── db.json： #source解析所得到的缓存文件。├── package.json # 应用程序信息。即配置Hexo运行需要js包。 主题内的结构 123456789101112├── LICENSE├── README.en.md // READEME 英文版├── README.md // READEME 中文文件├── _config.yml // 主题配置文件├── bower.json├── gulpfile.coffee├── languages // 多语言配置文件├── layout // 模板文件├── package.json // 项目的依赖文件├── scripts // 主题的脚本文件├── source // 主题的资源文件 CSS IMG└── test Hexo命令总览 hexo-cli hexo core hexo plugins hexo-cli作用： 启动hexo命令进程和参数解析机制 实现hexo命令的三个初始参数：init/version/plugins 加载hexo核心模块，并初始化 hexo core作用： 实现hexo的new、generate、publish等功能 hexo plugins扩展hexo的插件 扩展hexo命令的参数，如hexo-server 扩展hexo解析文件的”能力”，如增加jade模版解析功能的hexo-render-jade插件 Hexo的模板引擎模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。 我们就可以将source文件夹理解为数据库，而主题文件夹相当于界面。 Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。 layout 文件文档结构如下： 1234567891011121314├── _custom // 通用布局├── _layout.swig // 默认布局布局├── _macro // 插件模板├── _partials // 局部布局├── _scripts // script模板├── _third-party // 第三方插件模板├── archive.swig // 归档模板├── category.swig // 分类模板├── index.swig // 首页模板├── page.swig // 其他模板├── photo.swig // 照片模板（自定义）├── post.swig // 文章模板├── schedule.swig // 归档模板└── tag.swig // 标签模板 从markdown到html的旅程hexo中，从markdown到html的generate过程中做了两件事：模板渲染和模板渲染。 第一次渲染:主要目的就是给这个对象添加title,content等属性 第二次渲染:需要引入对应模板文件格式的插件，如.ejs文件就需要使用hexo-render-ejs插件，.jade文件需要使用hexo-render-jade插件，而.sass文件则需要hexo-render-sass插件来转换成css文件。hexo的这一设计有点类似webpack中的loader。 Hexo 每次部署的流程 hexo g：生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。 hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"正则表达式","slug":"B_JS_正则表达式","date":"2022-04-16T23:33:16.000Z","updated":"2024-06-01T12:20:05.326Z","comments":true,"path":"2022/04/17/B_JS_正则表达式/","link":"","permalink":"https://fuyunjinglong.github.io/2022/04/17/B_JS_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则Regular Expression即RE JS正则表达式入门，看这篇就够了 JS正则表达式完整教程（略长） 功能：利用它来校验数据的有效性，比如用户输入的手机号是不是符合规则；也可以从文本中提取想要的内容，比如从网页中抽取数据；还可以用来做文本内容替换，从而得到我们想要的内容。 1.元字符的概念正则常见的三种功能： 校验数据的有效性 查找符合要求的文本 对文本进行切割和替换等 正则元字符分类： 特殊字符 空白符 范围 量词 断言 特殊字符 英文的点（.）表示换行以外的任意单个字符 \\d 表示任意单个数字 \\w 表示任意单个数字或字母或下划线 \\s 表示任意单个空白符。 另外，还有与之对应的三个 \\D、\\W 和 \\S，分别表示着和原来相反的意思。 测试一下：https://regex101.com/r/PnzZ4k/1 空白符 \\r：回车符 \\n：换行符 \\f：换页符 \\t：制表符 \\v：垂直制表符 \\s：任意空白符 量词 *：0 到多次 +：1 到多次 ？：0 到 1 次，如 colou?r &#123;m&#125;：出现 m 次 &#123;m,&#125;：出现至少 m 次 &#123;m,n&#125;：m 到 n 次 范围 | ：或，比如： ab|bc 代表 ab 或 bc [...]：多选一，括号中任意单个元素 [a-z]：匹配 a 到 z 之间任意单个元素（按 ASCII 表，包含 a，z） [^...]：取反，不能是括号中的任意单个元素 2.量词与贪婪贪婪模式与非贪婪模式主要针对量词而言 贪婪模式， 即最长匹配，量词默认是贪婪模式即尽可能多的去匹配。 非贪婪模式，即 最短匹配，用法：量词后加?，就变成非贪婪模式即找出最短长度且符合要求的。 123测试文本：&quot;123&quot; is io &quot;45&quot;贪婪模式：&quot;.*&quot;，匹配到第一个引号到最后一个引号非贪婪模式：&quot;.*?&quot;,匹配到&quot;123&quot;和&quot;45&quot; 独占模式Possessive**用法：量词后加+**，就变成了独占模式。 不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能。 独占模式，它类似贪婪匹配，但匹配过程不会发生回溯。 独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间。 123text = “xyyz”独占模式：regex = “xy&#123;1,3&#125;+yz”，匹配失败贪婪模式：regex = “xy&#123;1,3&#125;yz”，匹配成功，因为有回溯。 正则回溯引发的血案Lazada 卖家中心店 铺名检验规则 比较复杂，名称中可以出现下面这些组合： 英文字母大小写； 数字； 越南文； 一些特殊字符，如 &amp;，-，_ 等。 开发的小伙伴在开发过程中使用了正则来实现店铺名称校验，如下所示： 123^([A-Za-z0-9._()&amp;&#x27;\\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$^([符合要求的组成1]|[符合要求的组成2])+$ 正则中有个加号（+），表示前面的内容出现一到多次，进行贪婪匹配，这样会导致大量回溯，占用大量 CPU 资源，引发线上问题，我们只需要将贪婪模式改成独占模式就可以解决这个问题。 在这个例子中，匹配不上时证明店铺名不合法，不需要进行回溯 3.分组与引用匹配15位或18位数字 示例一： \\d&#123;15&#125;\\d&#123;3&#125;? 由于 \\d&#123;3&#125; 表示三次，加问号非贪婪还是 3 次 示例二： \\d&#123;15&#125;(\\d&#123;3&#125;)? 在 \\d&#123;3&#125; 整体后加问号，表示后面三位有或无 123456测试文本：123456789012345123456789012345678\\d&#123;15&#125;\\d&#123;3&#125;?只能匹配到18位数字\\d&#123;15&#125;(\\d&#123;3&#125;)?匹配到15和18位数字 用法：括号在正则中的功能就是用于分组。简单来理解就是，由多个元字符组成某个部分，应该被看成一个整体的时候，可以用括号括起来表示一个整体，这是括号的一个重要功能。其实用括号括起来还有另外一个作用，那就是 复用 分组和编号括号在正则中可以 用于分组，被括号括起来的部分 「子表达式」会被保存成一个 子组。每一个分组表示一个编号。 比如2020-05-10 20:23:05，**(\\d{4}-\\d{2}-\\d{2})(**\\d{2}:\\d{2}:\\d{2})这就是2组编号。共有两个分组，日期是第 1 个，时间是第 2 个 不保存子组默认情况下，在括号里面的会保存成子组，后续继续使用。我们可以理解成，括号只用于归组，把某个部分当成「单个元素」，不分配编号，后面不会再进行这部分的引用。 用法：在括号里面使用 ?: ，则表示不保存子组，后续不再使用。 优点： 不保存子组可以提高正则的性能 子组计数时也更不容易出错 12345测试文本：123456789012345123456789012345678\\d&#123;15&#125;(\\d&#123;3&#125;)?匹配到123456789012345，123456789012345，678\\d&#123;15&#125;(?:\\d&#123;3&#125;)?匹配到123456789012345，123456789012345 括号嵌套在阿里云简单日志系统中，我们可以使用正则来匹配一行日志的行首。假设时间格式是 2020-05-10 20:23:05 。 **((\\d{4})-(\\d{2})-(\\d{2})((\\d{2}):(\\d{2}):(**\\d{2}) 1通过识别左括号即可区分分组编号，日期分组编号是 1，时间分组编号是 5，年月日对应的分组编号分别是 2，3，4，时分秒的分组编号分别是 6，7，8。 命名分组分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还 可能导致编号发生变化，因此一些编程语言提供了 命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为 (?P&lt;分组名&gt;正则)。 不是所有语言都支持的，在使用时，你需要查阅所用语言正则说明文档。 分组引用大部分情况下，使用 反斜扛 + 编号，即 \\number 的方式来进行引用，而 JavaScript 中是通过 $编号 来引用，如 $1。 分组查找和替换的引用方式： 变成语言 查找时引用方式 替换时引用方式 Python \\number 如 \\1 \\number 如 \\1 Go 官方不支持 官方不支持 Java \\number 如 \\1 $number 如 $1 JavaScript $number 如 $1 $number 如 $1 PHP \\number 如 \\1 \\number 如 \\1 Ruby \\number 如 \\1 \\number 如 \\1 分组引用在查找中使用\\w+ 来表示一个单词，语法\\1表示可以对相同字母或者数字进行筛选，用来匹配重复分组。 12测试文本：the litter cat cat is hat hat(\\w+) \\1匹配cat cat重复和hat hat重复 分组引用在替换中使用和查找类似，我们可以使用 反向引用，在得到的结果中，去拼出来我们想要的结果。还是使用刚刚日期时间的例子，我们可以很方便地将它替换成， 2020 年 05 月 10 日这样的格式。 https://regex101.com/r/2RVPTJ/2 1234测试文本：2020-05-10 20:23:052020-05-10 20:23:05((\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)) ((\\d&#123;2&#125;):(\\d&#123;2&#125;):(\\d&#123;2&#125;))日期\\1 时间\\5 \\2年\\3月\\4日 \\6时\\7分\\8秒 4.匹配模式匹配模式，指的是正则中一些 改变元字符匹配行为 的方式,常见有4种: 不区分大小写模式 点号通配模式 多行模式 注释模式 不区分大小写模式（Case-Insensitive）比如要查找单词 cat，不区分大小写，可以写成: 12测试文本：cat Cat CAT[Cc][Aa][Tt] 那么有没有更好的办法来实现这个需求呢？这时候不区分大小写模式就派上用场了。 把 模式修饰符 放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 (? 模式标识) 的方式来表示的。 1(?i)cat 不区分大小写模式的要点： 不区分大小写模式的指定方式，使用模式修饰符 (?i)； 修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则； 使用编程语言时可以使用预定义好的常量来指定匹配模式。 点号通配模式（Dot All）当我们需要匹配真正的「任意」符号的时候，可以使用 [\\s\\S] 或 [\\d\\D] 或 [\\w\\W] 等. 但是这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（.）可以匹配上包括换行的任何字符。 123456测试文本：the cat isCATCat(?s). 需要注意的是，JavasScript 不支持此模式，那么我们就可以使用前面说的 [\\s\\S] 等方式替代 多行匹配模式（Multiline）通常情况下，^ 匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 匹配行为。 12345测试文本：the little catis blue^the|blue$其中^匹配整个文本的开头，$匹配整个文本的结束 多行模式的作用在于，使 ^ 和 $ 能匹配上 每行 的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。 1(?m)^the|blue$其中^匹配每行文本的开头，$匹配每行文本的结束 注释模式（Comment）我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。正则中注释模式是使用 (?#comment) 来表示。 1(\\w+)(?#word) \\1(?#word repeat again) 小结： 不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。 点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。 多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。 注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。 思考：比如我们要提取网页中的 head 标签中的内容，用正则如何实现呢？ 1234567891011测试文本：&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt; 学习正则 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;# (?si) 是模式开关：s 单行匹配模式 i 是不区分大小写(?si)&lt;head&gt;(.*)&lt;\\/head&gt; 5.断言简单来说，断言是指对匹配到的文本位置有要求。 比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。 常见3种断言： 单词边界 行的开始和结束 环视 单词边界（Word Boundary）123测试文本：tom asked me if I would go fishing with him tomorrow.tom匹配到tom和tomorrow 这种结果不是我们想要的，正则中使用 \\b 来表示单词的边界。 \\b 中的 b 可以理解为是 边界（Boundary）。 1234tom表示包含tom\\btom表示以tom开头tom\\b表示以tom结尾\\btom\\b表示只有tom的 行的开始或结束如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定。常用于输入校验。 环视（ Look Around）环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为 零宽断言。 12345678910测试文本：邮政编码的规则是第一位是 1-9，一共有 6 位数字组成。012300 不满足第一位是 1-9130400 满足要求465441 满足要求4654000 长度过长138001380002 长度过长[1-9]\\d&#123;5&#125;对于4654000和138001380002也会误匹配到。 正则 名称 含义 示例 (?&lt;=Y) 肯定逆序环境 postive-lookahead 左边是 Y (?&lt;=\\d)th 左边是数字的 th，能匹配 9th (?&lt;!Y) 否定逆序环境 negative-lookahead 左边不是 Y (?&lt;!\\d)th 左边不是数字的 th，能匹配 health (?=Y) 肯定顺序环境 postive-lookbehind 右边是 Y six(?=\\d) 右边是数字的 six，能匹配 six6 (?!Y) 否定顺序环境 negative-lookbehind 右边不是 Y hi(?!\\d) 右边是不是数字的 hi，能匹配 high 口诀：左尖括号代表看左边，没有尖括号是看右边，感叹号是非 1(?&lt;!\\d)[1-9]\\d&#123;5&#125;(?!\\d)。这样就能够符合要求了。 环视与子组环视中虽然也有括号，但不会保存成子组。 环视拓展例子如下的正则表达式，含义是：必须出现 大小写字母、数字、特殊字符， 6-16 个字符 1234567(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\\d)(?=.*?[#@*&amp;.])[\\w!@#$%^&amp;*._]&#123;6,16&#125;拆解后：(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\\d)(?=.*?[#@*&amp;.])[\\w!@#$%^&amp;*._]&#123;6,16&#125; 前 4 组限定右侧的 6-16 个字符中必须要出现的字符有哪些， ``.*` ：任意字符出现 0 次或多次 ?：给这个量词 * 限定为非贪婪匹配模式 与不加该问号，即贪婪匹配模式的区别，在这里应该仅仅只是少匹配几次，增加了匹配性能 [a-z] ：那么唯一看不太懂的就是这个后面的可选字符了","categories":[{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"}],"tags":[]},{"title":"Vue2.0_入门","slug":"D_框架_Vue2.0_入门","date":"2022-04-16T22:33:16.000Z","updated":"2024-03-05T23:25:58.335Z","comments":true,"path":"2022/04/17/D_框架_Vue2.0_入门/","link":"","permalink":"https://fuyunjinglong.github.io/2022/04/17/D_%E6%A1%86%E6%9E%B6_Vue2.0_%E5%85%A5%E9%97%A8/","excerpt":"","text":"入门定义 vue2 是一套基于声明式渲染和渐进式的轻量级响应式框架，它可以设计为自底向上的逐层应用。 缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长 声明式渲染声明式渲染和命令式渲染比较 命令式渲染 ： 命令我们的程序去做什么，程序就会跟着你的命令去一步一步执行 声明式渲染 ： 我们只需要告诉程序我们想要什么效果，其他的交给程序来做。 渐进式框架 声明式渲染：数据到视图 组件系统：UI 结构到组件树 核心插件：客户端路由、状态管理、构建系统 vue-cli Vue 核心框架只做了前面 2 层，核心插件是热插拔部分。 细节结构图如下： Declarative Rendering(声明式渲染) Component System(组件系统) Client-Side Routing(客户端路由) Large Scale State Management(全局状态管理) Build System(构建系统) Vue2框架特点 轻量：内置 bunding 和 tree-shaking,打包后体积 30k,而 angular 是 65k 学习成本低：文档组织结构清晰，采用组件化模式，提高代码复用性 性能优化：虚拟dom和优化的diff算法,避免子组件渲染 国内生态良好：众多厂商使用，持续增长 从 0 开始构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; background-color: pink; &#125; .app-msg &#123; color: yellow; &#125; &lt;/style&gt; &lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 class=&quot;app-msg&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;div v-cloak&gt;&#123;&#123;noData&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;textData&quot;&gt;&lt;/div&gt; &lt;div v-html=&quot;textData&quot;&gt;&lt;/div&gt; &lt;input /&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTiop = false; //阻止Vue在生产环境下产生提示 var vm = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; msg: &quot;基本代码&quot;, noData: &quot;无数据&quot;, textData: &#x27;&lt;span style=&quot;color:red&quot;&gt;阳光&lt;/span&gt;&#x27;, &#125;; &#125;, mounted() &#123; const that = this; setTimeout(() =&gt; &#123; that.noData = &quot;&quot;; &#125;, 1000); &#125;, &#125;); console.log(&quot;vm&quot;, vm); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vm 实例如下： 进阶插件main.js 12import plugins from &#x27;./plugins&#x27;Vue.use(plugins) plugins.js 本质是包含install方法的对象，第一个参数是Vue 1234567891011export default&#123; install(Vue)&#123; //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,()=&gt;&#123;&#125;) //全局指令 Vue.directive(&#x27;mySlice&#x27;,()=&gt;&#123;&#125;) // 全局混入 Vue.mixin(&#x27;mySlice&#x27;,()=&gt;&#123;&#125;) Vue.prototype.$hello =&#x27;xx&#x27; &#125;&#125; 双向绑定v-model原理 12&lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;&lt;input type=&quot;text&quot; v-bind=&quot;age&quot; v-on:input=&quot;age = $event.target.value&quot;&gt; v-model的原理就是: v-bind 和 v-on的语法糖 第一种: v-bind 原理: 子组件通过监听父组件数据，子组件改变数据之后通知给父组件 错误写法: 不可以直接修改props的值 父组件： 12345678910111213141516171819202122// Users.vue &lt;template&gt; &lt;div&gt; &lt;Son :ageValue=&quot;age&quot; @changeInput=&quot;changeInput&quot;/&gt; &lt;el-button @click=&quot;age = Math.floor(Math.random()*10)&quot;&gt;添加&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &#x27;&#x27; &#125; &#125;, methods: &#123; changeInput(val) &#123; this.age = val &#125; &#125;&#125;&lt;/script&gt; 子组件： 12345678910111213141516171819202122232425262728293031323334353637383940// Son.vue&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; ageValue: &#123; typeof: String &#125; &#125;, data() &#123; return &#123; sonAge: &#x27;&#x27; &#125; &#125;, methods: &#123; changeInput() &#123; this.$emit(&#x27;changeInput&#x27;, this.sonAge) &#125; &#125;, /* 为什么要监听: 因为父组件传递过来属性, 可能有默认值, 子组件的input需要根据默认值回显,或者别的地方需要 */ watch: &#123; ageValue: &#123; immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数 handler(val) &#123; this.sonAge = val &#125; &#125; &#125;&#125;&lt;/script&gt; 第二种.sync修饰符 原理:.sync:名字 是自己起的, 通过update:名字进行触发对象的事件。update：是vue为我们约定好的名称部分 父组件： 12345678910111213141516171819// Users.vue&lt;template&gt; &lt;div&gt; &lt;Son :ageValue.sync=&quot;age&quot; /&gt; &lt;el-button @click=&quot;age = Math.floor(Math.random()*10)&quot;&gt;添加&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &#x27;&#x27; &#125; &#125;, methods: &#123; &#125;&#125;&lt;/script&gt; 子组件： 123456789101112131415161718192021222324252627282930313233343536// Son.vue&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; ageValue: &#123; typeof: String &#125; &#125;, data() &#123; return &#123; sonAge: &#x27;&#x27; &#125; &#125;, methods: &#123; changeInput() &#123; // this.$emit(&#x27;changeInput&#x27;, this.sonAge) // 这样父组件内的值也同时被更改,省略了监听事件这一步 this.$emit(&#x27;update:ageValue&#x27;, this.sonAge) &#125; &#125;, watch: &#123; ageValue: &#123; immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数 handler(val) &#123; this.sonAge = val &#125; &#125; &#125;&#125;&lt;/script&gt; 第三种 v-model 原理: 通过 model新属性: 配置一个 props:接受的属性, 和一个事件名。 父组件： 1234567891011121314151617// Users.vue&lt;template&gt; &lt;div&gt; &lt;Son v-model=&quot;age&quot; /&gt; &lt;el-button @click=&quot;age = Math.floor(Math.random()*10)&quot;&gt;添加&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &#x27;&#x27; &#125; &#125;&#125;&lt;/script&gt; 子组件： 123456789101112131415161718192021222324252627282930313233343536373839// Son.vue&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; typeof: String &#125; &#125;, data() &#123; return &#123; sonAge: &#x27;&#x27; &#125; &#125;, // 超级牛 model: &#123; prop: &#x27;value&#x27;, event: &#x27;change&#x27; &#125;, methods: &#123; changeInput() &#123; this.$emit(&#x27;change&#x27;, this.sonAge) &#125; &#125;, watch: &#123; value: &#123; immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数 handler(val) &#123; this.sonAge = val &#125; &#125; &#125;&#125;&lt;/script&gt; 修饰符与指令修饰符 lazy：改变输入框的值时value不会改变，当光标离开输入框时，v-model绑定的value才会改变 trim：给v-model绑定值的首尾空格过滤掉 number：将值转成数字。对于先输入数字，只取前面数字部分。对于先输入字母，则无效 stop：阻止冒泡 capture：事件默认是往外冒泡，capture表示反过来，由外往内捕获 self：只有点击事件绑定的本身才会触发事件 once：事件只执行一次 prevent：阻止默认事件，如a标签的跳转 native：加在自定义组件上，保证事件能执行 sync：父子传值，子组件想更新值 指令 v-html：更新innerHtml v-text：更新textContent v-bind：绑定变量属性 v-once：只渲染一次 v-if/v-for/v-show等 自定义指令 局部指令 12345678910111213141516171819202122232425&lt;input v-focuslw /&gt;data() &#123; return &#123; userName: &#x27;&#x27; &#125;; &#125;, directives: &#123; focuslw: &#123; // 指令的定义 inserted: function (el,binding,vnode,oldVnode) &#123; el.focus(); &#125; &#125; &#125;,指令钩子函数会被传入以下参数:el：指令所绑定的元素，可以用来直接操作 DOM。binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 全局指令 12345678&lt;input v-focusGlobal /&gt;Vue.directive(&#x27;focusGlobal&#x27;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el,binding,vnode,oldVnode) &#123; // 聚焦元素 el.focus(); &#125;&#125;); 指令的钩子函数如下： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用 自定义事件传递额外参数 1&lt;div @childClick=&quot;getData($event,&#x27;额外参数&#x27;)&quot;&gt;我是父级内容&lt;div&gt; 常用自定义指令 复制粘贴指令 v-copy 长按指令 v-longpress 输入框防抖指令 v-debounce 禁止表情及特殊字符 v-emoji 图片懒加载 v-LazyLoad 权限校验指令 v-premission 实现页面水印 v-waterMarker 拖拽指令 v-draggable 动态class/动态style 动态class对象：&lt;div :class=&quot;&#123; &#39;is-active&#39;: true, &#39;red&#39;: isRed &#125;&quot;&gt;&lt;/div&gt; 动态class数组：&lt;div :class=&quot;[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&quot;&gt;&lt;/div&gt; 动态style对象：&lt;div :style=&quot;&#123; color: textColor, fontSize: &#39;18px&#39; &#125;&quot;&gt;&lt;/div&gt; 动态style数组：&lt;div :style=&quot;[&#123; color: textColor, fontSize: &#39;18px&#39; &#125;, &#123; fontWeight: &#39;300&#39; &#125;]&quot;&gt;&lt;/div&gt; 全局组件创建全局组件的两种方式 component 和 use 123456789101112131415import PageTools from &#x27;@/components/PageTools&#x27; // 导入需要注册的组件Vue.component(PageTools.name, PageTools) // 全局注册组件import ExpHeader from &#x27;./ExpHeader&#x27;;const components = &#123; ExpHeader // 导航头&#125;;// 全局注册组件;const initComponent = function(app) &#123; Object.keys(components).forEach(comp =&gt; &#123; app.component(comp, components[comp]); &#125;);&#125;;export default initComponent;Vue.use(initComponent) 动态组件和异步组件动态组件 1&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; 异步组件 123456new Vue(&#123; // ... components: &#123; &#x27;my-component&#x27;: () =&gt; import(&#x27;./my-async-component&#x27;) &#125;&#125;) Vue 的异步组件放在哪个生命周期 结论：created 和 mounted 都可以。 对于作为子组件被调用的组件里，异步请求应当在mounted里调用，因为这个时候子组件可能需要涉及到对 dom 的操作； 对于页面级组件，当我们需要使用ssr（服务端渲染）的时候，只有created是可用的，所以这个时候请求数据只能用它； 对于页面级组件， 当我们做异步操作时，涉及到要访问 dom 的操作，我们仍旧只能使用mounted; 对于一般情况，created和mounted都是可以的； Socpe样式12&lt;style lang=&#x27;less&#x27;&gt;&lt;/style&gt;不指定lang，则默认按照css处理。否则按照less,sass等处理器处理 自定义事件props属性值也可以传递函数 child.vue 12345678...&lt;button @click=&quot;getVal&quot;&gt;&lt;/button&gt;props:[&#x27;getFatherVal&#x27;],method:&#123; getVal()&#123; this.getFatherVal() &#125;&#125; 销毁事件 1234this.$off(&#x27;clickMe&#x27;)//销毁一个事件this.$off([&#x27;clickMe]&#x27;)//销毁多个事件this.$off()//解绑所有自定义事件this.$destory()//销毁实例并解绑所有自定义事件 动画原生CSS 1234567891011.come&#123; animation:aiMe 1s;&#125;@keyframes aiMe&#123; from&#123; transform:translateX(-100px) &#125; to&#123; transform:translateX(0px) &#125;&#125; Vue2的transition标签 12345678910&lt;transition name=&quot;hello&quot; appear&gt;//使用name标记动画，appear初次加载产生动画 &lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt;&lt;/transition&gt;.hello-enter-active&#123; animation:aiMe 1s linear;&#125;.hello-leave-active&#123; animation:aiMe 1s linear reverse;&#125; 还有另外的2个指令hello-enter，hello-enter-to，可能比较繁琐 1234567891011121314&lt;transition name=&quot;hello&quot; appear&gt;//使用name标记动画，appear初次加载产生动画 &lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt;&lt;/transition&gt;// 进入的起点，离开的终点.hello-enter,.hello-leave-to&#123; transform：translateX(-100px)&#125;.hello-enter-active,hello-leave-active&#123; transform: 1s linear;&#125;// 进入的终点，离开的起点.hello-enter-to,.hello-leave&#123; transform：translateX(-100px)&#125; transition-group多个元素过度 1234&lt;transition-group name=&quot;hello&quot; appear&gt;//必须保证key唯一 &lt;div v-show=&quot;isShow&quot; key=&quot;0&quot;&gt;&lt;/div&gt; &lt;div v-show=&quot;isShow&quot; key=&quot;0&quot;&gt;&lt;/div&gt;&lt;/transition&gt; 使用第三方动画animate.css 123456&lt;transition-group name=&quot;animate_animated animate_bounce&quot; enter-active-class=&quot;animate_swing&quot; leave-active-calss=&quot;animate-backOutUp&quot;&gt; &lt;div v-show=&quot;isShow&quot;&gt;&lt;/div&gt;&lt;/transition&gt; 路由query参数 1234567891011&lt;!--1.完整路径--&gt;&lt;router-link :to=&quot;/home?id=11&quot;&gt;&lt;/router-link&gt;&lt;!--2.通过名字跳转--&gt;&lt;router-link :to=&quot;&#123;name:&#x27;home&#x27;&#125;&quot;&gt;&lt;/router-link&gt;&lt;!--3.配合参数-&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/home&#x27;,query:&#123;id:11&#125;&#125;&quot;&gt;&lt;/router-link&gt; param参数 123456789101112131415路由配置&#123; name:home, path:&#x27;/home/:id&#x27;,// id占位符 conponent:Home&#125;&lt;!--1.完整路径--&gt;&lt;router-link :to=&quot;/home/11&quot;&gt;&lt;/router-link&gt;&lt;!--2.配合参数-&gt;&lt;router-link :to=&quot;&#123;name:&#x27;home&#x27;,param:&#123;id:11&#125;&#125;&quot;&gt;&lt;/router-link&gt; Props配置项 12345678910111213141516路由配置&#123; name:home, path:&#x27;/home/:id&#x27;,// id占位符 conponent:Home， props:&#123;id:99&#125;,//用法1，固定值 props:true//用法2，只能接受所有的params参数 props:(route)&#123;//用法3，返回一组数据,路由组件可以接收到 return&#123; id：route.param.id &#125; &#125;&#125;组件props:[id] push和replace push是追加历史记录，replace是替换当前最新记录 12开启replace模式&lt;router-link replace :to=&quot;/home/11&quot;&gt;&lt;/router-link&gt; v-if 与 v-for 比较 2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 3.x 版本中 v-if 总是优先于 v-for 生效。 高级高级技巧 多用Array.includes() 提前退出/提前返回。如果不使用，可能有多层if 用字面量替代switch,如用obj的属性取值替代switch 提前退出/提前返回 12345a(&#123;type&#125;=&#123;&#125;)=&gt;&#123; if(!type) return &#x27;no type&#x27;; if(type===&#x27;dog&#x27;) return &#x27;is dog&#x27;; return type&#125; 接口权限-路由权限-菜单权限-按钮权限控制到按钮级别怎么做？ 接口权限 接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录 登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token 路由权限 方案一 初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验 缺点：加载所有的路由，菜单信息写死在前端，不易维护，菜单跟路由耦合 方案二 初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制 登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由 缺点：全局路由守卫里，每次路由跳转都要做判断；菜单跟路由耦合 菜单权限 菜单权限可以理解成将页面与理由进行解耦 方案一 菜单与路由分离，菜单由后端返回. 缺点:菜单需要与路由做一一对应，前端添加了新功能 方案二 菜单和路由都由后端返回. 缺点：全局路由守卫里，每次路由跳转都要做判断。前后端的配合要求高 按钮权限 方案一 按钮权限也可以用v-if判断 但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断 这种方式就不展开举例了 方案二 通过自定义指令进行按钮权限的判断 参考文献 https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw https://segmentfault.com/a/1190000020887109 https://juejin.cn/post/6844903648057622536#heading-6 vuecli 定制化模板需要准备内容包含三个件 generator/index.js preset.json template 自己封装的一套代码 generator/index.js 文件内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const fs = require(&#x27;fs&#x27;);const tool = (api) =&gt; &#123; return &#123; deleteFile(path) &#123; const file = api.resolve(path); if (fs.existsSync(file)) &#123; fs.unlinkSync(file); &#125; &#125;, deleteDir(path) &#123; const dir = api.resolve(path); if (fs.existsSync(dir)) &#123; fs.readdirSync(dir).forEach((o) =&gt; &#123; const file = dir + &#x27;\\\\&#x27; + o; if (fs.statSync(file).isDirectory()) &#123; fs.readdirSync(dir).forEach((p) =&gt; &#123; fs.unlinkSync(dir + &#x27;\\\\&#x27; + o + &#x27;\\\\&#x27; + p); &#125;); &#125; else &#123; fs.unlinkSync(file); &#125; &#125;); fs.rmdirSync(dir); &#125; &#125; &#125;;&#125;;module.exports = (api, options, rootOptions) =&gt; &#123; const utils = tool(api); // 命令 api.extendPackage(&#123; scripts: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, &#125;); // 安装一些基础公共库 api.extendPackage(&#123; dependencies: &#123; &quot;core-js&quot;: &quot;^3.6.4&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-router&quot;: &quot;^3.1.5&quot;, &quot;vuex&quot;: &quot;^3.1.2&quot;, &quot;element-ui&quot;: &quot;^2.15.6&quot;, &quot;vant&quot;: &quot;^2.12.31&quot;, &quot;axios&quot;: &quot;^0.24.0&quot;, &#125;, devDependencies: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-router&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-vuex&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;less&quot;: &quot;^3.0.4&quot;, &quot;less-loader&quot;: &quot;^5.0.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125; &#125;); api.render(&#x27;../template&#x27;); api.onCreateComplete(() =&gt; &#123; process.env.VUE_CLI_SKIP_WRITE = true; &#125;);&#125;; preset.json 文件内容 1234567891011&#123; &quot;useConfigFiles&quot;: true, &quot;plugins&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &#123;&#125;, &quot;@vue/cli-plugin-router&quot;: &#123; &quot;historyMode&quot;: true &#125;, &quot;@vue/cli-plugin-vuex&quot;: &#123;&#125; &#125;, &quot;cssPreprocessor&quot;: &quot;less&quot;&#125; 将模版上传 github https://github.com/fuyunjinglong/vue2_template 安装 vue3 cli 1npm install -g @vue/cli 创建项目 1vue create --preset fuyunjinglong/vue2_template demo 实现防抖截流函数1import &#123;debounce&#125; from &quot;@/utils/utils&quot; 12345methods: &#123; inputNum: debounce(function()&#123; console.log(1111); &#125;, 1000) &#125; vue-router动态路由动态路由的 2 种方案 前端将全部路由规定好，登录时根据用户角色权限来动态展示路由； 路由存储在数据库中，前端通过接口获取当前用户对应路由列表并进行渲染； 实战-大致思路 若未登录，跳转至登录页面 若已经登录，判断是否已获取路由列表 若未获取，从后端获取、解析并保存到 Vuex 中 若已获取，跳转至目标页面 实战-路由列表解析 将 JSON 格式的路由信息解析为 JavaScript 列表对象； 利用列表对象的 filter 方法实现解析函数，通过 component 判断是否为布局组件； 若为布局组件，使用布局组件代替 component 字符串； 若为具体页面，使用 loadView 函数加载对应的具体页面； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// router/index.jsimport Vue from &quot;vue&quot;;import store from &quot;@/store&quot;;import Router from &quot;vue-router&quot;;import &#123; getToken &#125; from &quot;@/lib/util&quot;;Vue.use(Router);// 定义静态路由const staticRoutes = [ &#123; path: &quot;/login&quot;, name: &quot;login&quot;, meta: &#123; title: &quot;登录页面&quot;, hideInMenu: true, &#125;, component: () =&gt; import(&quot;@/view/login/login.vue&quot;), &#125;, &#123; path: &quot;/401&quot;, name: &quot;error_401&quot;, meta: &#123; hideInMenu: true, &#125;, component: () =&gt; import(&quot;@/view/error-page/401.vue&quot;), &#125;, &#123; path: &quot;/500&quot;, name: &quot;error_500&quot;, meta: &#123; hideInMenu: true, &#125;, component: () =&gt; import(&quot;@/view/error-page/500.vue&quot;), &#125;,];// 定义登录页面名称（为了方便理解才定义的）const LOGIN_PAGE_NAME = &quot;login&quot;;// 实例化 Router 对象const router = new Router(&#123; routes: staticRoutes, mode: &quot;history&quot;,&#125;);// 定义全局前置守卫（里面有两个坑要注意）router.beforeEach((to, from, next) =&gt; &#123; // 通过自定义方法获取用户 token 用来判断用户登录状态 const token = getToken(); if (!token &amp;&amp; to.name !== LOGIN_PAGE_NAME) &#123; // 如果没有登录而且前往的页面不是登录页面，跳转到登录页 next(&#123; name: LOGIN_PAGE_NAME &#125;); &#125; else if (!token &amp;&amp; to.name === LOGIN_PAGE_NAME) &#123; // 如果没有登录而且前往的页面是登录页面，跳转到登录页面 // 这里有一个坑，一定要注意这一步和上一步得分开写 // 如果把前两步判断合并为 if (!token) next(&#123; name:login &#125;) // 则会形成登录页面无限刷新的错误，具体成因后面解释 next(); &#125; else &#123; // 如果登录了 if (!store.state.app.hasGetRoute) &#123; // 如果没有获取路由信息，先获取路由信息而后跳转 store.dispatch(&quot;getRouteList&quot;).then(() =&gt; &#123; router.addRoutes(store.state.app.routeList); // 这里也是一个坑，不能使用简单的 next() // 如果直接使用 next() 刷新后会一直白屏 next(&#123; ...to, replace: true &#125;); &#125;); &#125; else &#123; // 如果已经获取路由信息，直接跳转 next(); &#125; &#125;&#125;);export default router; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// store/index.jsimport router from &quot;@/router&quot;;import Main from &quot;@/components/main&quot;;import &#123; getToken &#125; from &quot;@/lib/util&quot;;import &#123; getRoute &#125; from &quot;@/api/app&quot;;const loadView = (viewPath) =&gt; &#123; // 用字符串模板实现动态 import 从而实现路由懒加载 return () =&gt; import(`@/view/$&#123;viewPath&#125;`);&#125;;const filterAsyncRouter = (routeList) =&gt; &#123; return routeList.filter((route) =&gt; &#123; if (route.component) &#123; if (route.component === &quot;Main&quot;) &#123; // 如果 component = Main 说明是布局组件 // 将真正的布局组件赋值给它 route.component = Main; &#125; else &#123; // 如果不是布局组件就只能是页面的引用了 // 利用懒加载函数将实际页面赋值给它 route.component = loadView(route.component); &#125; // 判断是否存在子路由，并递归调用自己 if (route.children &amp;&amp; route.children.length) &#123; route.children = filterAsyncRouter(route.children); &#125; return true; &#125; &#125;);&#125;;export default &#123; state: &#123; routeList: [], token: getToken(), hasGetRoute: false, &#125;, mutations: &#123; setRouteList(state, data) &#123; // 先将 JSON 格式的路由列表解析为 JavaScript List // 再用路由解析函数解析 List 为真正的路由列表 state.routeList = filterAsyncRouter(JSON.parse(data)); // 修改路由获取状态 state.hasGetRoute = true; &#125;, &#125;, atcions: &#123; getRouteList(&#123; state, commit &#125;) &#123; return new Promise((resolve) =&gt; &#123; const token = state.token; getRoute(&#123; token &#125;).then((res) =&gt; &#123; let data = res.data.data; // 注意这里取出的是 JSON 格式的路由列表 commit(&quot;setRouteList&quot;, data); resolve(); &#125;); &#125;); &#125;, &#125;,&#125;; 常见问题 1.页面卡在登录页面而且不断刷新 主要原因是把两种未登录的状态混在一起判断 2.动态路由刷新后 404 是因为在创建「基本静态路由」的时候回把 404 页面的路由也加入在里面，从而导致页面加载初期动态路由还没有加入到路由实例中，匹配范围最广的 404 页面就会跳出来。解决方法就是将 404 页面的路由也加入到动态路由中。 vuexVuex集中式存储管理应用的所有组件的状态，规定所有的数据操作必须通过 action -&gt; mutation -&gt; state(响应式数据) -&gt;update view 核心模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 vuex 的组成 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态 mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） Q1：vuex 的插件加载机制 所谓插件机制，就是需要实现 Install 方法，并且通过mixin形式混入到 Vue 的生命周期中 利用 vue 的插件机制，使用 Vue.use(vuex) 时，会调用 vuex 的 install 方法，装载 vuex。applyMixin 方法使用 vue 混入机制，vuex 是利用 vue 的 mixin 混入机制，在 beforeCreate 钩子前混入 vuexInit 方法，vuexInit 方法实现了 store 注入 vue 组件实例，并注册了 vuex store 的引用属性 $store。store 注入过程如下图所示： 将初始化 Vue 根组件时传入的 store 设置到 this 对象的 $store 属性上，子组件从其父组件引用 $store 属性，层层嵌套进行设置。在任意组件中执行 this.$store 都能找到装载的那个 store 对象。 Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的 $store 中。因此在 Vue Component 任意地方都能够通过 this.$store 访问到该 store。 Q2. state 内部支持模块配置和模块嵌套，如何实现的？ 在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(&#39;user&#39;, payload) 这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。 Q3. Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？ Vuex 中修改 state 的唯一渠道就是执行 commit 方法，其底层通过执行 this._withCommit(fn) 设置 _committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原 _committing 变量。外部修改虽然能够直接修改 state，但是并没有修改 _committing 标志位，所以只要 watch 一下 state，state 改变时判断是否 _committing 值为 true，即可判断修改的合法性 Q4. vuex 的 state 和 getters 是如何映射到各个组件实例中响应式更新状态呢？ 123456789101112131415161718192021222324252627282930313233343536function resetStoreVM(store, state, hot) &#123; const oldVm = store._vm; // 设置 getters 属性 store.getters = &#123;&#125;; const wrappedGetters = store._wrappedGetters; const computed = &#123;&#125;; // 遍历 wrappedGetters 属性 forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // 给 computed 对象添加属性 computed[key] = partial(fn, store); // 重写 get 方法 // store.getters.xx 其实是访问了store._vm[xx]，其中添加 computed 属性 Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true, // for local getters &#125;); &#125;); const silent = Vue.config.silent; Vue.config.silent = true; // 创建Vue实例来保存state，同时让state变成响应式 // store._vm._data.$$state = store.state store._vm = new Vue(&#123; data: &#123; $$state: state, &#125;, computed, &#125;); Vue.config.silent = silent; // 只能通过commit方式更改状态 if (store.strict) &#123; enableStrictMode(store); &#125;&#125; Vuex 的 state 状态是响应式，是借助 vue 的 data 响应式，将 state 存入 vue 实例组件的 data 中；Vuex 的 getters 则是借助 vue 的计算属性 computed 实现数据实时监听。 自定义实现一个 Vuex 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// store.jslet Vue// 定义store类class Store&#123; constructor(options = &#123;&#125;) &#123; this.$options = options this._mutations = options.mutations this._actions = options.actions this._wrappedGetters = options.getters // 定义computed const computed = &#123;&#125; this.getters = &#123;&#125; const store = this Object.keys(this._wrappedGetters).forEach(key =&gt; &#123; // 获取用户定义的getters const fn = store._wrappedGetters[key] // 转换为computed可以使用无参数形式 computed[key] = function() &#123; return fn(store.state) &#125; // 为getters定义只读属性 Object.defineProperty(store.getters, key &#123; get:() =&gt; store._vm[key] &#125;) &#125;) // state的响应式实现 this._vm = new Vue(&#123; data: &#123; // 加两个$，Vue不做代理 $$state: options.state &#125;, computed // 添加计算属性 &#125;) this.commit = this.commit.bind(this) this.dispatch = this.dispatch.bind(this) &#125; // 存取器，获取store.state ，只通过get形式获取，而不是直接this.xxx, 达到对state get state() &#123; return this._vm._data.$$state &#125; set state(v) &#123; // 如果用户不通过commit方式来改变state，就可以在这里做一控制 &#125; // commit的实现 commit(type, payload) &#123; const entry = this._mutations[type] if (entry) &#123; entry(this.state, payload) &#125; &#125; // dispatch的实现 dispatch(type, payload) &#123; const entry = this._actions[type] if (entry) &#123; entry(this, payload) &#125; &#125;&#125;// 实现installfunction install(_Vue) &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$Store = this.$options.store // 这样就可以使用 this.$store &#125; &#125; &#125;)&#125;// 导出Vuex对象export default &#123; Store, install&#125; 事件总线EventBus 发布订阅源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// $on 的实现逻辑Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) &#125; return vm &#125;// $emit 的实现逻辑Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) const info = `event handler for &quot;$&#123;event&#125;&quot;` for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; invokeWithErrorHandling(cbs[i], vm, args, vm, info) &#125; &#125; return vm &#125;// invokeWithErrorHandling 的实现逻辑export function invokeWithErrorHandling ( handler: Function, context: any, args: null | any[], vm: any, info: string) &#123; let res try &#123; res = args ? handler.apply(context, args) : handler.call(context) &#125; catch (e) &#123; handleError(e, vm, info) &#125; return res&#125; 分析： 首先我们都了解 vue 的数据相应是依赖于“观察-订阅”模式，那 o n 、 on、on、emit 也不例外; $on 用来收集所有的事件依赖，他会将传入的参数 event 和 fn 作为 key 和 value 的形式存到 vm._events 这个事件集合里，就像这样 vm._events[event]=[fn]; 而$emit 是用来触发事件的，他会根据传入的 event 在 vm_events 中找到对应的事件并执行 invokeWithErrorHandling(cbs[i], vm, args, vm, info) 最后我们看 invokeWithErrorHandling 方法可以发现，他是通过 handler.apply(context, args)和 handler.call(context)的形式执行对应的方法 自定义实现一个 Bus 12345678910111213141516171819// Bus： 事件派发、监听和回调class Bus &#123; constructor() &#123; this.callbacks = &#123;&#125; &#125; // 收集监听的回调函数 $on(name, fn) &#123; this.callbacks[name] = this.callbacks[name] || [] this.callbacks[name].push(fn) &#125; // 执行监听的回调函数 $emit(name, args) &#123; if (this.callbacks[name]) &#123; this.callbacks[name].forEach(cb =&gt; cb(args)) &#125; &#125;&#125;// 在main.js中这样使用Vue.prototype.$bus = new Bus() 手写发布订阅 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class EventEmitter &#123; constructor() &#123; this.cache = &#123;&#125;; &#125; on(name, fn) &#123; if (this.cache[name]) &#123; this.cache[name].push(fn); &#125; else &#123; this.cache[name] = [fn]; &#125; &#125; off(name, fn) &#123; const tasks = this.cache[name]; if (tasks) &#123; const index = tasks.findIndex((f) =&gt; f === fn || f.callback === fn); if (index &gt;= 0) &#123; tasks.splice(index, 1); &#125; &#125; &#125; emit(name, once = false) &#123; if (this.cache[name]) &#123; // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 const tasks = this.cache[name].slice(); for (let fn of tasks) &#123; fn(); &#125; if (once) &#123; delete this.cache[name]; &#125; &#125; &#125;&#125;// 测试const eventBus = new EventEmitter();const task1 = () =&gt; &#123; console.log(&quot;task1&quot;);&#125;;const task2 = () =&gt; &#123; console.log(&quot;task2&quot;);&#125;;eventBus.on(&quot;task&quot;, task1);eventBus.on(&quot;task&quot;, task2);eventBus.off(&quot;task&quot;, task1);setTimeout(() =&gt; &#123; eventBus.emit(&quot;task&quot;); // task2&#125;, 1000); 手写发布订阅 2 首先定义一个list对象用于存放事件的集合的映射表当调用on事件绑定的时候通过传入的事件名判断当前是否已存在list中，不存在则先设置一个空数组，否则就直接 push 进去。 emit发布执行对应事件 event 对入参 arguments 进行处理（shift 剪出要触发的事件名），通过事件名先浅拷贝一个列表副本，然后遍历执行对应列表的所有的函数this.list[event][i].apply(this, arguments) remove删除事件先获取fns对应主题的函数列表进行一些判断，如果没指定删除列表中的哪个函数（函数引用）就默认把对应整个列表给删除，如果有传 fn 就在循环中和对应的函数进行引用的判断fns.fn === fn是给 once 函数删除的时候使用的 once这里给传入的订阅者包装成一个闭包函数，把订阅者fn放在订阅者once函数属性下，当对应订阅者执行的时候先执行这个闭包函数删除掉自身后再去执行挂在once下的订阅者fn，做到用完即删。 因为如果想使用remove方法删除once订阅者的话和删除普通订阅者不一样，单凭传入的 fn(fns[i] === fn)是删除不掉once订阅者的（因为传入的fn函数和once包装函数引用不相等），需要用到包装函数下的fn属性引用（fns.fn === fn）去识别订阅者才能进行删除。 核心代码-eventEmitter.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//发布订阅模式var eventEmitter = (function () &#123; &quot;use strict&quot;; var eventEmitter = &#123; list: &#123;&#125;, //订阅主题 on: function (event, fn) &#123; if (typeof fn !== &quot;function&quot;) &#123; return false; &#125; //创建订阅者列表,如果存在就直接插入 (this.list[event] || (this.list[event] = [])).push(fn); return this; &#125;, //发布主题 emit: function () &#123; var event = [].shift.call(arguments); if (this.list[event] &amp;&amp; this.list[event].length) &#123; var fns = this.list[event].slice(); //浅拷贝后直接对列表所有订阅者函数依次执行 for (var i in fns) &#123; this.list[event][i].apply(this, arguments); &#125; return this; &#125; return false; &#125;, //创建执行后立即销毁的订阅者 once(event, fn) &#123; function once() &#123; this.remove(event, once); fn.apply(this, arguments); &#125; //存储当前fn副本用于删除时的查找 once.fn = fn; this.on(event, once); return this; &#125;, //移除对应订阅者 remove: function (event, fn) &#123; var fns = this.list[event]; if (!fns) return false; //如没传递对应的订阅者函数引用，就默认删除整个事件列表 if (!fn) &#123; delete this.list[event]; return this; &#125; //找到对应的订阅者进行删除,包括once的订阅者 for (var i = 0; i &lt;= fns.length; i++) &#123; if (fns[i] === fn || fns.fn === fn) &#123; fns.splice(i, 1); break; &#125; &#125; return this; &#125;, &#125;; return eventEmitter;&#125;)(); 使用 123456789&lt;script src=&quot;./eventEmitter.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //注册订阅者 eventEmitter.on(&#x27;test&#x27;,(t)=&gt;&#123; document.querySelector(&#x27;#txt&#x27;).textContent = t; &#125;) //发布 eventEmitter.emit(&#x27;test&#x27;,&#x27;start...&#x27;);&lt;/script&gt; nodeJS 手写 mock 数据服务器前言 koa 基本使用 koa-router 的基本用法 koa-logger 的使用 glob 支持文件遍历查寻 node 几个核心 api 的使用 使用 nodemon 做自动重启 核心代码 github 源码 api/v1/user.json 目录层级结构 index.js-关键五部曲 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Koa = require(&#x27;koa&#x27;);const Router = require(&#x27;koa-router&#x27;);const glob = require(&quot;glob&quot;);const logger = require(&#x27;koa-logger&#x27;)const &#123; resolve &#125; = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const app = new Koa();const router = new Router(&#123;prefix: &#x27;/api&#x27;&#125;);const routerMap = &#123;&#125;; // 存放路由映射//4.添加控制台日志 我们使用koa-logger实现在终端打印node日志，方便调试app.use(logger());//2.注册路由 我们使用koa-router来实现后台服务的路由功能，并通过koa提供的上下文ctx将读取到的数据返回给前端//3.自动注册api接口并返回数据 我们将在这个阶段实现api服务的自动注册，这里我们使用glob这个第三方模块来遍历目录，并通过node的fs模块读取api文件的数据并返回给前台glob.sync(resolve(&#x27;./api&#x27;, &quot;**/*.json&quot;)).forEach((item, i) =&gt; &#123; let apiJsonPath = item &amp;&amp; item.split(&#x27;/api&#x27;)[1]; let apiPath = apiJsonPath.replace(&#x27;.json&#x27;, &#x27;&#x27;); router.get(apiPath, (ctx, next) =&gt; &#123; try &#123; let jsonStr = fs.readFileSync(item).toString(); ctx.body = &#123; data: JSON.parse(jsonStr), code: 200, &#125; &#125;catch(err) &#123; ctx.throw(&#x27;服务器错误&#x27;, 500); &#125; &#125;); // 记录路由 routerMap[apiJsonPath] = apiPath;&#125;);//5.路由映射文件的生成 该功能也不是本文的重点，但是会极大的方便前端开发者调试请求fs.writeFile(&#x27;./routerMap.json&#x27;, JSON.stringify(routerMap, null , 4), err =&gt; &#123; if(!err) &#123; console.log(&#x27;路由地图生成成功！&#x27;) &#125;&#125;);app .use(router.routes()) .use(router.allowedMethods());//1.搭建一个node服务app.listen(9001); nodemon.json 12345678910111213141516&#123; &quot;restartable&quot;: &quot;rs&quot;, &quot;ignore&quot;: [ &quot;.git&quot;, &quot;dist&quot;, &quot;.cache&quot;, &quot;routerMap.json&quot;, &quot;readme.md&quot;, &quot;node_modules/**/node_modules&quot; ], &quot;verbose&quot;: true, &quot;watch&quot;: [ &quot;./&quot; ], &quot;ext&quot;: &quot;js json&quot;&#125; package.json 12345678910111213141516171819&#123; &quot;name&quot;: &quot;mockserver&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;nodemon -w ./ --exec&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;glob&quot;: &quot;^7.1.4&quot;, &quot;koa&quot;: &quot;^2.8.1&quot;, &quot;koa-logger&quot;: &quot;^3.2.1&quot;, &quot;koa-router&quot;: &quot;^7.4.0&quot;, &quot;nodemon&quot;: &quot;^1.19.2&quot; &#125;&#125;","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"组件库封装","slug":"D_框架_组件库封装","date":"2022-04-13T22:33:16.000Z","updated":"2024-06-02T01:27:48.709Z","comments":true,"path":"2022/04/14/D_框架_组件库封装/","link":"","permalink":"https://fuyunjinglong.github.io/2022/04/14/D_%E6%A1%86%E6%9E%B6_%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B0%81%E8%A3%85/","excerpt":"","text":"组件库开发的难点 数据通信：Vue 组件之间的数据通信可以使用 props、emit、provide/inject 等方式实现。但是，对于复杂的组件结构和组件之间的数据交互，数据通信可能会比较困难。 组件复杂度和扩展性：当组件的结构和逻辑变得复杂时，开发和维护组件就变得更加困难。需要通过合理的组件拆分、代码抽象和模块化等方式来降低组件的复杂度，提高可读性和可维护性。如拆分子组件，slot插槽扩展 生命周期和钩子函数：Vue 组件有很多生命周期函数和钩子函数，需要熟悉它们的执行顺序和作用，以便在组件开发过程中能够正确地处理组件的状态和行为。 性能优化：当组件的渲染次数过多、数据量过大时，会影响应用的性能。需要通过组件懒加载、异步渲染、缓存数据等方式来优化组件的性能，提高应用的响应速度。 组件-个人实践高质量组件 组件何时拆分 拆分出组件文件 用hooks抽离组件逻辑 组件何时拆分 拆分的组件要保持功能单一。即组件内部代码的代码都只跟这个功能相关； 组件要保持较低的耦合度，不要与组件外部产生过多的交互。如组件内部不要依赖过多的外部变量，父子组件的交互不要搞得太复杂等等。 用组件名准确描述这个组件的功能。就像函数那样，可以让人不用关心组件细节，就大概知道这个组件是干嘛的。如果起名比较困难，考虑下是不是这个组件的功能并不单一。 拆分出组件文件 本人更推荐统一放入到component文件夹下。 如果只是被页面内的组件复用，就放到页面文件夹下。 如果只是在当前业务场景下的不同页面复用，就放到当前业务模块的文件夹下。 如果可以在不同业务场景间通用，就放到最顶层的公共文件夹，或者考虑做成组件库。 12345678910homePage // 存放当前页面的文件夹 |-- components // 存放当前页面组件的文件夹 |-- componentA // 存放当前页面的组成部分A的文件夹 |-- index.(vue|tsx) // 组件A |-- AChild1.(vue|tsx) // 组件a的组成部分1 |-- AChild2.(vue|tsx) // 组件a的组成部分2 |-- ACommon.(vue|tsx) // 只在componentA内部复用的组件 |-- ComponentB.(vue|tsx) // 当前页面的组成部分B |-- Common.(vue|tsx) // 组件A和组件B里复用的组件 |-- index.(vue|tsx) // 当前页面 用hooks抽离组件逻辑 方式三：参考大崔哥的新写法(直接赋值引用)–强烈推荐 方式四：参考大崔哥的新写法(返回值引用) 前端组件设计原则 原文地址：Front end component design principles 文中示例代码：传送门 层次结构和 UML 类图 扁平化、面向数据的 state/props 更加纯粹的 State 变化 低耦合 辅助代码分离 提炼精华 及时模块化 集中/统一的状态管理 前言我在最近的工作中开始使用 Vue 进行开发，但是我在上一家公司积累了三年以上 React 开发经验。虽然在两种不同的前端框架之间进行切换确实需要学习很多，但是二者之间在很多基础概念、设计思路上是相通的。其中之一就是组件设计，包括组件层次结构设计以及组件各自的职责划分。 组件是大多数现代前端框架的基本概念之一，在 React 和 Vue 以及 Ember 和 Mithril 等框架中均有所体现。组件通常是由一串标记语言组成的集合，通常还包含一些逻辑和样式。它们被创建的目的就是作为可复用的模块去构建我们的应用程序。 类似于传统 OOP 语言中 class 的设计，在设计组件的时候需要考虑到很多方面，以便它们可以很好的复用，组合，分离和低耦合，但是功能可以比较稳定的实现，即使是在超出实际测试用例范围的情况下。这样的设计说起来容易做起来却很难，因为现实中我们往往没有足够的时间按照最优的方式去做。 方法在本文中，我想介绍一些组件相关的设计概念，在进行前端开发时应该考虑这些概念。我认为最好的方法是给每个概念一个简洁精炼的名字，然后逐一解释每个概念是什么以及为什么重要，对于比较抽象概念的会举一些例子来帮助理解。 以下这个列表并不是不全面也不完整，但我注意到的只有 8 件事情值得一提，对于那些已经可以编写基本组件但想要提高他们的技术设计技能的人来说。所以这是列表：以下列举的这个列表仅仅是是我注意到的 8 个方面，当然组件设计还有其他一些方面。在此我只是列举出来我认为值得一提的。 对于已经掌握基本的组件设计并且想要提高自身的组件设计能力的开发者，我认为以下 8 \b 项是我认为值得去注意的，当然这并不是组件设计的全部。 层次结构和 UML 类图 扁平化、面向数据的 state/props 更加纯粹的 State 变化 低耦合 辅助代码分离 提炼精华 及时模块化 集中/统一的状态管理 请注意，代码示例可能有一些小问题或有点人为设计。但是它们并不复杂，只是想通过这些例子来帮助更好的理解概念。 层次结构和类图应用内的组件共同形成树结构， 而在设计过程中将组件树可视化展示可以帮助你全面了解应用程序的布局。一个比较好的展示这些的办法就是组件图。 UML 中有一个在 OOP 类设计中经常使用的类型，称为 UML 类图。类图中显示了类属性、方法、访问修饰符、类与其他类的关系等。虽然 OOP 类设计和前端组件设计差异很大，但是通过图解辅助设计的方法值得参考。对于前端组件，该图表可以显示： State Props Methods 与其他组件的关系（ Relationship to other components ） 因此，让我们看一下下面这个基础表组件的组件层次图，该组件的渲染对象是一个数组。该组件的功能包括显示总行数、标题行和一些数据行，以及在单击其单元格标题格时对该列进行排序。在它的 props 中，它将传递列列表（具有属性名称和该属性的人类可读版本），然后传递数据数组。我们可以添加一个可选的’on row click’功能来进行测试。 虽然这样的事情可能看起来有点多，但是它具有许多优点，并且在大型应用程序开发设计中所需要的。这样会带来的一个比较重要的问题是它会需要你在开始 codeing 之前就需要考虑到具体细节的实现，例如每个组件需要什么类型的数据，需要实现哪些方法，所需的状态属性等等。 一旦你对如何构建一个组件（或一组组件）的整体有大概的思路，就会很容易认为当自己真正开始编码实现时，它会如自己所期望的按部就班的完成，但事实上往往会出现一些预料之外的事情， 当然你肯定不希望会因此去重构之前的某些部分，或者忍受初始设想中的缺点并因此扰乱你的代码思路。而这些类图的以下优点可以帮助你有效的规避以上问题，优点如下： 一个易于理解的组件组成和关联视图 一个易于理解的应用程序 UI 层次结构的概述 一个结构数据层次及其流动方式的视图 一个组件功能职责的快照 便于使用图表软件创建 顺带一提，上图并不是基于某些官方标准，比如 UML 类图，它是我基本上创建的一套表达规则。例如，在 props 、方法的参数和返回值的数据类型定义声明都是基于 Typescript 语法。我还没有找到书写前端组件类图的官方标准，可能是由于前端 Javascript 开发的相对较新且生态系统不够完善所致，但如果有人知道主流标准，请在回复中告诉我！ 扁平的，面向数据的 state/props在 state 和 props 频繁被 watch 和 update 的情况下，如果你有使用嵌套数据，那么你的性能可能会受到影响，尤其是在以下场景中，例如一些因为浅对于而触发的重新渲染；在涉及 immutability 的库中，比如 React，你必须创建状态的副本而不是像在 Vue 中那样直接更改它们，并且使用嵌套数据这样做可能会创建笨拙，丑陋的代码。 即使使用展开运算符，这种写法也并不够优雅。扁平 props 也可以很好地清除组件正在使用的数据值。如果你传给组件一个对象但是你并不能清楚的知道对象内部的属性值，所以找出实际需要的数据值是来自组件具体的属性值则是额外的工作。但如果 props 足够扁平化，那么起码会方便使用和维护。 state / props 还应该只包含组件渲染所需的数据。You shouldn’t store entire components in the state/props and render straight from there. （此外，对于数据繁重的应用程序，数据规范化可以带来巨大的好处，除了扁平化之外，你可能还需要考虑一些别的优化方法）。 更加纯粹的 State 变化对 state 的更改通常应该响应某种事件，例如用户单击按钮或 API 的响应。此外它们不应该因为别的 state 的变化而做出响应，因为 state 之间这种关联可能会导致难以理解和维护的组件行为。state 变化应该没有副作用。 如果你滥用watch而不是有限考虑以上原则，那么在 Vue 的使用中就可能由此引发的问题。我们来看一个基本的 Vue 示例。我正在研究一个从 API 获取一些数据并将其呈现给表的组件，其中排序，过滤等功能都是后端完成的，因此前端需要做的就是 watch 所有搜索参数，并在其变化时触发 API 调用。其中一个需要 watch 的值是“zone”，这是一个过滤器。当更改时，我们想要使用过滤后的值重新获取服务端数据。watcher 如下： 你会发现一些奇怪的东西。如果他们超出了结果的第一页，我们重置页码然后结束？这似乎不对,如果它们不在第一页上，我们应该重置分页并触发 API 调用，对吧？为什么我们只在第 1 页上重新获取数据？实际上原因是这样养，让我们来看下完整的 watch： 当分页改变时，应用首先会通过 pagination 的处理函数重新获取数据。因此，如果我们改变了分页，我们并不需要去关注数据更新这段逻辑。 让我们一下来考虑以下流程：如果当前页面超出了第 1 页并且更改了 zone，而这个变化会触发另一个状态（pagination）发生变化，进而触发 pagination 的观察者重新请求数据。这样并不是预料之中的行为，而且产生的代码也不够直观。 解决方案是改变页码这个行为的事件处理函数（不是观察者，用户更改页面的实际处理函数）应该更改页面值并触发 API 调用请求数据。这也将消除对观察者的需求。通过这样的设置，直接从其他地方改变分页状态也不会导致重新获取数据的副作用。 虽然这个例子非常简单，但不难看出将更复杂的状态更改关联在一起会产生令人难以理解的代码，这些代码不仅不可扩展并且是调试的噩梦。 松耦合组件的核心思想是它们是可复用的,为此要求它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的 props 的多少，以及内部使用的子组件（当然还有引用的部分，如第三方模块或用户脚本）。 紧密耦合的组件往往更不容易被复用，当它们作为特定父组件的子项时，就很难正常工作，当父组件的一个子组件或一系列子组件只能在该父组件才能够正常发挥作用时，就会使得代码写的很冗余。因为父子组件别过度的关联在一起了。 在设计组件时，你应该考虑到更加通用的使用场景，而不仅仅只是为了满足最开始某个特定场景的需求。虽然一般来说组件最初都是出于特定目的进行设计，但没关系，如果在设计它们站在更高的角度去看待，那么很多组件将具有更好的适用性。 让我们看一个简单的 React 示例，你想在写出一个带有一个 logo 的链接列表，通过连接可以访问特定的网站。最开始的设计可能是并没有跟内容合理的进行解耦。下面是最初的版本： 虽然这这样会满足预期的使用场景，但却很难被复用。如果你想要更改链接地址该怎么办？你必须重新复制一份相同代码，并且手动去替换链接地址。而且， 如果你要去实现一个用户可以更改连接的功能，那么意味着不可能将代码写“死”，也不能期望用户去手动修改代码，那么让我们来看一下复用性更高的组件应该如何设计： 在这里我们可以看到，虽然它的原始链接和 logo 具有默认值，但我们可以通过 props 传入的值去覆盖掉默认值。让我们来看一下它在实际中的使用： 并不需要重新编写新的组件！如果我们解决上文中用户可以自定义链接的使用场景，可以考虑动态构建链接数组。此外，虽然在这个具体的例子中没有解决，但我们仍然可以注意到这个组件没有与任何特定的父/子组件建立密切关联。它可以在任何需要的地方呈现。改进后的组件明显比最初版本具有更好的复用性。 如果不是要设计需要服务于特定的一次性场景的组件，那么设计组件的最终目标是让它与父组件松散耦合，呈现更好的复用性，而不是受限于特定的上下文环境。 辅助代码分离这个可能不那么的偏理论，但我仍然认为这很重要。与你的代码库打交道是软件工程的一部分，有时一些基本的组织原则可以使事情变得更加顺畅。在长时间与代码相处的过程中，即使改变一个很小的习惯也可以产生很大的不同。其中一个有效的原则就是将辅助代码分离出来放在特定的地方，这样你在处理组件时就不必考虑这些。以下列举一些方面： 配置代码 假数据 大量非技术说明文档 因为在尝试处理组件的核心代码时，你不希望看到与技术无关的一些说明（因为会多滚动几下鼠标滚轮甚至打断思路）。在处理组件时，你希望它们尽可能通用且可重用。查看与组件当前上下文相关的特定信息可能会使得设计出来的组件不易与具体业务解耦。 提炼精华虽然这样做起来可能具有挑战性，但开发组件的一个好方法是使它们包含渲染它们所需的最小 Javascript。一些无关紧要的东西，比如数据获取，数据整理或事件处理逻辑，理想情况下应该将通用的部分移入外部 js 或或者放在共同的祖先中。 单独从组件分的“视图”部分来看，即你看到的内容（html 和 样式）。其中的 Javascript 仅用于帮助渲染视图，可能还有一些针对特定组件的逻辑（例如在其他地方使用时）。除此之外的任何事情，例如 API 调用，数值的格式化（例如货币或时间）或跨组件复用的数据，都可以移动外部的 js 文件中。让我们看一下 Vue 中的一个简单示例，使用嵌套列表组件。我们可以先看下下面这个有问题的版本。 这是第一个层级： 这是嵌套列表组件： 在这里我们可以看到此列表的两个层级都具有外部依赖关系，最上层导引入外部 js 文件中的函数和 JSON 文件的数据，嵌套组件连接到 Vuex 存储并使用 axios 发送请求。它们还具有仅适用于当前场景的嵌入功能（最上层中源数据处理和嵌套列表的中度 click 时间的特定响应功能）。 虽然这里采用了一些很好的通用设计技术，例如将通用的 数据处理方法移动到外部脚本而不是直接将函数写死，但这样仍然不具备很高的复用性。如果我们是从 API 的响应中获取数据，但是这个数据跟我们期望的数据结构或者类型不同的时候要怎么办？或者我们期望单击嵌套项时有不同的行为？在遇到这些需求的场景下，这个组件无法被别的组件直接引用并根据实际需求改变自身的特性。 让我们看看我们是否可以通过提升数据并将事件处理作为 props 传递来解决这个问题，这样组件就可以简单地呈现数据而不会封装任何其他逻辑。 这是列表的新顶级： 而新的第二级： 使用这个新列表，我们可以获得想要的数据，并定义了嵌套列表的 onClick 处理函数，以便在父级中传入任何我们想要的操作，然后将它们作为 props 传递给顶级组件。这样，我们可以将导入和逻辑留给单个根组件，所以不需要为了能够在新的场景下使用去重新再实现一个类似组件。 有关此主题的简短文章可以在这里找到。它由 Redux 的作者 Dan Abramov 编写，虽然是用 React 举例说明。但是组件设计的思想是通用的。 及时模块化我们在实际进行组件抽离工作的时候，需要考虑到不要过度的组件化，诚然将大块代码变成松散耦合且可用的部分是很好的实践，但是并不是所有的页面结构（HTML 部分）都需要被抽离成组件，也不是所有的逻辑部分都需要被抽出到组件外部。 在决定是否将代码分开时，无论是 Javascript 逻辑还是抽离为新的组件，都需要考虑以下几点。同样，这个列表并不完整，只是为了让你了解需要考虑的各种事项。（记住，仅仅因为它不满足一个条件并不意味着它不会满足其他条件，所以在做出决定之前要考虑所有条件）： 是否有足够的页面结构/逻辑来保证它？如果它只是几行代码，那么最终可能会创建更多的代码来分隔它，而不仅仅是将代码放入其中。 代码重复（或可能重复）？如果某些东西只使用一次，并且服务于一个不太可能在其他地方使用的特定用例，那么将它嵌入其中可能会更好。如果需要，你可以随时将其分开（但不要在需要做这些工作的时候将此作为偷懒的借口）。 它会减少需要书写的模板吗？例如，假设你想要一个带有特定样式的 div 属性结构和一些静态内容/功能的组件，其中一些可变内容嵌套在内部。通过创建可重用的包装器（与 React 的 HOC 或 Vue 的 slot 一样），你可以在创建这些组件的多个实例时减少模板代码，因为你不需要重新再写外部的包装代码。 性能会收到影响吗？更改 state/props 会导致重新渲染，当发生这种情况时，你需要的是 只是重新去渲染经过 diff 之后得到的相关元素节点。在较大的、关联很紧密的组件中，你可能会发现状态更改会导致在不需要它的许多地方重新呈现，这时应用的性能就可能会开始受到影响。 你是否会在测试代码的所有部分时遇到问题？我们总是希望能够进行充分的测试，比如对于一个组件，我们会期望它的正常工作不依赖特定的用例（上下文），并且所有 Javascript 逻辑都按预期工作。当元素具有某个特定假设的上下文或者分别将一大堆逻辑嵌入到单个函数中时，这样将会很难满足我们的期望。如果测试的组件是具有比较大模板和样式的单个巨型组件，那么组件的渲染测试也会很难进行。 你是否有一个明确的理由？在分割代码时，你应该考虑它究竟实现了什么。这是否允许更松散的耦合？我是否打破了一个逻辑上有意义的独立实体？这个代码是否真的可能在其他地方被重复使用？如果你不能清楚地回答这个问题，那最好先不要进行组件抽离。因为这样可能导致一些问题（比如拆解掉原本某些潜在的耦合关系）。 这些好处是否超过了成本？分离代码不可避免地需要时间和精力，其数量根据具体情况而变化，并且在最终做出此决定时会有许多因素（例如此列表中列举出来的一些）。一般来说，进行一些对抽象的成本和收益研究可以帮助更快更准确去做出是否需要组件化的决策。最后，我提到了这一点，因为如果我们过分关注优势，就很容易忘记达成目标所需要做的努力，所以在做出决定以前需要权衡这两个方面。 集中/统一的状态管理许多大型应用程序使用 Redux 或 Vuex 等状态管理工具（或者具有类似 React 中的 Context API 状态共享设置）。这意味着他们从 store 获得 props 而不是通过父级传递。在考虑组件的可重用性时，你不仅要考虑直接的父级中传递而来的 props，还要考虑 从 store 中获取到的 props。如果你在另一个项目中使用该组件，则需要在 store 中使用这些值。或许其他项目根本不使用集中存储工具，你必须将其转换为从父级中进行 props 传递 的形式。 由于将组件挂接到 store（或上下文）很容易并且无论组件的层次结构位置如何都可以完成，因此很容易在 store 和 web 应用的组件之间快速创建大量紧密耦合（不关心组件所处的层级）。通常将组件与 store 进行关联只需简单几行代码。但是请注意一点，虽然这种连接（耦合）更方便，但它的含义并没有什么不同，你也需要考虑尽量符合如同在使用父级传递方式时的要点。 最后的想法最后，我想简要提醒以上这些组件设计的原则，或者你之前阅读过一些最佳实践在实际中的应用。虽然你应该尽力维护良好的设计，不要为了包装 JIRA ticket 或取消一个上拉请求而有损代码完整性，同时总是把理论置于现实世界结果之上的人也往往会让他们的工作受到影响。大型软件项目有许多活动部分，软件工程的许多方面与编码没有特别的关系，但仍然是不可或缺的，例如遵守最后期限和处理非技术期望。 虽然充分的准备很重要，应该成为任何专业软件设计的一部分，但在现实世界中，切实的结果才是最为重要的。当你被雇用来实际创造一些东西时，如果在最后期限到来之前，你有的只是一个如何构建完美产品的惊人计划，但却没有实际的成果，你的雇主可能不会太高兴吧？此外，软件工程中的东西很少完全按计划进行，因此过度具体的计划往往会在时间使用方面得到适得其反的效果。 此外，组件规划和设计的概念也适用于组件重构。虽然用了 50 年的时间来计划一切令人难以忍受的细节，然后从一开始就完美地编写它就会很好，回到现实世界，当你的关键时刻到来时你可能会发现自己设计组件并以不太理想的方式编写代码。然而，一旦压力得到缓解并且你有时间，那么返回并重构早期没有理想构建的代码总是一个好主意，这样它就可以作为向前发展的坚实基础。 在一天结束时，虽然你的直接责任可能是“编写代码”，但你不应忽视你的最终目标，即建立一些东西。创建产品。为了产生一些你可以引以为豪的东西并帮助别人，即使它在技术上并不完美，永远记得找到一个平衡点。不幸的是，在一周内每天 8 小时盯着眼前的代码会使得眼界和角度变得更为“狭窄”，这个时候你需要的你是退后一步，确保你不要为了一颗树而失去整个森林。 组件封装原则Vue的组件系统Vue组件的API主要包含三部分：prop、event、slot props 表示组件接收的参数，最好用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，此外还可以通过type、validator等方式对输入进行验证 slot可以给组件动态插入一些内容或组件，是实现高阶组件的重要途径；当需要多个插槽时，可以使用具名slot event是子组件向父组件传递消息的重要途径 单向数据流 单向数据流是Vue组件一个非常明显的特征，不应该在子组件中直接修改props的值 如果传递的prop仅仅用作展示，不涉及修改，则在模板中直接使用即可 如果需要对prop的值进行转化然后展示，则应该使用computed计算属性 如果prop的值用作初始化，应该定义一个子组件的data属性并将prop作为其初始值 基本原则1、单一原则：负责单一的页面渲染 2、多重职责：负责多重职责，获取数据，复用逻辑，页面渲染等 3、明确接受参数：必选，非必选，参数尽量设置以_开头，避免变量重复 4、可扩展：需求变动能够及时调整，不影响之前代码 5、代码逻辑清晰 6、封装的组件必须具有高性能，低耦合的特性 7、组件具有单一职责：封装业务组件或者基础组件，如果不能给这个组件起一个有意义的名字，证明这个组件承担的职责可能不够单一，需要继续抽组件，直到它可以是一个独立的组件即可。 维护性扩展性1：活用组件继承2：活用slot3：使用props灵活表现界面元素4：父子拆分 协作性1：使用computed对props进行二次封装2：css使用BEM命名3：事件以handle开头4：私有方法以_开头著名5：对外暴露类似html空间的原生属性来贴近原生行为6：常量使用const声明 组件封装的注意点制定规范规范的制定应该考虑css命名的统一，比如类库mint-ui样式前缀统一为mint-，iview的样式前缀统一为ivu-{componentname}。这样用户在解决样式覆盖等问题的时候，能够一目了然的知道是哪里出了问题。 另一个需要考虑的是组件对外暴露的方法名或者属性名的统一以及方法名传参顺序的一致性等，在方法和属性的命名上应该考虑兼容性，避免有歧义或者与原生属性冲突。比如有确定和取消按钮的组件，一些定义暴露的方法名为oncancel(instance,cb),onconfirm(instance,cb) 另外开发者在组件开发中不要炫技，不要过分设计，不要给用户预留彩蛋‘惊喜’，如果团队想给库增加feature，请给用户选择的权利，否则开源项目的信任度会大打折扣，参考antd企业级UI框架的圣诞节事件，HoHoHo~ 回顾：今早一到公司，就发现群里有人说 antd 组件的样式变了，所有的Button组件都被加上了雪花，接着就看到 GitHub 上的 issue，几乎所有前端相关的群都在讨论这件事。 高内聚、低耦合及集中的数据管理高内聚低耦合是判断设计好坏的标准，很多开发人员在组件封装过程中，设计的组件能够满足使用，但是组件的独立性不高，组件和组件之间的耦合性又不合理，当组件的使用场景变化时又得需要对组件进行改造。开发者在开发组件中应避免组件间相互依赖、共用状态等导致的逻辑理不清，糅合在一起形成一堆乱麻的情形。 举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!--公共蒙层--&gt;&lt;r-popup v-model=&quot;visible&quot; position=&quot;bottom&quot; zIndex=&quot;900&quot;&gt; &lt;div class=&quot;r-birth-age_wrapper&quot;&gt; &lt;!--出生日期选择，操作区(取消、确认、tab切换)在组件内部封装，弹出动效单独处理--&gt; &lt;birthPicker :attrs=&quot;birthAttrsData&quot; v-show=&quot;tabIndex == 0&quot; @tabClick=&quot;tabClick&quot; @onconfirm=&quot;birthConfirm&quot; @change=&quot;birthChange&quot; @cancel=&quot;cancel(&#x27;birth&#x27;)&quot; &gt;&lt;/birthPicker&gt; &lt;!--年龄选择，操作区(取消、确认、tab切换)在组件内部封装，弹出动效单独处理--&gt; &lt;agePicker :attrs=&quot;ageAttrsData&quot; v-show=&quot;tabIndex == 1&quot; @tabClick=&quot;tabClick&quot; @confirm=&quot;ageConfirm&quot; @cancel=&quot;cancel(&#x27;age&#x27;)&quot; @change=&quot;ageChange&quot; &gt;&lt;/agePicker&gt; &lt;/div&gt; &lt;/r-popup&gt; tabClick (index) &#123; this.initbirthData = &#123; value: this.birthAttrsData.value, text: this.birthAttrsData.text &#125; this.initAgeData = &#123; value: this.ageAttrsData.value, text: this.ageAttrsData.text &#125; if (index === 0) &#123; if (this.birthObj) &#123; this.birthAttrsData.value = this.birthObj.value this.birthAttrsData.text = this.birthObj.text &#125; &#125; else &#123; if (this.ageObj) &#123; this.ageAttrsData.value = this.ageObj.value this.ageAttrsData.text = this.ageObj.text &#125; &#125; setTimeout(() =&gt; &#123; this.tabIndex = index &#125;, 0) &#125;,cancel (type) &#123; //重置列表选择数据为组件初始化数据 if (this.tabIndex != this.initTabIndex) &#123; if (type == &#x27;birth&#x27; &amp;&amp; this.tabIndex == 0 &amp;&amp; this.initAgeData) &#123; this.tabIndex = 1 this.ageAttrsData.value = this.initAgeData.value this.ageAttrsData.text = this.initAgeData.text &#125; else if (type == &#x27;age&#x27; &amp;&amp; this.tabIndex == 1 &amp;&amp; this.initbirthData) &#123; this.tabIndex = 0 this.birthAttrsData.value = this.initbirthData.value this.birthAttrsData.text = this.initbirthData.text &#125; &#125; this.$emit(&#x27;cancel&#x27;) &#125;, birthChange (year, month, day) &#123; //根据选择的出生日期，计算用户年龄，修改年龄数据 ...... this.ageObj = &#123; value: `XXXX-01-01`, text: `Y周岁` &#125; &#125;, ageChange (obj) &#123; //根据选择的年龄计算，修改出生日期数据 this.birthObj = &#123; value: obj.value, text: obj.value &#125; &#125;, birthConfirm (obj, val, el) &#123; //浮层消失等操作后 ...... this.$emit(&#x27;confirm&#x27;, arguments[0].value, arguments[0].value) &#125;, ageConfirm () &#123; //浮层消失等操作后 ...... this.$emit(&#x27;confirm&#x27;, arguments[2].text, arguments[2].value) &#125; 从dom结构和事件逻辑上看，两个子类型组件内部完成了各自逻辑封装，每个组件有自己的操作区和选择区，组件的初始化数据和暴露的事件也基本保持了一致。但是细看，会发现很多问题： 1）数据管理不集中：组件的数据可以分为初始化数据（未操作过的初始化数据或用户上次点击确认时暴露出的数据）、出生日期和年龄tab切换或滚动选择时的临时数据（只要不点击确认按钮，这份数据就一直保存用户当前操作值）、暴露出的数据（点击确认按钮后的数据露出）。原设计中数据是分开管理的，数据的状态分散在多个事件、多个变量中，当tab点击后，birthObj、ageOb及birthAttrsData、ageAttrsData相互作用，相互影响，如果其中一个数据计算出错，那么出生日期和年龄都存在不一致的可能性。 2）事件管理的不集中：组件的操作区放在了每个子类型组件中，子类型组件再通过事件往父组件进行事件传递，父组件中对子类型触发的事件处理函数是独立处理单个变量的，如果需要排查问题，那么需要在组件事件中层层排查，耗时耗力。 3）dom结构过于松散：组件的蒙层及动效分别放到了每个子类型组件中，操作区结构也很分散，dom的深度及复杂度就增加了。 改进后的代码设计： dom结构： 蒙层和内容区合并、操作区整合、子类型组件事件统一、事件传参保持一致 改造后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;div v-if=&quot;visible&quot; class=&quot;r-birth-age-wrap&quot;&gt; &lt;div class=&quot;r-birth-age-cliper&quot; ref=&quot;cliper&quot; @touchmove.stop.prevent&gt;&lt;/div&gt; &lt;div class=&quot;r-birth-age-content&quot; ref=&quot;content&quot;&gt; &lt;div class=&quot;r-birth-age-head&quot;&gt; &lt;div class=&quot;r-birth-age-head-cancel&quot; @click=&quot;doCancel&quot;&gt;取消&lt;/div&gt; &lt;ul class=&quot;r-birth-age-head-button&quot;&gt; &lt;li :class=&quot;&#123; active: tabIndex == 0 &#125;&quot; @click=&quot;tabClick(0)&quot;&gt;出生日期&lt;/li&gt; &lt;li :class=&quot;&#123; active: tabIndex == 1 &#125;&quot; @click=&quot;tabClick(1)&quot;&gt;年龄&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;r-birth-age-head-confirm&quot; @click=&quot;doConfirm&quot;&gt;确认&lt;/div&gt; &lt;/div&gt; &lt;birthPicker v-if=&quot;tabIndex == 0&quot; :attrs=&quot;birthAttrs&quot; @input=&quot;doChange(...arguments, 0)&quot; &gt;&lt;/birthPicker&gt; &lt;agePicker class=&quot;r-birth-age-body&quot; ref=&quot;agepicker&quot; :slots=&quot;ageSlots&quot; v-if=&quot;tabIndex == 1&quot; @input=&quot;doChange(...arguments, 1)&quot; &gt;&lt;/agePicker&gt; &lt;/div&gt; &lt;/div&gt;tabClick(index) &#123; //点击出生日期，把年龄的值带过来；点击年龄时，把出生日期对应的值带过来 if (index == 0) &#123; this.setBirthDate(this.valueMaps.birthValue) &#125; else &#123; this.setAgeSlots(this.valueMaps.ageValue) &#125; this.$nextTick(() =&gt; &#123; this.tabIndex = index &#125;) &#125;, doChange(param, tabIdx) &#123; //生日 if (tabIdx == 0) &#123; //传参param为出生日期,如&#x27;2019-12-29&#x27;，进行年龄计算后，保存临时值 ...... this.valueMaps = &#123; ageText, ageValue, birthText, birthValue &#125; &#125; else &#123; //传参param为年龄值，如&#123;text: &#x27;7周岁&#x27;,value: &#x27;2013-01-01&#x27;&#125;，取value做出生日期，保存临时值 ...... this.valueMaps = &#123; ageText, ageValue, birthText， birthValue &#125; &#125; &#125;, doConfirm() &#123; this.addCloseAnimation() ...... this.visible = false this.$emit(&#x27;confirm&#x27;,Object.assign(this.valueMaps, &#123; tabIndex: this.tabIndex &#125;) ) &#125;, doCancel() &#123; this.addCloseAnimation() this.visible = false this.$emit(&#x27;cancel&#x27;) &#125; 辅助代码分离组件库的组件经过合理粒度划分后，每个组件都包含代码（结构+样式+逻辑控制）、文档、例子、单元测试等内容 单元测试不管是常用的karma+mocha+chai进行的vue单元测试还是Jest+enzyme配合的react单元测试，其单元测试均须覆盖初始化组件、初始化组件的属性、访问组件的数据、调用组件的方法、组件的事件触发、组件内元素的查找等过程。以Vue单元测试为例，其核心是通过@vue/test-utils提供的方法，将组件进行实例化，对渲染后的html输出进行上述验证，以下一段代码示例Vue组件单元测试的各个过程。 12345678910111213141516171819202122232425import &#123; mount &#125; from &#x27;@vue/test-utils&#x27;//组件：初始计数count为0，button点击后计数count+1的计数器import Counter from &#x27;./counter&#x27; describe(&#x27;Counter&#x27;, () =&gt; &#123; // 组件初始化，可以传属性值propsData const wrapper = mount(Counter) // 组件渲染结果检验 it(&#x27;has a button&#x27;, () =&gt; &#123; expect(wrapper.contains(&#x27;button&#x27;)).toBe(true) &#125;) //模拟用户交互 it(&#x27;button click should increment the count&#x27;, () =&gt; &#123; //访问组件的数据 expect(wrapper.vm.count).toBe(0) //组件内元素查找 const button = wrapper.find(&#x27;button&#x27;) //组件的事件触发 button.trigger(&#x27;click&#x27;) expect(wrapper.vm.count).toBe(1) &#125;)&#125;) 文档的产出在组件库的开发过程中，开发者经常面对两个问题： 1）实例化组件以便于调试 2）为组件生成文档便于使用者了解组件的使用，文档内容包括了组件的引入、组件使用场景demo及源码、组件的[props、events、slots、methods]说明等。 打包发布及版本升级组件库的发布过程比较简单，配置好package.json文件，执行npm publish即可。这里需要注意的是版本管理。 建议给发布脚本传版本参数，通过脚本修改package.json里version字段；如修改一些issues后进行的小的发版，次版本号或修正版本号需要改变，建议通过发布脚本先获取npm仓库中最新的版本号后，根据版本号递增规则，修改package.json里的version字段后发布。 理解 value 与 defaultValuedefaultValue 属性用于设置组件初始值，之后组件内部触发的值的改变，不会受到这个属性的影响，当父级组件触发 render 后，组件的值应当重新被赋予 defaultValue。 value 是受控属性，也用来设置值，但除了可以设置初始值（优先级比 defaultValue 高）之外，还应满足只要设置了 value，组件内部就无法修改状态的要求，这个组件的状态只能由父级授予并控制，所以叫受控属性。 value 与 defaultValue 不应该同时存在，最好做一下检查。 render 函数中最小化代码逻辑React 的宗旨是希望通过修改状态来修改渲染内容，尽量不要在 render 函数中编写过多的业务逻辑和判断语句，最好将能抽离成状态的放在 state 中，在 componentWillReceiveProps 中改变它 通用前端组件2.组件库通用设计方案分散维护 VS 集中维护问题:组件库的代码放在一起，还是分散在各个仓库？ Antd 、Material-UI、 React-UI 采用集中式管理等等。 集中管理 优点：方便组件统一管理，开发时不需要在多个仓库之间切换，而且预览效果只需运行跟项目，而不是为每个组件开启一个端口进行预览。 缺点： 引用默认是载入全部，虽然可以通过配置方式避免，（Antd 还提供了 webpack 插件做这个事情），但安装时必须全量。 无法对每个组件做更细粒度的版本控制。 协作开发困难，每个人都要搭建一套全环境，提 pr 也具有不少难度 分散管理 优点：对比集中管理的缺点。 缺点： 无法在同一个项目中观察全局，修改组件后引发的连带风险无法观察，组件之间引用需要发布或者 mock，不直观，甚至组件之间的版本关联、依赖分析都没法有效进行管理。 Fit 组件库在设计时，分散部署+集中维护。 建立根项目 Root，用来做整体容器，顺便还可以当对外网站 建立 Group，并在其中建立多个组件仓库 开发时只要用到项目 Root，根据依赖文件编写脚本自动拉取每个仓库中的内容 主要负责人拉取全部子项目仓库，子组件维护者只需要下载对应组件 发布时独立发布每个组件 管理时，统一管理所有组件 package 版本统一组件的依赖版本号需要统一，比如 fit-input ,fit-checkbox,fit-auto-complete 都依赖了 lodash，但因为先后开发时隔久远，安装时分别依赖了 2.x 3.x 4.x，当别人一起使用你最新版的时候，就会无辜的额外增加了两个 lodash 文件大小。 React 的版本都不可靠，之前就遇到过一半组件留在 0.14.x ，一半新组件装了 15.x 的情况，直接导致了线上编译后项目出错，因为多个 React 组件不能同时兼容。 因为项目开发时组件在一起，使统一版本号成为可能。我们将所有依赖到的组件都安装在 Root 项目中，每个组件的 package.json 由脚本自动生成，这个脚本需要静态扫描每个组件的 Import 或 require 语法，分析到依赖的模块后，使用根目录的版本号，填写在组件的 package.json 中，核心代码如下： 先收集每个组件中的依赖， 如果在根目录的 package.json 中找到了，就使用根目录的版本号。 完整代码仓库：https://github.com/fex-team/fit/blob/master/scripts/module-manage/utils/upgrade-dependencies.js 依赖联动依赖联动是指，fit-button 更新了代码，如果 fit-table 依赖了 fit-button，那么其也要发布一个版本，更新 fit-button 依赖的版本号。 除了依赖第三方模块，组件之间可能也有依赖，如果将模块分散维护，想更新一下依赖模块都需要发布+下载，非常消耗时间，而且依赖联动根本没法做。集中维护使用 webpack 的 alias 方案，在 typescript 找不到引用，总之不想找麻烦就不能写 hack 的代码。 回到 Fit 组件库结构，因为所有组件都被下载到了 Root 仓库下，因此组件之间的引用也自然而然的使用了相对路径，这样组件更新麻烦的问题迎刃而解，唯一需要注意的是，发布后，将所有引入非本组件目录的引用，替换成为 npm 名称，例如： 1234// 源码的内容import Button from &#x27;../../../button&#x27;// 发布时，通过编译脚本替换为import Button from &#x27;fit-button&#x27; 依赖联动，需要在发布时，扫描所有组件，找出所有有更新的组件，并生成一项依赖配置，最后将所有更新、或者被依赖的组件统一升级版本号加入发布队列。 依赖联动主要考虑到，主模块的连带升级，如果由于依赖模块小版本改动造成，那么依赖模块升级小版本其实为了 fix bug。如果业务模块升级了这个主模块，就要强制升级依赖模块到最新版解决那个 bug，如果以 ^ 打头就不强制了，不过这只是一种希望修复bug的方案，对灵活性有一定影响。 对与B的不兼容升级，对A来说发一个patch就可以，因为A对B兼容了，B不直接暴露给用户，就算用户安装了B模块，不需要升级版本，可以两个版本B模块共存。 3.组件库常用方式独立化组件+私有 npm 仓库 项目外部组件化,企业内部私有npm仓库+本地跨项目包引用 优 私有包托管在内部服务器或者单独的服务器上 对于下载，发布，有对应的权限管理 劣（npm link能适当缓减本地联调压力） 版本号过多，版本号传递过程中的繁琐 组件库与项目间调试困难 需要规范的组件化开发与npm包管理学习成本 monorepo 在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo 区分子项目依赖和公有依赖 体积大，重复依赖 ，考验团队 github/@dependencies将组件代码托管在git上，利用git搭建内部私有库。 同方案1，便易搭建但版本管理较差 参考： 4.组件库管理方案 npm公共管理方式 私有仓库管理：Npm 私库、Git Subtree Lerna进阶工具 npm私仓 优点： 和日常npm install操作相同，简单易用 一次架设成本，后续直接使用即可，人员更换及人员水平变动没有影响 组件修改发布后，所有项目都能使用，并且可以指定版本 缺点 日常开发不便，需要将组件更新发布任何项目更新组件版本后才能看到效果 Git Subtree 优点 跟git的多人协作同理，关联后一个项目更新所有项目都可以收到推送 无需更改现有工程目录 组件更新所见即所得，调试效果拉满 缺点 多人协作，多项目关联，随意性较高，可能改本项目无意间影响了所有项目，因此使用必须给所有成员做培训说明 需要一定git相关知识，并且命令较长相对复杂 Lerna进阶工具 作为组件库使用方，我希望能在在历史项目里按需去引入某一个或几个组件，然后，也希望在新项目能够以合包的形式引入（效率考量）。另外，我也希望在未来一些迭代研发的项目中，如果没有集中的研发投入而需要去独立维护部分的组件时，我可以仅升级其中一个组件，而不用升级合包导致所有东西都升级了 所以我们采用的分包的开发模式（Monorepo），分包的解决方案用的是 Lerna 这一个比较成熟的第三方解决方案。 按照这个思路，每一个组件都是一个子包，每个子包有自己的独立版本，然后根据一定的逻辑把部分子包合起来，合并成一个 Bundle（合包），比如说 main，合包也有自己的独立版本。 5.组件库维护经验最早、最彻底的把后端模块思维引入到前端，所以 React 组件生态迅速壮大。 分散部署 VS 集中维护到底把组件库的代码放在一起，还是分散在各个仓库？ 调查发现 Antd 是将所有组件都写入一个项目中，这样方便组件统一管理，开发时不需要在多个仓库之间切换，而且预览效果只需运行跟项目，而不是为每个组件开启一个端口进行预览。 但是集中管理有一些弊端。 引用默认是载入全部，虽然可以通过配置方式避免，（Antd 还提供了 webpack 插件做这个事情），但安装时必须全量。 无法对每个组件做更细粒度的版本控制。 协作开发困难，每个人都要搭建一套全环境，提 pr 也具有不少难度。 分散维护的弊端更明显，无法在同一个项目中观察全局，修改组件后引发的连带风险无法观察，组件之间引用需要发布或者 mock，不直观，甚至组件之间的版本关联、依赖分析都没法有效进行管理。 最后采用了两者结合的方案，分散部署+集中维护的折中方式： 建立根项目 Root，用来做整体容器，顺便还可以当对外网站 建立 Group，并在其中建立多个组件仓库 开发时只要用到项目 Root，根据依赖文件编写脚本自动拉取每个仓库中的内容 主要负责人拉取全部子项目仓库，子组件维护者只需要下载对应组件 发布时独立发布每个组件 管理时，统一管理所有组件 package 版本统一 React 的版本都不可靠，之前就遇到过一半组件留在 0.14.x ，一半新组件装了 15.x 的情况，直接导致了线上编译后项目出错，因为多个 React 组件不能同时兼容，这只是不能并存的其中一个例子。 因为项目开发时组件在一起，使统一版本号成为可能。我们将所有依赖到的组件都安装在 Root 项目中，每个组件的 package.json 由脚本自动生成，这个脚本需要静态扫描每个组件的 Import 或 require 语法，分析到依赖的模块后，使用根目录的版本号，填写在组件的 package.json 中。 先收集每个组件中的依赖， 如果在根目录的 package.json 中找到了，就使用根目录的版本号。 依赖联动依赖联动是指，fit-button 更新了代码，如果 fit-table 依赖了 fit-button，那么其也要发布一个版本，更新 fit-button 依赖的版本号。 因为所有组件都被下载到了 Root 仓库下，因此组件之间的引用也自然而然的使用了相对路径，这样组件更新麻烦的问题迎刃而解，唯一需要注意的是，发布后，将所有引入非本组件目录的引用，替换成为 npm 名称，例如： 1234// 源码的内容import Button from &#x27;../../../button&#x27;// 发布时，通过编译脚本替换为import Button from &#x27;fit-button&#x27; 依赖联动，需要在发布时，扫描所有组件，找出所有有更新的组件，并生成一项依赖配置，最后将所有更新、或者被依赖的组件统一升级版本号加入发布队列。 6.组件库开发的三大关键点整体架构设计 单包架构 多包架构 单包架构 如Antd，所有的组件看成一个整体，一起打包发布。这叫做单包架构 优点：它最大的优点是可以通过相对路径实现组件与组件的引用，公共代码之间的引用。 缺点：缺点就是组件完全耦合在了一起，必须把它作为一个整体统一发包。就算只改一个组件的一个非常小的功能，都要对整个包发布更新。 多包架构 每个组件彼此独立，单独打包发布，单个仓库多个包，统一维护单独管理。多包架构在业界称之为 “Monorepo”。 Lerna针对包之间有依赖的场景做了一些特殊优化，开发模式下，它会把所有存在依赖关系的包通过软链的形式连在一起，就可以很方便的本地开发联调 123456789101112├── lerna.json ├── package.json └── packages/ # 这里将存放所有子 repo 目录 ├── project_1/ # 组件1的包 │ ├── index.js │ ├── node_modules/ │ └── package.json ├── project_2/ # 组件2的包 │ ├── index.js │ ├── node_module/ │ └── package.json ... 优点：它最大的优势是组件发布灵活，并且天然支持按需使用， 缺点：缺点就是组件与组件之间物理隔离。对于相互依赖，公共代码抽象等场景，就只能通过NPM包引用的方式来实现。 基础技术能力构建能力 选择Webpack，Rollup Glup Grunt….. 构建组件库推荐Rollup， 构建项目推荐Webpack. 这里需要特别注意产物的格式要求，像我们常用的cjs, esm,umd格式。 你的组件考虑支持 node环境， 像需要支持ssr, 你就需要打包出 cjs格式 你的组件考虑支持 &lt;script &gt; 标签引用，, 你就需要打包出 umd格式 比如说： 组件库Bable的配置是否与项目中Babel的配置重复 依赖包是打包到产物中，还是使用项目中的依赖包。如:lodash, moment… 依赖包的样式是否打包到产物中以及Polyfill的配置 文档 你需要提供一个可以实时运行的文档服务。 包括支持静态内容的展示，以及可以查看源码的实施运行效果，这方面有很多优秀的开源库,比如 StoryBook&amp;Styleguidist，Docz 对外文档服务 可能是纯静态资源 配到的CI怎么搭建","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"NodeJS入门","slug":"D_框架_NodeJS入门","date":"2022-04-02T22:33:16.000Z","updated":"2024-09-10T23:27:12.246Z","comments":true,"path":"2022/04/03/D_框架_NodeJS入门/","link":"","permalink":"https://fuyunjinglong.github.io/2022/04/03/D_%E6%A1%86%E6%9E%B6_NodeJS%E5%85%A5%E9%97%A8/","excerpt":"","text":"大纲10套教程 Node基础-尚硅谷-video/千峰前端Node.JS基础 Node.js+Express+Koa2 开发Web Server博客-video-慕课网mk Vue Element＋Node.js开发企业通用管理后台系统-video-mk Node.js-Koa2框架生态实战－从零模拟新浪微博-video-mk Node.js+Koa2+MySQL 打造前后端分离精品项目《旧岛》-小程序服务端-video-mk 中级-Vue3 + TS仿知乎专栏企业级项目-mk 高级-Vue3.0+TS打造企业级组件库-mk Vue核心技术（Vue+Vue-Router+Vuex+SSR）实战精讲-mk 初始化项目1npm init -y package版本(^和~)区别123~1.15.2 := &gt;=1.15.2 &lt;1.16.0 ^3.3.4 := &gt;=3.3.4 &lt;4.0.0 Node入门NodeJS是什么Node.js 是一个开源与跨平台的 JavaScript 运行时环境在浏览器外运行 V8 JavaScript 引擎(Google Chrome 的内核)，利用事件驱动、非阻塞和异步输入输出模型等技术提高性能可以理解为 Node.js 就是一个服务器端的、非阻塞式I/O的、事件驱动的JavaScript运行环境 非阻塞异步 Nodejs采用了非阻塞型I/O机制，在做I/O操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率 事件驱动 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数 应用场景场景如下：善于I/O，不善于计算。因为Nodejs是一个单线程，如果计算(同步)太多，则会阻塞这个线程。大量并发的I/O，应用程序内部并不需要进行非常复杂的处理。与 websocket 配合，开发长连接的实时交互应用程序。 用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序 基于web、canvas等多人联网游戏 基于web的多人实时聊天客户端、聊天室、图文直播 单页面浏览器应用程序 操作数据库、为前端和移动端提供基于json的API windows环境安装下载nodejs官网下载https://nodejs.org/en/ 安装及配置最好安装到非系统盘，依赖后续会越来越大。 检查第一步安装是否成功 123node -vnpm -v都需要出现版本号 1.配置node全局引用和缓存 在node安装目录下创建node_global和node_cache文件夹 12npm config set prefix D:\\programFiles\\node\\node_globalnpm config set cache D:\\programFiles\\node\\node_cache 测试下配置是否生效 1npm install -g vue 成功后在node_global和node_cache中出现对应vue文件 2.配置全局模块环境变量 先检查是否正确配置： 12输入node进入交互界面，然后输入require(&#x27;vue&#x27;)查看是否出现vue相关的指令或生命周期，出现则环境变量正确，否则需要配置环境变量 我的电脑-高级属性-环境变量下： 先配置用户变量，将原有的AppData\\Roaming\\npm修改为D:\\programFiles\\node\\node_global 再配置系统变量，新建NODE_PATH,值为D:\\programFiles\\node\\node_global\\node_modules。接着在path中添加%NODE_PATH% 最后使用require(‘vue’)检查是否最终安装成功 cnpm install -g @vue/cli全局安装 vue -V查看vuecli版本 vue init是vuecli2的初始化方式 vue create 是vuecli3的初始化方式 安装常见镜像npm清空缓存 1npm cache clean --force npm淘宝镜像 123npm config set registry https://registry.npmmirror.com，切换国内镜像，使用淘宝镜像npm config get registry，查看当前镜像使用的地址，返回成功，则代表设置成功 cnpm淘宝镜像 123npm install -g cnpm --registry=https://registry.npmmirror.com，安装cnpmcnpm install xxx，使用cnpm安装所想要的包 cnpm安装依赖包的方式和npm是一样，只是npm的命令变成cnpm 以上两种模式的对比，cnpm在安装某些包的时候，package环境不是很正确，所以推荐使用npm安装淘宝镜像即可 卸载nodejs重装1.卸载程序卸载nodejs应用程序 2.删除以下文件夹下npm文件 C:\\Program Files (x86)\\NodejsC:\\Program Files\\NodejsC:\\Users{User}\\AppData\\Roaming\\npm（或%appdata%\\npm）C:\\Users{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） 3.检查您的%PATH%环境变量以确保没有引用Nodejs或npm存在。 4.重启 常见问题1.安装依赖报错npm EPERM mkdir 使用cmd，管理员权限打开对话窗口 2.出现unable to verify the first certificate npm config set strict-ssl false 3.Error: EPERM: operation not permitted, mkdir… 文件夹邮件，添加用户操作权限 yarn安装12npm install -g yarn --registry=https://registry.npm.taobao.orgyarn config get registry // 查看淘宝源是否正确 修改 yarn的全局安装位置和缓存位置 12yarn config set global-folder &quot;D:\\nvm\\nvm\\yarn\\global&quot;yarn config set cache-folder &quot;D:\\nvm\\nvm\\yarn\\cache&quot; 查看版本 1yarn -v yarn 常用命令 12345678910111213141516npm init === yarn initnpm install === yarn 或者 yarn installnpm install taco --save === yarn add taconpm uninstall taco --save === yarn remove taconpm install taco --save-dev === yarn add taco --devnpm update --save === yarn upgradenpm install taco@latest --save === yarn add taconpm install taco --global === yarn global add taconpm init --yes/-y === yarn init --yes/-ynpm link === yarn linknpm outdated === yarn outdatednpm publish === yarn publishnpm run === yarn runnpm cache clean === yarn cache cleannpm login === yarn loginnpm test === yarn test 123456789101112131415161718192021222324252627282930313233343536373839404142434445初始化项目:yarn init // 同npm init，执行输入信息后，会生成package.json文件yarn的配置项：yarn config list // 显示所有配置项yarn config get &lt;key&gt; //显示某配置项yarn config delete &lt;key&gt; //删除某配置项yarn config set &lt;key&gt; &lt;value&gt; [-g|--global] //设置配置项安装包：yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lockyarn install --flat //安装一个包的单一版本yarn install --force //强制重新下载所有包yarn install --production //只安装dependencies里的包yarn install --no-lockfile //不读取或生成yarn.lockyarn install --pure-lockfile //不生成yarn.lock添加包（会更新package.json和yarn.lock）：yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：yarn add --dev/-D // 加到 devDependenciesyarn add --peer/-P // 加到 peerDependenciesyarn add --optional/-O // 加到 optionalDependencies//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0发布包yarn publish移除一个包yarn remove &lt;packageName&gt;：移除一个包，会自动更新package.json和yarn.lock更新一个依赖yarn upgrade 用于更新包到基于规范范围的最新版本运行脚本yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本显示某个包的信息yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息 两者比较 并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。 更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。 pnpm安装全局安装 1npm install pnpm -g 设置淘宝源 1234//查看源pnpm config get registry //切换淘宝源pnpm config set registry http://registry.npm.taobao.org 查看 1pnpm -v linux环境安装1.安装nodejs环境123456789101112131415161.卸载npm和node npm uninstall npm -g yum remove nodejs npm -y 看看是否有残留 进入 /usr/local/lib 删除所有 node 和 node_modules文件夹 进入 /usr/local/include 删除所有 node 和 node_modules 文件夹 进入 /usr/local/bin 删除 node 的可执行文件,这里删除所有软连接rm- rf ./node 2.到nodejs官网下载并解压 wget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz tar -xvf node-v10.16.0-linux-x64.tar.xz 3.重命名文件夹，将软连接变为全局ln -snf /newen/programfiles/node-v10.16.0-linux-x64/bin/npm /usr/local/bin/ ln -snf /newen/programfiles/node-v10.16.0-linux-x64/bin/node /usr/local/bin/ 4.查看nodejs是否安装成功node -vv10.16.0","categories":[{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"}],"tags":[]},{"title":"项目经验","slug":"Z_业务和面经_项目经验","date":"2021-11-07T22:33:16.000Z","updated":"2024-03-06T23:08:28.736Z","comments":true,"path":"2021/11/08/Z_业务和面经_项目经验/","link":"","permalink":"https://fuyunjinglong.github.io/2021/11/08/Z_%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F_%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"项目经验搜索github上优秀的javascript 项目 项目可以是商城、SCRM 系统、OA 系统、物流系统、ERP 系统、CMS 系统、HIS 系统、支付系统、IM 聊天、微信公众号、微信小程序等等。 PSP产品选型基于运营商BG（carrier network business group）产品360平台，在地区部代表处运营商不同区域下，按照不同产品线无限数通光划分，对不同产品按照不同维度进行量化分析。其中包括射频bbu主控基带天线等购物车功能，以图表结合的形式分析其商务盈利、现网存量，对产品进行规格、特性、策略多维度数据对比展示。 职位描述1.负责组件库与业务页面开发。2.带领团队完成技术产品实现。3.负责大型多应用架构设计。4.利用前端技术与服务端协同完成团队业务目标。 职位要求0.掌握图形学，webgl或熟练使用threejs框架，熟练canvas相关渲染及动画操作的优先。1.熟练掌握JavaScript。2.熟悉常用工程化工具，掌握模块化思想和技术实现方案。3.熟练掌握React前端框架，了解技术底层。同时了解vue以及angular等其他框架者优先。4.熟练掌握react生态常用工具，redux/react-router等。5.熟悉各种Web前端技术，包括HTML/XML/CSS等，有基于Ajax的前端应用开发经验。6.有良好的编码习惯，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和各种背景的人合作。7.具有TS/移动设备上前端开发/NodeJS/服务端开发等经验者优先。 项目问题Echarts Echarts常见问题及解决方法 如何处理大量数据渲染 设置datazoom，类似分页效果 如何动态适配容器宽高 window.resize window.resizeObserver echart.resize() 文件超长如何处理 对formatter显示的文字长度做个截断展示，如a.slice(0,5)+’…’ 切换图表卡顿 原因：可能内存溢出了 解决：echarts.clear()和echarts.dispose() echarts.clear()是清空当前实例，会移除实例中所有的组件和图表。类似v-show echarts.dispose()是销毁实例，销毁后实例无法再被使用。类似v-if ElelemtUI如何实现table组件自定义功能 开启slot插槽功能 如何覆盖组件样式 使用样式穿透,deep popover组件二次封装 自定义虚拟手动触发 1v-model:visible=&quot;isPop&quot; 是否将内容插入到body 1:teleported=&quot;false&quot; 国际化配置 123456789import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;;import en from &#x27;element-plus/es/locale/lang/en&#x27;;&lt;el-config-provider :locale=&quot;locale&quot;&gt; // zhCn : en &lt;router-view v-if=&quot;comStore.leaf&quot; /&gt; &lt;div v-else class=&quot;noPermit&quot;&gt; &lt;span&gt;抱歉，您暂无访问权限！&lt;/span&gt; &lt;/div&gt;&lt;/el-config-provider&gt; 项目难点Vue2的CSP安全策略-202301总结：因为看了Vue3的源码，基于Vue.js 3.0 的编译过程，发现它在离线编译的时候也会把结果编译成带前缀的，核心代码借过来，然后再做一些修改来支持自己特定的一些 feature，这个难题就被我解决了。 背景：今年1月份，在我们的 Web 项目中开启了 CSP 安全策略，其中把 unsafe-eval 从 script-src 中拿掉了，但是这么操作导致了一个很严重的问题，由于运行在 Web 的项目有一部分组件是通过 Vue.js 开发的，这部分代码全部不能正常工作了。 问题：目前老项目是直接通过 CDN 的方式引入 Vue.js，并在后端的 Java 模板中写组件的 template，然后用在运行时编译模板。我们知道编译的过程最后是生成一段 code 字符串，然后通过 new Function 的方式转成 render 函数，但是 CSP 安全策略开启后，new Function 和 eval 都被禁用了，导致整个编译后的流程不能进行下去。 解决： 使用 runtime-only 版本的 Vue.js，涉及大量使用vue.js的页面，成本高，短期实现不了 开发一个CSP 兼容版本的 Vue.js，但是到了 Vue.js 2.x 后，官方就不再提供 CSP 兼容版本了，因为从官方的视角看，我都提供了 runtime-only 版本的解决方案了，完全没必要提供 CSP 兼容版本了。 现阶段最小成本解决问题的方式就是使用一个 CSP 兼容版本的 Vue.js，所以只能魔改 Vue.js 了。 一、new Function替换为notevil库 new Function 不能用了，那么生成的 code 字符串如何执行呢？经过调研，我选用了 notevil 这个库。 它其实就是用 JavaScript 去实现 JavsScript 的解析引擎，大致原理是先把源码解析成 AST 树，再去遍历 AST 树，对不同类型的节点做不同的处理，达到最终执行 JavaScript 代码的目的。 但 notevil 的实现还是不够完整，致命的是对 with 的语法不支持。还如一些 ES6 的语法，像箭头函数、数组对象的解构赋值，是不支持的 Vue.js 2.x 组件模板最终编译的代码，是使用 with 语法做了一层包装： 12345&lt;div&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;编译后：with(this)&#123;return _c(&#x27;div&#x27;,[_v(_s(message))])&#125; Vue.js 为了让用户使用方便，在模板中访问数据不用手动加 this。Vue自己将this定义在组件实例上。 如果不用 with(this) 的话，我们需要生成如下的代码： 123function(_ctx) &#123; return _ctx._c(&#x27;div,[_ctx._v(_ctx._s(_ctx.message))])&#125; 我们定义一个函数，接受一个 _ctx 参数，这个 _ctx 在运行时就是组件传入的实例对象 this。 这个时候，你可能会说，这有何难的，我们给所有的变量和函数的对象前面加上 _ctx 前缀不就可以了吗，但事情并没有你想的那么简单。尤其对于复杂的表达式。 二、该加this的添加this Vue.js 2.x 的编译会经过三个过程：template 解析生成 AST ——&gt; AST 优化 ——&gt; AST 生成 code。我的思路是不改变这三个过程，最后追加一个转换生成的 code的过程。 具体思路：先把转换前的代码解析生成 AST，再去遍历这颗 AST，根据语法在相关的位置上加上前缀（修改 AST 的 节点），最后再把修改后的 AST 转换成代码。 recast 库完成了code → AST 和 AST → code estree-walker 库去遍历 AST 的节点，通过一系列判断条件去判断这个节点需不需要加前缀 注意： 1.函数的参数不能加前缀，局部变量不能加前缀，全局内置变量不能加前缀，已经加过前缀的节点不能加前缀等。 2.函数嵌套函数，存在闭包情况。需要设计一个堆栈的数据结构，在函数进入入栈，函数退出出栈，如果是外层函数中定义的变量，内部函数是不能加前缀的。 3.recast、estree-walker 原本都是在 node.js 端跑的，为了让它们在前端运行，我也分别 clone 了它们的代码， 用 rollup 对它们做打包，并删除了内部一些 node only 的代码和一定程度的魔改，最终编译出一份在 web 端跑的代码，放到了 lib 目录。 为什么 Vue.js 编译生成的代码需要用 with 包一层？ 缺点： 在 ECMAScript 5 的严格模式中是被禁用的。优点：利用 with 的特性动去指定的对象中查找即可，完全不用做多余的转换，也不用引入这些 AST 解析库了，因为引入这些库(recast,estree-walker)要让 Vue.js 最终打包的体积大了约四倍。 题外话 我们平时经常会强调技术选型的能力，其实技术选型的一个标准，就是你选择的第三方依赖，你能不能 hold 住。首先是你知道它的职责边界，知道它能做什么不能做什么，怎么利用它帮助你开发需求；其次是出了错你能不能快速定位到原因，知道是依赖的问题还是自身使用的问题；最后就是当它不能满足你的需求，并且官方不愿意解决或者不维护的情况下，你能不能去 fork 这个库，自己开发解决并实现。那么显然拥有这些能力就需要你对它的源码实现非常了解，所以这也是一些高阶岗位为什么会在面试中考察你对技术原理掌握的一方面原因 盈利测算轮询接口内存泄漏-20220506盈利测算轮询接口，发现有些大数据量场景下，页面出现卡顿，使用chrome memory打印内存快照，发现发起测算后内存使用率比较高。 (1)内存泄露原因JS和DOM垃圾回收是两套机制，增加了回收难度。JS对象使用标记清除；DOM对象使用引用计数。其中DOM的引用计数在循环引用场景下，结合闭包容易造成内存泄露。(2)引发内存泄露(2.1)使用完毕对象后，没有主动销毁(2.2)循环引用DOM对象和Javascript对象循环引用function leakTest(){let x=nee Object();x.obj=document.createElement(‘div’);x.obj.jsobj=x;}(3)分析内存泄露工具chrome的memory内存快照工具 (4)避免内存泄露(4.1)创建dom或大数组后，也要对应删除dom，数组(4.2)事件监听页面组件销毁时，要解绑事件监听，能解决90%的内存泄露(4.3)禁止使用console.log打印大量数据，setInterval启动定时器后必要时销毁，尽量避免使用iframe。 nginx安全组策略配置错误引起的性能问题-20220108问题：用户反馈系统时不时出现响应慢的问题，查询产品列表接口，经常出现一次5秒的转圈，影响用户体验定位： (1)微服务接口分析，f12查看接口比对tomcat后台日志，时间基本吻合，排除微服务本身问题； (2)nginx路由分析，登录深圳region的两台nginx，打印耗时也只有255ms; (3)域名服务器，东莞部署的域名服务器，终于找到5s耗时，大胆推测是因为某种机制导致额外耗时，要么流控，要么失败重试。首先排查流控，流量访问量较低，远远没有达到流控的阈值-qps50。5s有可能是重试机制的请求间隔时间。 (4)顺着重试的机制可能性，对比正常日志，分析两者差异，发现有5s间隔时间，本来想找504网关超时，但没找到，后来发现，nginx根本没进去。最后发现另外一台nginx访问不通。后来发现其他域名能正常访问这台ip89结尾的nginx服务器，排除防火墙问题，对比nginx配置，也一样，联想到504日志也没有，请求进入nginx前就被拒了，最后怀疑是云服务的安全组策略问题。ip以89结尾的nginx服务器缺少routerservice-front-sg策略解决与反思： 添加安全组策略。 (1)因为更换了域名，该问题一直以性能问题暴露，没及时处理，主要是历史原因，性能一直不高，潜意识里已经默认接受，没有引起关注(2)从正常思维来考虑，性能问题大多数出现在微服务自身，有可能之前有人发现过，但又不了了之。 改进： (1)增加系统告警策略，当域名请求异常时，增加短信电话通知关系人(2)动员团队成员学习问题排除流程，加快问题定位。 前端渲染10w数据-20230604前置工作后端模拟服务 新建一个server.js文件，简单起个服务，并返回给前端10w条数据，并通过nodemon server.js开启服务 没有安装nodemon的同学可以先全局安装npm i nodemon -g 12345678910111213141516171819202122232425262728293031// server.jsconst http = require(&#x27;http&#x27;)const port = 8000;http.createServer(function (req, res) &#123; // 开启Cors res.writeHead(200, &#123; //设置允许跨域的域名，也可设置*允许所有域名 &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, //跨域允许的请求方法，也可设置*允许所有方法 &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE,PUT,POST,GET,OPTIONS&quot;, //允许的header类型 &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27; &#125;) let list = [] let num = 0 // 生成10万条数据的list for (let i = 0; i &lt; 100000; i++) &#123; num++ list.push(&#123; src: &#x27;https://p3-passport.byteacctimg.com/img/user-avatar/d71c38d1682c543b33f8d716b3b734ca~300x300.image&#x27;, text: `我是$&#123;num&#125;号嘉宾林三心`, tid: num &#125;) &#125; res.end(JSON.stringify(list));&#125;).listen(port, function () &#123; console.log(&#x27;server is listening on port &#x27; + port);&#125;) 前端页面 1234567891011121314151617181920212223242526// index.html&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; #container &#123; height: 100vh; overflow: auto; &#125; .sunshine &#123; display: flex; padding: 10px; &#125; img &#123; width: 150px; height: 150px; &#125; &lt;/style&gt;// html部分&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122// index.js// 请求函数const getList = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; //步骤一:创建异步对象 var ajax = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数 ajax.open(&#x27;get&#x27;, &#x27;http://127.0.0.1:8000&#x27;); //步骤三:发送请求 ajax.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 resolve(JSON.parse(ajax.responseText)) &#125; &#125; &#125;)&#125;// 获取container对象const container = document.getElementById(&#x27;container&#x27;) 方案1:直接渲染一次性渲染出10w个节点,耗时12s。 123456789101112const renderList = async () =&gt; &#123; console.time(&#x27;列表时间&#x27;) const list = await getList() list.forEach(item =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) div.className = &#x27;sunshine&#x27; div.innerHTML = `&lt;img src=&quot;$&#123;item.src&#125;&quot; /&gt;&lt;span&gt;$&#123;item.text&#125;&lt;/span&gt;` container.appendChild(div) &#125;) console.timeEnd(&#x27;列表时间&#x27;)&#125;renderList() 方案2:setTimeout分页渲染把10w按照每页数量limit分成总共Math.ceil(total / limit)页，然后利用setTimeout，每次渲染1页数据，这样的话，渲染出首页数据的时间大大缩减了。 12345678910111213141516171819202122232425const renderList = async () =&gt; &#123; console.time(&#x27;列表时间&#x27;) const list = await getList() console.log(list) const total = list.length const page = 0 const limit = 200 const totalPage = Math.ceil(total / limit) const render = (page) =&gt; &#123; if (page &gt;= totalPage) return setTimeout(() =&gt; &#123; for (let i = page * limit; i &lt; page * limit + limit; i++) &#123; const item = list[i] const div = document.createElement(&#x27;div&#x27;) div.className = &#x27;sunshine&#x27; div.innerHTML = `&lt;img src=&quot;$&#123;item.src&#125;&quot; /&gt;&lt;span&gt;$&#123;item.text&#125;&lt;/span&gt;` container.appendChild(div) &#125; render(page + 1) &#125;, 0) &#125; render(page) console.timeEnd(&#x27;列表时间&#x27;)&#125; 方案3:requestAnimationFrame使用requestAnimationFrame代替setTimeout，减少了重排的次数，极大提高了性能，建议大家在渲染方面多使用requestAnimationFrame。 1234567891011121314151617181920212223242526const renderList = async () =&gt; &#123; console.time(&#x27;列表时间&#x27;) const list = await getList() console.log(list) const total = list.length const page = 0 const limit = 200 const totalPage = Math.ceil(total / limit) const render = (page) =&gt; &#123; if (page &gt;= totalPage) return // 使用requestAnimationFrame代替setTimeout requestAnimationFrame(() =&gt; &#123; for (let i = page * limit; i &lt; page * limit + limit; i++) &#123; const item = list[i] const div = document.createElement(&#x27;div&#x27;) div.className = &#x27;sunshine&#x27; div.innerHTML = `&lt;img src=&quot;$&#123;item.src&#125;&quot; /&gt;&lt;span&gt;$&#123;item.text&#125;&lt;/span&gt;` container.appendChild(div) &#125; render(page + 1) &#125;) &#125; render(page) console.timeEnd(&#x27;列表时间&#x27;)&#125; 方案4:fragment文档碎片 + requestAnimationFrame优点 1、之前都是每次创建一个div标签就appendChild一次，但是有了文档碎片可以先把1页的div标签先放进文档碎片中，然后一次性appendChild到container中，这样减少了appendChild的次数，极大提高了性能 2、页面只会渲染文档碎片包裹着的元素，而不会渲染文档碎片 123456789101112131415161718192021222324252627282930const renderList = async () =&gt; &#123; console.time(&#x27;列表时间&#x27;) const list = await getList() console.log(list) const total = list.length const page = 0 const limit = 200 const totalPage = Math.ceil(total / limit) const render = (page) =&gt; &#123; if (page &gt;= totalPage) return requestAnimationFrame(() =&gt; &#123; // 创建一个文档碎片 const fragment = document.createDocumentFragment() for (let i = page * limit; i &lt; page * limit + limit; i++) &#123; const item = list[i] const div = document.createElement(&#x27;div&#x27;) div.className = &#x27;sunshine&#x27; div.innerHTML = `&lt;img src=&quot;$&#123;item.src&#125;&quot; /&gt;&lt;span&gt;$&#123;item.text&#125;&lt;/span&gt;` // 先塞进文档碎片 fragment.appendChild(div) &#125; // 一次性appendChild container.appendChild(fragment) render(page + 1) &#125;) &#125; render(page) console.timeEnd(&#x27;列表时间&#x27;)&#125; 方案5:懒加载原理 在列表尾部放一个空节点blank，然后先渲染第1页数据，向上滚动，等到blank出现在视图中，就说明到底了，这时候再加载第二页，往后以此类推。 至于怎么判断blank出现在视图上，可以使用getBoundingClientRect方法获取top属性。 其中IntersectionObserver 性能更好，但是我这里就拿getBoundingClientRect来举例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script setup lang=&quot;ts&quot;&gt;import &#123; onMounted, ref, computed &#125; from &#x27;vue&#x27;const getList = () =&gt; &#123; // 跟上面一样的代码&#125;const container = ref&lt;HTMLElement&gt;() // container节点const blank = ref&lt;HTMLElement&gt;() // blank节点const list = ref&lt;any&gt;([]) // 列表const page = ref(1) // 当前页数const limit = 200 // 一页展示// 最大页数const maxPage = computed(() =&gt; Math.ceil(list.value.length / limit))// 真实展示的列表const showList = computed(() =&gt; list.value.slice(0, page.value * limit))const handleScroll = () =&gt; &#123; // 当前页数与最大页数的比较 if (page.value &gt; maxPage.value) return const clientHeight = container.value?.clientHeight const blankTop = blank.value?.getBoundingClientRect().top if (clientHeight === blankTop) &#123; // blank出现在视图，则当前页数加1 page.value++ &#125;&#125;onMounted(async () =&gt; &#123; const res = await getList() list.value = res&#125;)&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;container&quot; @scroll=&quot;handleScroll&quot; ref=&quot;container&quot;&gt; &lt;div class=&quot;sunshine&quot; v-for=&quot;(item) in showList&quot; :key=&quot;item.tid&quot;&gt; &lt;img :src=&quot;item.src&quot; /&gt; &lt;span&gt;&#123;&#123; item.text &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div ref=&quot;blank&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 方案6:虚拟列表参考 「前端进阶」高性能渲染十万条数据(虚拟列表) 原理 虚拟滚动，就是根据容器可视区域的列表容积数量，监听用户滑动或滚动事件，动态截取长列表数据中的部分数据渲染到页面上，动态使用空白站位填充容器上下滚动区域内容，模拟实现原生滚动效果。总结一句话：使用绝对定位和滚动监听实现。 浏览器渲染===康熙选秀：一次性渲染10000个肯定会使浏览器压力大，造成用户体验差 容器可视区域===选秀大殿：10000个排队去渲染，比如一次渲染10个 上方下方区域===左右偏殿：轮不到你渲染，你就乖乖进空白区待着 基本实现过程 步骤1:计算列表总高度listHeight和可视区域高度screenHeight 步骤2:根据可视区域高度计算可显示的列表项数visibleCount 步骤3:在滚动时，重新计算起始索引start和结束索引end，核心滚动偏移量startOffset。 固定高度代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;VirtualList :listData=&quot;d&quot; :itemSize=&quot;100&quot; /&gt;let d = ref([]);for (let i = 0; i &lt; 1000; i++) &#123; d.value.push(&#123; id: i, value: i &#125;);&#125; // VirtualList.vue &lt;template&gt; &lt;div ref=&quot;list&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;div class=&quot;infinite-list-phantom&quot; :style=&quot;&#123; height: listHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;infinite-list&quot; :style=&quot;&#123; transform: getTransform &#125;&quot;&gt; &lt;div ref=&quot;items&quot; class=&quot;infinite-list-item&quot; v-for=&quot;item in visibleData&quot; :key=&quot;item.id&quot; :style=&quot;&#123; height: itemSize + &#x27;px&#x27;, lineHeight: itemSize + &#x27;px&#x27; &#125;&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;VirtualList&#x27;, props: &#123; //所有列表数据 listData: &#123; type: Array, default: () =&gt; [], &#125;, //每项高度 itemSize: &#123; type: Number, default: 200, &#125;, &#125;, data() &#123; return &#123; //可视区域高度 screenHeight: 0, //核心滚动偏移量 startOffset: 0, //起始索引 start: 0, //结束索引 end: null, &#125;; &#125;, computed: &#123; //列表总高度 listHeight() &#123; return this.listData.length * this.itemSize; &#125;, //可显示的列表项数 visibleCount() &#123; return Math.ceil(this.screenHeight / this.itemSize); &#125;, //偏移量对应的style getTransform() &#123; return `translate3d(0,$&#123;this.startOffset&#125;px,0)`; &#125;, //获取真实显示列表数据 visibleData() &#123; return this.listData.slice(this.start, Math.min(this.end, this.listData.length)); &#125;, &#125;, mounted() &#123; this.screenHeight = this.$el.clientHeight; this.start = 0; this.end = this.start + this.visibleCount; &#125;, methods: &#123; scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引 this.start = Math.floor(scrollTop / this.itemSize); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.startOffset = scrollTop - (scrollTop % this.itemSize); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.infinite-list-container &#123; height: 100%; overflow: auto; position: relative; -webkit-overflow-scrolling: touch;&#125;.infinite-list-phantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.infinite-list &#123; left: 0; right: 0; top: 0; position: absolute; text-align: center;&#125;.infinite-list-item &#123; padding: 10px; color: #555; box-sizing: border-box; border-bottom: 1px solid #999;&#125;&lt;/style&gt; html元素 infinite-list-container 为可视区域的容器 infinite-list-phantom 为容器内的占位，高度为总列表高度，用于形成滚动条 infinite-list 为列表项的渲染区域 参数 假定可视区域高度固定，称之为screenHeight 假定列表每项高度固定，称之为itemSize 假定列表数据称之为listData 假定当前滚动位置称之为scrollTop 则可推算出： 列表总高度listHeight = listData.length * itemSize 可显示的列表项数visibleCount = Math.ceil(screenHeight / itemSize) 数据的起始索引startIndex = Math.floor(scrollTop / itemSize) 数据的结束索引endIndex = startIndex + visibleCount 列表显示数据为visibleData = listData.slice(startIndex,endIndex) 重要参数 当滚动后，由于渲染区域相对于可视区域已经发生了偏移，此时我需要获取一个偏移量startOffset，通过样式控制将渲染区域偏移至可视区域中。 滚动偏移量startOffset = scrollTop - (scrollTop % itemSize); 为什么不写成this.startOffset = scrollTop？ 通俗理解：如果写成这个，数据都是固定跳变，没有滚动的动画变化效果。 具体解释： 比如说，列表第0项，高度100px，你现在滚动条滚动了50px，期望的效果必然是第0项，一半在屏幕外，一半在屏幕内，此时是没有偏移量的，完全由滚动条来控制页面显示内容。此时又发生了滚动，滚动到了100px，此时我们期望的的：可视区域已经没有第0项了，变成第1项。由于我们是虚拟列表，所以第0项的dom发生了修改变成了第1项的dom，第一项的dom变成了第2项dom，如果没有偏移量，可视区域的第一条内容就变成了第2项，所以我们需要修改偏移量，让列表像下偏移100px，将第1项的dom显示出来。 没有达到换一个item的时候就设置没有偏移量 这个scrollTop - (scrollTop % this.itemSize)就是没达到一个itemSize的时候就是多余的减掉多余的变成o这个内容会被浏览器带着走 就会看到动画 如果你有设置等于scrollTop的话 你浏览器滚动了 那你偏移量和scrollTop一样的话 相当于没有动画 和浏览器同步走了 然后到了换数据item1变成item2的时候就会突然给你换掉 就没有动画了 这样写就让浏览器带着走有动画 列表项动态高度代码 对于不是固定高度的列表，上述方案就不能解决这个问题。 目前虚拟列表动态高度的解决方案有3种： 方案1:包含所有列表项高度的数据，如 [50, 20, 100, 80, …] 方案2:将列表项渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。 方案3:以预估高度先行渲染，然后获取真实高度并缓存。 方案1虽然灵活，但需要事先知道高度，无法解决列表项高度由内容撑开的情况 方案2:由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。 方案3:可以解决前面2种方案的缺陷 实现过程 定义组件属性estimatedItemSize,用于接收预估高度 定义positions，用于列表项渲染后存储每一项的高度以及位置信息 列表高度实际就等于列表中最后一项的底部距离列表顶部的位置。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;VirtualList :listData=&quot;data&quot; :estimatedItemSize=&quot;100&quot; /&gt; import faker from &quot;faker&quot;;let data = [];for (let id = 0; id &lt; 1000; id++) &#123; data.push(&#123; id, value: faker.lorem.sentences() // 长文本 &#125;);&#125; // VirtualList.vue&lt;template&gt; &lt;div ref=&quot;list&quot; :style=&quot;&#123; height &#125;&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt; &lt;div ref=&quot;phantom&quot; class=&quot;infinite-list-phantom&quot;&gt;&lt;/div&gt; &lt;div ref=&quot;content&quot; class=&quot;infinite-list&quot;&gt; &lt;div class=&quot;infinite-list-item&quot; ref=&quot;items&quot; :id=&quot;item._index&quot; :key=&quot;item._index&quot; v-for=&quot;item in visibleData&quot;&gt; &lt;p&gt; &lt;span style=&quot;color: red&quot;&gt;&#123;&#123; item.id &#125;&#125;&lt;/span&gt; &#123;&#123; item.value &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; //所有列表数据 listData: &#123; type: Array, default: () =&gt; [], &#125;, //预估高度 estimatedItemSize: &#123; type: Number, required: true, &#125;, //容器高度 100px or 50vh height: &#123; type: String, default: &#x27;100%&#x27;, &#125;, &#125;, data() &#123; return &#123; //可视区域高度 screenHeight: 0, //起始索引 start: 0, //结束索引 end: 0, &#125;; &#125;, computed: &#123; _listData() &#123; return this.listData.map((item, index) =&gt; &#123; return &#123; _index: `_$&#123;index&#125;`, item, &#125;; &#125;); &#125;, visibleCount() &#123; return Math.ceil(this.screenHeight / this.estimatedItemSize); &#125;, visibleData() &#123; return this._listData.slice(this.start, this.end); &#125;, &#125;, created() &#123; this.initPositions(); &#125;, mounted() &#123; this.screenHeight = this.$el.clientHeight; this.start = 0; this.end = this.start + this.visibleCount; &#125;, updated() &#123; this.$nextTick(function () &#123; if (!this.$refs.items || !this.$refs.items.length) &#123; return; &#125; //获取真实元素大小，修改对应的尺寸缓存 this.updateItemsSize(); //更新列表总高度 let height = this.positions[this.positions.length - 1].bottom; this.$refs.phantom.style.height = height + &#x27;px&#x27;; //更新真实偏移量 this.setStartOffset(); &#125;); &#125;, methods: &#123; initPositions() &#123; this.positions = this.listData.map((d, index) =&gt; (&#123; index, height: this.estimatedItemSize, top: index * this.estimatedItemSize, bottom: (index + 1) * this.estimatedItemSize, &#125;)); &#125;, //获取列表起始索引 getStartIndex(scrollTop = 0) &#123; //二分法查找 return this.binarySearch(this.positions, scrollTop); &#125;, //二分法查找 binarySearch(list, value) &#123; let start = 0; let end = list.length - 1; let tempIndex = null; while (start &lt;= end) &#123; let midIndex = parseInt((start + end) / 2); let midValue = list[midIndex].bottom; if (midValue === value) &#123; return midIndex + 1; &#125; else if (midValue &lt; value) &#123; start = midIndex + 1; &#125; else if (midValue &gt; value) &#123; if (tempIndex === null || tempIndex &gt; midIndex) &#123; tempIndex = midIndex; &#125; end = end - 1; &#125; &#125; return tempIndex; &#125;, //获取列表项的当前尺寸 updateItemsSize() &#123; let nodes = this.$refs.items; nodes.forEach((node) =&gt; &#123; let rect = node.getBoundingClientRect(); let height = rect.height; let index = +node.id.slice(1); let oldHeight = this.positions[index].height; let dValue = oldHeight - height; //存在差值 if (dValue) &#123; this.positions[index].bottom = this.positions[index].bottom - dValue; this.positions[index].height = height; for (let k = index + 1; k &lt; this.positions.length; k++) &#123; this.positions[k].top = this.positions[k - 1].bottom; this.positions[k].bottom = this.positions[k].bottom - dValue; &#125; &#125; &#125;); &#125;, //获取当前的偏移量 setStartOffset() &#123; let startOffset = this.start &gt;= 1 ? this.positions[this.start - 1].bottom : 0; this.$refs.content.style.transform = `translate3d(0,$&#123;startOffset&#125;px,0)`; &#125;, //滚动事件 scrollEvent() &#123; //当前滚动位置 let scrollTop = this.$refs.list.scrollTop; //此时的开始索引 this.start = this.getStartIndex(scrollTop); //此时的结束索引 this.end = this.start + this.visibleCount; //此时的偏移量 this.setStartOffset(); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.infinite-list-container &#123; overflow: auto; position: relative; -webkit-overflow-scrolling: touch;&#125;.infinite-list-phantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.infinite-list &#123; left: 0; right: 0; top: 0; position: absolute;&#125;.infinite-list-item &#123; padding: 5px; color: #555; box-sizing: border-box; border-bottom: 1px solid #999; /* height:200px; */&#125;&lt;/style&gt; 不足与改进 监听scroll事件，会频繁触发，重复计算，性能上浪费，可使用IntersectionObserver替换监听scroll事件 动态高度下的虚拟列表，如果是图片，可能由于网络请求加载时机导致高度不准确，如果我们能监听列表项的大小变化就能获取其真正的高度了。我们可以使用ResizeObserver来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。 方案7:第三方库 vue-virtual-scroller: 这是一个基于 Vue 3 的虚拟滚动列表组件，可以用于大型数据集的渲染。它支持水平和垂直方向的滚动，并且具有无限滚动、缓存、动态高度等功能。 vue3-virtual-scroll-list: 这是一个支持垂直方向的无限滚动列表组件，可以用于渲染大量数据。它支持异步加载、滚动到指定位置、动态高度等功能。 vue3-infinite-scroll: 这是一个支持无限滚动的 Vue 3 组件，可以用于渲染大量数据。它支持异步加载、滚动到指定位置、动态高度等功能。 vue-lazy-render: 这是一个基于 Vue 3 的懒加载组件，可以用于渲染大量数据。它支持滚动监听、动态高度、动画效果等功能。 接单项目1.接单网站 猿急送：按需雇佣互联网坐班兼职工程师 外包大师：快速发布外包项目，以高质量为驱动 开源众包：为客户提供解决方案 英选：可信赖的软件外包服务 人人开发：让管理软件更简单 我爱方案网： 智筹：牛人为我所用 开发邦：服务众多客户 码市：互联网软件外包服务平台 自由职客： 解放号：数字化平台 程序员客栈：云端开发团队 任务栈： 猪八戒： 一品威客： SXSOFT:众包模式 智诚Taskcity:零交易佣金 码易： yespmp: 云沃克： 实现网： 电鸭社区：","categories":[{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"博客_Hexo","slug":"H_工程热点_博客_Hexo","date":"2021-11-05T22:33:16.000Z","updated":"2024-04-21T02:28:57.789Z","comments":true,"path":"2021/11/06/H_工程热点_博客_Hexo/","link":"","permalink":"https://fuyunjinglong.github.io/2021/11/06/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E5%8D%9A%E5%AE%A2_Hexo/","excerpt":"","text":"认识HexoHexo 使用 Node.js 编写。得益于 Node.js，使得 Hexo 生成上百个页面游刃有余。 只需要一条指令就可以部署到 GitHub Pages、Heroku、Coding Pages 等其他网站。 准备工作安装Node.js见本博客相关文档 安装Gityum install -y git 安装Nginx 在线下载解压 12wget http://nginx.org/download/nginx-1.5.9.tar.gztar -zxvf nginx-1.5.9.tar.gz 安装 123./configuremakemake install 配置 12345678910111213141516/usr/local/nginx/conf目录下的nginx.conf文件upstream myserver&#123; #定义upstream名字，下面会引用 server 120.79.33.76:5000 weight=3; #指定后端服务器地址 server 123.206.218.36:5000 weight=2; &#125;server &#123; listen 80; server_name anandasuper.top; location / &#123; root html; index index.html index.htm; proxy_pass http://myserver; &#125;&#125; 启动 123./sbin/nginx 初次启动./sbin/nginx -s reload 重启./sbin/nginx -s stop 停止 安装Hexo 1.全局安装依赖 1npm install hexo-cli -g 配置hexo软连接到全局 1ln -snf /newen/programfiles/node-v10.16.0-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo 初始化工程目录 123mkdir hexo2022cd hexo2022hexo init 配置Hexo下载主题 1.将主题git到themes目录下 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 2.修改博客根目录的config配置，theme更改为pure 3.如果使用后台启动，建议使用js脚本;如果调试的话，hexo s即可。在博客根目录下面创建一个hexo_run.js 12345678910//runconst &#123; exec &#125; = require(&#x27;child_process&#x27;)exec(&#x27;hexo server -p 5001&#x27;,(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(&#x27;exec error: $&#123;error&#125;&#x27;) return &#125; console.log(&#x27;stdout: $&#123;stdout&#125;&#x27;); console.log(&#x27;stderr: $&#123;stderr&#125;&#x27;);&#125;) 4.安装依赖 1npm i PM2进程管理 PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。我们都知道nodejs是单进程执行的，当程序出现错误死掉之后需要能够自动，这时候就需要PM2了。 安装pm2 1npm install -g pm2 配置软连接到全局 1ln -snf /newen/programfiles/node-v10.16.0-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/local/bin/ 启动进程 1pm2 start hexo_run.js 常用命令 查看所有任务 1pm2 list 停止所有任务 1pm2 stop all或pm2 delete all 停止某个任务 1pm2 stop 1 部署Github Page创建远程仓库连接详情见Github入门的ssh秘钥 引入deployer插件要将hexo生成的文章部署到GitHub上，首先要编辑站点配置文件，将hexo和GitHub关联起来，其中username为GitHub用户名。在博客文件夹里，修改站点配置文件_config.yml，在文件最后加上（已有则修改）： 12345deploy: type: git # 提交类型git repo: git@github.com:fuyunjinglong/fuyunjinglong.github.io.git # 提交仓库地址 branch: hexoPage # 分支GitHub的默认分支是main Gitee的分支是master 可以填branch让hexo默认提交 message: &#x27;初始化博客&#x27; # 提交信息 注意：需要先安装Git部署插件，才能用命令部署到GitHub，输入以下命令安装hexo-deployer-git插件。 1$ npm install hexo-deployer-git --save 123456789$ hexo clean #清除缓存和已生成的静态文件$ hexo generate #等于hexo g$ hexo deploy #等于hexo d# 可将上述命令合并为“一键三连”package.json配置&quot;deployGithub&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;一键部署github pagenpm run deployGithub github博客仓库设置博客仓库-settings-Pages,选择对应分支和访问目录 浏览器中访问**https://&lt;username&gt;.github.io**即可看到你的博客了！！ Hexo命令创建分类1hexo new page categories自动生成目录结构 categories/index.md 设置分类 123456---title: 分类date: 2019-09-04 07:13:04layout: categoriestype: categories--- 清理缓存1hexo clean 重启服务12hexo s -p 5001或者pm2 stop all和pm2 start hexo_run.js hexo server1hexo s -p 端口号,也可不加端口 hexo generate这个命令是生成网站静态文件的时候用的，生成后网页将会放在根目录下面的 public 文件夹里。 hexo deploy这个命令用来部署网站，使用此命令将会把生成好的页面（即 public 文件夹里的内容）部署到指定的地方上。 hexo常见问题基本 1234567891011121314151617181920212223240.目录结构 可展示的大纲目录采用： 一级标题 二级标题 ... 不需要展示的大纲目录采用： 1.细分-加粗 1.1细分1.代码段&#123;% codeblock %&#125;&#123;% endcodeblock %&#125;2.图片![image](/img/2024-03-29_065127.png)或C:\\Users\\fuyunjinglong\\AppData\\Roaming\\Typora\\typora-user-images\\/img/3.加粗**加粗**4.链接&#123;% link 深入理解分布式事务 http://wwwe/distributed-transaction.html [external] [title] %&#125;5.点点li- 风格1- 风格2 高级 12345678910111213141516171819201.页面内跳转i.跳转到任意位置[跳转到指定锚点上面](#锚点)&lt;a name=&quot;锚点&quot;&gt; &lt;/a&gt;ii.跳转到标题位置[跳转到标题](#任意标题名)2.页面外跳转内部跳转页面&#123;% post_link E_数据结构_0基础 可点击%&#125;内部跳转页面锚点&lt;a target=&quot;_blank&quot; href=&quot;&#123;% post_path &#x27;E_数据结构_0基础&#x27; %&#125;#LRU-K&quot;&gt;LRU-K&lt;/a&gt;3.取消文章目录的自动编号./node_modules/hexo/lib/plugins/helper/toc.jslist_number: false4.页面外跳转定位锚点过慢删除av-min.js无效cdn","categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"}],"tags":[]},{"title":"清单","slug":"AA_面试_清单","date":"2021-10-31T22:33:16.000Z","updated":"2023-05-26T13:29:32.323Z","comments":true,"path":"2021/11/01/AA_面试_清单/","link":"","permalink":"https://fuyunjinglong.github.io/2021/11/01/AA_%E9%9D%A2%E8%AF%95_%E6%B8%85%E5%8D%95/","excerpt":"","text":"面试清单 一行命令爬取掘金文章榜单 github更多面试题 Vue3+ &amp; Vue-CLI3+开发生态圈资讯-地表最强 FrontEndGitHub-前端尤其Issues Front-end-Developer-Questions-前端面试问题 Daily-Question-大厂每日一题 CS-Interview-Knowledge-Map-前端进阶之道 Daily-Interview-Question-木易杨前端进阶 alibaba-intervie-阿里巴巴面试资源汇总 haizlin-fe-interview-前端知识每日3+1 fe-interview-大前端面试宝典 fe-interview-前端硬核面试 fe-interview-前端知识每日3+1 fe-interview-最全的前端面试题 Front-end-Web-Development-Interview-Question-前端面试笔试题 helloqingfeng-前端资源汇总 node-interview-饿了么大前端 Front-End-Interview-Notebook-前端复习笔记 FE-Interview-前端面试星球 javascript-guidebook-JavaScript知识图谱 前端收集图谱 阿秀的学习笔记 前端进阶之旅 冰雨博客 前端那些事 进击的大前端 前端系统进阶 前端九部-入门指南 前端语音社群 阿离王 前端自我修养 maqixiang的学习 TeqNG Nealyang-一个优秀的前端都应该阅读这些文章 一名【合格】前端工程师的自检清单 jamey系列 其他更精彩 cs自学指南 面试中的套路和反套路 前端负责人资源教程 JavaScript 资源大全中文版 免费的工具书 2020 - 2021 年 Web 前端最新导航 GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目 恕我直言，你可能连 GitHub 搜索都不会用 - 如何精准搜索的神仙技巧 TypeScript 入门教程 深入理解 TypeScript 老司机 前端老司机 70+ 实用工具网站分享 前端仔电脑里的秘密 github优秀仓库后端 JavaGuide CS-Notes advanced-java JCSprout technology-talk fullstack-tutorial 3y java-bible interviews 算法 LeetCodeAnimation awesome-java-leetcode leetcode 瓶子君 GitHub上最火的、最值得前端学习的数据结构与算法项目 awesome-coding-js算法 待整理 0.优秀博客 【👍 5059】一个合格(优秀)的前端都应该阅读这些文章 【👍 4695】2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文 【👍 4425】中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上) 【👍 3013】2018春招前端面试: 闯关记(精排精校) | 掘金技术征文 【👍 2493】前端面试考点多？看这些文章就够了（2019年6月更新版） 一名【合格】前端工程师的自检清单 JS 原生面经从初级到高级【近1.5W字】 技术胖155集前端 一个合格的中级前端 冴羽的博客 一个优秀的前端都应该阅读这些文章 阿里我是如何当面试官 写给初中级前端的高级进阶指南 我是如何零基础入门前端开发的（2021 版） 1.JavaScript 讲讲js数据类型？基本和引用的区别？symbol和bigint讲一讲应用场景？ 判断数据类型的方法？instanceof原理?判断空对象？ typeof null？typeof NaN？ var/let/const 区别？暂时性死区？块级作用域？const a = {}; a.x = 1 能不能修改？ 说说你对函数式编程的理解？函数柯里化的理解？平时的使用场景？ 防抖、节流的含义，使用场景？手写一下？ call、apply、bind区别？bind实现？bind之后还能修改this指向吗？为什么？ 闭包概念，最主要的还是问闭包的场景？ 用es5实现es6类的继承？各种继承问的挺多的 深拷贝与浅拷贝？常用方法？手写一个深拷贝函数？ 说说你知道的JavaScript设计模式？观察者和发布订阅的区别？手写一个发布订阅？我真的写了 说说对你对JavaScript异步编程的理解？ ES Module与 CommonJS 模块的差异？两者互相加载的方式？一般会扯到AMD Promise.all、race、allSettled 概念、手写？很多手写题都会用到，比如用promise实现请求并发个数限制？ 2.CSS 水平垂直居中？兼容性？不知道宽高情况下？ BFC概念？作用？常用场景？ Flex？注意flex：1的含义，一般会给你个场景题 盒模型概念，如何切换盒模型？ 实现1px边框？1px线条？ 伪类和伪元素区别？使用场景？ 3.Http &amp;浏览器 浏览器缓存？http缓存？ 主要要讲一讲强缓存、协商缓存、preload、prefetch、Service Worker等，304的含义？协商缓存e-tag是怎么生成的？Last-Modified是基于什么生成的？两者对比一下？优先级哪个高？ 什么是跨域？什么情况下会跨域？浏览器根据什么字段判断是否允许跨域？跨域的解决方案有哪些？options请求了解过吗？说说CORS中的简单请求和复杂请求？form表单提交会跨域吗？ 讲一讲浏览器事件循环Event Loop？node 事件循环描述一下？ http2有哪些新特性？http2还有哪些缺陷？http3的一些了解？ 从输入 URL 到页面加载完成的过程，一般要很详细的描述：包括DNS查询，缓存查询，3次握手，4次挥手，浏览器渲染进程等，面试官会从里面再挑几个问题深入问，比如为什么是3次握手4次挥手？渲染进程中的GUI渲染线程、JS引擎线程、事件触发线程等等？可能会问到进程线程的区别？浏览器为什么是多进程？js为什么是单线程？怎么支持多线程？等等 https加密原理？主要是讲对称加密和非对此加密结合使用的一个过程。什么是中间人攻击？和http区别？ 4.VUE 生命周期？那个生命周期可以获取到真实DOM？修改data里面的数据，会触发什么生命周期？ 组件data为什么是一个函数？ vue 组件通信？一般说了vuex，就会问vuex用法？action和mutations区别？实现原理等？ vue 导航守卫，分全局和组件的，一般用于权限控制，这个就可能扯到项目中的一些鉴权问题。 $nextTick 作用？实现原理？微任务向宏任务的降级处理，经常被问到说出几种宏任务，微任务。 vue响应式原理？基本都会问 vue scoped属性作用？实现原理？ vue router有几种模式？实现方式？ key的作用？没有key的情况，vue会怎么做？会引出diff的问题 vue diff过程，和react diff区别？ vue 2.x defineProperty缺陷？业务代码里面怎么处理？$set原理？vue是怎么重写数组方法的？考察你是不是真的看过源码 vue 3.0 proxy优缺点？怎么处理vue3不支持IE？ computed 和 watch 的区别和运用的场景？除了基本的，看你能不能说出三种watcher的区别 5.React 生命周期详细描述一下？官方为什么改变？ 说说你对虚拟DOM的理解？直接全量更新和diff哪个快（这个问题要分情况）？ 什么是HOC？React里面用过哪些？可能让你实现一个add(1)(2)(3)的函数 Fiber干了什么事情？requestIdleCallback了解多少？ react性能优化？ hooks出现的意义？类组件和函数组件之间的区别是什么？ 为什么不要在循环、条件语句或者嵌套函数中调用hooks？记住官网的一句话，Not Magic, just Arrays setState 同步还是异步？比较常问，问的可能也比较深入 如何避免组件的重新渲染？memo/useMemo、PureComponent？useMemo和useCallback区别？ 6.其他 webpack 构建流程？打包原理？ 项目中做的一些优化？ loader和plugin的区别？有没有写过？常用哪些loader和plugin webpack热跟新原理？ tree-shaking？对于 CommonJS，tree shaking怎么办？ webpack loader的执行顺序？从左到右？从上到下？ 项目做过的一些性能优化，基本必问 长列表渲染怎么优化？ 各种懒加载的实现原理？路由？图片？ Typescript 中的 interface 和 type 到底有什么区别","categories":[{"name":"AA_面试","slug":"AA-面试","permalink":"https://fuyunjinglong.github.io/categories/AA-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"编码规范","slug":"A_编码规范","date":"2021-10-31T22:33:16.000Z","updated":"2024-01-10T23:37:39.916Z","comments":true,"path":"2021/11/01/A_编码规范/","link":"","permalink":"https://fuyunjinglong.github.io/2021/11/01/A_%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"通用命名规范命名规则1默认规则是camelCase(小驼峰) PascalCase(大驼峰): 各个单次首字母大写 camelCase(小驼峰)：首个单词首字母小写，其余单词首字母大写 命名实践如下： 目录或项目命名：全小写，连接符(-, _)，如/project-athena 组件名：大驼峰，如KeepLive.vue js,ts文件名：小驼峰 class命名 基于姓氏命名法（继承 + 外来），modulename，modulename_info，modulename_info_user 嵌套层次最多3层，超过3层或名字过长，新开作用区间，取缩写miu_tit，miu_tit_co 变量：小驼峰 布尔类型：需要有含义的前缀，比如has, is, wether, can, should等，如isVisited 数组复数：需要标识复数的结尾，比如s或list 函数：小驼峰 常量：全大写，连接符(_)，如MAX_IMAGE_SIZE 注释：单行用//,多行用/**/ 前缀含义如下： 动词 含义 返回值 can 判断是否可执行某个动作 ( 权限 ) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 参考 阿里前端命名规范 不要在sass嵌套过深 sass的ClassName命名 拒绝屎山代码 TypeScript不要用成AnyScript 代码不要太长 组件和方法解耦 使用 Mutable Data响应式数据 多用魔术字符串即枚举 多尝试不同的方式来解决相同的问题 TypeScript不要用成AnyScript 如果充分发挥 AnyScript 的宗旨，意味着你很轻松地就让代码增加了 30% 毫无用处但也挑不出啥毛病的代码，这些代码甚至还会增加项目的编译时间（毕竟增加了ts校验和移除的成本嘛） 代码不要太长 单文件不超过400行，函数不超过100行 组件和方法解耦 组件优先使用pros和emit,回避vuex 使用 Mutable Data响应式数据 只需要三个单词：Watch、Watch、Watch 多用魔术字符串即枚举 12345enum EventType &#123; Move, Skip, Batch&#125; 多尝试不同的方式来解决相同的问题 比如vue不只有template，还有render 通用编码规范规则12345678910规则1 访问外部对象时，需先判断该对象是否为空规则2 功能失效时必须彻底删除对应的功能代码规则3 禁止注释中含有员工个人信息规则4 禁止硬编码用户账户密码规则5 在客户端对外部输入进行校验，对输入字符转义，防止sql注入和XSS注入规则7 禁止使用eval()函数，IE9下使用eval()存在内存泄露问题规则8 禁止直接对不可信的JS对象进行序列化，可能有代码注入的安全漏洞规则10 禁止未验证的输入作为重定向URL规则12 禁止直接将不可信数据插入到WEB页面中，防止XSS攻击盗取cookie和会话信息。可以先转义js，再插入dom规则13 禁止在 localStorage存储敏感信息。开发人员可能希望在旅游应用程序中使用多个浏览器选项卡或实例,以支持用户打开多个选项卡来比较住宿选择，同时保留用户最初的搜索条件。开发人员必须多加小心，以免将敏感信息从 sessionStorage 范围移至 localStorage。 HTML编码规范12345678规则1：语法规范，嵌套的节点应该缩进； • 在属性上，使用双引号，不要使用单引号； • 属性名全小写，用中划线做分隔符；规则3：文件编码，所有的文件以UTF-8的方式进行编码规则4：文件命名，命名全小写，多个单词用中划线-间隔，注意：class,id，属性，组件名等命名规格也要这样规则2：Class 与 ID，应以功能或内容命名，规则同文件，id作为唯一标识规则3：属性顺序， • id • class • name • data-xxx • src, for, type, href • title, alt • aria-xxx, role规则7：多媒体标签的alt属性，资源无法加载时，指定备份文字规则8：正确使用闭合标签，自定义标签一定要闭合，void element标签不要闭合。如：&lt;br标签&gt; 。根据w3的规范，void元素有area，base，br，col，command，embed，hr，img，input，keygen，link，meta，param，source，track，wbr。规则9：IE 兼容模式。IE 支持通过特定的标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。规则12：层级简单，避免多余的父元素，html尽量简化 CSS编码规范（1）代码规范 styleguide 2.3k spec 3.9k 1234567规则1：代码缩进，4个空格缩进，不能使用tab字符规则1：css文件的引用总是放在head区规则4：css加限定。针对多级class时，避免直接使用class,要带层级的访问。规则8：属性值前用空格分开，选择器后用空格分开规则9：不同css规则之间用空行隔开规则13：选择器。当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。规则15：属性书写顺序。以Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 • Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 • Box Model 相关属性包括：border / margin / padding / width / height 等 • Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 • Visual 相关属性包括：background / color / transition / list-style 等 其中LESS编码规则: 12规则2：@import 语句。.less 后缀不得省略。@import &quot;mixins/size.less&quot;;规则4：避免嵌套层级过多。嵌套深度限制在2级 eslint编码(1)js代码规范 airbnb-中文版，更为主流 standard (24.5k star) 中文版 百度前端编码规范 3.9k (2)eslint-config-airbnb规则 eslint-config-airbnb规则， airbnb官方的规则过于庞大，有10多个规则文件。维护起来成本较高。 大型团队和小团队（或独立开发者）的差异性： 技术层面上： 技术场景更加广泛：对于大型团队，其开发场景一般不会局限在传统 Web 领域内，往往还会涉及 Node.js、React Native、小程序、桌面应用（例如 Electron）等更广泛的技术场景。 技术选型更加分散：团队内工程技术选型往往并不统一，如 React/Vue、JavaScript/TypeScript 等。 工程数量的增加和工程方案离散化导致 ESLint 方案的复杂度提升：这样会进一步增加工程接入成本、升级成本和方案维护成本。 在团队层面，随着人员的增加和组织结构的复杂化： 人员风格差异性更大、沟通协调成本更高。 方案宣导更难触达，难以保证规范执行的落实。 执行状况和效果难以统计和分析。 因为存在诸多差异，我们在设计具体方案时，需要考虑和解决更多问题，以保证规范的落实。针对上述分析，我们梳理了以下需要解决的问题： 如何制定统一的代码规范和对应的 ESLint 配置？ 场景支撑：如何实现对场景差异的支持？如何保证不同场景间一致部分（例如 JavaScript 基础语法）的规范一致性？ 技术选型支撑：如何在支撑不同技术选型的前提下，保证基础规则（例如缩进）的一致性？ 可维护性：具体到规则配置上，能否提升可复用性？在方案升级迭代时成本是否可控？ 该配置架构采用了分层、分类的结构，其中： 基础层：制定统一的基础语法和格式规范，提供通用的代码风格和语法规则配置，例如缩进、尾逗号等等。 框架支撑层（可选）：提供对通用的一些技术场景、框架的支持，包括 Node.js、React、Vue、React Native 等；这一层借助开源社区的各种插件进行配置，并对各种框架的规则都进行了一定的调整。 TypeScript 层（可选）：这一层借助 typescript-eslint，提供对 TypeScript 的支持。 适配层（可选）：提供对特殊场景的定制化支持，例如 MRN（美团内部的 React Native 定制化方案）、配合 prettier 使用、或者某些团队的特殊规则诉求。 具体的实际项目中，可以灵活的选择各层级、各类型的搭配，获得和项目匹配的 ESLint 规则集。例如，对于使用 TypeScript 语言的 React 项目，可以将基础层、框架层的 React 分支、以及 TypeScript 支撑层的 React 分支层叠到一起，最终形成适用于该项目的 ESLint 配置。如果项目不再使用 TypeScript 语言，只需要将 ts-react 这一层去掉即可。 最终，形成了如下所示的 ESLint 配置集： ES6编码规范123456789101112规则1 导出默认的函数使用驼峰式命名规则2 导出单例、函数库、空对象时使用帕斯卡式命名即所有首字母大写规则5 变量必须显式声明作用域，尽量使用const,let，慎用var规则9 使用对象属性值的简写.ES6 允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。const obj = &#123; lukeSkywalker,&#125;;规则13 不要使用 arguments。可以选择 rest 语法 ... 替代.// 不推荐function concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&#x27;&#x27;); &#125;// 推荐function concatenateAll(...args) &#123; return args.join(&#x27;&#x27;);&#125;规则14 直接给函数的形参数指定默认值规则16 使用大括号包裹所有的多行代码块规则18 代码中总是使用ES6标准的模块(import/export)方式， 而不是使用非标准的模块化加载器commonjs。规则19 不要使用通配符 * 的 import。确保被import的模块只有一个默认的export项。规则24 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。规则27 使用解构存取和使用多属性对象或数组规则31 构建字符串时，使用字符串模板而不是字符串连接 vue编码规范1234prop定义尽量详细，如require,default等v-for设置键值避免 v-if 和 v-for 同时使用为组件样式设置作用域基础组件名，使用Base和父组件紧密耦合的子组件应该以父组件名作为前缀命名 团队规范前端团队规范总结 前端协作规范","categories":[{"name":"A_编码规范","slug":"A-编码规范","permalink":"https://fuyunjinglong.github.io/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[]}],"categories":[{"name":"H_工程热点","slug":"H-工程热点","permalink":"https://fuyunjinglong.github.io/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/"},{"name":"I_移动端","slug":"I-移动端","permalink":"https://fuyunjinglong.github.io/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"F_计算机网络","slug":"F-计算机网络","permalink":"https://fuyunjinglong.github.io/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"E_数据结构","slug":"E-数据结构","permalink":"https://fuyunjinglong.github.io/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"J_设计模式","slug":"J-设计模式","permalink":"https://fuyunjinglong.github.io/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"C_H5和CSS","slug":"C-H5和CSS","permalink":"https://fuyunjinglong.github.io/categories/C-H5%E5%92%8CCSS/"},{"name":"B_JS","slug":"B-JS","permalink":"https://fuyunjinglong.github.io/categories/B-JS/"},{"name":"D_框架和类库","slug":"D-框架和类库","permalink":"https://fuyunjinglong.github.io/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/"},{"name":"AA_面试","slug":"AA-面试","permalink":"https://fuyunjinglong.github.io/categories/AA-%E9%9D%A2%E8%AF%95/"},{"name":"Z_业务和面经","slug":"Z-业务和面经","permalink":"https://fuyunjinglong.github.io/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/"},{"name":"A_编码规范","slug":"A-编码规范","permalink":"https://fuyunjinglong.github.io/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[]}