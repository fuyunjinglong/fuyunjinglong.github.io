---
title: 2022年大前端技术趋势与展望
date: 2022-06-26 07:33:16
categories:
- H_工程热点
toc: true # 是否启用内容索引
---

大前端包括：传统的web应用开发，跨客户端(客户端，桌面端，车载，小程序)，跨服务(通过NodeJs的后端服务和工具链)三大类。

TypeScript逐渐成为前端开发标配语言。

# 工程开发(框架，微前端，工程构建)

从Github和NPM两大平台数据分析，React一马当先，国内则是Vue.

Hooks直译“钩子”，通常指系统运行到某一时期，会调用被注册到该时机的回调函数。以React为例：

> 一系列以"use"作为开头的方法，它们提供了让你完全避开Class式写法，在函数式组件中完成生命周期，状态管理，逻辑复用等组件开发能力。

**微前端**

独立开发，独立运行，独立部署。不限制技术栈，自由组合业务。

*微前端核心要解决的10个问题*

- JS沙箱重要：子应用之间互不影响，包括全局变量和事件等
- CSS隔离重要：子应用之间样式互不影响
- 父子应用通讯重要：子应用如何调父应用方法，父应用如何下发状态
- 子应用并行：多个微前端如何同时存在
- 子应用嵌套：如何嵌套微前端
- 预加载：空闲时加载子应用资源
- 公共依赖加载：大部分子应用都用到的资源
- 按需加载：切换页面才加载相应的html,css,js
- Config Entry:配置每个应用的JS和CSS
- Html Entry:简化开发者使用，但把解析消耗留给了用户

| 开源类型     | 项目             | 核心实现逻辑                |
| ------------ | ---------------- | --------------------------- |
| 社区主导     | single-spa       | 中心路由基座式架构          |
| 阿里主导     | qiankun/icestark | 中心路由基座式架构          |
| 字节主导     | Garfish          | 中心路由基座式架构          |
| 京东主导     | MicroApp         | web Components              |
| 欢聚时代主导 | EMP              | webpack5(Module Federation) |

**工程构建**

grunt->gulp->webpack->rollup->parcel->swc->vite

目前webpack,Babel,Terser,Prettier,都有了Rust替代方案。Rust构建逐渐成为新势力。

# 低代码技术

围绕无码，底码构建可视化搭建能力，提升研发效率。

现阶段No Code/Low Code主要面向小型客户的戏份领域业务场景，比如电商，业务简单且高度同质化，不涉及太多系统之间的耦合。

国内外低代码厂商已超过60家，渗透到各个业务领域(数据可视化，IOT,AI,GIS,CRM,ERP)

2021年阿里云峰会提供阿里云云钉一体化策略-低代码3.0，将”低代码开发“作为应用生态构建的主要方式

2020年阿里成立20人的中后台搭建团队，负责构建阿里通用搭建服务能力UIPass,基于同一的低代码引擎，支撑公司内的不同领域低代码平台开发，于2022年2月开源。

**一般模式**

物料选择区+画布+物料属性编辑器

**AWS的Amplify云服务**

提供了Amplify Studio在线平台，将Figma的UI设计直接导入，转化为前端可读的React组件代码

**阿里Imgcook能力**

设计稿智能生成代码,代码可用率79%，研发效率提升68%

- 组件识别能力：自动识别合理DOM嵌套结构，相对定位布局等
- 可视化编辑:支持组件样式、属性值修改，支持拖拉拽
- 代码生成:支持不同类型代码导出，react、vue、Rax

**京东DECO能力**

设计稿一键生成多端代码，京东凹凸实验室2020年发起的Deco智能代码项目，实现将Sketch/Photoshop等设计稿解析并直接生成代码。

# 跨端技术(跨平台，小程序)

排名有先后：Flutter,React Native,cordova,Ionic

移动端跨平台三大难题：性能，动态性，一致性。其中性能最关键。

Flutter能接近Native的性能体验，同时配有高效的开发套件，BAT均基于Flutter做二次封装，适配自身业务。

**Flutter和React Native方案比较**

*Flutter*

一次编写，到处运行

- Dart(Framework)
- Platform Channel(C++ Engine)
- Native Plugins（iOS/Android）

> 统一图形引擎，UI控件提供iOS和Android风格
>
> Native平台差异在Channel抹平，需额外开发
>
> 三端开发无法避免，三种框架/语言/环境切换

*React Native*

一次学习，到处编写

- JavaScript(Framework)
- JSI(JSCore)
- Native API(iOS/Android)

> JS/DOM最终转为Native原生组件
>
> Native平台差集封装JS后暴露给开发者
>
> 学习成本无法避免，同一种语言调用两端API

**小程序**

Taro,Uni-app是当前主流的开源跨端解决方案

# 后端技术(NodeJs,Serverless，WASM)

NodeJs应用框架：造轮子变少，TS变多，使用企业级框架变多。

Koa.js和Express.js为最常见框架，其他的有Egg.js,Nest.js,Midway.js,Next.js

**Serverless**

它是基于Serverless重塑前端应用研发模式

在BFF架构下，将BFF的运维成本释放掉，由以往的BFF server的多应用级转向Faas服务的函数级一体化，前端不再关系服务器等运维工作，专注业务。

比如：华为云的icejs的一体化工程设计

**WASM**

一种Web前端技术，价值在于方便引入python,c/c++,Rust等丰富的生态

- 增强功能，效果和接近Native APP的使用体验
- 提供控制逻辑代码执行性能，ts

使用建议：

- 尽量将纯的计算逻辑，放在WASM
- 涉及JS交互的，会损失性能

## BFF模式

BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。

BFF 的几个优点：

- 关注点分离——前端需求将与后端关注点分离，便于维护。
- 更容易维护和修改 API——客户端应用程序对 API 结构了解较少，这将使其对 API 中的更改更有弹性。
- 更好的前端错误处理——大部分时间，服务器错误对前端用户是没有意义的。BFF 可以映射出需要显示给用户的错误，而不是直接返回服务器错误，这将改善用户体验。
- 多种设备类型可以并行调用后端——当浏览器向 BFF 发出请求时，移动设备也可以这样做。这将有助于更快地获得相应服务的响应。
- 更好的安全性——某些敏感信息可以被隐藏，并且在向前端返回响应时可以忽略不必要的数据。这种抽象将使攻击者更难以应用程序为目标。
- 共享组件的团队所有权——应用程序的不同部分可以由不同的团队轻松处理。前端团队可以共享客户端应用程序及其底层资源消耗层的所有权，从而提高开发速度。下图显示了团队划分 BFF 的例子。



> 在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。

### **演进过程:单端调用基础服务**

<img src="/img/image-20220912125857000.png" alt="image-20220912125857000" style="zoom: 67%;" />

传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的`高耦合`就决定了这一点。

### 演进过程:多端直接调用基础服务

<img src="/img/image-20220912130104777.png" alt="image-20220912130104777" style="zoom: 67%;" />

如果我们的接口同时提供给`web`、`移动端`使用，`移动端`仅用来采集数据以及数据的展示，而`web`端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。

### 演进过程:多端共用一个BFF

<img src="/img/image-20220912130137621.png" alt="image-20220912130137621" style="zoom: 67%;" />

针对多端共用服务接口的场景，我们将基础的`数据服务`与`BFF`进行了**分离**，`数据服务`仅提供数据的`增删改查`，并不过多涉及业务的判断处理，所有业务判断处理都交给`BFF`来把控，遇到的一些`业务逻辑异常`也同样由`BFF`格式化处理后展示给访问端点。

这种设计方式同样存在一定的问题，虽然`基础服务`与`BFF`进行了分离，我们只需要在`BFF`层面进行业务判断处理，但是多个端共用一个`BFF`，也会导致代码`编写复杂度增高`、`代码可阅读性降低`、`多端业务耦合`。

### 演进过程:每个端提供一个BFF

<img src="/img/image-20220912130225184.png" alt="image-20220912130225184" style="zoom: 67%;" />

如果我们为每一个端点都提供一个`BFF`，每个端点的`BFF`处理自身的业务逻辑，需要数据时从`基础服务`内获取，然后在接口返回之前进行组装数据用于实例化返回对象。



这样基础服务如果有新功能添加，`BFF`几乎不会受到影响，而我们如果后期把`App`端点进行拆分成`Android`、`IOS`时我们只需要将`app-bff`进行拆分为`android-bff`、`ios-bff`，基础服务同样也不会受到影响

<img src="/img/image-20220912130300871.png" alt="image-20220912130300871" style="zoom: 67%;" />

**小结**

在微服务架构设计中，`BFF`起到了一个业务聚合的关键作用，可以 通过`openfeign`、`restTemplate`调用`基础服务`来获取数据，将获取到的数据进行组装返回结果对象，`BFF`解决了业务场景问题，也同样带来了一些问题，如下所示：

- 响应时间延迟（服务如果是内网之间访问，延迟时间较低）
- 编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码）
- 业务异常处理（统一格式化业务异常的返回内容）
- 分布式事务（微服务的通病）