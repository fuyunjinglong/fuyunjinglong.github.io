# 前端模块化

参考

- [前端模块化详解(完整版)](https://juejin.cn/post/6844903744518389768#heading-2)

## 模块化是什么？

- 按照一定的规则(规范)封装成几个块(文件), 并自由组合在一起
- 对内数据封装，对外暴露接口

## 模块化进化过程

**全局function模式** 

 将不同的功能封装成不同的全局函数

- 编码: 将不同的功能封装成不同的全局函数
- 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

**namespace模式** 

简单对象封装

- 作用: 减少了全局变量，解决命名冲突
- 问题: 数据不安全(外部可以直接修改模块内部的数据)

```
let myModule = {
  data: 'www.baidu.com',
  foo() {
    console.log(`foo() ${this.data}`)
  },
  bar() {
    console.log(`bar() ${this.data}`)
  }
}
myModule.data = 'other data' //能直接修改模块内部的数据
myModule.foo() // foo() other data
```

**IIFE模式**

匿名函数自调用(闭包)

- 作用: 数据是私有的, 外部只能通过暴露的方法操作
- 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
- 问题: 如果当前这个模块依赖另一个模块怎么办?

```
// index.html文件
<script type="text/javascript" src="module.js"></script>
<script type="text/javascript">
    myModule.data = 'xxxx' //不是修改的模块内部的data
    myModule.foo() //没有改变
</script>

// module.js文件
(function(window) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window)
```

**IIFE模式增强** 

 引入依赖,这就是现代模块实现的基石。**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**。

```
// module.js文件
(function(window, $) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar }
})(window, jQuery)
```



# ES6

## new一个对象发生了什么？

四件事：

1.创建一个空对象

2.把该对象的`__proto__`属性指向`Sub.prototype`

3.让构造函数里的`this`指向新对象，然后执行构造函数，

4.返回该对象

## ES5和ES6之继承的区别 ？

- ES5的继承通过寄生组合式继承来实现。`ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）`。
- `ES6 的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this`。

**ES5 寄生组合式继承**

ES5的继承，实质上是先创造子类的实例对象this，然后再将父类的方法添加到子类（this）上面。

所以，

> **es5的写法不能继承原生构造函数**（比如Array、Number等） 因为es5的继承是先创造子类的实例对象this，再将父类原型的属性和方法重写到子类上，因为没法访问父类的内部属性，导致**es5的继承方式无法继原生的构造函数**。

截图：https://cloud.tencent.com/developer/article/1865384

**ES6 extend继承**

参考

- [廖雪峰的原型继承](https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072)
- [ES6类以及继承的实现原理](https://segmentfault.com/a/1190000014798678)
- [ES6下babel如何编译Class](https://www.aligoogle.net/pages/25e63f/#%E4%BA%94-babel-%E7%BC%96%E8%AF%91)

ES6的继承机制完全不同，实质上是先创造父类的实例对象this，并将父类的属性和方法放到this上（前提是通过super函数调用），然后再用子类的构造函数修改this。

所以，

>  es6允许继承构造函数生成子类。因为es6是先创建父类的实例对象this，然后再用子类的构造函数修饰，所以子类就可以继承父类的所有属性和方法。因此**class可以继承并自定义原生构造函数的子类**。extends不仅可以用来继承类，还能用来继承原生构造函数，因此也就可以在原生数据结构的基础上，构造自定义的数据结构。

截图：https://cloud.tencent.com/developer/article/1865384

**ES6继承核心源码**

bable编译Class文件后的代码：

```
var Child = function(_Parent) {
    _inherits(Child, _Parent);// 核心
    function Child(name, age) {
        _classCallCheck(this, Child);
        // 调用父类的 constructor(name)
        var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name));
        _this.age = age;
        return _this;
    }

    return Child;
}(Parent);
```

其中核心是_inherits：

```
function _inherits(subClass, superClass) {
    // extend 的继承目标必须是函数或者是 null
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    // 代码1，类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });

    // 代码2，设置子类的 __proto__ 属性指向父类
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
```

_inherits通俗理解：

- 代码1：保证了`c instanceof Parent`是true,Child的实例可以访问到父类的属性，包括内部属性，以及原型属性。截图：https://segmentfault.com/a/1190000014798678
- 代码2：子类能访问到父类的静态方法

```
// 代码1翻译下就是
function F(){}
F.prototype = superClass.prototype
subClass.prototype = new F()
subClass.prototype.constructor = subClass
简写为一行代码是：subClass.prototype.__proto__ = superClass.prototype

// 代码2翻译下就是：
function A(){}
var a = new A()
a.__proto__ = A.prototype
// a是一个实例，A.prototype是构造方法的原型。通过这种方式，那么a就可以访问A.prototype上面的方法。
// 那把 subClass类比成 a，superClass类比成A.prototype，那是不是subClass可以直接访问 superClass的静态属性，静态方法了。
```



# JS

## 常用函数

### 数组去重

```
const uniqueArr = (arr) => [...new Set(arr)];
```

### 从url获取参数

```
    const getParameters = () => {
      const url = window.location.href;
      return JSON.parse(`{"${decodeURI(url.split('?')[1]).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"')}"}`);
    };
```

### 检查对象是否为空

```
const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;
```

### 反转字符串

```
const reverse = str => str.split('').reverse().join('');
```

### 生成随机十六进制颜色

```
const randomHexColor = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0")}`
```

### 检查设备类型

```
const judgeDeviceType =
      () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? 'Mobile' : 'PC';
```

### 文字复制到剪贴板

```
const copyText = async (text) => await navigator.clipboard.writeText(text)
```

## 变量对象

**参考**

- [JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5#top)

对于每个执行上下文，都有三个重要属性：

- 变量对象( variable object ，VO)
- 作用域链( scope chain)
- this

**变量对象**

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

接下来是：全局上下文下的变量对象和函数上下文下的变量对象。

**全局上下文**

全局对象。在 [W3School](http://www.w3school.com.cn/jsref/jsref_obj_global.asp) 中也有介绍：

> 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。

> 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。

> 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。

```
// 全局对象就是 Window 对象
console.log(this);
console.log(this instanceof Object);
// 都能生效
console.log(Math.random());
console.log(this.Math.random());
var a = 1;
// 作为全局变量的宿主
console.log(this.a);
// 全局对象有 window 属性指向自身
console.log(window.a);

this.window.b = 2;
console.log(this.b);
```

**函数上下文**

在函数上下文中，我们用活动对象(activation object , AO)来表示变量对象。

**执行过程**

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

1. 进入执行上下文
2. 代码执行

## 彻底搞懂this

## 不同使用场景的this取值

JavaScript函数中this取值主要区分以下几个情况：

1. 默认绑定(函数的普通调用)
2. 隐式绑定(函数作为对象方法调用)
3. new绑定(函数作为构造函数调用)
4. 显示绑定(函数通过`call`、`apply`、`bind`间接调用)
5. ES6绑定(箭头函数的调用)

测试练习

```
var name = 'window'

const person1 = {
  name: 'person1',
  show1: function () {
    console.log(this.name)
  },
  show2: () => console.log(this.name),
  show3: function () {
    return function () {
      console.log(this.name)
    }
  },
  show4: function () {
    return () => console.log(this.name)
  }
}
const person2 = { name: 'person2' }

person1.show1()                     // person1 函数作为对象方法调用，this指向对象
person1.show1.call(person2)         // person2 使用call间接调用函数，this指向传入的person2

person1.show2()                     // window  箭头函数无this绑定，在全局环境找到this，指向window
person1.show2.call(person2)         // window  间接调用改变this指向对箭头函数无效

person1.show3()()                   // window  person1.show3()返回普通函数，相当于普通函数调用，this指向window
person1.show3().call(person2)       // person2 使用call间接调用函数，this指向传入的person2
person1.show3.call(person2)()       // window  person1.show3.call(person2)仍然返回普通函数

person1.show4()()                   // person1 person1.show4调用对象方法，this指向person1，返回箭头函数，this在person1.show4调用时的词法环境中找到，指向person1
person1.show4().call(person2)       // person1  间接调用改变this指向对箭头函数无效
person1.show4.call(person2)()       // person2  改变了person1.show4调用时this的指向，所以返回的箭头函数的内this解析改变
```



## 作用域

**参考**

- [JavaScript深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/blog/issues/3)
- [JavaScript深入之执行上下文栈](https://github.com/mqyqingfeng/Blog/issues/4)

作用域是指程序源代码中定义变量的区域。

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

**静态作用域与动态作用域**

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

```
var value = 1;
function foo() {
    console.log(value);
}
function bar() {
    var value = 2;
    foo();
}
bar();
// 结果是 ???
```

假设JavaScript采用静态作用域，让我们分析下执行过程：

执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value (价值) ，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value (价值) 等于 1，所以结果会打印 1。

假设JavaScript采用动态作用域，让我们分析下执行过程：

执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value (价值) 。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value (价值) 变量，所以结果会打印 2。

前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

来自《JavaScript权威指南》中的例子：

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码都会打印：`local scope`。因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。

> 引用《JavaScript权威指南》的回答就是：
>
> JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope (范围) 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

## instanceOf手写

**实现思路：**

> 1. 首先 instanceof 左侧必须是对象, 才能找到它的原型链
> 2. instanceof 右侧必须是函数, 函数才会prototype属性
> 3. 迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧

```
// 手写instanceOf-递归版本
function instanceOfMe(obj, Constructor) { // obj 表示左边的对象，Constructor表示右边的构造函数
  let leftP = obj.__proto__ // 取对象隐式原型
    let rightP = Constructor.prototype // 取构造函数显示原型
    // 到达原型链顶层还未找到则返回false
    if (leftP === null) {
        return false
    }
    // 对象实例的隐式原型等于构造函数显示原型则返回true
    if (leftP === rightP) {
        return true
    }
    // 查找原型链上一层
    return instanceOfMe(obj.__proto__, Constructor)
}
// 手写instanceOf-非递归版本
function instanceOfMe(L, R) { // L 表示左边的对象，R表示右边的构造函数
    // 验证如果为基本数据类型，就直接返回false
    const baseType = ['string', 'number','boolean','undefined','symbol']
    if(baseType.includes(typeof(L))) { return false }
    
    let RP  = R.prototype;  //取 R 的显示原型
    L = L.__proto__;       //取 L 的隐式原型
    while(true){           // 无线循环的写法（也可以使 for(;;) ）
        if(L === null){    //找到最顶层
            return false;
        }
        if(L === RP){       //严格相等
            return true;
        }
        L = L.__proto__;  //没找到继续向上一层原型链查找
    }
}
```



# 程序员副业

## 副业方向

**1、有技术的程序员**

有的中小公司会找业内的技术专家，解决某个技术问题，又或许是针对开发需求组织的团队内训，包括一些程序员培训机构，也会邀请技术专家参与课程研发，都是为你的技能付费。

并且做得好还可以打造个人IP，把自己越卖越贵，直接上升N个档次。

**2、有资源的程序员**

有机会有能力接项目来做，一方面在工作中积累了人脉和资源，另一方面自己可以组织或整合一个兼职的小团队。

所以善待身边的人，说不定下个单子就是他开给你的！

**3、有个人见解的程序员**

写技术博客，做自媒体，做短视频，分享工作经验，拆解技能……走自媒体路线，有独特个性的人会更吃香，更有甚者可以卖课、卖书，吃流量，赚稿费。

## 副业平台

记住：

> - 个人的，别想着在这种线上平台接单赚钱，线上平台能接到单赚钱的，都是专门成立了外包小公司的团队。
> - 线上接单我5年前就不玩了，当时猪八戒很火，很多程序员上面接单，但是发现付出与收获不成正比， 作为程序员线上接单不是好路子，最好是自己开发一个产品(比如小程序)，靠产品赚钱，这个钱赚的又舒服又锻炼自己成为老板
> - 做视频聚合资源app，一个月1w没问题，纯赚，容易进局子，版权问题
> - 线上接单这种挣得比较少，价格透明，竞争大。最好的是善待周围的人，扩大交际圈，说不定哪天给你介绍一单，跨行业的容易挣信息不对称的💰，利润大。

**1、程序员客栈**

国内领先的程序员自由远程工作平台，这行的应该都知道吧。灵活度高，比较自由，单子比较多，个人推荐！

**2、英选**

平台以定制开发外包服务为主，也是外包项目平台。它的项目管理方面是特色，阶段确认和及时反馈较好。

**3、Devnors**

国外的一个互联网软件定制开发与软件外包开发服务平台，英语好的朋友可以看看，它比较有意思的是平台用的是区块链技术支付。要是能接上国外的单，那还是香的！

**4、开源众包**

上面的项目以众包为主。接包方质量较好，它的协助开发工具比较完善。也是比较常见的一个网站。

# Vue3入门

## Hooks

方式三：参考大崔哥的新写法(直接赋值引用)--强烈推荐

```
// Task.vue
<script setup lang="ts">
import { ref,onBeforeMount } from 'vue';
import { initListTag } from '@/service/task'

let listTags =reactive([])
onBeforeMount(async () => {
   initListTag()
})
</script>
<template>
<div v-for="(listTag,i) in listTags" :key="'listTags'+i">{{ listTag.label }}</div>
</template>

// @/service/task.ts
import { ref } from 'vue';
import * as myapi from '@/service/myapi';

let listTags =[]

 export async function initListTag(
  listTagsReactive
) {
  // 0.初始化
  declareListTag(listTagsReactive)
  await loadTags()
}

 function declareListTag(
  listTagsReactive
) {
  // 1.初始化-变量
  listTags = listTagsReactive
}

export async function loadTags() {
  // 2.初始化-填充tags
  const tab={}
  listTags.push(createListTag(tag.name, tag.color, tag.parentTagId || undefined, tag.id))
}

export function createListTag(name, color?, parentTagId?, id = 0){
  // 3.初始化-创建tag
  return {
    id,
    name,
    color: color || '',
    parentTagId: parentTagId || null,
    loadTasks: () => {
      return myapi.getTasksByTagId(id)
    },
  }
}

export async function addListTag(tag) {
  // 添加tag等其他逻辑处理,此处可以拿到listTags变量
  const pIndex = await myapi.addTag(tag.name, tag.parentTagId, tag.color)
  if (pIndex)
    tag.id = pIndex
  listTags.push(tag)
}
```

方式四：参考大崔哥的新写法(返回值引用)

```
// User.vue
<template>
    <!-- 视图部分省略，在对应btn处引用onChangePassword和onChangeUserInfo即可 -->
   <div @click="onChangePassword"> {{userInfo}}</div>
</template>
<script setup>
import useUserControl from './useUserControl';
const { userInfo, onChangeUserInfo,onChangePassword } = useUserControl();
<script>

// @/service/useUserControl.ts
import useUser from './useUser';
const useUserControl = () => {
    // 组合用户hook
    const { userInfo, getUserInfo, changeUserInfo } = useUser();
    // 数据查询loading状态
    const loading = ref(false);
    // 初始化数据
    const initData = () => {
        getUserInfo();
    }
    // 修改密码
     const onChangePassword = () => {
    }
    onMounted(initData);
    return {
        // 用户数据
        userInfo,
        // 修改用户信息
        onChangeUserInfo: changeUserInfo,
        onChangePassword:onChangePassword
    }
}

// @/service/useUser.ts
const useUser = () => {
    // vue版本的用户状态
    const userInfo = ref({});
    // 获取用户状态
    const getUserInfo = () => {}
    // 修改用户状态
    const changeUserInfo = () => {};
    return {
        userInfo,
        getUserInfo,
        changeUserInfo
    }
}
```



# 组件库封装

## 高质量组件编写

- 组件何时拆分
- 拆分出组件文件
- 用hooks抽离组件逻辑

**组件何时拆分**

> 拆分的组件要保持功能单一。即组件内部代码的代码都只跟这个功能相关；
>
> 组件要保持较低的耦合度，不要与组件外部产生过多的交互。如组件内部不要依赖过多的外部变量，父子组件的交互不要搞得太复杂等等。
>
> 用组件名准确描述这个组件的功能。就像函数那样，可以让人不用关心组件细节，就大概知道这个组件是干嘛的。如果起名比较困难，考虑下是不是这个组件的功能并不单一。

**拆分出组件文件**

本人更推荐统一放入到component文件夹下。

> 1. 如果只是被页面内的组件复用，就放到页面文件夹下。
> 2. 如果只是在当前业务场景下的不同页面复用，就放到当前业务模块的文件夹下。
> 3. 如果可以在不同业务场景间通用，就放到最顶层的公共文件夹，或者考虑做成组件库。

```
homePage // 存放当前页面的文件夹
    |-- components // 存放当前页面组件的文件夹
        |-- componentA // 存放当前页面的组成部分A的文件夹
            |-- index.(vue|tsx) // 组件A
            |-- AChild1.(vue|tsx) // 组件a的组成部分1
            |-- AChild2.(vue|tsx) // 组件a的组成部分2
            |-- ACommon.(vue|tsx) // 只在componentA内部复用的组件
        |-- ComponentB.(vue|tsx) // 当前页面的组成部分B
        |-- Common.(vue|tsx) // 组件A和组件B里复用的组件
    |-- index.(vue|tsx) // 当前页面
```

**用hooks抽离组件逻辑**

- 方式三：参考大崔哥的新写法(直接赋值引用)--强烈推荐
- 方式四：参考大崔哥的新写法(返回值引用)

# 书单

- [awesome-book](https://github.com/fuyunjinglong/awesome-books/)

# React入门

- [当公司要求你必须会 React，Vueer 不得不学](https://juejin.cn/post/7173953093158060039#heading-3)

# JS发布订阅-极简

```
class SyncHook {
  constructor() {
    this.taps = [];
  }

  //注册监听函数，这里的name其实没啥用
  tap(name, fn) {
    this.taps.push({ name, fn });
  }

  //执行函数
  call(...args) {
    this.taps.forEach((tap) => tap.fn(...args));
  }
}
```

# webpack的Loader机制

- [【万字长文｜趣味图解】彻底弄懂Webpack中的Loader机制](https://juejin.cn/post/7157739406835580965#heading-16)

**Loader本质**

Loader 本质上是导出为函数的 JavaScript 模块。`它接收资源文件或者上一个 Loader 产生的结果作为入参，也可以用多个 Loader 函数组成 loader chain（链），最终输出转换后的结果`。

**Loader的四种类型**

分为：[前置(pre)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[普通(normal)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[行内(inline)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[后置(post)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)。

```
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", //将css内容变成style标签插入到html中去
          "css-loader", //解析css文件的路径等
          "less-loader", //将less=>css
        ],
        enforce: "pre", //这里也可以是post，默认不写就是normal
      },
    ],
  },
```

**Loader执行顺序**

简单说：Loader 的执行顺序是由右向左，或者由下到上执行。

官方说法：**Pitching** 阶段和**Normal** 阶段

所有一个接一个地进入的 Loader，都有两个阶段：

1. **Pitching** 阶段: Loader 上的 pitch 方法，按照 `后置(post)、行内(inline)、普通(normal)、前置(pre)` 的顺序调用。
2. **Normal** 阶段: Loader 上的 常规方法，按照 `前置(pre)、普通(normal)、行内(inline)、后置(post)` 的顺序调用。模块源码的转换， 发生在这个阶段。
3. 同等类型下的 Loader 执行顺序才是由右向左，或者由下到上执行。

# Vue模板编译流程(编译器原理)

一个编译器完整执行过程：

**Parsing(解析过程)**：这个过程要经`词法分析`、`语法分析`、`构建AST（抽象语法树）`一系列操作；

**Transformation（转化过程**）：这个过程就是将上一步解析后的内容，按照编译器指定的规则进行处理，`形成一个新的表现形式`；

**Code Generation（代码生成**）：将上一步处理好的内容`转化为新的代码`；

截图：https://juejin.cn/post/7155151377013047304#heading-4



# ES6的导入导出

- [「万字进阶」深入浅出 Commonjs 和 Es Module](https://juejin.cn/post/6994224541312483336)
- [深入 CommonJs 与 ES6 Module](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000017878394)
- [「Node.js系列」深入浅出Node模块化开发——CommonJS规范](https://juejin.cn/post/6892786383249735687)

```
/**
 * 导出
 */
export * from 'module'; //重定向导出 不包括 module内的default
export { name1, name2, ..., nameN } from 'module'; // 重定向命名导出
export { import1 as name1, import2 as name2, ..., nameN } from 'module'; // 重定向重命名导出
export { name1, name2, …, nameN }; // 与之前声明的变量名绑定 命名导出
export { variable1 as name1, variable2 as name2, …, nameN }; // 重命名导出
export let name1 = 'name1'; // 声明命名导出 或者 var, const，function， function*, class
export default expression; // 默认导出
export default function () { ... } // 或者 function*, class
export default function name1() { ... } // 或者 function*, class

/**
 * 导入
 */
import defaultExport from "module"; // 默认导入
import { a, b, c } from "module"; //解构导入
import defaultExport, { a, b, c as newC } from "module"; //混合导入
import * as name from "module"; //混合导入
var promise = import("module"); //动态导入(异步导入)
```



# axios取消请求

**方式1：AbortController**

从 `v0.22.0` 开始，Axios 支持以 fetch API 方式—— [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) 取消请求：

```js
const controller = new AbortController();
// 取消重复请求
controller.signal && controller.abort();
axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
```

**方式2：CancelToken** 

通过传递一个 executor 函数到 `CancelToken` 的构造函数来创建一个 cancel token：。

此 API 从 `v0.22.0` 开始已被弃用，不应在新项目中使用。

```js
const CancelToken = axios.CancelToken;
let cancel;
// 取消重复请求
cancel && cancel();
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});
```



# 事件冒泡和事件捕获

DOM事件流（event flow ）存在三个阶段：**事件捕获阶段、处于目标阶段、事件冒泡阶段。**

**事件捕获：**通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始**由外到内**进行事件传播。

**事件冒泡**：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。

截图：https://juejin.cn/post/6844903834075021326



# 人生规划和职业发展

**问题1：武汉是一个大城市，相比一般小县城，有以下优势和劣势：**

> 优势：
>
> 1. 经济发展水平高：武汉是湖北省的省会，也是中部地区的重要城市，拥有较为完善的产业体系和发达的经济。相比小县城，武汉的经济发展水平更高，就业机会更多。
> 2. 文化氛围浓厚：武汉是一个历史悠久的城市，有着丰富的文化底蕴和独特的文化氛围。武汉有许多著名的文化景点和历史遗迹，如黄鹤楼、古琴台、汉口江滩等，这些都是小县城所没有的。
> 3. 生活便利：武汉是一个大城市，拥有完善的基础设施和便利的生活服务。相比小县城，武汉的医疗、教育、交通等方面更加发达，居民的生活质量更高。
>
> 劣势：
>
> 1. 交通拥堵：武汉是一个大城市，交通压力较大，尤其是高峰期，交通拥堵现象比较严重。相比小县城，武汉的交通状况更为复杂，需要花费更多的时间和精力。
> 2. 空气质量差：由于武汉是一个工业城市，空气质量相对较差，尤其是冬季和雾霾天气，空气污染问题比较严重。相比小县城，武汉的环境质量更差。
> 3. 生活成本高：武汉是一个大城市，生活成本相对较高，尤其是房价和物价方面。相比小县城，武汉的生活成本更高，需要花费更多的钱。

**问题2：父母公务员对孩子的影响主要有以下几个方面：**

> 1. 教育环境：公务员家庭通常注重教育，重视孩子的学习和成长，提供更好的教育环境和资源，这对孩子的成长有积极的影响。
>
> 2. 社会关系：公务员家庭通常有更广泛的社会关系，这对孩子的人际交往和社交能力的培养有一定的帮助。
>
> 3. 安全稳定：公务员家庭通常有较为稳定的收入和职业，这对孩子的成长环境和生活条件都有一定的保障。
>
> 4. 压力和期望：公务员家庭通常对孩子的期望较高，希望孩子能够继承父母的优秀品质和成就，这可能会给孩子带来一定的压力。
>
> 总的来说，父母公务员对孩子的影响是多方面的，既有积极的方面，也有一些潜在的负面影响。但是，这些影响并不是绝对的，还要考虑具体的家庭情况和孩子的个性特点。

**问题3：中国公务员的待遇**

> 1. 薪资待遇：公务员的薪资待遇相对较高，一般比同等学历的企业员工要高。
>
> 2. 福利待遇：公务员享有较好的福利待遇，包括医疗保险、养老保险、住房公积金等。
>
> 3. 工作稳定性：公务员的工作相对稳定，一般不会出现裁员等情况。
>
> 4. 职业发展：公务员的职业发展空间相对较大，可以通过考试晋升到更高级别的职位。
>
> 需要注意的是，公务员的工作压力较大，工作时间也相对较长，同时需要承担一定的责任和义务。
>
> 一般来说，公务员晋升的年龄限制如下：
>
> 1. 初次录用的公务员，一般要求年龄在35周岁以下；
> 2. 普通公务员晋升为副科级干部，一般要求年龄在45周岁以下；
> 3. 副科级干部晋升为正科级干部，一般要求年龄在50周岁以下；
> 4. 正科级干部晋升为副县级干部，一般要求年龄在55周岁以下；
> 5. 副县级干部晋升为正县级干部，一般要求年龄在60周岁以下。
>
> 公务员的缺陷和劣势可能包括以下几点：
>
> 1. 薪资相对较低：公务员的薪资相对于同等学历和工作经验的民营企业员工来说较低，尤其是在一些发展较快的行业和地区。
>
> 2. 晋升机会较少：公务员的晋升机会相对较少，晋升的速度也比较慢，这可能会影响到个人的职业发展。
>
> 3. 工作压力大：公务员的工作压力也比较大，尤其是在一些重要的岗位上，需要承担较大的责任和压力。
>
> 4. 工作环境相对单一：公务员的工作环境相对较为单一，缺乏多样性和挑战性，可能会导致工作的单调性和乏味性。
>
> 5. 工作稳定性较高：虽然公务员的薪资相对较低，但是工作稳定性较高，相对于民营企业来说更加稳定和安全。
>
> 总的来说，公务员的缺陷和劣势与个人的职业发展和价值观有关，需要根据自身情况进行权衡和选择。

**问题4：放弃程序员高薪，专职去考取国家公务员，合适吗**

> 这个问题的答案取决于你的个人情况和目标。如果你对公务员职业有浓厚的兴趣，并且相信这是你实现自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。
>
> 在做出这个决定之前，你需要考虑以下几个因素：
>
> 1. 薪资：一般来说，程序员的薪资比国家公务员高。如果你更看重薪资，那么选择程序员工作可能更适合你。
>
> 2. 工作内容：程序员工作需要具备一定的技术能力和创造力，需要不断学习和更新知识。而国家公务员的工作内容相对稳定，需要具备一定的组织协调和管理能力。如果你更喜欢挑战和创造，那么选择程序员工作可能更适合你。
>
> 3. 工作环境：程序员工作一般在IT公司或科技企业中，工作环境比较自由，注重创新和团队合作。而国家公务员的工作环境相对稳定，注重规范和纪律。如果你更喜欢自由和创新，那么选择程序员工作可能更适合你。
>
> 4. 职业发展：程序员工作有很多不同的职业发展路径，可以成为技术专家、项目经理、创业者等。而国家公务员的职业发展路径相对单一，主要是晋升到更高级别的公务员。如果你更看重职业发展和多元化选择，那么选择程序员工作可能更适合你。
>
> 综上所述，如果你认为公务员职业是符合自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。
>
> 这个问题的答案取决于个人的价值观和职业规划。如果你认为成为国家公务员是实现个人价值和职业规划的最佳途径，那么这个决定就是合适的。但是，需要注意的是，放弃高薪的程序员职业，转而成为国家公务员，可能会对个人的经济状况产生影响。因此，在做出这个决定之前，需要仔细考虑自己的职业规划和生活需求，并做好充分的准备。
>
> 这是一个非常棘手的问题，需要你自己权衡利弊并做出决定。首先，你需要考虑自己的职业兴趣和发展方向，如果你对公务员这个职业没有兴趣，那么转行可能会让你感到不满和失落。其次，你需要考虑你和女朋友的关系，如果你们的感情很深，你可以考虑妥协，但是如果你们的感情并不牢固，你需要好好考虑是否值得为了她的要求而放弃自己的职业发展。最后，你需要考虑你们未来孩子的教育和成长，公务员这个职业相对稳定，但是也有一定的局限性，你需要好好权衡。 总之，这是一个需要你自己做出决定的问题，你需要考虑自己的职业兴趣、个人发展、感情关系和未来孩子的教育等多个方面，做出最合适的决定。

# vue与react比较

## Hooks

- [浅谈：为啥vue和react都选择了Hooks](https://juejin.cn/post/7066951709678895141#heading-1)

**定义**

"hooks" 直译是 “钩子”，它并不仅是 `react`，甚至不仅是前端界的专用术语，而是整个行业所熟知的用语。通常指：

> 系统运行到某一时期时，会调用被注册到该时机的回调函数。

以 `react` 为例，`hooks` 是：

> 一系列以 `“use”` 作为开头的方法，它们提供了让你可以完全避开 `class式写法`，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。

而在 `vue` 中， `hooks` 的定义可能更模糊，姑且总结一下：

> 在 `vue` 组合式API里，以 `“use”` 作为开头的，一系列提供了组件复用、状态管理等开发能力的方法。

**命名规范和指导思想**

在 `react` 官方文档里，对 `hooks` 的定义和使用提出了 **“一个假设、两个只在”** 核心指导思想。

> **一个假设：** 假设任何以 「`use`」 开头并紧跟着一个大写字母的函数就是一个 `Hook`。
>
> **第一个只在：** 只在 `React` 函数组件中调用 `Hook`，而不在普通函数中调用 `Hook`。（`Eslint` 通过判断一个方法是不是大坨峰命名来判断它是否是 `React` 函数）
>
> **第二个只在：** 只在最顶层使用 `Hook`，而不要在循环，条件或嵌套函数中调用 Hook。
>
> 因为是约定，因而 `useXxx` 的命名并非强制，你依然可以将你自定义的 `hook` 命名为 `byXxx` 或其他方式，但不推荐。

**为什么我们需要 `hooks` ?**

- 更好的代码组织
- 更好的逻辑复用

**如何开始玩 `hooks`** 

react 的 `Hooks` 写法，因为 react Hooks 仅支持“函数式”组件，因此需要创建一个函数式组件 `my-component.js`

```
// my-component.js
import { useState, useEffect } from 'React'

export default () => {
  // 通过 useState 可以创建一个 状态属性 和一个赋值方法
  const [ name, setName ] = useState('')

  // 通过 useEffect 可以对副作用进行处理
  useEffect(() => {
    console.log(name)
  }, [ name ])

  // 通过 useMemo 能生成一个依赖 name 的变量 message
  const message = useMemo(() => {
    return `hello, my name is ${name}`
  }, [name])

  return <div>{ message }</div>
}
```

vue 的 `Hooks` 写法，vue 的 `Hooks` 写法依赖于 `组合式API`，因此本例采用 `<script setup>` 来写：

```
<template>
  <div>
    {{ message }}
  </div>
</template>
<script setup>
import { computed, ref } from 'vue'
// 定义了一个 ref 对象
const name = ref('')
// 定义了一个依赖 name.value 的计算属性
const message = computed(() => {
  return `hello, my name is ${name.value}`
})
</script>
```

**自定义Hooks**

react写法：

```
import React from 'react';

export const useName = () => {
  // 这个 useMemo 很关键
  const randomName = React.useMemo(() => genRandomName(), []);
  const [ name, setName ] = React.useState(randomName)

  return {
    name,
    setName
  }
}
```

vue写法：

```
import { ref } from 'vue';

export const useName = () => {
  const name = ref(genRandomName())
  const setName = (v) => {
    name.value = v
  }
  return {
    name,
    setName
  }
}
```



# CSS

## 中英文换行

- word-break:break-word
- word-wrap:break-word

# web前端导航

- [印记中文](https://docschina.org/)
- [前站导航](http://www.frontendjs.com/)
- [程序员盒子](https://www.coderutil.com/)