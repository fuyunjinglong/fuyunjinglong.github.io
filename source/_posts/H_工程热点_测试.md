---
title: 测试
date: 2022-05-04 06:33:16
categories:
- H_工程热点
toc: true # 是否启用内容索引
---

# 基本概念

**单元测试的上下文就是存在于「敏捷」当中**。敏捷为的是更快地交付有价值的可工作的软件。为此，它有一个指标来度量这个「更快」，那就是 lead time，它度量的是一个 idea 从提出被验证，到最终上生产环境面对用户的时间。显然，这个时间越短，软件获得反馈的时间就越短，对价值的验证就越快发生。

## 前言

> 我从不觉得自己是一个好的程序员，甚至可能连合格都谈不上，不过在内心深处我却渴望着在编程这件事上获得成功。
>
> 可惜每次审视自己写的暂且称之为代码的东西，都会有挫折感，想重构却又感觉盘根错节，难以下手;想重写却又感觉自己好不容易写出来的，也花了不少心思，就这样丢弃心有不甘。
>
> 也曾思考过如何才能写好代码，有段时间觉得只有严格符合编程规范的代码才是好代码进而如同遵守戒律一样地字字斟酌，还有段时间觉得只有用上设计模式才能称之优秀代码进而非模式不用，一切套用模式。不过这些都没有让我走出开发的迷雾，永远是加不完的班，修不完的bug。
>
> 先测试后开发，小步迭代，持续集成。
>
> **测试先行**，其实讲的是需求边界，测试不是漫无目的而是精确计算成本的一项活动。测试从何而来，从需求来，需求推演出测试，也规划出产品边界，不能反映需求的测试是一种浪费，因此引申出开发需要讲求适当。开发是一项功利性的活动，永远都在追求盈利，而测试就一条红线，一旦跨过就意味着亏损。
>
> **小步迭代**，“让子弹飞”中有句话很经典:步子要一步一步迈，一步迈大了，咔，容易扯着蛋。代码堆叠的后遗症是复杂，复杂到没人愿意触碰，且不停地咒骂这代码有多烂，这是步子迈太大的真实写照。TDD讲求的小步迭代是写完一个测试再去写完一个实现，每个实现都是通过测试的，如此累加小胜为大胜，最后所有代码的收尾也不过是让最后一个测试通过而已，就是这样简单。
>
> **重构**，这是我最喜欢的部分，为啥？因为这里面所有的活动都会要求你去思考，且看上去都像是让你的代码向着大师级代码前进。漂亮的代码并不是堆砌各种技巧，而是在正确的时间，正确的地点做正确的事，重构很容易实现这个目标。重构是一件让人一旦开始就会欲罢不能的事，会让开发者在整个开发阶段都能够不停地去思考、实践再思考，直到无法再添加或删除一个字母。
>
> **持续集成**，你终究是需要交付产品的，产品就是客户需要的价值，就如同厨师终究会端出客人点的大餐一样，没有哪个厨师是把所有食材罗列着呈现给你的，而是混合在一起，蒸煮炖烧，有些食材需要先处理，这样吃起来才软硬适中，而有些则是最后下锅，这样吃起来才鲜嫩多汁，厨师就是这样一步步将食材集成起来，每一步的处理都是可用都是有价值的，都是为后续进行的铺垫。软件开发也一样，持续集成就要保证每一次的完成都是有价值都可以为后续提供支撑。
>
> TDD是一个很好的思维框架，如果非要教人一个思维框架的话就得教TDD， 不然人会瞎碰，不思考，不总结，不结果导向，靠灵感编程，凭直觉设计，撞大运修bug。最糟糕的是因为没有好的习惯 会接二连三的发生灵异现象。同一道题，习惯不好的人做，总能做出无数种新问题来。而且问题套问题，给他解决要浪费 我半天时间，如果他学会了TDD出的错只在最近一个引入的变化里，就好纠正多了。甚至他自己都能纠正。
>
> TDD重要的不是测试代码本身，是解决问题的思维，也许可以泛化，哪怕没测试，如果能够做到快速验证，反馈，价值的 稳定叠加，有足够信心，也未尝不可。也许你会说测试可以cover功能，那么如果只有这一点的话，我更喜欢BDD (behavior-driven development)，因为这具有用户最终的使用价值。如果你说快速定位bug，我们我更倾向于BDD (bug-driven development，自创的)。这写都是TDD的结果导致的好处所在，而价值反馈思维才是实现TDD背后原理。 TDD驱使我们以结果导向，使得我们简单设计(并不是无设计)，日常重构我们的代码库，注重交付价值流稳定叠加。

以下几种情况可以不写单元测试：

- 业务部门不需要频繁上线，并且我有足够的人力来覆盖手工测试
- 不在意代码腐化，并且我也不做重构
- 不在意代码质量，好几个没有测试保护的 `if-else` 裸奔也不在话下，脑不好还做什么程序员
- 确有快速部署的需求，但我们不 care 质量问题，出回归问题就修

除此之外，你就需要写单元测试。如果你想随时整理重构代码，那么你需要写单元测试；如果你想有自动化的测试套件来帮你快速验证提交的完整性，那么你需要写单元测试。

## 测试分类

- 单元测试Unit
- 集成测试Integration
- 端到端测试E2E

其它的功能测试、UI 测试、界面测试只是它们中里面的一种。

[前端测试一共有哪几种？](https://www.51cto.com/article/707816.html)

## 选择测试框架

**A.远古测试框架**

> Jest 是一个“零配置”的前端测试工具，具有诸如模拟和代码覆盖之类的开箱即用特性

我们团队对采用 JEST 做前端测试的结果非常满意。它提供了一种“零配置”的开发体验，并具备诸多开箱即用的功能，比如 Mock 和代码覆盖率等。你不仅可以将此测试框架应用于 React.js 应用程序，也可以应用于其他 JavaScript 框架。Jest 经常被炒作的功能之一是用户界面的快照测试。快照测试可以作为测试金字塔上层一个很好的补充，但请记住，单元测试仍然是坚实的基础。

Jest几大好处：

- Fast 天下武功，唯快不破。确实很快，虽然实测下来跟 [Mocha 新版本](https://github.com/mochajs/mocha/blob/master/CHANGELOG.md)还是慢了些，以后找个机会再测一次。
- Opinionated 不需要你做出选择和配置，就能提供所有的东西，比如 Mock（干掉 Sinon）、Test Runner（干掉 Karma）、Matcher（干掉 Chai）、Test Coverage（内置 istanbul）
- Watch Mode 守护模式。非常注重开发者体验，能够在编码的时候帮助我们快速获得测试结果的反馈。
- Snapshot Testing 快照测试。这是值得争议的一点，前文也提到过会专门开个 issue 来讨论，在此不再赘述。

测试框架比较：

**Mocha**

> Mocha 是生态最好，使用最广泛的单测框架，但是他需要较多的配置来实现它的高扩展性。

**Ava**

> Ava 是更轻量高效简单的单测框架，但是自身不够稳定，并发运行文件多的时候会撑爆 CPU。

**Jasmine**

> Jasmine 是单测框架的“元老”，开箱即用，但是异步测试支持较弱。

**Jest**

> Jest 基于 Jasmine, 做了大量修改并添加了很多特性，同样开箱即用，但异步测试支持良好。

**Karma**

> Karma 能在真实的浏览器中测试，强大适配器，可配置其他单测框架，一般会配合 Mocha 或 Jasmine 等一起使用。

每个框架都有自己的优缺点，没有最好的框架，只有最适合的框架。

Vue和React 的默认测试框架是 Jest，Augular 的默认测试框架就是 Karma + Jasmine

**B.现代测试框架**

- vitest
- Jest
- Cypress
- WebdriverIO
- Web Test Runner
- uvu

**Jest**

[Jest](https://jestjs.io/) 通过为大多数 JavaScript 项目提供开箱即用的支持、舒适的 API（`it` 和 `expect`）以及大多数设置所需的完整测试功能（快照、模拟和覆盖率），在测试框架领域占据了主导地位。

**Cypress**

[Cypress](https://www.cypress.io/) 是基于浏览器的测试工具，是 Vitest 的补充工具之一。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。

Cypress 是著名的端到端测试工具，他们[最新的组件测试运行器](https://on.cypress.io/component) 对测试 Vite 组件有很好的支持，是测试任何在浏览器中渲染的东西的理想选择。

基于浏览器运行测试的框架，例如 Cypress, WebdriverIO 和 Web Test Runner，会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。

Cypress 的测试更加专注于确定元素是否可见，是否可以访问和交互。

**WebdriverIO**

[WebdriverIO](https://webdriver.io/) 类似于 Cypress，一个基于浏览器的替代测试运行器和 Vitest 的补充工具。它可以用作端到端测试工具以及测试 [web 组件](https://webdriver.io/docs/component-testing)。它甚至在底层使用了 Vitest 的组件，例如对于组件测试中的 [mocking and stubing](https://webdriver.io/docs/mocksandspies/)。

WebdriverIO 具有与 Cypress 相同的优点，允许你在真实浏览器中测试逻辑。然而，它使用实际的[ web 标准](https://w3c.github.io/webdriver/)进行自动化，在运行 Cypress 测试时克服了一些权衡和限制。此外，它还允许你在移动设备上运行测试，使你可以在更多环境中测试应用程序。

**Web Test Runner**

[@web/test-runner](https://modern-web.dev/docs/test-runner/overview/) 在无头浏览器中进行测试，提供与你的 Web 应用程序相同的运行环境，而不需要模拟浏览器的 API 和 DOM。虽然没有像 Cypress 那样显示用于单步执行测试的 UI，但也使得我们可以使用 devtools 在浏览器中进行调试。

**uvu**

[uvu](https://github.com/lukeed/uvu) 是一个适用于 Node.js 和浏览器的测试运行器。

## 参考

- [Vue 应用单元测试的策略与实践 01 - 前言和目标](https://blog.jimmylv.info/2018-09-19-vue-application-unit-test-strategy-and-practice-01-introduction/)
- [测试框架比较](https://cn.vitest.dev/guide/comparisons.html#webdriverio)

# TDD

## TDD与BDD

- TDD:**侧重点偏向开发**，通过测试用例来规范约束开发者编写出质量更高、bug更少的代码
- BDD:**侧重设计**，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。

## 定义

TDD （Test Driven Development）**TDD 专指 UTDD（Unit Test Driven Development），即 「单元测试驱动开发」**。

> 误解
>
> TDD = XP 的测试优先原则 + 重构，认为 TDD 只是通过单元测试来推动代码的编写，然后通过重构来优化程序的内部结构。这很容易被理解成只需要先写单元测试就可以驱动出高质量的代码

> Kent Beck：“测试驱动开发不是一种测试技术。它是一种分析技术、设计技术，更是一种组织所有开发活动的技术”。

**分析技术：** 体现在对问题域的分析，当问题还没有被分解成一个个可操作的任务时，分析技术就派上用场，例如需求分析、任务拆分和任务规划等，《实例化需求》这本书可以给予一定的帮助作用。

**设计技术：** 测试驱动代码的设计和功能的实现，然后驱动代码的再设计和重构，在持续细微的反馈中改善代码。

**组织所有开发活动的技术：** TDD 很好地组织了测试、开发和重构活动，但又不仅限于此，比如实施 TDD 的前置活动包括需求分析、任务拆分和规划活动，这使得 TDD 具有非常好的扩展性。

## TDD原则

两条规则：

- **仅在自动测试失败时才编写新代码**
- **消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化**

> 第一条规则指每次**只编写刚刚好使测试通过的代码，并且只在测试运行失败的时候才编写新的代码**，因为每次增加的代码少，即使有问题定位起来也非常快。
>
> 第二条规则指**在自动化测试的支撑下，通过重构环节消除代码的坏味道来避免代码日渐腐烂，为接下来编码打造一个舒适的环境**

## TDD口号

1. 不可运行——写一个功能最小完备的单元测试，并使得该单元测试编译失败。
2. 可运行——快速编写刚刚好使测试通过的代码，不需要考虑太多，甚至可以使用一些不合理的方法。
3. 重构——消除刚刚编码过程引入的重复设计，优化设计结构。

## TDD好处

- 控制编程过程中的忧虑感：当感觉压力越大，就越不想去做足够多的测试，对代码越不自信
- 把控编程过程中的反馈与决策之间的差距

> 如果我做了一周的规划，并且量化成一个个可操作的任务写到 to-do list，然后使用测试驱动编码，把完成的任务像这样划掉，那么我的工作目标将变得非常清晰，因为我明确工期，明确待办事项，明确难点，可以在持续细微的反馈中有意识地做一些适当的调整，比如添加新的任务，删除冗余的测试；还有一点更加让人振奋，我可以知道我大概什么时候可以完工。项目经理对软件开发进度可以更精确的把握。

## TDD的难点

- 缺乏软件质量意识

- 缺乏一定程度的程序设计能力，很难设计出高内聚低耦合、意图清晰的结构和代码。

- 缺乏分析需求并进行任务分解和规划的能力，很容易在还没开始 TDD 的时候就被打乱了节奏。

- 缺乏合适的测试环境和测试规范。

- 测试优先的习惯难以养成。

- 重构手法不熟练。

## 参考

- [测试驱动开发（TDD）总结——原理篇](https://juejin.cn/post/6844903780970921991#heading-0)

- [三角法](https://link.juejin.cn/?target=http%3A%2F%2Ffeelings-erased.blogspot.com%2F2013%2F03%2Fthe-two-main-techniques-in-test-driven.html)
- [推行TDD的思考——张逸](https://link.juejin.cn/?target=http%3A%2F%2Fagiledon.github.io%2Fblog%2F2013%2F12%2F25%2Fthought-about-applying-tdd%2F)
- [TDD(测试驱动开发)培训录-破狼](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fwhitewolf%2Fp%2F4205761.html)

# TDD-JEST

[官网](https://jestjs.io/zh-Hans/docs/getting-started)



# TDD-Vue

## Vue测试策略

|   架构层级   | 测试内容                                                     | 测试策略                                                     | 解释                                                         |
| :----------: | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|  action 层   | 1. 是否获取了正确的参数 2. 是否正确地调用了 API 3. 是否使用了正确的返回值存取回 Vuex 中 4. 业务分支逻辑 5. 异常逻辑 | 这五个业务点建议 100% 覆盖                                   | 这个层级主要包含前述 5 大方面的业务逻辑，进行测试很有重构价值 |
| mutation 层  | 是否正确完成计算                                             | 有逻辑的 mutation 要求 100%覆盖率                            | 这个层级输入输出明确，又包含业务计算，非常适合单元测试       |
|  getter 层   | 是否正确完成计算                                             | 有逻辑的 getter 要求 100%覆盖率                              | 这个层级输入输出明确，又包含业务计算，非常适合单元测试       |
| component 层 | 是否渲染了正确的组件                                         | 1. 组件的分支渲染逻辑要求 100%覆盖 2. 交互事件的调用参数一般要求 100%覆盖 3. 连接 vuex store 的容器组件不测 4.渲染出来的UI不测 | 这个层级最为复杂，还是以「代价最低，收益最高」为指导原则进行 |
|    UI 层     | 组件是否渲染了正确的样式                                     | 1. 纯 UI 不测 2. CSS 不测                                    | 这个层级以我目前理解来说测试较难稳定，成本又较高             |
|   utils 层   | 各种辅助工具函数                                             | 没有副作用的必须 100% 覆盖                                   |                                                              |

Component 层，遵循以上的两测两不测原则

- 展示型业务组件
- 容器型业务组件
- 通用 UI 组件
- 功能型组件

## Vue Test Utils

- [Vue测试实战](https://lmiller1990.github.io/vue-testing-handbook/zh-CN/#%E8%BF%99%E6%9C%AC%E6%8C%87%E5%8D%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F)

- [Vue Test Utils实战](https://v1.test-utils.vuejs.org/zh/)

- [使用 TDD 开发组件 --- Notification](https://juejin.cn/post/6844904013503152141#heading-19)
- [【element3-开发日记】手摸手教你重写 Button 组件](https://juejin.cn/post/6898959238576472077#heading-0)

# 测试解决方案落地

## 单元测试从 Jest 到 Karma+Mocha+Chai

引子：Jest 的运行环境是 JSDOM，一个伪 DOM 引擎。JSDOM 不能理解 DOM 的布局，尺寸，样式，以及浏览器的高级 API，例如 `ResizeObserver`，`matchMedia()`。我们无法在代码中避免使用它们，于是只能去 Mock 很多东西。结果，我们欺骗了我们自己写的测试。即使你达成了 100% 测试覆盖，所有测试用例都通过，还是会怀疑代码是否在真实环境中会出错…更不要提浏览器兼容性测试了。

Karma 是 Google 开发的测试运行工具。当人们无法忍受太多 Mock，他们通常会转投 Karma 然后发现它真香！你不需要再 Mock 浏览器的特性，便可获得更真实的测试结果，甚至能做浏览器兼容性测试。更重要的是，从 Jest 到 Karma 的迁移并不难。

Karma 不能单独使用。你至少需要一个测试框架（例如 Mocha）和一个断言库（例如 Chai）。

**两种工具集对比**

| Karma 系                          | Jest 系                       |                              |
| --------------------------------- | ----------------------------- | ---------------------------- |
| 测试运行环境 Test Runtime         | Chrome/Firefox/Safari/Edge/IE | JSDOM + Node.js              |
| 代码转译器 Transpiler             | TypeScript                    | TypeScript                   |
| 测试运行工具 Test Runner          | Karma                         | Jest                         |
| 测试框架 Test Framework           | Mocha/Jasmine                 | Jest                         |
| 断言库 Assertion Library          | Chai/Expect.js                | Jest                         |
| React 测试工具 React Test Utility | Enzyme/React-Testing-Library  | Enzyme/React-Testing-Library |

## 鱼与熊掌

**单元测试和集成测试选择：**

*简而言之，如果你是想踏出测试的第一步，或者想为大型项目配备足以快速上手的框架，建议使用 **Jest**。
想要灵活性高可扩展性好，那就用 **Mocha**。
想再简单点，就用 **Ava**。
想做底层的测试，用 **tape**。*

**UI测试选择：**

*简而言之，如果你想立刻着手在多个运行环境下尝试下功能测试，想要一个 all-in-one 的工具，试试 **TestCafe**。
如果你希望测试流程完整，还有强大的社区支持。**WebdriverIO** 是个不错的选择。* *如果不需要测试跨浏览器的支持性，推荐使用 **Puppeteer**。
如果你的应用没有复杂的界面和交互逻辑，比如一个全是表单和导航的系统。换言之，是相对较容易测试de的场景。可以使用 headless 浏览器工具，比如 **Casper**，高效完成测试。*