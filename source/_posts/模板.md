---
title: A_模板
date: 2023-03-11 07:33:16
categories:
- A_编码规范
toc: true # 是否启用内容索引
---

```
1.代码段
{% codeblock %}
{% endcodeblock %}

2.图片
{% img /img/20200302_1_9.png  "imgPIC'alt text'" %}

3.加粗
**加粗**

4.链接
{% link 深入理解分布式事务 http://wwwe/distributed-transaction.html [external] [title] %}

5.点点
- 风格1
- 风格2

6.换行符
末尾两个空格表示换行

7.本地图片使用服务器绝对路径
C:\Users\fuyunjinglong\AppData\Roaming\Typora\typora-user-images\
/img/

8.竖线段落
使用>回车即可
```

# Hexo目录整理

整合B_0xxx到各自目录，然后再抽取核心题目到面经

A_编码规范 

B_JavaScript

C_HTML和CSS

D_计算机网络

编译原理、网络协议

E_数据结构和算法

F_框架和类库

G_性能优化

H_设计模式

I_前端工程和热点趋势

版本控制、持续集成、nginx

J_移动端

Z_项目业务和面经

面经-H5JSCSS





# Vue2和Vue3的diff算法

diff算法一般流程：

> - 同级比较，再比较子节点
> - 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
> - 比较都有子节点的情况(核心diff)
> - 递归比较子节点

正常Diff两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行`跨层级的移动DOM`，所以Vue将Diff进行了优化，从`O(n^3) -> O(n)`，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

**Vue2中diff**

> 采用了`双端比较`的算法。
>
> 从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

**Vue3中diff**

> 借鉴了 [ivi](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flocalvoid%2Fivi)算法和 [inferno](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno)算法。
>
> 在创建VNode时就确定其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。
>
> 还运用了`动态规划`的思想求解最长递归子序列。

# 面试过程

## 我们喜欢什么样的面试者

- 基础扎实
  - 从多年的经验看，那些发展好的同学都具备扎实的基础知识
  - 比如只懂 jQuery 不懂 JavaScript 是不行的哦
  - 如果了解计算机基础会更好，因为我们将面临很多非前端技术的问题
- 主动思考
  - 被动完成任务的同学在这里进步会很慢
  - 你需要有自己的想法，而不是仅仅完成任务
- 爱学习
  - 前端领域知识淘汰速度很快，所以最好能经常学习和接触新东西
- 有深度
  - 遇到问题时多研究背后深层次的原因，而不是想办法先绕过去
  - 比如追踪某个 Bug 一直了解它本质的原因
- 有视野
  - 创新往往来自于不同学科的交集，如果你了解的领域越多，就越有可能有新想法

## 我们喜欢问的问题

以下会列出一些我们常问的问题，请提前做好准备。

需要注意的是，校招和社招的是不一样的，校招会更加关注基础知识，而社招会更加关注之前做过的项目情况。

### 项目相关

面试其实说白了就是根据一个人之前的经历，来判断出后续这人会做得怎样，如果你之前从没做成过一件事情，凭什么让别人相信你之后能做成呢？因此无论哪里的面试都会问你之前做过的项目

项目可以是多人协助开发一个产品，也可以是自己个人做过的业余应用，只需介绍 1、2 个就够了，需要注意的是 1 + 1 != 2，做了两个平庸的项目不如做了一个好项目

一般来说会问如下几方面的问题：

- 做过最满意的项目是什么？
- 项目背景
  - 为什么要做这件事情？
  - 最终达到什么效果？
- 你处于什么样的角色，起到了什么方面的作用？
- 在项目中遇到什么技术问题？具体是如何解决的？
- 如果再做这个项目，你会在哪些方面进行改善？

### 技术相关 - 1 面

技术一面主要判断对基础知识的掌握

- 描述一个你遇到过的技术问题，你是如何解决的？
  - 这个问题很常见，有没有遇到过很不常见的问题？比如在网上根本搜不到解决方法的？
- 是否有设计过通用的组件？
  - 请设计一个 Dialog（弹出层） / Suggestion（自动完成） / Slider（图片轮播） 等组件
  - 你会提供什么接口？
  - 调用过程是怎样的？可能会遇到什么细节问题？
- 更细节的问题推荐参考 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/

### 技术相关 - 2 面

技术二面主要判断技术深度及广度

- 你最擅长的技术是什么？
  - 你觉得你在这个技术上的水平到什么程度了？你觉得最高级别应该是怎样的？
- 浏览器及性能
  - 一个页面从输入 URL 到页面加载完的过程中都发生了什么事情？越详细越好
    - （这个问既考察技术深度又考察技术广度，其实要答好是相当难的，注意越详细越好）
  - 谈一下你所知道的页面性能优化方法？
    - 这些优化方法背后的原理是什么？
    - 除了这些常规的，你还了解什么最新的方法么？
  - 如何分析页面性能？
- 其它
  - 除了前端以外还了解什么其它技术么？
  - 对计算机基础的了解情况，比如常见数据结构、编译原理等

### 兴趣相关

- 最近在学什么？接下来半年你打算学习什么？
- 做什么方面的事情最让你有成就感？需求设计？规划？具体开发？
- 后续想做什么？3 年后你希望自己是什么水平？

### 主动性相关

FEX 和很多其它团队不一样，我们没有 PM 天天跟在你后面催你做事情，所以你需要自主去发现和解决问题，主动性是我们最看重的软素质之一

- 在之前做过的项目中，有没有什么功能或改进点是由你提出来的？
- 是否有参与和改进其它开源项目

## FAQ

- 公开面试题不怕面试者精心准备么？
  - 面试题大多是开放性问题，是无法准备的
  - 如果真的精心准备，在各方面都能答好，那说明做事态度认真且努力，这正是我们需要的品质，因为我们相信一个人不是一成不变的，可以不断学习和进步，只要 ta 肯努力
- 我只会 CSS/HTML，或只会 JavaScript，可以么？
  - 不行，而且很多内部项目还需要用 PHP
- 如果投递简历后 2 周都没面试消息，意味着没筛选通过么？
  - 首先，你确定简历提交到的是「Web 前端研发部」，而且我们正在招聘
  - 如果符合前面的条件，很遗憾，或许是我们招满了，或许是你暂时不适合我们部门，但这不意味着你不能改进，请继续努力
- 如果面试不过，可以提供后续发展建议么？
  - 可以，请发邮件到 [fex-hr@baidu.com](mailto:fex-hr@baidu.com) 咨询，我们会尽量抽时间回复，但不能保证回复所有人
- 有疑问如何咨询？
  - 可以在这个项目中提 Issues，或发邮件到 [fex-hr@baidu.com](mailto:fex-hr@baidu.com) 上

# 前端学习之路

- [前端架构师亲述：前端工程师成长之路的 N 问 及 回答](https://github.com/biaochenxuying/blog/issues/33)

# 计算机网络待处理

# Github

[Git 的 4 个阶段的撤销更改](https://segmentfault.com/a/1190000011969554)

[惊艳！小姐姐用动画图解 Git 的 10 大命令，这也太秀了吧！](https://github.com/biaochenxuying/blog/issues/67)

# 数据结构与算法

[JavaScript 数据结构与算法之美 - 十大经典排序算法](https://juejin.cn/post/6844903902484103182#heading-0)

## 两个变量交换

- 临时变量
- 一次加，两次减
- 复用对象
- 利用数组
- 一行代码
- ES6 的解构赋值

```
// 临时变量
var t; 
t = a; 
a = b; 
b = t;
// 一次加，两次减
a = a + b; 
b = a - b; 
a = a - b;
// 复用对象
a = { a: b, b: a }; 
b = a.b; 
a = a.a;
// 利用数组
a = [a, b]; 
b = a[0]; 
a = a[1];
// 一行代码
a = [b, b = a][0];
// ES6 的解构赋值
[a,b]=[b,a]
```

##  js 实现斐波那契数列

定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2)

解法：

> - 解法1：递归
> - 解法2：动态规划

解法1：递归

```
function f(n) {
  if (n === 1 || n === 2){
    return 1;
  } else {
    return f(n-1) + f(n-2);
  }
}
```

解法2：动态规划

```
function f(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1;
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2;
        n1 = n2;    // 往后移动一位数
        n2 = sum
    }
    return sum
}
```

## 随机生成指定长度的字符串

解法：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。

```
function randomString(n) {  
  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
  let tmp = '',i = 0,l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}
```

## 判断是否为回文

```
function checkPalindrom(str) {  
    return str == str.split('').reverse().join('');
}
```

## 数组去重

- ES6 的 Set 
- 扩展运算符（…）
- 对象数组方法去重

ES6 的 Set 

```
function dedupe(array) { 
  return Array.from(new Set(array)); 
} 
```

扩展运算符（…）

```
let arr = [1, 2, 3, 3];
let unique = [...new Set(arr)];
```

对象数组方法去重

```
function sort(arr){
    let obj = {};
    let newArr = [];
    for(let i = 0; i < arr.length; i++){
        if(!obj[arr[i]]){
            obj[arr[i]] = 1;
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
```

# 

# 
