---
title: A_模板
date: 2023-03-11 07:33:16
categories:
- A_编码规范
toc: true # 是否启用内容索引
---

```
1.代码段
{% codeblock %}
{% endcodeblock %}

2.图片
{% img /img/20200302_1_9.png  "imgPIC'alt text'" %}

3.加粗
**加粗**

4.链接
{% link 深入理解分布式事务 http://wwwe/distributed-transaction.html [external] [title] %}

5.点点
- 风格1
- 风格2

6.换行符
末尾两个空格表示换行

7.本地图片使用服务器绝对路径
C:\Users\fuyunjinglong\AppData\Roaming\Typora\typora-user-images\
/img/

8.竖线段落
使用>回车即可
```

# Hexo目录整理

整合B_0xxx到各自目录，然后再抽取核心题目到面经

A_编码规范 

B_JavaScript

C_HTML和CSS

D_计算机网络

编译原理、网络协议

E_数据结构和算法

F_框架和类库

G_性能优化

H_设计模式

I_前端工程和热点趋势

版本控制、持续集成、nginx

J_移动端

Z_项目业务和面经

面经-H5JSCSS

# 计算机网络文件目录调整

**参考**

[小林coding](https://xiaolincoding.com/)

## 基础

## HTTP篇

## TCP篇

### TCP是什么?

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

> - **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
> - **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
> - **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文

### 什么是TCP连接

定义：**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。**

> - Socket：由 IP 地址和端口号组成
> - 序列号：用来解决乱序问题等
> - 窗口大小：用来做流量控制

###  如何唯一确定一个 TCP 连接呢？

###  **为什么是三次握手？不是两次、四次？**



## IP篇

# Node

**优缺点**

> 优点
>
> - 事件驱动，通过闭包很容易实现客户端的生命活期。
> - 不用担心多线程，锁，并行计算的问题
> - V8 引擎速度非常快
> - 对于游戏来说，写一遍游戏逻辑代码，前端后端通用
>
> 缺点
>
> - nodejs 更新很快，可能会出现版本兼容
> - nodejs 还不算成熟，还没有大制作
> - nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作

# React

[必须要会的 50 道 React 面试题](https://segmentfault.com/a/1190000018604138)

# TypeScript

[TypeScript 入门教程](https://github.com/xcatliu/typescript-tutorial)

[深入理解 TypeScript](https://github.com/jkchao/typescript-book-chinese)

## 入门

### interface和type什么区别

一句话：能用 interface 实现，就用 interface , 如果不能就用 type 。

**相同点：**

> 1. 都可以描述一个对象或者函数
> 2. 都允许拓展（extends）

1.描述对象或函数

```
interface User {
  name: string
  age: number
}
 
interface SetUser {
  (name: string, age: number): void;
}

type User = {
  name: string
  age: number
};
 
type SetUser = (name: string, age: number): void;
```

2.都允许拓展（extends）

interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。

```
// interface extends interface
interface Name { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}

// type extends type
type Name = { 
  name: string; 
}
type User = Name & { age: number  };

// interface extends type
type Name = { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}

// type extends interface
interface Name { 
  name: string; 
}
type User = Name & { 
  age: number; 
}
```

**不同点：**

> 1. type 可以而 interface 不行
>    - type 可以声明基本类型别名，联合类型，元组等类型
>    - type 语句中还可以使用 typeof 获取实例的 类型进行赋值
> 2. interface 可以而type  不行
>    - interface 能够声明合并

1.type 可以而 interface 不行

```
// 基本类型别名
type Name = string
 
// 联合类型
interface Dog {
    wong();
}
interface Cat {
    miao();
}
type Pet = Dog | Cat
// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]
 
// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement('div');
type B = typeof div
```

2.interface 可以而type  不行

```
interface User {
  name: string
  age: number
}
 
interface User {
  sex: string
}
 
/*
User 接口为 {
  name: string
  age: number
  sex: string 
}
*/
```

# `instanceof`操作符

`typeof`运算符判断基本类型可以，但对引用类型无法判断(函数对象会返回`function`外，其他都返回`object`)。

**关键一句话**：`instanceof`用于检查右边变量的原型存在于左边变量的原型链上。其实它表示的是一种原型链继承的关系

> MDN描述：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置

```html
instanceof`操作符左边是一个对象，右边是一个构造函数，在左边对象的原型链上查找，直到找到右边构造函数的prototype属性就返回`true`，或者查找到顶层`null`（也就是`Object.prototype.__proto__`），就返回`false
```

```
// 手写instanceOf
function instanceOfMe(obj, Constructor) { // obj 表示左边的对象，Constructor表示右边的构造函数
 let leftP = obj.__proto__ // 取对象隐式原型
    let rightP = Constructor.prototype // 取构造函数显示原型
    // 到达原型链顶层还未找到则返回false
    if (leftP === null) {
        return false
    }
    // 对象实例的隐式原型等于构造函数显示原型则返回true
    if (leftP === rightP) {
        return true
    }
    // 查找原型链上一层
    return instanceOfMe(obj.__proto__, Constructor)
}
```

# Object.create

其实是创建对象的第三种方法，是ES5提供的，原理：将传入的对象作为原型

```
// 手写Object.create
function createObj(proto) {
    function F() {}
    F.prototype = proto
    return new F()
}
```

# `new`操作符

当我们使用`new`时，做了些什么？

1. 创建一个全新对象，并将其`__proto__`属性指向构造函数的`prototype`属性。
2. 将构造函数调用的this指向这个新对象，并执行构造函数。
3. 如果构造函数返回对象类型Object(包含Functoin, Array, Date, RegExg, Error等)，则正常返回，否则返回这个新的对象。

依然来模拟实现一下：

```javascript
function myNew (fun) {
  return function () {
    // 创建一个新对象且将其隐式原型指向构造函数原型
    let obj = {
      __proto__ : fun.prototype
    }
    // 执行构造函数
    fun.call(obj, ...arguments)
    // 返回该对象
    return obj
  }
}

function person(name, age) {
  this.name = name
  this.age = age
}
let obj = myNew(person)('chen', 18) // {name: "chen", age: 18}
```

# 手写-Promise-核心流程!!!

通俗易懂版本：

```
// 自执行函数+三个状态+then,未处理异步和边界条件
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

function MyPromise(fn) {
    const that = this
    this.state = PENDING
    // value 变量用于保存 resolve 或者 reject 中传入的值
    this.value = null

    // 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用
    that.fulfilledCallbacks = []
    that.rejectedCallbacks = []

    function resolve(value) {
         // 首先两个函数都得判断当前状态是否为等待中
        if(that.state === PENDING) {
            that.state = FULFILLED
            that.value = value

            // 遍历回调数组并执行
            that.fulfilledCallbacks.map(cb=>cb(that.value))
        }
    }
    function reject(value) {
        if(that.state === PENDING) {
            that.state = REJECTED
            that.value = value
            that.rejectedCallbacks.map(cb=>cb(that.value))
        }
    }

    // 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了
    try {
        fn(resolve,reject)
    }cach(e){
        reject(e)
    }
}

// 最后我们来实现较为复杂的 then 函数
MyPromise.prototype.then = function(onFulfilled,onRejected){
  const that = this
  // 判断两个参数是否为函数类型，因为这两个参数是可选参数
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
  onRejected = typeof onRejected === 'function' ? onRejected : e => throw e;

  // 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数
  if(this.state === PENDING) {
      this.fulfilledCallbacks.push(onFulfilled)
      this.rejectedCallbacks.push(onRejected)
  }
  if(this.state === FULFILLED) {
      onFulfilled(that.value)
  }
  if(this.state === REJECTED) {
      onRejected(that.value)
  }
}
```

# 手写-深浅拷贝

手写钱拷贝：

```
// 1. ...扩展运算符实现
let copy1 = {...{x:1}}

// 2. Object.assign实现
let copy2 = Object.assign({}, {x:1})
```

手写深拷贝：

```
// 1. JOSN.stringify()/JSON.parse()
let obj = {a: 1, b: {x: 3}}
JSON.parse(JSON.stringify(obj))

// 2. 递归拷贝
function deepClone(obj) {
  let copy = obj instanceof Array ? [] : {}
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
    }
  }
  return copy
}
```

# 使用setTimeout模拟setInterval

```
// 可避免setInterval因执行时间导致的间隔执行时间不一致
setTimeout (function () {
  // do something
  setTimeout (arguments.callee, 500)
}, 500)
```

# 手写-EventBus

```
// 组件通信，一个触发与监听的过程
class EventEmitter {
  constructor () {
    // 存储事件
    this.events = this.events || new Map()
  }
  // 监听事件
  addListener (type, fn) {
    if (!this.events.get(type)) {
      this.events.set(type, fn)
    }
  }
  // 触发事件
  emit (type) {
    let handle = this.events.get(type)
    handle.apply(this, [...arguments].slice(1))
  }
}

// 测试
let emitter = new EventEmitter()
// 监听事件
emitter.addListener('ages', age => {
  console.log(age)
})
// 触发事件
emitter.emit('ages', 18)  // 18
```

# 手写-数据双向绑定

```
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了')
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
```

# 手写-简单路由

```
// hash路由
class Route{
  constructor(){
    // 路由存储对象
    this.routes = {}
    // 当前hash
    this.currentHash = ''
    // 绑定this，避免监听时this指向改变
    this.freshRoute = this.freshRoute.bind(this)
    // 监听
    window.addEventListener('load', this.freshRoute, false)
    window.addEventListener('hashchange', this.freshRoute, false)
  }
  // 存储
  storeRoute (path, cb) {
    this.routes[path] = cb || function () {}
  }
  // 更新
  freshRoute () {
    this.currentHash = location.hash.slice(1) || '/'
    this.routes[this.currentHash]()
  }   
}
```

# 手写-JS实现图片懒加载

```
let imgs =  document.querySelectorAll('img')
// 可视区高度
let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
function lazyLoad () {
  // 滚动卷去的高度
  let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
  for (let i = 0; i < imgs.length; i ++) {
    // 图片在可视区冒出的高度
    let x = clientHeight + scrollTop - imgs[i].offsetTop
    // 图片在可视区内
    if (x > 0 && x < clientHeight+imgs[i].height) {
      imgs[i].src = imgs[i].getAttribute('data')
    } 
  }      
}
// addEventListener('scroll', lazyLoad) or setInterval(lazyLoad, 1000)
```

# 手写-rem实现原理

```
// 原始配置
function setRem () {
  let doc = document.documentElement
  let width = doc.getBoundingClientRect().width
  let rem = width / 75
  doc.style.fontSize = rem + 'px'
}
// 监听窗口变化
addEventListener("resize", setRem)
```

# 手写-AJAX

```
// 1. 简单流程

// 实例化
let xhr = new XMLHttpRequest()
// 初始化
xhr.open(method, url, async)
// 发送请求
xhr.send(data)
// 设置状态变化回调处理请求结果
xhr.onreadystatechange = () => {
  if (xhr.readyStatus === 4 && xhr.status === 200) {
    console.log(xhr.responseText)
  }
}

// 2. 基于promise实现 

function ajax (options) {
  // 请求地址
  const url = options.url
  // 请求方法
  const method = options.method.toLocaleLowerCase() || 'get'
  // 默认为异步true
  const async = options.async
  // 请求参数
  const data = options.data
  // 实例化
  const xhr = new XMLHttpRequest()
  // 请求超时
  if (options.timeout && options.timeout > 0) {
    xhr.timeout = options.timeout
  }
  // 返回一个Promise实例
  return new Promise ((resolve, reject) => {
    xhr.ontimeout = () => reject && reject('请求超时')
    // 监听状态变化回调
    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
        // 200-300 之间表示请求成功，304资源未变，取缓存
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
          resolve && resolve(xhr.responseText)
        } else {
          reject && reject()
        }
      }
    }
    // 错误回调
    xhr.onerror = err => reject && reject(err)
    let paramArr = []
    let encodeData
    // 处理请求参数
    if (data instanceof Object) {
      for (let key in data) {
        // 参数拼接需要通过 encodeURIComponent 进行编码
        paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]))
      }
      encodeData = paramArr.join('&')
    }
    // get请求拼接参数
    if (method === 'get') {
      // 检测url中是否已存在 ? 及其位置
      const index = url.indexOf('?')
      if (index === -1) url += '?'
      else if (index !== url.length -1) url += '&'
      // 拼接url
      url += encodeData
    }
    // 初始化
    xhr.open(method, url, async)
    // 发送请求
    if (method === 'get') xhr.send(null)
    else {
      // post 方式需要设置请求头
      xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8')
      xhr.send(encodeData)
    }
  })
}
```

# 手写-实现拖拽

```
window.onload = function () {
  // drag处于绝对定位状态
  let drag = document.getElementById('box')
  drag.onmousedown = function(e) {
    var e = e || window.event
    // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离
    let diffX = e.clientX - drag.offsetLeft
    let diffY = e.clientY - drag.offsetTop
    drag.onmousemove = function (e) {
      // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离
      let left = e.clientX - diffX
      let top = e.clientY - diffY
      // 避免拖拽出可视区
      if (left < 0) {
        left = 0
      } else if (left > window.innerWidth - drag.offsetWidth) {
        left = window.innerWidth - drag.offsetWidth
      }
      if (top < 0) {
        top = 0
      } else if (top > window.innerHeight - drag.offsetHeight) {
        top = window.innerHeight - drag.offsetHeight
      }
      drag.style.left = left + 'px'
      drag.style.top = top + 'px'
    }
    drag.onmouseup = function (e) {
      this.onmousemove = null
      this.onmouseup = null
    }
  }
}
```

# AST抽象语法树详解

- [AST 抽象语法树——最基础的 javascript 重点知识，99% 的人根本不了解](https://segmentfault.com/a/1190000016231512)

# Vue

## Virtual DOM 

Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。

Virtual DOM做了两件事:

> - 1、用 JS对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中；
> - 2、当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异；
> - 3、把两棵树差异应用到真实DOM上

属性key的作用：

> key的作用是尽可能的复用 DOM 元素

## Virtual DOM算法

算法实现的三个核心函数：element,diff,patch。

算法大致流程:

```
// 1. 构建虚拟 DOM
var tree = el('div', {'id': 'container'}, [
    el('h1', {style: 'color: blue'}, ['simple virtal dom']),
    el('p', ['Hello, virtual-dom']),
    el('ul', [el('li')])
])
// 2. 通过虚拟 DOM 构建真正的 DOM
var root = tree.render()
document.body.appendChild(root)
// 3. 生成新的虚拟 DOM
var newTree = el('div', {'id': 'container'}, [
    el('h1', {style: 'color: red'}, ['simple virtal dom']),
    el('p', ['Hello, virtual-dom']),
    el('ul', [el('li'), el('li')])
])
// 4. 比较两棵虚拟 DOM 树的不同
var patches = diff(tree, newTree)
// 5. 在真正的 DOM 元素上应用变更
patch(root, patches)
```

## 在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用。

建议在created中调用：

> - 能更快获取到服务端数据，减少页面 loading 时间；
> - ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

## Vuex

**核心模块：**

> State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
>
> Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
>
> Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
>
> Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
>
> Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

**为什么 Vuex 的 mutation 中不能做异步操作？**

- Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
- 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

**为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态**

- mutation 必须同步执行，我们可以在 action 内部执行异步操作
- 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）



## 双向绑定

> - Vue是单向数据流，不是双向绑定
> - Vue的双向绑定不过是语法糖，v-bind数据绑定 与 v-on处理函数绑定

## 数据响应式

[数据响应式图1](https://blog.csdn.net/forever__fish/article/details/127163227)

[数据响应式图2](https://www.jianshu.com/p/b1564296a78b)

**原理**

通过数据劫持代理+发布订阅模式来实现

**核心流程**

> 1. 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
> 2. 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
> 3. 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
> 4. 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

## vm.$set()如何解决对象属性新增问题

原理：

> - 如果目标是数组，使用 vue 实现的变异方法 splice 实现响应式
> - 如果目标是对象,判断属性存在,同时也为响应式,直接赋值
> - 如果 target 本身就不是响应式,直接赋值
> -  如果属性不是响应式,则调用 defineReactive 方法进行响应式处理

## Vue性能优化

编码阶段

> v-if 和 v-show 区分使用场景
> computed 和 watch 区分使用场景
> v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
> 事件的销毁
> 图片懒加载、路由懒加载、异步组件
> 第三方插件的按需引入
> 服务端渲染 SSR or 预渲染
> SPA 页面采用keep-alive缓存组件
> key保证唯一
> 防抖、节流
> 第三方模块按需导入
> 长列表性能优化

SEO优化

- 预渲染
- 服务端渲染SSR

打包优化

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化

用户体验

- 骨架屏
- PWA

## Vue模板编译

[Vue | 模板是如何编译的](https://juejin.cn/post/7035832002620162084#heading-0)

Vue提供两个不同构建版本：

> - `vue.js`： 完整版本，包含了模板编译的能力；
> - `vue.runtime.js`： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。

所以

> - 如果通过 `script` 标签引入 Vue，需要使用 `vue.min.js`
> - 如果使用了vue-loader,就可以只用 `vue.runtime.js`

核心流程：

> - parse解析器：将模板解析成 AST
> - optimize优化器：标记静态节点
> - generate代码生成器：将 AST 转换成“代码字符串”

## Keep-alive的理解

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

> - 一般结合路由和动态组件一起使用，用于缓存组件；
> - 常用的两个属性include/exclude，允许组件有条件的进行缓存。其中 exclude 的优先级比 include 高
> - 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。
> - keep-alive的中还运用了LRU(Least Recently Used)算法。

## Vue中SSR

**定义**

将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

**特点**

> 优点：更好的SEO、首屏加载速度更快
>
> 缺点：服务端渲染应用程序需要处于Node.js的运行环境，服务器端渲染只支持`beforeCreate`和`created`两个钩子。

## computed 和 watch 的区别和运用的场景？

- computed：是计算属性，依赖其它属性值，并且 computed 的值有**缓存**，只有它**依赖的属性值**发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
- watch：没有缓存性，更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项。

## Vue2.x组件通信方式

> 父子组件通信
>
> - 事件机制(**父->子props,子->父 `$on、$emit`)
> - 获取父子组件实例 `$parent、$children`
> - Ref 获取实例的方式调用组件的属性或者方法
> - Provide、inject (不推荐使用，组件库时很常用)
>
> 兄弟组件通信
>
> - eventBus ,也适用任意组件
>
> 跨级组件通信
>
> - Vuex
> - `$attrs、$listeners`
> - Provide、inject

## v-for和v-if不能连用

> - 因为v-for的优先级比v-if的优先级高，所以如果嵌套使用的话，每次v-for都会执行一次v-if，造成重复计算的问题，会影响性能，所以vue官方不推荐这样使用
> - 建议使用 computed，对数据先过滤

## 组件中的data为什么是一个函数？

> - 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。
> - 如果data是对象的话，对象属于引用类型，会影响到所有的实例。而函数就不影响
> - 如果是root根实例，可以使用对象，因为只有一个实例。

## vue的单向数据流

> - Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。
> - 如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

## nextTick的实现原理是什么？

> - 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。
> - nextTick主要使用了**宏任务**和**微任务**。
> - 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

## hash模式和history模式原理

> - hash 模式：
>   - \#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面
>   - 通过监听 **hashchange** 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。
> - history 模式：
>   - history 模式的实现，主要是 HTML5 标准发布的两个 API，**pushState** 和 **replaceState**，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作
> - 区别
>   - url 展示上，hash 模式有“#”，history 模式没有
>   - 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由
>   - 兼容性，hash 可以支持低版本浏览器和 IE。

## Vue-router导航守卫有哪些

- 全局前置/钩子：beforeEach、beforeResolve、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

# Vue2和Vue3的diff算法

diff算法一般流程：

> - 同级比较，再比较子节点
> - 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
> - 比较都有子节点的情况(核心diff)
> - 递归比较子节点

正常Diff两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行`跨层级的移动DOM`，所以Vue将Diff进行了优化，从`O(n^3) -> O(n)`，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

**Vue2中diff**

> 采用了`双端比较`的算法。
>
> 从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

**Vue3中diff**

> 借鉴了 [ivi](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flocalvoid%2Fivi)算法和 [inferno](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno)算法。
>
> 在创建VNode时就确定其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。
>
> 还运用了`动态规划`的思想求解最长递归子序列。