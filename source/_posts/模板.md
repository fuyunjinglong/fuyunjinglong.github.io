---
title: A_模板
date: 2023-03-11 07:33:16
categories:
- A_编码规范
toc: true # 是否启用内容索引
---

```
1.代码段
{% codeblock %}
{% endcodeblock %}

2.图片
{% img /img/20200302_1_9.png  "imgPIC'alt text'" %}

3.加粗
**加粗**

4.链接
{% link 深入理解分布式事务 http://wwwe/distributed-transaction.html [external] [title] %}

5.点点
- 风格1
- 风格2

6.换行符
末尾两个空格表示换行

7.本地图片使用服务器绝对路径
C:\Users\fuyunjinglong\AppData\Roaming\Typora\typora-user-images\
/img/

8.竖线段落
使用>回车即可
```

# Hexo目录整理

整合B_0xxx到各自目录，然后再抽取核心题目到面经

A_编码规范 

B_JavaScript

C_HTML和CSS

D_计算机网络

编译原理、网络协议

E_数据结构和算法

F_框架和类库

G_性能优化

H_设计模式

I_前端工程和热点趋势

版本控制、持续集成、nginx

J_移动端

Z_项目业务和面经

面经-H5JSCSS



# Vue

## 在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用。

建议在created中调用：

> - 能更快获取到服务端数据，减少页面 loading 时间；
> - ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

## Vuex

**核心模块：**

> State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
>
> Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
>
> Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
>
> Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
>
> Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

**为什么 Vuex 的 mutation 中不能做异步操作？**

- Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
- 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

**为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态**

- mutation 必须同步执行，我们可以在 action 内部执行异步操作
- 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）



## 双向绑定

> - Vue是单向数据流，不是双向绑定
> - Vue的双向绑定不过是语法糖，v-bind数据绑定 与 v-on处理函数绑定

## 数据响应式

[数据响应式图1](https://blog.csdn.net/forever__fish/article/details/127163227)

[数据响应式图2](https://www.jianshu.com/p/b1564296a78b)

**原理**

通过数据劫持代理+发布订阅模式来实现

**核心流程**

> 1. 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
> 2. 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
> 3. 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
> 4. 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

## vm.$set()如何解决对象属性新增问题

原理：

> - 如果目标是数组，使用 vue 实现的变异方法 splice 实现响应式
> - 如果目标是对象,判断属性存在,同时也为响应式,直接赋值
> - 如果 target 本身就不是响应式,直接赋值
> -  如果属性不是响应式,则调用 defineReactive 方法进行响应式处理

## Vue性能优化

编码阶段

> v-if 和 v-show 区分使用场景
> computed 和 watch 区分使用场景
> v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
> 事件的销毁
> 图片懒加载、路由懒加载、异步组件
> 第三方插件的按需引入
> 服务端渲染 SSR or 预渲染
> SPA 页面采用keep-alive缓存组件
> key保证唯一
> 防抖、节流
> 第三方模块按需导入
> 长列表性能优化

SEO优化

- 预渲染
- 服务端渲染SSR

打包优化

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化

用户体验

- 骨架屏
- PWA

## Vue模板编译

[Vue | 模板是如何编译的](https://juejin.cn/post/7035832002620162084#heading-0)

Vue提供两个不同构建版本：

> - `vue.js`： 完整版本，包含了模板编译的能力；
> - `vue.runtime.js`： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。

所以

> - 如果通过 `script` 标签引入 Vue，需要使用 `vue.min.js`
> - 如果使用了vue-loader,就可以只用 `vue.runtime.js`

核心流程：

> - parse解析器：将模板解析成 AST
> - optimize优化器：标记静态节点
> - generate代码生成器：将 AST 转换成“代码字符串”

## Keep-alive的理解

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

> - 一般结合路由和动态组件一起使用，用于缓存组件；
> - 常用的两个属性include/exclude，允许组件有条件的进行缓存。其中 exclude 的优先级比 include 高
> - 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。
> - keep-alive的中还运用了LRU(Least Recently Used)算法。

## Vue中SSR

**定义**

将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

**特点**

> 优点：更好的SEO、首屏加载速度更快
>
> 缺点：服务端渲染应用程序需要处于Node.js的运行环境，服务器端渲染只支持`beforeCreate`和`created`两个钩子。

## computed 和 watch 的区别和运用的场景？

- computed：是计算属性，依赖其它属性值，并且 computed 的值有**缓存**，只有它**依赖的属性值**发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
- watch：没有缓存性，更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项。

## Vue2.x组件通信方式

> 父子组件通信
>
> - 事件机制(**父->子props,子->父 `$on、$emit`)
> - 获取父子组件实例 `$parent、$children`
> - Ref 获取实例的方式调用组件的属性或者方法
> - Provide、inject (不推荐使用，组件库时很常用)
>
> 兄弟组件通信
>
> - eventBus ,也适用任意组件
>
> 跨级组件通信
>
> - Vuex
> - `$attrs、$listeners`
> - Provide、inject

## v-for和v-if不能连用

> - 因为v-for的优先级比v-if的优先级高，所以如果嵌套使用的话，每次v-for都会执行一次v-if，造成重复计算的问题，会影响性能，所以vue官方不推荐这样使用
> - 建议使用 computed，对数据先过滤

## 组件中的data为什么是一个函数？

> - 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。
> - 如果data是对象的话，对象属于引用类型，会影响到所有的实例。而函数就不影响
> - 如果是root根实例，可以使用对象，因为只有一个实例。

## vue的单向数据流

> - Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。
> - 如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

## nextTick的实现原理是什么？

> - 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。
> - nextTick主要使用了**宏任务**和**微任务**。
> - 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

## hash模式和history模式原理

> - hash 模式：
>   - \#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面
>   - 通过监听 **hashchange** 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。
> - history 模式：
>   - history 模式的实现，主要是 HTML5 标准发布的两个 API，**pushState** 和 **replaceState**，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作
> - 区别
>   - url 展示上，hash 模式有“#”，history 模式没有
>   - 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由
>   - 兼容性，hash 可以支持低版本浏览器和 IE。

## Vue-router导航守卫有哪些

- 全局前置/钩子：beforeEach、beforeResolve、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

# Vue2和Vue3的diff算法

diff算法一般流程：

> - 同级比较，再比较子节点
> - 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
> - 比较都有子节点的情况(核心diff)
> - 递归比较子节点

正常Diff两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行`跨层级的移动DOM`，所以Vue将Diff进行了优化，从`O(n^3) -> O(n)`，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

**Vue2中diff**

> 采用了`双端比较`的算法。
>
> 从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

**Vue3中diff**

> 借鉴了 [ivi](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flocalvoid%2Fivi)算法和 [inferno](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno)算法。
>
> 在创建VNode时就确定其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。
>
> 还运用了`动态规划`的思想求解最长递归子序列。

# 面试过程

## 我们喜欢什么样的面试者

- 基础扎实
  - 从多年的经验看，那些发展好的同学都具备扎实的基础知识
  - 比如只懂 jQuery 不懂 JavaScript 是不行的哦
  - 如果了解计算机基础会更好，因为我们将面临很多非前端技术的问题
- 主动思考
  - 被动完成任务的同学在这里进步会很慢
  - 你需要有自己的想法，而不是仅仅完成任务
- 爱学习
  - 前端领域知识淘汰速度很快，所以最好能经常学习和接触新东西
- 有深度
  - 遇到问题时多研究背后深层次的原因，而不是想办法先绕过去
  - 比如追踪某个 Bug 一直了解它本质的原因
- 有视野
  - 创新往往来自于不同学科的交集，如果你了解的领域越多，就越有可能有新想法

## 我们喜欢问的问题

以下会列出一些我们常问的问题，请提前做好准备。

需要注意的是，校招和社招的是不一样的，校招会更加关注基础知识，而社招会更加关注之前做过的项目情况。

### 项目相关

面试其实说白了就是根据一个人之前的经历，来判断出后续这人会做得怎样，如果你之前从没做成过一件事情，凭什么让别人相信你之后能做成呢？因此无论哪里的面试都会问你之前做过的项目

项目可以是多人协助开发一个产品，也可以是自己个人做过的业余应用，只需介绍 1、2 个就够了，需要注意的是 1 + 1 != 2，做了两个平庸的项目不如做了一个好项目

一般来说会问如下几方面的问题：

- 做过最满意的项目是什么？
- 项目背景
  - 为什么要做这件事情？
  - 最终达到什么效果？
- 你处于什么样的角色，起到了什么方面的作用？
- 在项目中遇到什么技术问题？具体是如何解决的？
- 如果再做这个项目，你会在哪些方面进行改善？

### 技术相关 - 1 面

技术一面主要判断对基础知识的掌握

- 描述一个你遇到过的技术问题，你是如何解决的？
  - 这个问题很常见，有没有遇到过很不常见的问题？比如在网上根本搜不到解决方法的？
- 是否有设计过通用的组件？
  - 请设计一个 Dialog（弹出层） / Suggestion（自动完成） / Slider（图片轮播） 等组件
  - 你会提供什么接口？
  - 调用过程是怎样的？可能会遇到什么细节问题？
- 更细节的问题推荐参考 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/

### 技术相关 - 2 面

技术二面主要判断技术深度及广度

- 你最擅长的技术是什么？
  - 你觉得你在这个技术上的水平到什么程度了？你觉得最高级别应该是怎样的？
- 浏览器及性能
  - 一个页面从输入 URL 到页面加载完的过程中都发生了什么事情？越详细越好
    - （这个问既考察技术深度又考察技术广度，其实要答好是相当难的，注意越详细越好）
  - 谈一下你所知道的页面性能优化方法？
    - 这些优化方法背后的原理是什么？
    - 除了这些常规的，你还了解什么最新的方法么？
  - 如何分析页面性能？
- 其它
  - 除了前端以外还了解什么其它技术么？
  - 对计算机基础的了解情况，比如常见数据结构、编译原理等

### 兴趣相关

- 最近在学什么？接下来半年你打算学习什么？
- 做什么方面的事情最让你有成就感？需求设计？规划？具体开发？
- 后续想做什么？3 年后你希望自己是什么水平？

### 主动性相关

FEX 和很多其它团队不一样，我们没有 PM 天天跟在你后面催你做事情，所以你需要自主去发现和解决问题，主动性是我们最看重的软素质之一

- 在之前做过的项目中，有没有什么功能或改进点是由你提出来的？
- 是否有参与和改进其它开源项目

## FAQ

- 公开面试题不怕面试者精心准备么？
  - 面试题大多是开放性问题，是无法准备的
  - 如果真的精心准备，在各方面都能答好，那说明做事态度认真且努力，这正是我们需要的品质，因为我们相信一个人不是一成不变的，可以不断学习和进步，只要 ta 肯努力
- 我只会 CSS/HTML，或只会 JavaScript，可以么？
  - 不行，而且很多内部项目还需要用 PHP
- 如果投递简历后 2 周都没面试消息，意味着没筛选通过么？
  - 首先，你确定简历提交到的是「Web 前端研发部」，而且我们正在招聘
  - 如果符合前面的条件，很遗憾，或许是我们招满了，或许是你暂时不适合我们部门，但这不意味着你不能改进，请继续努力
- 如果面试不过，可以提供后续发展建议么？
  - 可以，请发邮件到 [fex-hr@baidu.com](mailto:fex-hr@baidu.com) 咨询，我们会尽量抽时间回复，但不能保证回复所有人
- 有疑问如何咨询？
  - 可以在这个项目中提 Issues，或发邮件到 [fex-hr@baidu.com](mailto:fex-hr@baidu.com) 上

# 前端学习之路

- [前端架构师亲述：前端工程师成长之路的 N 问 及 回答](https://github.com/biaochenxuying/blog/issues/33)

# 计算机网络待处理

# Github

[Git 的 4 个阶段的撤销更改](https://segmentfault.com/a/1190000011969554)

[惊艳！小姐姐用动画图解 Git 的 10 大命令，这也太秀了吧！](https://github.com/biaochenxuying/blog/issues/67)

# 数据结构与算法

[JavaScript 数据结构与算法之美 - 十大经典排序算法](https://juejin.cn/post/6844903902484103182#heading-0)

## 两个变量交换

- 临时变量
- 一次加，两次减
- 复用对象
- 利用数组
- 一行代码
- ES6 的解构赋值

```
// 临时变量
var t; 
t = a; 
a = b; 
b = t;
// 一次加，两次减
a = a + b; 
b = a - b; 
a = a - b;
// 复用对象
a = { a: b, b: a }; 
b = a.b; 
a = a.a;
// 利用数组
a = [a, b]; 
b = a[0]; 
a = a[1];
// 一行代码
a = [b, b = a][0];
// ES6 的解构赋值
[a,b]=[b,a]
```

##  js 实现斐波那契数列

定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2)

解法：

> - 解法1：递归
> - 解法2：动态规划

解法1：递归

```
function f(n) {
  if (n === 1 || n === 2){
    return 1;
  } else {
    return f(n-1) + f(n-2);
  }
}
```

解法2：动态规划

```
function f(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1;
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2;
        n1 = n2;    // 往后移动一位数
        n2 = sum
    }
    return sum
}
```

## 随机生成指定长度的字符串

解法：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。

```
function randomString(n) {  
  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
  let tmp = '',i = 0,l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}
```

## 判断是否为回文

```
function checkPalindrom(str) {  
    return str == str.split('').reverse().join('');
}
```

## 数组去重

- ES6 的 Set 
- 扩展运算符（…）
- 对象数组方法去重

ES6 的 Set 

```
function dedupe(array) { 
  return Array.from(new Set(array)); 
} 
```

扩展运算符（…）

```
let arr = [1, 2, 3, 3];
let unique = [...new Set(arr)];
```

对象数组方法去重

```
function sort(arr){
    let obj = {};
    let newArr = [];
    for(let i = 0; i < arr.length; i++){
        if(!obj[arr[i]]){
            obj[arr[i]] = 1;
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
```

# router路由-按需加载

# router路由-hash和history
