



# 程序员副业

## 副业方向

**1、有技术的程序员**

有的中小公司会找业内的技术专家，解决某个技术问题，又或许是针对开发需求组织的团队内训，包括一些程序员培训机构，也会邀请技术专家参与课程研发，都是为你的技能付费。

并且做得好还可以打造个人IP，把自己越卖越贵，直接上升N个档次。

**2、有资源的程序员**

有机会有能力接项目来做，一方面在工作中积累了人脉和资源，另一方面自己可以组织或整合一个兼职的小团队。

所以善待身边的人，说不定下个单子就是他开给你的！

**3、有个人见解的程序员**

写技术博客，做自媒体，做短视频，分享工作经验，拆解技能……走自媒体路线，有独特个性的人会更吃香，更有甚者可以卖课、卖书，吃流量，赚稿费。

## 副业平台

记住：

> - 个人的，别想着在这种线上平台接单赚钱，线上平台能接到单赚钱的，都是专门成立了外包小公司的团队。
> - 线上接单我5年前就不玩了，当时猪八戒很火，很多程序员上面接单，但是发现付出与收获不成正比， 作为程序员线上接单不是好路子，最好是自己开发一个产品(比如小程序)，靠产品赚钱，这个钱赚的又舒服又锻炼自己成为老板
> - 做视频聚合资源app，一个月1w没问题，纯赚，容易进局子，版权问题
> - 线上接单这种挣得比较少，价格透明，竞争大。最好的是善待周围的人，扩大交际圈，说不定哪天给你介绍一单，跨行业的容易挣信息不对称的💰，利润大。

**1、程序员客栈**

国内领先的程序员自由远程工作平台，这行的应该都知道吧。灵活度高，比较自由，单子比较多，个人推荐！

**2、英选**

平台以定制开发外包服务为主，也是外包项目平台。它的项目管理方面是特色，阶段确认和及时反馈较好。

**3、Devnors**

国外的一个互联网软件定制开发与软件外包开发服务平台，英语好的朋友可以看看，它比较有意思的是平台用的是区块链技术支付。要是能接上国外的单，那还是香的！

**4、开源众包**

上面的项目以众包为主。接包方质量较好，它的协助开发工具比较完善。也是比较常见的一个网站。

# Vue3入门

## Hooks

方式三：参考大崔哥的新写法(直接赋值引用)--强烈推荐

```
// Task.vue
<script setup lang="ts">
import { ref,onBeforeMount } from 'vue';
import { initListTag } from '@/service/task'

let listTags =reactive([])
onBeforeMount(async () => {
   initListTag()
})
</script>
<template>
<div v-for="(listTag,i) in listTags" :key="'listTags'+i">{{ listTag.label }}</div>
</template>

// @/service/task.ts
import { ref } from 'vue';
import * as myapi from '@/service/myapi';

let listTags =[]

 export async function initListTag(
  listTagsReactive
) {
  // 0.初始化
  declareListTag(listTagsReactive)
  await loadTags()
}

 function declareListTag(
  listTagsReactive
) {
  // 1.初始化-变量
  listTags = listTagsReactive
}

export async function loadTags() {
  // 2.初始化-填充tags
  const tab={}
  listTags.push(createListTag(tag.name, tag.color, tag.parentTagId || undefined, tag.id))
}

export function createListTag(name, color?, parentTagId?, id = 0){
  // 3.初始化-创建tag
  return {
    id,
    name,
    color: color || '',
    parentTagId: parentTagId || null,
    loadTasks: () => {
      return myapi.getTasksByTagId(id)
    },
  }
}

export async function addListTag(tag) {
  // 添加tag等其他逻辑处理,此处可以拿到listTags变量
  const pIndex = await myapi.addTag(tag.name, tag.parentTagId, tag.color)
  if (pIndex)
    tag.id = pIndex
  listTags.push(tag)
}
```

方式四：参考大崔哥的新写法(返回值引用)

```
// User.vue
<template>
    <!-- 视图部分省略，在对应btn处引用onChangePassword和onChangeUserInfo即可 -->
   <div @click="onChangePassword"> {{userInfo}}</div>
</template>
<script setup>
import useUserControl from './useUserControl';
const { userInfo, onChangeUserInfo,onChangePassword } = useUserControl();
<script>

// @/service/useUserControl.ts
import useUser from './useUser';
const useUserControl = () => {
    // 组合用户hook
    const { userInfo, getUserInfo, changeUserInfo } = useUser();
    // 数据查询loading状态
    const loading = ref(false);
    // 初始化数据
    const initData = () => {
        getUserInfo();
    }
    // 修改密码
     const onChangePassword = () => {
    }
    onMounted(initData);
    return {
        // 用户数据
        userInfo,
        // 修改用户信息
        onChangeUserInfo: changeUserInfo,
        onChangePassword:onChangePassword
    }
}

// @/service/useUser.ts
const useUser = () => {
    // vue版本的用户状态
    const userInfo = ref({});
    // 获取用户状态
    const getUserInfo = () => {}
    // 修改用户状态
    const changeUserInfo = () => {};
    return {
        userInfo,
        getUserInfo,
        changeUserInfo
    }
}
```



# 组件库封装

## 高质量组件编写

- 组件何时拆分
- 拆分出组件文件
- 用hooks抽离组件逻辑

**组件何时拆分**

> 拆分的组件要保持功能单一。即组件内部代码的代码都只跟这个功能相关；
>
> 组件要保持较低的耦合度，不要与组件外部产生过多的交互。如组件内部不要依赖过多的外部变量，父子组件的交互不要搞得太复杂等等。
>
> 用组件名准确描述这个组件的功能。就像函数那样，可以让人不用关心组件细节，就大概知道这个组件是干嘛的。如果起名比较困难，考虑下是不是这个组件的功能并不单一。

**拆分出组件文件**

本人更推荐统一放入到component文件夹下。

> 1. 如果只是被页面内的组件复用，就放到页面文件夹下。
> 2. 如果只是在当前业务场景下的不同页面复用，就放到当前业务模块的文件夹下。
> 3. 如果可以在不同业务场景间通用，就放到最顶层的公共文件夹，或者考虑做成组件库。

```
homePage // 存放当前页面的文件夹
    |-- components // 存放当前页面组件的文件夹
        |-- componentA // 存放当前页面的组成部分A的文件夹
            |-- index.(vue|tsx) // 组件A
            |-- AChild1.(vue|tsx) // 组件a的组成部分1
            |-- AChild2.(vue|tsx) // 组件a的组成部分2
            |-- ACommon.(vue|tsx) // 只在componentA内部复用的组件
        |-- ComponentB.(vue|tsx) // 当前页面的组成部分B
        |-- Common.(vue|tsx) // 组件A和组件B里复用的组件
    |-- index.(vue|tsx) // 当前页面
```

**用hooks抽离组件逻辑**

- 方式三：参考大崔哥的新写法(直接赋值引用)--强烈推荐
- 方式四：参考大崔哥的新写法(返回值引用)

# 书单

- [awesome-book](https://github.com/fuyunjinglong/awesome-books/)

# React入门

- [当公司要求你必须会 React，Vueer 不得不学](https://juejin.cn/post/7173953093158060039#heading-3)

# JS发布订阅-极简

```
class SyncHook {
  constructor() {
    this.taps = [];
  }

  //注册监听函数，这里的name其实没啥用
  tap(name, fn) {
    this.taps.push({ name, fn });
  }

  //执行函数
  call(...args) {
    this.taps.forEach((tap) => tap.fn(...args));
  }
}
```

# webpack的Loader机制

- [【万字长文｜趣味图解】彻底弄懂Webpack中的Loader机制](https://juejin.cn/post/7157739406835580965#heading-16)

**Loader本质**

Loader 本质上是导出为函数的 JavaScript 模块。`它接收资源文件或者上一个 Loader 产生的结果作为入参，也可以用多个 Loader 函数组成 loader chain（链），最终输出转换后的结果`。

**Loader的四种类型**

分为：[前置(pre)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[普通(normal)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[行内(inline)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)、[后置(post)](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fmodule%2F%23ruleenforce)。

```
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", //将css内容变成style标签插入到html中去
          "css-loader", //解析css文件的路径等
          "less-loader", //将less=>css
        ],
        enforce: "pre", //这里也可以是post，默认不写就是normal
      },
    ],
  },
```

**Loader执行顺序**

简单说：Loader 的执行顺序是由右向左，或者由下到上执行。

官方说法：**Pitching** 阶段和**Normal** 阶段

所有一个接一个地进入的 Loader，都有两个阶段：

1. **Pitching** 阶段: Loader 上的 pitch 方法，按照 `后置(post)、行内(inline)、普通(normal)、前置(pre)` 的顺序调用。
2. **Normal** 阶段: Loader 上的 常规方法，按照 `前置(pre)、普通(normal)、行内(inline)、后置(post)` 的顺序调用。模块源码的转换， 发生在这个阶段。
3. 同等类型下的 Loader 执行顺序才是由右向左，或者由下到上执行。

# Vue模板编译流程(编译器原理)

一个编译器完整执行过程：

**Parsing(解析过程)**：这个过程要经`词法分析`、`语法分析`、`构建AST（抽象语法树）`一系列操作；

**Transformation（转化过程**）：这个过程就是将上一步解析后的内容，按照编译器指定的规则进行处理，`形成一个新的表现形式`；

**Code Generation（代码生成**）：将上一步处理好的内容`转化为新的代码`；

截图：https://juejin.cn/post/7155151377013047304#heading-4



# ES6的导入导出

- [「万字进阶」深入浅出 Commonjs 和 Es Module](https://juejin.cn/post/6994224541312483336)
- [深入 CommonJs 与 ES6 Module](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000017878394)
- [「Node.js系列」深入浅出Node模块化开发——CommonJS规范](https://juejin.cn/post/6892786383249735687)

```
/**
 * 导出
 */
export * from 'module'; //重定向导出 不包括 module内的default
export { name1, name2, ..., nameN } from 'module'; // 重定向命名导出
export { import1 as name1, import2 as name2, ..., nameN } from 'module'; // 重定向重命名导出
export { name1, name2, …, nameN }; // 与之前声明的变量名绑定 命名导出
export { variable1 as name1, variable2 as name2, …, nameN }; // 重命名导出
export let name1 = 'name1'; // 声明命名导出 或者 var, const，function， function*, class
export default expression; // 默认导出
export default function () { ... } // 或者 function*, class
export default function name1() { ... } // 或者 function*, class

/**
 * 导入
 */
import defaultExport from "module"; // 默认导入
import { a, b, c } from "module"; //解构导入
import defaultExport, { a, b, c as newC } from "module"; //混合导入
import * as name from "module"; //混合导入
var promise = import("module"); //动态导入(异步导入)
```



# axios取消请求

**方式1：AbortController**

从 `v0.22.0` 开始，Axios 支持以 fetch API 方式—— [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) 取消请求：

```js
const controller = new AbortController();
// 取消重复请求
controller.signal && controller.abort();
axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
```

**方式2：CancelToken** 

通过传递一个 executor 函数到 `CancelToken` 的构造函数来创建一个 cancel token：。

此 API 从 `v0.22.0` 开始已被弃用，不应在新项目中使用。

```js
const CancelToken = axios.CancelToken;
let cancel;
// 取消重复请求
cancel && cancel();
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});
```



# 事件冒泡和事件捕获

DOM事件流（event flow ）存在三个阶段：**事件捕获阶段、处于目标阶段、事件冒泡阶段。**

**事件捕获：**通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始**由外到内**进行事件传播。

**事件冒泡**：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。

截图：https://juejin.cn/post/6844903834075021326



# 人生规划和职业发展

**问题1：武汉是一个大城市，相比一般小县城，有以下优势和劣势：**

> 优势：
>
> 1. 经济发展水平高：武汉是湖北省的省会，也是中部地区的重要城市，拥有较为完善的产业体系和发达的经济。相比小县城，武汉的经济发展水平更高，就业机会更多。
> 2. 文化氛围浓厚：武汉是一个历史悠久的城市，有着丰富的文化底蕴和独特的文化氛围。武汉有许多著名的文化景点和历史遗迹，如黄鹤楼、古琴台、汉口江滩等，这些都是小县城所没有的。
> 3. 生活便利：武汉是一个大城市，拥有完善的基础设施和便利的生活服务。相比小县城，武汉的医疗、教育、交通等方面更加发达，居民的生活质量更高。
>
> 劣势：
>
> 1. 交通拥堵：武汉是一个大城市，交通压力较大，尤其是高峰期，交通拥堵现象比较严重。相比小县城，武汉的交通状况更为复杂，需要花费更多的时间和精力。
> 2. 空气质量差：由于武汉是一个工业城市，空气质量相对较差，尤其是冬季和雾霾天气，空气污染问题比较严重。相比小县城，武汉的环境质量更差。
> 3. 生活成本高：武汉是一个大城市，生活成本相对较高，尤其是房价和物价方面。相比小县城，武汉的生活成本更高，需要花费更多的钱。

**问题2：父母公务员对孩子的影响主要有以下几个方面：**

> 1. 教育环境：公务员家庭通常注重教育，重视孩子的学习和成长，提供更好的教育环境和资源，这对孩子的成长有积极的影响。
>
> 2. 社会关系：公务员家庭通常有更广泛的社会关系，这对孩子的人际交往和社交能力的培养有一定的帮助。
>
> 3. 安全稳定：公务员家庭通常有较为稳定的收入和职业，这对孩子的成长环境和生活条件都有一定的保障。
>
> 4. 压力和期望：公务员家庭通常对孩子的期望较高，希望孩子能够继承父母的优秀品质和成就，这可能会给孩子带来一定的压力。
>
> 总的来说，父母公务员对孩子的影响是多方面的，既有积极的方面，也有一些潜在的负面影响。但是，这些影响并不是绝对的，还要考虑具体的家庭情况和孩子的个性特点。

**问题3：中国公务员的待遇**

> 1. 薪资待遇：公务员的薪资待遇相对较高，一般比同等学历的企业员工要高。
>
> 2. 福利待遇：公务员享有较好的福利待遇，包括医疗保险、养老保险、住房公积金等。
>
> 3. 工作稳定性：公务员的工作相对稳定，一般不会出现裁员等情况。
>
> 4. 职业发展：公务员的职业发展空间相对较大，可以通过考试晋升到更高级别的职位。
>
> 需要注意的是，公务员的工作压力较大，工作时间也相对较长，同时需要承担一定的责任和义务。
>
> 一般来说，公务员晋升的年龄限制如下：
>
> 1. 初次录用的公务员，一般要求年龄在35周岁以下；
> 2. 普通公务员晋升为副科级干部，一般要求年龄在45周岁以下；
> 3. 副科级干部晋升为正科级干部，一般要求年龄在50周岁以下；
> 4. 正科级干部晋升为副县级干部，一般要求年龄在55周岁以下；
> 5. 副县级干部晋升为正县级干部，一般要求年龄在60周岁以下。
>
> 公务员的缺陷和劣势可能包括以下几点：
>
> 1. 薪资相对较低：公务员的薪资相对于同等学历和工作经验的民营企业员工来说较低，尤其是在一些发展较快的行业和地区。
>
> 2. 晋升机会较少：公务员的晋升机会相对较少，晋升的速度也比较慢，这可能会影响到个人的职业发展。
>
> 3. 工作压力大：公务员的工作压力也比较大，尤其是在一些重要的岗位上，需要承担较大的责任和压力。
>
> 4. 工作环境相对单一：公务员的工作环境相对较为单一，缺乏多样性和挑战性，可能会导致工作的单调性和乏味性。
>
> 5. 工作稳定性较高：虽然公务员的薪资相对较低，但是工作稳定性较高，相对于民营企业来说更加稳定和安全。
>
> 总的来说，公务员的缺陷和劣势与个人的职业发展和价值观有关，需要根据自身情况进行权衡和选择。

**问题4：放弃程序员高薪，专职去考取国家公务员，合适吗**

> 这个问题的答案取决于你的个人情况和目标。如果你对公务员职业有浓厚的兴趣，并且相信这是你实现自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。
>
> 在做出这个决定之前，你需要考虑以下几个因素：
>
> 1. 薪资：一般来说，程序员的薪资比国家公务员高。如果你更看重薪资，那么选择程序员工作可能更适合你。
>
> 2. 工作内容：程序员工作需要具备一定的技术能力和创造力，需要不断学习和更新知识。而国家公务员的工作内容相对稳定，需要具备一定的组织协调和管理能力。如果你更喜欢挑战和创造，那么选择程序员工作可能更适合你。
>
> 3. 工作环境：程序员工作一般在IT公司或科技企业中，工作环境比较自由，注重创新和团队合作。而国家公务员的工作环境相对稳定，注重规范和纪律。如果你更喜欢自由和创新，那么选择程序员工作可能更适合你。
>
> 4. 职业发展：程序员工作有很多不同的职业发展路径，可以成为技术专家、项目经理、创业者等。而国家公务员的职业发展路径相对单一，主要是晋升到更高级别的公务员。如果你更看重职业发展和多元化选择，那么选择程序员工作可能更适合你。
>
> 综上所述，如果你认为公务员职业是符合自己职业和个人目标的最佳途径，那么这个决定就是合适的。但是，如果你只是因为放弃程序员高薪而考虑公务员职业，那么这个决定可能不是最明智的选择。
>
> 这个问题的答案取决于个人的价值观和职业规划。如果你认为成为国家公务员是实现个人价值和职业规划的最佳途径，那么这个决定就是合适的。但是，需要注意的是，放弃高薪的程序员职业，转而成为国家公务员，可能会对个人的经济状况产生影响。因此，在做出这个决定之前，需要仔细考虑自己的职业规划和生活需求，并做好充分的准备。
>
> 这是一个非常棘手的问题，需要你自己权衡利弊并做出决定。首先，你需要考虑自己的职业兴趣和发展方向，如果你对公务员这个职业没有兴趣，那么转行可能会让你感到不满和失落。其次，你需要考虑你和女朋友的关系，如果你们的感情很深，你可以考虑妥协，但是如果你们的感情并不牢固，你需要好好考虑是否值得为了她的要求而放弃自己的职业发展。最后，你需要考虑你们未来孩子的教育和成长，公务员这个职业相对稳定，但是也有一定的局限性，你需要好好权衡。 总之，这是一个需要你自己做出决定的问题，你需要考虑自己的职业兴趣、个人发展、感情关系和未来孩子的教育等多个方面，做出最合适的决定。

# vue与react比较

## Hooks

- [浅谈：为啥vue和react都选择了Hooks](https://juejin.cn/post/7066951709678895141#heading-1)

**定义**

"hooks" 直译是 “钩子”，它并不仅是 `react`，甚至不仅是前端界的专用术语，而是整个行业所熟知的用语。通常指：

> 系统运行到某一时期时，会调用被注册到该时机的回调函数。

以 `react` 为例，`hooks` 是：

> 一系列以 `“use”` 作为开头的方法，它们提供了让你可以完全避开 `class式写法`，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。

而在 `vue` 中， `hooks` 的定义可能更模糊，姑且总结一下：

> 在 `vue` 组合式API里，以 `“use”` 作为开头的，一系列提供了组件复用、状态管理等开发能力的方法。

**命名规范和指导思想**

在 `react` 官方文档里，对 `hooks` 的定义和使用提出了 **“一个假设、两个只在”** 核心指导思想。

> **一个假设：** 假设任何以 「`use`」 开头并紧跟着一个大写字母的函数就是一个 `Hook`。
>
> **第一个只在：** 只在 `React` 函数组件中调用 `Hook`，而不在普通函数中调用 `Hook`。（`Eslint` 通过判断一个方法是不是大坨峰命名来判断它是否是 `React` 函数）
>
> **第二个只在：** 只在最顶层使用 `Hook`，而不要在循环，条件或嵌套函数中调用 Hook。
>
> 因为是约定，因而 `useXxx` 的命名并非强制，你依然可以将你自定义的 `hook` 命名为 `byXxx` 或其他方式，但不推荐。

**为什么我们需要 `hooks` ?**

- 更好的代码组织
- 更好的逻辑复用

**如何开始玩 `hooks`** 

react 的 `Hooks` 写法，因为 react Hooks 仅支持“函数式”组件，因此需要创建一个函数式组件 `my-component.js`

```
// my-component.js
import { useState, useEffect } from 'React'

export default () => {
  // 通过 useState 可以创建一个 状态属性 和一个赋值方法
  const [ name, setName ] = useState('')

  // 通过 useEffect 可以对副作用进行处理
  useEffect(() => {
    console.log(name)
  }, [ name ])

  // 通过 useMemo 能生成一个依赖 name 的变量 message
  const message = useMemo(() => {
    return `hello, my name is ${name}`
  }, [name])

  return <div>{ message }</div>
}
```

vue 的 `Hooks` 写法，vue 的 `Hooks` 写法依赖于 `组合式API`，因此本例采用 `<script setup>` 来写：

```
<template>
  <div>
    {{ message }}
  </div>
</template>
<script setup>
import { computed, ref } from 'vue'
// 定义了一个 ref 对象
const name = ref('')
// 定义了一个依赖 name.value 的计算属性
const message = computed(() => {
  return `hello, my name is ${name.value}`
})
</script>
```

**自定义Hooks**

react写法：

```
import React from 'react';

export const useName = () => {
  // 这个 useMemo 很关键
  const randomName = React.useMemo(() => genRandomName(), []);
  const [ name, setName ] = React.useState(randomName)

  return {
    name,
    setName
  }
}
```

vue写法：

```
import { ref } from 'vue';

export const useName = () => {
  const name = ref(genRandomName())
  const setName = (v) => {
    name.value = v
  }
  return {
    name,
    setName
  }
}
```



# CSS

## 中英文换行

- word-break:break-word
- word-wrap:break-word

# web前端导航

- [印记中文](https://docschina.org/)
- [前站导航](http://www.frontendjs.com/)
- [程序员盒子](https://www.coderutil.com/)

# Flow静态类型检测器

- [Flow官网](https://flow.org/en/docs/install/)
- [Flow中文网](https://zhenyong.github.io/flowtype/docs/getting-started.html#_)
- [Flow中文攻略](https://flowjs.judysocute.com/startup/installation)

## 安装编译器

首先，你需要一个编译器来剔除`Flow`的类型注解。你可以选择`Babel`或`flow-remove-types`.

### Babel

`Babel`是一个支持`Flow`的`Javascript`编译器。`Babel`我们通俗的理解就是把现在浏览器不支持的新特性（比如：ES6）转换为可以支持的ES5语法，从而使我们能在项目中体测新标准带来的福利。`Babel`使用我们`Flow`代码，并剔除所有的类型注解。

首先得安装 `babel-cli` 或 `babel-preset-flow`

npm环境

```undefined
npm install --save-dev babel-cli babel-preset-flow
```

新建一个 `.babelrc`文件，并在 `presets`属性里设置 `flow`

```javascript
{
  "presets": ["flow"]
}
```

如果你的源代码在 `src` 目录里，你可以将这些代码编译到另一个目录中

npm环境

```undefined
./node_modules/.bin/babel src/ -d lib/
```

当然，在 `package.json`配置运行

```javascript
{
  "name": "my-project",
  "main": "lib/index.js",
  "scripts": {
    "build": "babel src/ -d lib/"
  }
}
```

### flow-remove-types

`flow-remove-types`是一个简单去掉类型注释的命令行工具，他是一个不需要 `Babel` 支持的轻量级代替 `Babel`的工具。

首行安装 `flow-remove-types`

```undefined
npm install --save-dev flow-remove-types
```

如果你的源代码在 `src` 目录里，你可以将这些代码编译到另一个目录中

```undefined
./node_modules/.bin/flow-remove-types src/ -d lib/
```

在 `package.json`配置运行

```javascript
{
  "name": "my-project",
  "main": "lib/index.js",
  "scripts": {
    "build": "flow-remove-types src/ -d lib/"
  }
}
```

## 安装 Flow

把`npm`包安装到`devDependency`上

```undefined
npm install --save-dev flow-bin
```

在 `package.json` 的 `scripts` 里添加 `"flow"`

```javascript
{
  "name": "my-flow-project",
  "version": "1.0.0",
  "devDependencies": {
    "flow-bin": "^0.86.0"
  },
  "scripts": {
    "flow": "flow"
  }
}
```

首先运行

```undefined
npm run flow init
```

在第一次运行了 `init` 后，运行

```undefined
npm run flow
```

/src/index.js

```
// @flow
function square(n: number): number {
  return n * n;
}

square(2);


```



# CSS

## CSS实现节流

实现过程：

1. 函数节流是一个非常常见的优化方式，可以有效避免函数过于频繁的执行
2. CSS 的实现思路和 JS 不同，重点在于在于找到和该场景相关联的属性
3. CSS 实现“节流”其实就是控制一个动画的精准控制，假设有一个动画控制按钮从**禁用**->**可点击**的变化，每次点击时让这个动画重新执行一遍，在执行的过程中，一直处于**禁用**状态，这样就达到了“节流”的效果
4. 还可以通过 transition 的回调函数动态设置按钮禁用态
5. 这种实现的好处在于禁用逻辑和业务逻辑是完全解耦的

```
<button onclick="console.log('保存1')">我是“普通”保存</button>
<button class="throttle" onclick="console.log('保存2')">我是“节流”保存</button>

  body{
    display: grid;
    place-content: center;
    height: 100vh;
    margin: 0;
    gap: 15px;
    background: #f1f1f1;
}
button{
  user-select: none;
}
.throttle{
  opacity: .99;
  transition: opacity 2s;
}
.throttle:not(:disabled):active{
  opacity: 1;
  transition: 0s;
}

document.addEventListener('transitionstart', function(ev){
      ev.target.disabled = true
    })
    document.addEventListener('transitionend', function(ev){
      ev.target.disabled = false
    })
```



## 优秀代码实践

### 巧用not选择器

> 有些情况下`所有`的元素都需要某些样式，唯独`最后一个`不需要，这时候使用not选择器将会特别方便

```
li:not(:last-child){
  border-bottom: 1px solid #ebedf0;
}
```

### 使用flex布局实现智能固定底部

> 内容不够时，`规则说明`要处于底部，内容足够多时，`规则说明`随着内容往下沉，大家一定也遇到过类似的需求，使用flex巧妙实现布局。

```
<div class="container">
  <div class="main">我是内容区域</div>
  <div class="footer">规则说明</div>
</div>

 .container{
  height: 100vh;
  /* 关键css处 */
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.main{
  /* 关键css处 */
  flex: 1;
  background-image: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
}
.footer{
  padding: 15px 0;
  text-align: center;
  color: #ff9a9e;
  font-size: 14px;
}
```

### 画三角形

```
<div class="box">
  <div class="box-inner">
    <div class="triangle bottom"></div>
    <div class="triangle right"></div>
    <div class="triangle top"></div>
    <div class="triangle left"></div>
  </div>
</div>

.triangle {
  display: inline-block;
  margin-right: 10px;
  /* 基础样式 */
  border: solid 10px transparent;
}
  /*下*/
.triangle.bottom {
  border-top-color: #0097a7;
}
  /*上*/
.triangle.top {
  border-bottom-color: #b2ebf2;
}
/*左*/
.triangle.left {
  border-right-color: #00bcd4;
}
/*右*/
.triangle.right {
  border-left-color: #009688;
}
```

### 画小箭头

```
<div class="box">
  <div class="box-inner">
    <div class="arrow bottom"></div>
    <div class="arrow top"></div>
    <div class="arrow right"></div>
    <div class="arrow left"></div>
  </div>
</div>

.arrow {
    display: inline-block;
    margin-right: 10px;
    /* 基础样式 */
    width: 0;
    height: 0;
    /* 基础样式 */
    border: 16px solid;
    border-color: transparent #CDDC39 transparent transparent;
    position: relative;
  }

  .arrow::after {
    content: "";
    position: absolute;
    /* 通过位移覆盖背景 */
    right: -20px;
    top: -16px;
    border: 16px solid;
    border-color: transparent #fff transparent transparent;
  }
  /*下*/
  .arrow.bottom {
    transform: rotate(270deg);
  }
  /*上*/
  .arrow.top {
    transform: rotate(90deg);
  }
  /*左*/
  .arrow.left {
    transform: rotate(180deg);
  }
  /*右*/
  .arrow.right {
    transform: rotate(0deg);
  }
```

### 禁止选择文本

```
user-select: none;
```

### 文本超出

单行文本超过部分显示省略号

```
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

多行文本超过部分显示省略号

```
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
word-break: break-all;
```

若使用vue，则可使用下面这种方式

```
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
overflow: hidden;
word-break: break-all;
```

### 网页呈现哀悼模式

```
body{
  filter: grayscale(1);
}
```



# JS

## 为什么要**用setTimeout来模拟setInterval的行为**？

这里用setInerval不是更方便吗？

```
setTimeout(function(){··· }, n); // n毫秒后执行function
setInterval(function(){··· }, n); // 每隔n毫秒执行一次function
```

可以看看setInterval有什么缺点：

> 再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。

```
setInterval(function, N)  
//即：每隔N秒把function事件推到消息队列中
```

截图:https://www.vue-js.com/topic/61e13ee5cbbfd1003b11f98b

上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果。

综上所述，setInterval有两个缺点：

1. 使用setInterval时，某些间隔会被跳过；
2. 可能多个定时器会连续执行；

可以这么理解：**每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)**。因而我们一般用setTimeout模拟setInterval，来规避掉上面的缺点。

# 后台给你10w数据

https://www.vue-js.com/topic/61e56bd4cbbfd1003b11fa09

# Vue3

[Vue3的漏洞](https://www.vue-js.com/topic/61e622a4cbbfd1003b11fa19)

[前端框架设计理念与趋势](https://juejin.cn/post/7123178292865155102#heading-0)

## 常用的周边生态轮子

**PC UI**

- Element Plus
- Ant Design Vue
- Echarts
- Quasar
- Vuetify
- NativeUI
- Prime Vue

**Mobile UI**

- Ionic Vue
- Vant
- Varlet

**国际化**

- vue-i18n
- i18next

**其他生态**

- VueUse：针对vue3 composition api的工具库
- lodash.js
- moment:解析、校验、操作、显示日期和时间
- validator.js：表单验证
- nuxt3
- Animate.css：动画库
- mescroll.js：滚动插件
- swiper：轮播图
- day.js
- vue-draggable：拖拽
- vue-qr：生成二维码
- vue-cropper：图片裁剪
- vue-lazyload：图片懒加载
- clipboard.js：复制粘贴

# 设计模式

《JavaScript设计模式与开发实践》

《JavaScript设计模式核⼼原理与应⽤实践》

**其他**

https://github.com/mynane/PDF/blob/master/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.pdf

https://tb-tech.oss-cn-hangzhou.aliyuncs.com/The%20Complete%20Works%20of%20Tao%20Technology%202022.pdf

**发布订阅模式**

通俗理解：

> 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。
>
> 小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。

有三个要点：

- `发布者`：dep 对象
- `缓存列表`：dep.subscribers
- `发布消息`：dep.notify()

1. 首先要指定好谁充当发布者（比如售楼处）
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）

# gupiao

ETF的T+0交易
主要分为两种：直接T+0和变相T+0。
1.当前跨境ETF（恒生国企ETF、恒生ETF）、债券ETF、黄金ETF、货币ETF基本都可以实现直接T+0交易。
2、变相T+0，是指T日买入的ETF虽然T日不可以卖出，但却可以T日赎回，赎回得到的份额T日可以卖出。反之，T日买入的股票T日可以申购ETF份额，申购得到的份额可以T日卖出。比如上证50ETF

集合竞价
9:15—9:20：这五分钟是开放式集合竞价，可以委托买进和卖出的单子。这段时间是可以撤单的，因此这个时间段你看到的活跃个股的成交量基本上都是假的，因为很多大单是故意挂的，他们会在9:19:30之后撤单，根据开盘价的最大成交量原则，撤单后成交量最大的价格会被打下来很多。

9:20—9:25：这个时间段交易所接受申报，同样可以委托买进和卖出的单子，但是不可以撤单，因此这个时间段你看到的委托单子是真实的。但是!成交价未必，别忘了开盘价的形成是最大成交量原则，如果真正的大资金想要出货，他会在9:24:30之后挂真正的大卖单，价格会瞬间被打下来很多

9:25—9:30：新规则之后，这个时间段交易所不接受买卖申报和撤单。但是，在交易软件你依然可以下单，只是这个委托暂时会被存放到券商的系统里，等到9:30开盘之后，券商会按照下单的时间传送到交易所。

14:57-15:00：深市的股票在这个阶段进行集合竞价形成收盘价，这个时间只能接受买进和卖出申报，不能撤单。

# Webpack

[掘金站内 webpack 优秀文章汇总](https://juejin.cn/post/6844903986185650190)

# Vue Test Utils

- [使用 TDD 开发组件 --- Notification](https://juejin.cn/post/6844904013503152141#heading-19)
- [【element3-开发日记】手摸手教你重写 Button 组件](https://juejin.cn/post/6898959238576472077#heading-0)

# SolidJS

## SolidJS是什么

号称支持现代前端特性：**JSX**、**Fragments**、**Context**、**Portals**、**Suspense**、**Streaming SSR**、**Error Boundaries**、**并发渲染**等现代功能。

又一个摒弃 虚拟DOM，跟 Svelte 一样走编译型路线的框架，没了虚拟DOM 运行时，又通过优秀的响应式系统保证更新颗粒度非常小，性能爆表。和 Svelte 不同的是 Solid 直接借用了 React 社区的 JSX 来编写模板，没有像 Vue Svelte 那样去自定义模板语法。总体来讲 React 有的 API 大部分都能在它里面找到，甚至包括 React 18 的 useTransition，SuspenseList. 另外不提供 Class 组件玩法，所有的组件都是函数组件，且该组件函数只会执行一次。内置了 For 组件来替代 map 来优化性能。支持自定指令等

## 使用

```
import { render } from 'solid-js/web';
import { createSignal, createEffect } from 'solid-js';

const Counter = () => {
  const [getCount, setCount] = createSignal(0);
  const add = () => setCount(getCount() + 1);
  createEffect(() => {
    console.log('count is change:', getCount());
  });

  return (
    <button type='button' onClick={add}>
      {getCount()}
    </button>
  );
};

render(() => <Counter />, document.getElementById('root'));
```

**SolidJS**不仅打包体积小，性能也是 **Number 1**

参照[js-framework-benchmark](https://link.juejin.cn/?target=https%3A%2F%2Fkrausest.github.io%2Fjs-framework-benchmark%2Findex.html) 跑分结果：截图https://juejin.cn/post/7018846783203704863#heading-1

## 特点

### 平衡了 jsx 与 template 的利弊

**jsx** 和 **template** 的优缺点：

> jsx
>
> - 优点：作为`js`的语法糖拥有高度灵活性，可以随意编写
> - 缺点：因为过于灵活在 **编译阶段** 很难分析操作意图
>
> template
>
> - 优点：因为语法有限制，大部分带有 **操作意图（v-if、v-for）** 的代码都可以在 **编译阶段**被识别以做优化
> - 缺点：写法受限，大部分情况下不如`jsx`灵活

**Vue3** 对比 **Vue2** 性能之所以实现了一个质的飞跃，这其中就离不开 **编译阶段优化**。

> 1、 比如在**编译阶段**标记出`template`中永远不会变化的节点作为**静态节点**存储，将来更新时直接绕过他们；
>
> 2、提前对`v-if、v-for`这一类**区块**做区分，将来diff时绕过不必要的判断；
>
> 3、绑定`props`时记录哪些**属性**可能会变，将来 **diff** 时只对比“可能会变化的动态节点和属性”，跳过“永远不会变化的节点和属性”。
>
> 除此之外还有**缓存事件处理程序**等等

但JSX就不能识别操作意图，主要是写法太灵活。如果每种情况都去判断一遍，那么 **编译阶段** 将会非常复杂且耗时，另外显得也非常麻瓜。

```
v-if的写法就有三种：
// 写法1
return status === 1 ? <span>通过</span> : status === 2 ? <span>拒绝</span> : null;
// 写法2
return (
  <>
    {status === 1 && <span>通过</span>}
    {status === 2 && <span>拒绝</span>}
  </>
);
// 写法3
switch (status) {
  case 1:
    return <span>通过</span>;
  case 2:
    return <span>拒绝</span>;
}
```

**SolidJS** 采用的方案是：在 **JSX** 的基础上做了一层规范，中文译名为 [控制流](https://link.juejin.cn/?target=https%3A%2F%2Fwww.solidjs.com%2Fdocs%2Flatest%2Fapi%23%E6%8E%A7%E5%88%B6%E6%B5%81)。写法上类似某种预设的组件，用于**编译阶段**优化。这样在**编译阶段**就可以做**意图分析**，提前知道这是在**做按条件渲染**，然后编译成对应的**dom操作**即可。

SolidJS小结：

> - 即借鉴了 **template** 更容易做编译阶段优化的优势
> - 又保留了 **JSX** 的灵活性

### No Dom Diff

**No Dom Diff** 是说 **SolidJS**在**更新粒度**方面，摒弃了**虚拟dom**，采用**节点级更新**。

目前前端主流的几种方案：

- 应用级更新：状态更新会引起整个应用`render`，具体渲染哪些内容取决于**协调**的结果。代表作有 **React**(因为 **React** 每次更新都会重新走一遍更新流程，做这些限制是为了获取到完整的**VDom树/Fiber树**，通过 **diff新旧两棵树**来决定真正更新哪些组件，所以 **React** 并不是**组件级更新**)
- 组件级更新：状态更新时只会引起绑定了该状态的组件渲染，具体渲染哪些内容同样取决于**协调**的结果。代表作有**vue2.x**
- 节点级更新：状态更新时直接触法绑定该状态的节点更新，也就是**指向型更新**。代表作有**vue1.x**、**Svelte**、**SolidJS**

而**SolidJS**对于三大对象均采用**简单对象**存储，另外不需要**递归观察**，所以占用内存非常少。对于**如何更新dom**，具体的做法是：在**编译阶段**提前生成类似 `insert`、`update`、`delete`的**dom操作**方法，将来更新时直接调用。

### 重·编译时

- 提前生成节点渲染方法

刚才说到 **SolidJS** 在 **jsx** 中借鉴了部分 **template** 的规范写法，在编译阶段 **分析意图**，提前生成对应的**dom操作方法**

- 按需打包，缩小体积

这一步也就是 **tree-shaking**，只打包用到的模块，近一步缩小打包资源体积。

### 轻·运行时

由于没有了**diff**这一大规模计算，使得运行时代码更轻量，所以**SolidJS**在更新时也更**简洁**。

**SolidJS** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

**React v16** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

### 不被顺序限制的 hook

说到前端框架中的 **Hook**，最先将这个方案落地的是**React**，但由于**React**一直推崇 **immutable** 思想，每次更新必须重新走一遍整个树的更新流程，使得 **React Hook** 不可以在条件循环中使用，否则**可能**使渲染结果受到影响。

后来尤大发布了**Vue3.0**，伴随而来的一大特性是**Composition API**，俗称**Vue3 hook**，由于**Vue2**以后都采用**组件级**的**更新粒度**，再加上**响应式原理**采用的是**自动收集依赖**，所以**Vue3 hook**不会有顺序/条件的限制，另外还可以嵌套使用。

**SolidJS**的**响应式原理**主要借鉴了**React Hook**的思想，同时也保留了**Vue3**的**依赖收集模型**，所以用起来非常丝滑。

### 其他

- 脚手架：**degit**，内部集成了 **vite**。
- 支持`TS`且**类型**友好
- 现代前端框架大部分特性：`Fragments`、`Portals`、`Context`、`Suspense`、`事件委托`、`SSR`等等

**参考**

- [比React还Vue3的框架SolidJS](https://juejin.cn/post/7018846783203704863#heading-1)

# Vue与React

## 心智负担

**React的心智负担**

不能在条件语句中使用，`useMemo` 和 `useCallback` 需要显式指定依赖，解决子组件重新渲染可能还需要配合 `React.memo` 使用等等。虽然有对应的 `eslint-plugin` 可以帮助填充依赖，但是依赖项一旦很多，代码的可能读会非常差。现在普遍的观点是计算量大的再用 `useMemo`, 而 `useCallback` 能不用就不用。因为这点优化对性能的影响是微乎其微的，99% 的情况下都不会出现问题，等到出现问题的时候再进行优化也不迟。

**Vue的心智负担**

> 定义状态

ref定义的变量使用时，需要.value。虽然有了 `$ref` 语法糖，但最新已经废弃了。解构 `props` 也会出现响应丢失的问题，还要使用 `toRefs` 来解决。

> 插槽

因为在 `react` 中万物皆 `props`。Vue中需要具名插槽和作用于插槽等。

> props 和 emits 的定义

属性 和 事件 还需要分成 defineProps 和 defineEmits 两个 api。反观 react，还是万物皆 props 。

> 侦听 watch

watch监听对象里的某个属性时，第一个参数还需要是一个函数。还分为好多种，watch、watchPostEffect、watchSyncEffect、watchEffect。watch 的第三个参数又有很多属性。

> 渲染函数

`vue3` 提供了一个 `h` 函数，但还是很难用,还不如tsx。

> typescript 支持

存在语法限制。给 `defineProps` 定义的 ts 类型，不能从其它文件导入，只能写在这个文件里。想分开写到别的文件，只能不使用 ts 来定义类型，要使用 `defineProps` 的第一个参数来指定类型，这样才能从别的文件导入了。这就是为什么大多数组件库没有使用 ts 来定义类型的原因，这样定义的类型要用 `ExtractPropTypes` 来提取 ts 类型。

> breaking change

`vue2` 升级到 `vue3` 是不兼容的，旧项目升级是很麻烦的。反观 `react`，几乎是没什么影响。

# Vue3源码

**生态整理**

> **构建工具**： nuxt3: 一款基于`Vue3`的混合开发框架。 vite: 前端开发与构建工具.
>
> **工具库**： vueuse: 针对vue3 composition api的工具库。
>
> **路由管理库**： vue-router4
>
> **状态管理库**： pinia
>
> ------
>
> **组件库**:
>
> **UI框架**: [element plus](https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2F)、[ant design vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.antdv.com%2F)、[quasar](https://link.juejin.cn?target=https%3A%2F%2Fquasar.dev%2F)、[vuetify3beta](https://link.juejin.cn?target=https%3A%2F%2Fnext.vuetifyjs.com%2Fen%2Fgetting-started%2Finstallation%2F)、[naive ui](https://link.juejin.cn?target=https%3A%2F%2Fwww.naiveui.com%2Fen-US%2Fos-theme)、[prime vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.primefaces.org%2F)
>
> **移动端**: [ionic](https://link.juejin.cn?target=https%3A%2F%2Fionicframework.com%2F)、[vant](https://link.juejin.cn?target=https%3A%2F%2Fyouzan.github.io%2Fvant%2F%23%2Fen-US)、[varlet](https://link.juejin.cn?target=https%3A%2F%2Fmadewithvuejs.com%2Fvarlet-ui)、[nutui](https://link.juejin.cn?target=https%3A%2F%2Fnutui.jd.com%2F%23%2Fstart)、[waveui](

# Vite性能优化

[记一次Vite打包优化](https://developer.aliyun.com/article/1166403)

三部曲：

- Network 分析
- Lighthouse 分析
- Bundle 分析

# 数据结构-1亿数据中访问某数据

先来看一下都有哪些题目：

- 如何从大量的 URL 中找出相同的 URL？（百度）
- 如何从大量数据中找出高频词？（百度）
- 如何找出某一天访问百度网站最多的 IP？（百度）
- 如何在大量的数据中找出不重复的整数？（百度）
- 如何在大量的数据中判断一个数是否存在？（腾讯）
- 如何查询最热门的查询串？（腾讯）
- 如何统计不同电话号码的个数？（百度）
- 如何从 5 亿个数中找出中位数？（百度）
- 如何按照 query 的频度排序？（百度）
- 如何找出排名前 500 的数？（腾讯）

答案呢？往下看~

## 1. 如何从大量的 URL 中找出相同的 URL？

**题目描述**

给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。

**解答思路**

每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。

> 5,000,000,000 * 64B ≈ 5GB * 64 = 320GB

由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用**分治策略**，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。

**思路如下**：

首先遍历文件 a，对遍历到的 URL 求 `hash(URL) % 1000`，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。

接着遍历 ai( `i∈[0,999]`)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。

**方法总结**

1. 分而治之，进行哈希取余；
2. 对每个子文件进行 HashSet 统计。

## 2. 如何从大量数据中找出高频词？

**题目描述**

有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。

**解答思路**

由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用**分治策略**，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。

**思路如下**：

首先遍历大文件，对遍历到的每个词x，执行 `hash(x) % 5000`，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。

接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 `map.put(x, 1)`；若存在，则执行 `map.put(x, map.get(x)+1)`，将该词频数加 1。

上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个**小顶堆**来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个**小顶堆**，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为**小顶堆**，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 3. 如何找出某一天访问百度网站最多的 IP？

**题目描述**

现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。

**解答思路**

这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。

> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 4. 如何在大量的数据中找出不重复的整数？

**题目描述**

在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

**解答思路**

**方法一：分治法**

与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。

**方法二：位图法**

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 `[0,7]` 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0
复制代码
```

然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：

```
0 0 0 0 1 0 1 0
复制代码
```

依次遍历，结束后，位数组是这样的：

```
0 1 1 0 1 1 1 0
复制代码
```

每个为 1 的位，它的下标都表示了一个数：

```arduino
for i in range(8):
    if bits[i] == 1:
        print(i)
复制代码
```

这样我们其实就已经实现了排序。

对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。

**那么对于这道题**，我们用 2 个 bit 来表示各个数字的状态：

- 00 表示这个数字没出现过；
- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；
- 10 表示这个数字出现了多次。

那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：

遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。

**方法总结**

**判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 5. 如何在大量的数据中判断一个数是否存在？

**题目描述**

给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？

**解答思路**

**方法一：分治法**

依然可以用分治法解决，方法与前面类似，就不再次赘述了。

**方法二：位图法**

40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。

我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。

**方法总结**

**判断数字是否存在、判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 6. 如何查询最热门的查询串？

**题目描述**

搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。

假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）

**解答思路**

每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。

**方法一：分治法**

分治法依然是一个非常实用的方法。

划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。

方法可行，但不是最好，下面介绍其他方法。

**方法二：HashMap 法**

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。

**思路如下**：

首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 `O(N)`。

接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。

遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 `O(Nlog10)`。

**方法三：前缀树法**

方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。

**思路如下**：

在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。

最后依然使用小顶堆来对字符串的出现次数进行排序。

**方法总结**

前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。

## 7. 如何统计不同电话号码的个数？

**题目描述**

已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。

**解答思路**

这道题本质还是求解**数据重复**的问题，对于这类问题，一般首先考虑位图法。

对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

**思路如下**：

申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。

**方法总结**

求解数据重复问题，记得考虑位图法。

## 8. 如何从 5 亿个数中找出中位数？

**题目描述**

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 `(N+1)/2` 个数；当样本数为偶数时，中位数为 第 `N/2` 个数与第 `1+N/2` 个数的均值。

**解答思路**

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)`。这里使用其他方法。

**方法一：双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。

若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

```ini
class MedianFinder {
    
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        minHeap = new PriorityQueue<>(Integer::compareTo);
    }
    
    public void addNum(int num) {
        if (maxHeap.isEmpty() || maxHeap.peek() > num) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        if (size1 - size2 > 1) {
            minHeap.offer(maxHeap.poll());
        } else if (size2 - size1 > 1) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    public double findMedian() {
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        
        return size1 == size2 
            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2
            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());
    }
}
复制代码
```

> 见 LeetCode No.295：[leetcode.com/problems/fi…](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.com%2Fproblems%2Ffind-median-from-data-stream%2F)

以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法**适用于数据量较小的情况**。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。

**方法二：分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

> **提示**，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。

对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

> **注意**，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。

**方法总结**

分治法，真香！

## 9. 如何按照 query 的频度排序？

**题目描述**

有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。

**解答思路**

如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。

**方法一：HashMap 法**

如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。

**方法二：分治法**

分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 `hash(query) % 10` 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。

接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。

**方法总结**

- 内存若够，直接读入进行排序；
- 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。

## 10. 如何找出排名前 500 的数？

**题目描述**

有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？

**解答思路**

对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：

首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。

接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。

重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。

> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

```ini
import lombok.Data;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * @author https://github.com/yanglbme
 */
@Data
public class DataWithSource implements Comparable<DataWithSource> {
    /**
     * 数值
     */
    private int value;

    /**
     * 记录数值来源的数组
     */
    private int source;

    /**
     * 记录数值在数组中的索引
     */
    private int index;

    public DataWithSource(int value, int source, int index) {
        this.value = value;
        this.source = source;
        this.index = index;
    }

    /**
     *
     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改
     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆
     */
    @Override
    public int compareTo(DataWithSource o) {
        return Integer.compare(o.getValue(), this.value);
    }
}


class Test {
    public static int[] getTop(int[][] data) {
        int rowSize = data.length;
        int columnSize = data[0].length;

        // 创建一个columnSize大小的数组，存放结果
        int[] result = new int[columnSize];

        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();
        for (int i = 0; i < rowSize; ++i) {
            // 将每个数组的最大一个元素放入堆中
            DataWithSource d = new DataWithSource(data[i][0], i, 0);
            maxHeap.add(d);
        }

        int num = 0;
        while (num < columnSize) {
            // 删除堆顶元素
            DataWithSource d = maxHeap.poll();
            result[num++] = d.getValue();
            if (num >= columnSize) {
                break;
            }

            d.setValue(data[d.getSource()][d.getIndex() + 1]);
            d.setIndex(d.getIndex() + 1);
            maxHeap.add(d);
        }
        return result;

    }

    public static void main(String[] args) {
        int[][] data = {
                {29, 17, 14, 2, 1},
                {19, 17, 16, 15, 6},
                {30, 25, 20, 14, 5},
        };

        int[] top = getTop(data);
        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]
    }
}
复制代码
```

**方法总结**

求 TopK，不妨考虑一下堆排序？