

# ES6

## Generator函数是什么

Generator 是ES6引入的新语法，Generator是一个可以暂停和继续执行的函数。Generator函数是将函数分步骤阻塞 ，只有主动调用next() 才能进行下一步 。

简单的用法，可以当做一个Iterator来用，进行一些遍历操作。复杂一些的用法，他可以在内部保存一些状态，成为一个状态机。

```
Generator 基本语法包含两部分：函数名前要加一个星号；函数内部用 yield 关键字返回值。
yield，表达式本身没有返回值，或者说总是返回undefined。
next，方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
```

```
function * foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);

}

var b = foo(5); 
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false } 
b.next(13) // { value:42, done:true }

```

## async函数是什么

asyns函数是Generator函数的语法糖。

相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。

但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的。

async 对应的是 * 。

await 对应的是 yield 。

async/await 自动进行了 Generator 的流程控制。

**为什么Async/Await更好？**

1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。
2. 错误处理：Async/Await 让 try/catch 可以同时处理同步和异步错误。

# Html

## 为什么要语义化?

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

# 简历

## 简历核心

- 个人信息
- 专业技能
- 工作经历
- 项目经历
- 社区贡献

**个人信息**

- 必备：姓名 电话 邮箱。
- 年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。
- 可以放 github 链接，前提是有内容。

**专业技能**

- 表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。
- 内容不要太多，3、5 条即可。
- 太基础的不要写，例如会用 vscode、lodash。

**工作经历**

- 如实写。
- 写明公司，职位，入职离职时间即可，多写无益。
- 如果有空窗期，如实写明即可。

**项目经历**

- 写 2-4 个具有说服力的项目（不要什么项目都写，没用）。
- 项目名称，项目描述，技术栈，个人角色。

**社区贡献**

- 有博客或者开源作品，会让你更有竞争力。
- 切记：需要真的有内容，不可临时抱佛脚。

**注意事项**

- 界面不能太花哨，简洁明了即可。
- 注意用词，“精通”“熟练”等慎用，可用“熟悉”。
- 不可造假，会被拉入黑名单。

# Mixin-HOC-Hook

参考

- [【React深入】从Mixin到HOC再到Hook](https://juejin.cn/post/6844903815762673671#heading-1)

**前言**

Mixin-HOC的缺点：

- 渲染上下文中公开的属性的来源不清楚。 例如，当使用多个 mixin 读取组件的模板时，可能很难确定从哪个 mixin 注入了特定的属性。

- 命名空间冲突。 Mixins 可能会在属性和方法名称上发生冲突，而 HOC 可能会在预期的 prop 名称上发生冲突。

- 性能问题，HOC 和无渲染组件需要额外的有状态组件实例，这会降低性能。

Hook的优点：

- 暴露给模板的属性具有明确的来源，因为它们是从 Hook 函数返回的值。

- Hook 函数返回的值可以任意命名，因此不会发生名称空间冲突。

- 没有创建仅用于逻辑重用的不必要的组件实例。

Hook的缺点：比如 `ref` 带来的心智负担

## Mixin

广义的mixin方法，就是用赋值的方式将mixin对象中的方法都挂载到原对象上，来实现对象的混入，类似ES6中的Object.assign()的作用。原理如下：

```
const mixin = function(obj, mixins){
  const newObj = obj;
  newObj.prototype = Object.create(obj.prototype);

  for(let prop in mixins){ // 遍历mixins的属性
    if(mixins.hasOwnPrototype(prop)){ // 判断是否为mixin的自身属性
      newObj.prototype[prop] = mixins[prop]; // 赋值
    }
  }

  return newObj;
}
```

**React.createClass的mixins的危害**

1. Mixin 可能会相互依赖，相互耦合，不利于代码维护
2. 不同的 Mixin中的方法可能会相互冲突
3. Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 `React.createClass`现在已经不再推荐使用`Mixin`来解决代码复用问题，因为`Mixin`带来的危害比他产生的价值还要巨大，并且`HOC`是纯净的JavaScript，不用担心他们会被废弃。

`React`现在已经不再推荐使用`Mixin`来解决代码复用问题，因为`Mixin`带来的危害比他产生的价值还要巨大，并且`React`全面推荐使用高阶组件来替代它。

## HOC(High-Order-Components高阶组件)

高阶组件可以看作`React`对装饰模式的一种实现，高阶组件就是一个纯函数，且该函数接受一个组件作为参数，并返回一个新的组件。

**高阶组件实现的方法有两种：**

1. 属性代理：通过被包裹组件的props来进行相关操作。主要进行组件的复用。
2. 反向继承：继承被包裹的组件。主要进行渲染的劫持。

**高阶组件可以实现什么功能:**

1. **双向绑定**
2. **组合渲染:** 可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。
3. **条件渲染:** 根据特定的属性决定原组件是否渲染
4. **操作props:** 可以对传入组件的props进行增加、修改、删除或者根据特定的 props进行特殊的操作。
5. **获取refs:** 高阶组件中可获取原组件的 ref，通过 ref获取组件实例, 从而可以实现对组件中的方法进行调用
6. **状态管理:** 将原组件的状态提取到 HOC中进行管理
7. **操作state:** 通过反向继承，我们可以直接操作原组件的 state
8. **渲染劫持:** 高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种 渲染劫持。

**HOC的缺陷**

1. HOC需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难。
2. HOC可以劫持 props，在不遵守约定的情况下也可能造成冲突。

**为什么在 Vue 中实现高阶组件比较难**

主要是二者的设计思想和设计目标不同，在 `React` 中写组件就是在写函数，函数拥有的功能组件都有。而 `Vue` 更像是高度封装的函数，在更高的层面 `Vue` 能够让你轻松的完成一些事情，但与高度的封装相对的就是损失一定的灵活，你需要按照一定规则才能使系统更好地运行。

## **Hook**

使用 Hooks，你可以在将含有 state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。 Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。

```

<template>
 <p>{{ person.name }}</p>
 <p>{{ car.name }}</p>
 <p>{{ animal.name }}</p>
</template>


<script lang="ts" setup>
import { usePerson, useCar, useAnimal } from "./hooks";


const { person, changePersonName } = usePerson();

const { car } = useCar();
</script>
```

```
// usePerson.ts
import { reactive, watch } from "vue";

export default function usePerson() {
 const person = reactive<{ name: string; sex: string }>({
  name: "小明",
  sex: "male",
 });
 watch(
  () => [person.name, person.sex],
  ([nameVal, sexVal]) => {
   console.log(`名字被修改了, 修改为 ${nameVal}`);
   console.log(`名字被修改了, 修改为 ${sexVal}`);
  }
 );
 function changePersonName() {
  person.name = "小浪";
 }
 return {
  person,
  changePersonName,
 };
}
```

**使用Hooks的动机**

1. 减少状态逻辑复用的风险: Hook和 Mixin在用法上有一定的相似之处，但是 Mixin引入的逻辑和状态是可以相互覆盖的，而多个 Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。
2. 避免地狱式嵌套
3. 让组件更容易理解
4. 使用函数代替class

## React Hook 和 Vue Hook 对比

 React Hook 的缺点(限制非常多)：

- 不要在循环，条件或嵌套函数中调用 Hook

- 确保总是在你的 React 函数的最顶层调用他们。

- 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。

Vue Hook的优点：

- 与 React Hooks 相同级别的逻辑组合功能，但有一些重要的区别。 与 React Hook 不同，`setup` 函数仅被调用一次，这在性能上比较占优。

- 对调用顺序没什么要求，每次渲染中不会反复调用 Hook 函数，产生的的 GC 压力较小。

- 不必考虑几乎总是需要 useCallback 的问题，以防止传递`函数prop`给子组件的引用变化，导致无必要的重新渲染。

- React Hook 有臭名昭著的闭包陷阱问题（甚至成了一道热门面试题，omg），如果用户忘记传递正确的依赖项数组，useEffect 和 useMemo 可能会捕获过时的变量，这不受此问题的影响。 Vue 的自动依赖关系跟踪确保观察者和计算值始终正确无误。

- 不得不提一句，React Hook 里的「依赖」是需要你去手动声明的，而且官方提供了一个 eslint 插件，这个插件虽然大部分时候挺有用的，但是有时候也特别烦人，需要你手动加一行丑陋的注释去关闭它。

黄子毅大大眼中的Vue Hook的优点：

- `setup` 仅执行一遍，而 React Function Component 每次渲染都会执行

- Vue 的代码使用更符合 JS 直觉。JS 并非是针对 Immutable 设计的语言，所以 Mutable 写法非常自然，而 Immutable 的写法就比较别扭。

- 当 Hooks 要更新值时，Vue 只要用等于号赋值即可，而 React Hooks 需要调用赋值函数，当对象类型复杂时，还需借助第三方库才能保证进行了正确的 Immutable 更新。

- 对 Hooks 使用顺序无要求，而且可以放在条件语句里。

 > 对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。
 >
 > 而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 `setup` 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。

- 不会再每次渲染重复调用，减少 GC 压力

 > React的Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。
 >
 > Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 `setup` 的执行，所以确实不会造成 GC 压力。

- React 必须要总包裹 `useCallback` 函数确保不让子元素频繁重渲染

 > Vue 3.0，由于 `setup` 仅执行一次，因此函数本身只会创建一次，不存在多实例问题，不需要 `useCallback` 的概念，更不需要使用 [lint 插件](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react-hooks) 保证依赖书写正确.

- Vue不需要使用 `useEffect` `useMemo` 等进行性能优化，所有性能优化都是自动的。

[React Hook + TS 购物车实战（性能优化、闭包陷阱、自定义 hook）](https://juejin.cn/post/6844904079181905927)

**参考**

[Vue3 究竟好在哪里？（和 React Hook 的详细对比）](https://juejin.cn/post/6844904132109664264#heading-9)

[精读《Vue3.0 Function API》](https://juejin.cn/post/6844903877574295560#heading-4)

## React 和 Vue逻辑结构对比

- Vue：Mutable + Template
- React：Immutable + JSX

JSX 与 Template 的根本区别：

- jsx:JSX 使模版与 JS 可以写在一起，因此数据层与渲染层可以耦合在一起写（也可以拆分）
- template:Vue 采取的 Template 思路使数据层强制分离了，这也使代码分层更清晰

**不建议在 JSX 中再实现类似 Mutable + JSX** 

# 书单

## github书单库

- [java-books-collections](https://github.com/RongleXie/java-books-collections)

# 设计模式

## 策略模式+代理模式-Vue3-Proxy

参考

- [探索两种优雅的表单验证](https://github.com/jawil/blog/issues/19)

**场景：前端表单校验**

- 所有选项不能为空
- 用户名长度不能少于6位
- 密码长度不能少于6位
- 手机号码必须符合格式
- 邮箱地址必须符合格式

**常规校验**

```
  let registerForm = document.querySelector('#registerForm')
  registerForm.addEventListener('submit', function() {
      if (registerForm.userName.value === '') {
          alert('用户名不能为空！')
          return false
      }
      if (registerForm.userName.length < 6) {
          alert('用户名长度不能少于6位！')
          return false
      }
      if (registerForm.passWord.value === '') {
          alert('密码不能为空！')
          return false
      }
      if (registerForm.passWord.value.length < 6) {
          alert('密码长度不能少于6位！')
          return false
      }
      if (registerForm.phoneNumber.value === '') {
          alert('手机号码不能为空！')
          return false
      }
      if (!/^1(3|5|7|8|9)[0-9]{9}$/.test(registerForm.phoneNumber.value)) {
          alert('手机号码格式不正确！')
          return false
      }
      if (registerForm.emailAddress.value === '') {
          alert('邮箱地址不能为空！')
          return false
      }
      if (!/^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
      $/.test(registerForm.emailAddress.value)) {
          alert('邮箱地址格式不正确！')
          return false
      }
  }, false)
```

但存在很多问题，比如：

> - `registerForm.addEventListener`绑定的函数比较庞大，包含了很多的`if-else`语句，看着都恶心，这些语句需要覆盖所有的校验规则。
> - `registerForm.addEventListener`绑定的函数缺乏弹性，如果增加了一种新的校验规则，或者想要把密码的长度校验从6改成8，我们都必须深入`registerForm.addEventListener`绑定的函数的内部实现，这是违反了开放-封闭原则的。
> - 算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野。

**用策略模式重构表单校验**

> 思路：一键验证，使用策略模式，核心思想:将做什么和谁去做相分离

策略模式的组成

- 抽象策略角色：策略类，通常由一个接口或者抽象类实现。
- 具体策略角色：包装了相关的算法和行为。
- 环境角色：持有一个策略类的引用，最终给客户端用的。

具体策略角色——编写策略类

```
/*策略对象*/
const strategies = {
        isNonEmpty(value, errorMsg) {
            return value === '' ?
                errorMsg : false
        },
        minLength(value, length, errorMsg) {
            return value.length < length ?
                errorMsg : false
        },
        isMoblie(value, errorMsg) {
            return !/^1(3|5|7|8|9)[0-9]{9}$/.test(value) ?
                errorMsg : false
        },
        isEmail(value, errorMsg) {
            return !/^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(value) ?
                errorMsg : false
        }
    }
```

抽象策略角色——编写Validator类

```
/*Validator类*/
class Validator {
    constructor() {
        this.cache = [] //保存校验规则
    }
    add(value,name,...other) {
        this.cache.push(strategies[name])
    }
    start() {
        for (let validatorFunc of this.cache) {
            let errorMsg = validatorFunc()//开始校验，并取得校验后的返回信息
            if (errorMsg) {//r如果有确切返回值，说明校验没有通过
                return errorMsg
            }
        }
    }
}
```

环境角色——客户端调用代码

```
// 获取表单form元素
let registerForm = document.querySelector('#registerForm')
function validatorFunc(){
    // 创建表单校验实例
    let validator = new Validator();
    // 编写校验配置
    validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空')
    validator.add(registerForm.userName, 'minLength', '用户名长度不能小于6')
    // 开始校验，并接收错误信息
    let errorMsg = validator.start()
    // 如果有错误信息输出，说明校验未通过
    if(errorMsg){
        alert(errorMsg)
        return false//阻止表单提交
    }
}
validatorFunc()
```

**策略模式的优缺点**

- 策略模式利用组合、委托和多态等技术思想，可以有效的避免多种条件选择语句；
- 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于拓展；
- 策略模式中的算法也可以复用在系统的其它地方，从而避免了许多重复的复制黏贴的工作；
- 在策略模式利用组合和委托来让Context拥有执行算法的能力，这也是继承一种更轻便的替代方案。

当然，策略模式也有一些缺点，但掌握了策略模式，这些缺点并不严重。

- 编写难度加大，代码量变多了，这是最直观的一个缺点，也算不上缺点，毕竟不能完全以代码多少来衡量优劣。
- 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。
- 其次，要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时strategy要向客户暴露它的所有实现，这是违反最少知识原则的。

# JS

## 手写forEach

```
if(!Array.prototype.forEach) {
    Array.prototype.forEach = function(fn, context) {
        var context = arguments[1];
        if(typeof fn !== "function") {
            throw new TypeError(fn + "is not a function");
        }

        for(var i = 0; i < this.length; i++) {
            fn.call(context, this[i], i, this);
        }
    };
}
```

## 手写setTimeOut实现setInterval

```
function myInterval(fn,time){
    let interval=()=>{
      fn()
      setTimeout(interval,time)
    }
    setTimeout(interval,time)
  }
```

## 手写map

```
Array.prototype.map = function (fn) {
    let arr = []
    for (let i = 0; i < this.length; i++) {
        arr.push(fn(this[i], i, this))
    }
    return arr
}
```

## 手写reduce

```
Array.prototype.myReduce = function (fn, initVal) {
    let res = initVal ? initVal : 0
    for (let i = 0; i < this.length; i++) {
        res = fn(res, this[i], i, this)
    }
    return res
}
```

## 手写filter

```
Array.prototype.myFilter = function (fn) {
    let arr = []
    for (let i = 0; i < this.length; i++) {
        if (fn(this[i], i, this)) {
            arr.push(this[i])
        }
    }
    return arr
}
```

## 手写push

```
Array.prototype.myPush = function () {
    let args = arguments
    for (let i = 0; i < args.length; i++) {
        this[this.length] = args[i]
    }
    return this.length
}
```



## ES6箭头函数与普通函数区别

参考

- [ES6 - 箭头函数、箭头函数与普通函数的区别](https://juejin.cn/post/6844903805960585224#heading-0)

区别：

- 语法更加简洁、清晰
- 箭头函数不会创建自己的this
- 箭头函数继承而来的this指向在定义时指定后，永远不变
- .call()/.apply()/.bind()无法改变箭头函数中this的指向
- 箭头函数不能作为构造函数使用
- 箭头函数没有自己的arguments
- 箭头函数没有原型prototype
- 箭头函数不能用作Generator函数，不能使用yeild关键字

## ES6 扩展运算符

- 替代apply方法，一般在函数调用时处理参数
- 剩余参数(rest运算符)，主要针对函数形参
- 数据连接、合并
- 数组和对象的拷贝
- 字符串转数组

替代apply方法，一般在函数调用时处理参数

```
function addFun(x, y, z) {
    return x + y + z;
}
var args = [1, 2, 3];
// 用apply方法直接传递数组
addFun.apply(null, args);
// 替代apply的扩展运算符
addFun(...args);
```

剩余参数(rest运算符)，主要针对函数形参

```
function(argA, ...args){
 //
}
```

数据连接、合并

```
// ES5 合并
var es5Arr = arr1.concat(arr2);
// ES6 合并
var es6Arr = [...arr1, ...arr2];
```

数组和对象的拷贝

```
var arr1 = [1, 2, 3];
var arr2 = [...arr1];
```

字符串转数组

```
var str = 'hello';
// ES5 处理方式
var es5Arr = str.split('');
// ES6 处理方式
var es6Arr = [...str];
```



## 字符串自动补全padStart()和padEnd()

`padStart`可以在字符串的前面进行字符补全.padEnd是在字符串后面补全。

```
let month  = 8;
month.padStart(2, 0);// 08
```

可以省掉

```
if (month < 10) {
    month = '0' + month;
}
```

## 三大山-作用域和闭包

### 作用域-执行上下文

参考

- [JavaScript 深入之执行上下文栈](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4)；
- [JavaScript 深入之变量对象](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F5)；
- [JavaScript 深入之作用域链](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6)；
- [JavaScript 深入之执行上下文](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F8)。

对于每个执行上下文，都有三个重要属性：

- 变量对象（Variable object，VO）；
- 作用域链（Scope chain）；
- [this](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的**所有执行上下文**。

因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文**栈**（Execution context stack，ECS）来**管理**执行上下文。

当 JavaScript 初始化的时候会向执行上下文栈压入一个**全局**执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。

**一、执行上下文**

执行上下文总共有三种类型

- **全局执行上下文**：只有一个，浏览器中的全局对象就是 window 对象，`this` 指向这个全局对象。
- **函数执行上下文**：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
- **Eval 函数执行上下文**： 指的是运行在 `eval` 函数中的代码，很少用而且不建议使用。

**二、执行上下文的创建**

分为2个阶段：

- 创建阶段
- 执行阶段

**1.创建阶段**

分为3部分：

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
- 3、**VariableEnvironment（变量环境）** 组件被创建。

**(1)This Binding**

- **全局**执行上下文中，`this` 的值指向全局对象，在浏览器中`this` 的值指向 `window`对象，而在`nodejs`中指向这个文件的`module`对象。
- **函数**执行上下文中，`this` 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、`new`绑定、箭头函数，具体内容会在【this全面解析】部分详解。

**(2)词法环境**

分为2部分：

- **环境记录**：存储变量和函数声明的实际位置
- **对外部环境的引用**：可以访问其外部词法环境

词法环境有两种**类型**

- 1、**全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。
- 2、**函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

**(3)变量环境**

变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。

**2.执行阶段**

完成对所有变量的分配，执行代码，函数出栈

### 作用域-变量对象(VO/AO/GO)

JS有两个特性，一个是单线程，一个是解释性语言。

JS运行步骤：1.语法分析2.预编译3.解释执行

函数执行四部曲：

1.创建AO对象，供js引擎自己去访问

activation object （活跃对象/执行期上下文）

2.找变量和形参的声明，作为AO对象的属性名，值是undefined

3.实参和形参相统一，实参赋值给形参

4.找函数声明(注意不是函数表达式)，会覆盖变量的声明。

```js
   function fn(a,c){
console.log(a);//function a(){}
var a=123;
console.log(a);//123
console.log(c);//function c(){}
function a(){}
if(false){
var d= 678;
}
console.log(d);//undefined
console.log(b);//undefined
var b=function(){}
console.log(b);//function (){}
function c(){}
console.log(c);//function c(){}
}
fn(1,2);

AO{
a:undefined,1,function a(){}
c:undefined,2,function c(){}
d:undefined,
b:undefined,
}
```

**静态作用域与动态作用域**

> JavaScript 采用词法作用域(lexical scoping)，就是静态作用域。

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

```
var value = 1;
function foo() {
    console.log(value);
}
function bar() {
    var value = 2;
    foo();
}
bar();
// 结果是 ???
```

假设JavaScript采用静态作用域，让我们分析下执行过程：

执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value (价值) ，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value (价值) 等于 1，所以结果会打印 1。

假设JavaScript采用动态作用域，让我们分析下执行过程：

执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value (价值) 。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value (价值) 变量，所以结果会打印 2。

前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

来自《JavaScript权威指南》中的例子：

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码都会打印：`local scope`。因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。

> 引用《JavaScript权威指南》的回答就是：
>
> JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope (范围) 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

**变量提升**

var上升为全局，let是块级作用域，作用于当前。

- var：声明提升，没有局部作用域，声明覆盖
- let:

```
    for(var i =0;i<5;i++){
        setTimeout(()=>{
            console.log('var的事件循环机制:',i);// 输出55555
        },500)
    }
    for(let j =0;j<5;j++){
        setTimeout(()=>{
            console.log('let的块级作用域：',j);// 输出01234
        },500)
    }
```

例子一：变量提升

```js
foo;  // undefined
var foo = function () {
    console.log('foo1');
}

foo();  // foo1，foo赋值

var foo = function () {
    console.log('foo2');
}

foo(); // foo2，foo重新赋值
```

例子二：函数提升

```js
foo();  // foo2
function foo() {
    console.log('foo1');
}

foo();  // foo2

function foo() {
    console.log('foo2');
}

foo(); // foo2
```

例子三：声明优先级，函数 > 变量

```js
foo();  // foo2
var foo = function() {
    console.log('foo1');
}

foo();  // foo1，foo重新赋值

function foo() {
    console.log('foo2');
}

foo(); // foo1
```

上面三个例子中，第一个例子是变量提升，第二个例子是函数提升，第三个例子是函数声明优先级高于变量声明。

有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

答案是 执行上下文栈的变化不一样。

第一段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

第二段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

**讨论题**

```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x  // --> undefined
b.x  // --> {n: 2}
```

答案已经写上面了，这道题的关键在于

- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。
- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`

### 作用域-作用域与作用域链

**`作用域`** 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。

**`作用域链`** 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。

作用域具体可细分为四种：**`全局作用域`**、**`模块作用域`**、**`函数作用域`**、**`块级作用域`**

**全局作用域：** 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。

**模块作用域：** 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（AMD、CommonJS、UMD、ES6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。

**函数作用域：** 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。

**块级作用域：** 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。

```
// var demo
for(var i=0; i<10; i++) {
    console.log(i);
}
console.log(i); // 10

// let demo
for(let i=0; i<10; i++) {
    console.log(i);
}
console.log(i); //ReferenceError：i is not defined
```



## 闭包

**闭包的特征：**

- 函数中存在函数；
- 内部函数可以访问外层函数的作用域；
- 参数和变量不会被 GC，始终驻留在内存中；
- 有内存地方才有闭包。

## 异步和单线程

为什么js是一门单线程语言呢？最初设计JS是用来在浏览器验证表单以及操控DOM元素，为了避免同一时间对同一个DOM元素进行操作从而导致不可预知的问题，JavaScript从一诞生就是单线程。

# Vue3

## 生命周期

截图：https://juejin.cn/post/7019692533240299550#heading-0

## 入门

- [📺 VueMastery原版](https://link.juejin.cn/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1my4y1m7sz%3Fp%3D6)
- [📺 然叔与杨村长的深度解读](https://link.juejin.cn/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1my4y1m7sz%3Fp%3D7)
- [🔥 39岁的夺路狂奔| 掘金年度征文](https://juejin.cn/post/6903701243361755149) 98赞
- [🔥 Element3开发内幕 - Vue CLI插件开发](https://juejin.cn/post/6899334776860180494) 167赞
- [🔥 天天造轮子系列](https://juejin.cn/post/6893338774088974343) 500+ 赞
- [🔥 Vue3.0全球发布会干货总结](https://juejin.cn/post/6875236411349008398) 267赞

## Proxy是代理，Reflect是干嘛用的？

准确讲应该是这样的，Reflect更像是一种语法变体，其挂在的所有方法都能找到对应的原始语法，也就是Reflect的替代性非常强。

比较常用的两个方法就是`get()`和`set()`方法：

```
Reflect.get(target, propertyKey)
Reflect.set(target, propertyKey, value)
```

等效于

```
target[propertyKey]
target[propertyKey] = value;
```

Reflect对象经常和Proxy代理一起使用，原因有三点：

1. Reflect提供的所有静态方法和Proxy第2个handle参数方法是一模一样的。
2. Proxy get/set()方法需要的返回值正是Reflect的get/set方法的返回值，可以天然配合使用，比直接对象赋值/获取值要更方便和准确(通过返回值知道是否赋值成功，并不会因为报错而中断正常代码执行)。
3. receiver参数具有不可替代性。

**关于receiver参数**

receiver是接受者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver参数是无需使用的，但是如果发生了继承，为了*明确调用主体*，receiver参数就需要出马了。

```
let miaoMiao = {
  _name: '疫苗',
  get name () {
    return this._name;
  }
}
let miaoXy = new Proxy(miaoMiao, {
  get (target, prop, receiver) {
    return target[prop];
  }
});

let kexingMiao = {
  __proto__: miaoXy,
  _name: '科兴疫苗'
};

// 结果是疫苗
console.log(kexingMiao.name);
```

实际上，这里预期显示应该是“科兴疫苗”，而不是“疫苗”。

这个时候，就需要使用`receiver`参数了，代码变化部分参见下面标红的那一行：

```
return Reflect.get(target, prop, receiver);
// 也可以简写为 Reflect.get(...arguments) 
```

## Vite

**模板全宇宙入口**

- [awesome-vite](https://github.com/vitejs/awesome-vite)

## Object.defineProperty 和Porxy

**前言**

Vue都是采用数据劫持代理+发布订阅模式方式实现，vue2到vue3的差别是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变。Proxy/Reflect是在ES2015规范中加入的，Proxy可以更好的拦截对象行为，Reflect可以更优雅的操纵对象。

> **并不是说`Proxy`的性能就比`Object.defineProperty`高多少**
>
> 在`Proxy`里的处理方式比`Vue2`时期的好很多：`Vue2`的响应式是一上来就一顿`遍历`+`递归`把你定义的所有数据全都变成响应式的，这就会导致如果页面上有很多很复杂的数据结构时，用`Vue2`写的页面就会白屏一小段时间。毕竟`遍历`+`递归`还是相对很慢的一个操作嘛！
>
> 对于vue3,当我们获取对象上的某个键对应的值时，会先判断这个值到底有没有对应的发布者对象，没有的话再创建发布者对象。而且当获取到的值是引用类型时再把这个值变成`响应式对象`，等你用到了响应式对象里的值时再去新建发布者对象。
>
> 总结成一句话就是：`Vue3`是用到哪部分的数据的时候，再把数据变成响应式的。而`Vue2`则是不管三七二十一，刚开局就全都给你变成响应式数据。

对比：

> - Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法
> - defineProperty 不能监听到数组下标变化和对象新增属性，Proxy 可以
> - defineProperty 是劫持对象属性，Proxy 是代理整个对象
> - defineProperty 局限性大，只能针对单属性监听，所以在一开始就要全部递归监听。Proxy 对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能提升很大，且首次渲染更快
> - defineProperty 会污染原对象，修改时是修改原对象，Proxy 是对原对象进行代理并会返回一个新的代理对象，修改的是代理对象
> - defineProperty 不兼容 IE8，Proxy 不兼容 IE11

| 对比                                | Object.defineProperty | Porxy          |
| ----------------------------------- | --------------------- | -------------- |
| 功能                                | 监听对象的单个属性    | 监听整个对象   |
| 属性为对象时                        | 需要递归监            | 不需要         |
| 对象新增一个属性时                  | 需要手动监听          | 不需要手动监听 |
| 数组通过push、unshift方法增加的元素 | 无法监听              | 可以监听       |

**一、Object.defineProperty**

> 基本使用

核心：

- 对象: 通过 defineProperty 对对象的已有属性值的读取和修改进行劫持(监视/拦截)
- 数组: 通过重写数组原型方法实现元素修改的劫持

缺陷：

- 初始化时需要遍历对象所有 key，如果对象层次较深，性能不好
- 通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多
- Object.defineProperty 无法监听到数组元素的变化，只能通过劫持重写方法
- 动态新增，删除对象属性无法拦截，只能用特定 set/delete API 代替
- 不支持 Map、Set 等数据结构

```
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
// value:10, //初值
// enumerable:true,//属性是否支持枚举,默认false
// writable:true,//属性是否支持修改,默认false
// configurable:true,//属性是否支持删除,默认false
  get() {
    console.log('获取数据了')
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
```

> 监听对象上的多个属性

```
Object.keys(person).forEach(function (key) {
    Object.defineProperty(person, key, {
        enumerable: true,
        configurable: true,
        // 默认会传入this
        get() {
            return person[key]
        },
        set(val) {
            console.log(`对person中的${key}属性进行了修改`)
            person[key] = val
            // 修改之后可以执行渲染操作
        }
    })
})
console.log(person.age)
```

> 深度监听一个对象

```
function defineProperty(obj, key, val) {
    //如果某对象的属性也是一个对象，递归进入该对象，进行监听
    if(typeof val === 'object'){
    observer(val)
    }
    Object.defineProperty(obj, key, {
        get() {
            console.log(`访问了${key}属性`)
            return val
        },
        set(newVal) {
         // 如果原本的属性值是一个对象，递归进入该对象进行监听
            if(typeof newVal === 'object'){
                observer(key)
            }
            // 如果原本的属性值是一个字符串
            console.log(`${key}属性被修改为${newVal}了`)
            val = newVal
        }
    })
}

// 在observer里面加一个递归停止的条件
function Observer(obj) {
    //如果传入的不是一个对象，return
    if (typeof obj !== "object" || obj === null) {
        return
    }
    // for (key in obj) {
    Object.keys(obj).forEach((key) => {
        defineProperty(obj, key, obj[key])
    })
    // }
}
```

> 监听数组

如果还是按照基本用法，是无法监听数组变化，vue2采用重写Array原型上的方法实现监听。

**Proxy**

> 基本使用

Proxy 也就是代理，可以帮助我们完成很多事情，例如对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义，因此提供了一种机制，可以对外界的访问进行过滤和改写。

核心：

- 通过 Proxy(代理): 拦截对 data 任意属性的任意(13 种)操作, 包括属性值的读写, 属性的添加, 属性的删除等…
- 通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作

语法：`const p = new Proxy(target, handler)` 参数:

1. target:要使用 `Proxy` 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
2. handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为。

通过Proxy，我们可以对`设置代理的对象`上的一些操作进行拦截，外界对这个对象的各种操作，都要先通过这层拦截。

```
let w3cjs = {
   name: "w3cjs",
   age: 99
};
w3cjs = new Proxy(w3cjs, {
  get(target, key) {
       let result = target[key];
       //如果是获取 年龄 属性，则添加 岁字
       if (key === "age") result += "岁";
       return result;
  },
  set(target, key, value) {
         if (key === "age" && typeof value !== "number") {
         throw Error("age字段必须为Number类型");
      }
      return Reflect.set(target, key, value);
  }
});
console.log(`我叫${w3cjs.name}  我今年${w3cjs.age}了`);
w3cjs.age = 100;
```

Proxy的表单验证

```
// 验证规则
  const validators = {
    name: {
      validate(value) {
        return value.length > 6;
      },
      message: '用户名长度不能小于六'
    },
    password: {
      validate(value) {
        return value.length > 10;
      },
      message: '密码长度不能小于十'
    },
    moblie: {
      validate(value) {
        return /^1(3|5|7|8|9)[0-9]{9}$/.test(value);
      },
      message: '手机号格式错误'
    }
  }


  // 验证方法
  function validator(obj, validators) {
    return new Proxy(obj, {
      set(target, key, value) {
        const validator = validators[key]
        if (!validator) {
          target[key] = value;
        } else if (validator.validate(value)) {
          target[key] = value;
        } else {
          alert(validator.message || "");
        }
      }
    })
  }
  let form = {};
  form = validator(form, validators);
  form.name = '666'; // 用户名长度不能小于六
  form.password = '113123123123123';
```

**Proxy支持拦截的操作，一共有13种：**

- get(target, propKey, receiver)：拦截对象属性的读取，比如 `proxy.foo` 和`proxy['foo']`。

- set(target, propKey, value, receiver)：拦截对象属性的设置，比如`proxy.foo = v` 或 `proxy['foo'] = v`，返回一个布尔值。
- has(target, propKey)：拦截 `propKey in proxy` 的操作，返回一个布尔值。
- deleteProperty(target, propKey)：拦截 `delete proxy[propKey]`的操作，返回一个布尔值。
- ownKeys(target)：拦截 `Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。
- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。
- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- getPrototypeOf(target)：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- isExtensible(target)：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。
- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。



# 前端工程师出路

> 无论你想做什么事情，首先都要以开放积极的心态去面对，而不是打定了一个主意后就立马埋头苦干，在做之前先倾听其他人的意见，看看是否有更好的解决思路，或者是否已经有人做过类似的事情，不要重复造轮子。

技术架构

- 技术选型，预见未来，比如是否有跨端需求，提前选择跨端框架
- 可维护性、可复用性、可测试性

降本增效

- 目录自动生成，参考 egg.js（提效）
- 低代码运营页面自动搭建（提效降本）
- 快捷键工具
- 自动化测试工具
- 批量处理国际化（提效）
  - nodejs-translate
  - react-intl 以及 I18N-loader

业务场景

- 大文件批量断点续传及优化
- 微应用模板、组件库和脚手架（提交）
- SSO 登录，CAS
- 异步流程控制

技术驱动业务

- 主动推进项目
  - 和后端约定接口规范
  - 推荐适合当前场景的技术
- 提出建设性的需求
  - 样式：美观、统一
  - 性能：首屏性能
  - 交互&体验：简单高效
  - 多端兼容
- 砍除不合理的需求
  - 实现成本，可行性分析
  - 替代方案
- 开发周期
  - 需求优先级
  - 开发排期



# CSS

## CSS选择器优先级

> 第一优先级：`!important`会覆盖页面内任何位置的元素样式
>
> 1.内联样式，如`style="color: green"`，权值为`1000`
>
> 2.ID选择器，如`#app`，权值为`0100`
>
> 3.类、伪类、属性选择器，如`.foo, :first-child, div[class="foo"]`，权值为`0010`
>
> 4.标签、伪元素选择器，如`div::first-line`，权值为`0001`
>
> 5.通配符、子类选择器、兄弟选择器，如`*, >, +`，权值为`0000`
>
> 6.继承的样式没有权值

## CSS动画

css实现动画有三种方式：

> - transition 实现渐变动画
> - transform 转变动画
> - animation 实现自定义动画

| 属性               | 含义                                                         |
| ------------------ | ------------------------------------------------------------ |
| transition（过度） | 用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同 |
| transform（变形）  | 用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表” |
| translate（移动）  | 只是transform的一个属性值，即移动                            |
| animation（动画）  | 用于设置动画属性，他是一个简写的属性，包含6个属性            |

**transition 实现渐变动画**

`transition`的属性如下：

- property:填写需要变化的css属性
- duration:完成过渡效果需要的时间单位(s或者ms)
- timing-function:完成效果的速度曲线
- delay: 动画效果的延迟触发时间

其中`timing-function`的值有如下：

| 值                            | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| linear                        | 匀速（等于 cubic-bezier(0,0,1,1)）                           |
| ease                          | 从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)）              |
| ease-in                       | 慢慢变快（等于 cubic-bezier(0.42,0,1,1)）                    |
| ease-out                      | 慢慢变慢（等于 cubic-bezier(0,0,0.58,1)）                    |
| ease-in-out                   | 先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果 |
| cubic-bezier(*n*,*n*,*n*,*n*) | 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值 |

注意：并不是所有的属性都能使用过渡的，如`display:none<->display:block`

```
<div class="base"></div>
.base {
  width: 100px;
  height: 100px;
  display: inline-block;
  background-color: #0ea9ff;
  border-width: 5px;
  border-style: solid;
  border-color: #5daf34;
  // transition-property: width, height, background-color, border-width;
  // transition-duration: 2s;
  // transition-timing-function: ease-in;
  // transition-delay: 500ms;
  /*简写*/
  transition: all 2s ease-in 500ms;
}

.base:hover {
  width: 200px;
  height: 200px;
  background-color: #5daf34;
  border-width: 10px;
  border-color: #3a8ee6;
}   
```

**transform 转变动画**

包含四个常用的功能：

- translate：位移
- scale：缩放
- rotate：旋转
- skew：倾斜

一般配合`transition`过度使用

注意的是，`transform`不支持`inline`元素，使用前把它变成`block`

```
.base {
  width: 100px;
  height: 100px;
  display: inline-block;
  background-color: #0ea9ff;
  border-width: 5px;
  border-style: solid;
  border-color: #5daf34;
  // 搭配transition
  transition: all 2s ease-in 500ms;
}

.base:hover {
  width: 200px;
  height: 200px;
  background-color: #5daf34;
  border-width: 10px;
  border-color: #3a8ee6;
  transform: scale(0.8, 1.5) rotate(35deg) skew(5deg) translate(15px, 25px);
}
```

**animation 实现自定义动画**

`animation`是由 8 个属性的简写，分别如下：

| 属性                                   | 描述                                                         | 属性值                                        |
| -------------------------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| animation-duration                     | 指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0 |                                               |
| animation-timing-function              | 指定动画计时函数，即动画的速度曲线，默认是 "ease"            | linear、ease、ease-in、ease-out、ease-in-out  |
| animation-delay                        | 指定动画延迟时间，即动画何时开始，默认是 0                   |                                               |
| animation-iteration-count              | 指定动画播放的次数，默认是 1                                 |                                               |
| animation-direction 指定动画播放的方向 | 默认是 normal                                                | normal、reverse、alternate、alternate-reverse |
| animation-fill-mode                    | 指定动画填充模式。默认是 none                                | forwards、backwards、both                     |
| animation-play-state                   | 指定动画播放状态，正在运行或暂停。默认是 running             | running、pauser                               |
| animation-name                         | 指定 @keyframes 动画的名称                                   |                                               |

`CSS` 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来，

通过 `@keyframes` 来定义关键帧

```
.base {
  width: 100px;
  height: 100px;
  display: inline-block;
  background-color: #0ea9ff;
  border-width: 5px;
  border-style: solid;
  border-color: #5daf34;
}

.base:hover {
  animation: rotate 2s;
}
@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
```



# JS

## async和defer的作用是什么？有什么区别?

- `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- `async script` ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- `defer script`：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。

![image-20211201070616431](/img/image-20211201070616431.png)

## 闭包

#### 闭包：

> 当内部函数被保存到外部时会产生闭包。闭包会导致原有作用域链不释放,造成内存泄漏。

#### 闭包的作用：

> - 实现公有变量 => 累加器
> - 可以做缓存,存储结构
> - 可以实现封装,属性私有化
> - 模块化开发,防止污染全局变量

#### 如何快速判断闭包：

> - 三个特点：
>   - 1. 闭包一定具有嵌套函数
>   - 1. 内层函数一定操作了外层函数的局部变量
>   - 1. 外层函数,将内层函数返回到外部,变量接住(全局变量)

#### 闭包的执行结果

> - 外层函数被调用几次,就有几个受保护的局部变量副本
> - 来自一个闭包的函数被调用几次,受保护的局部变量就变化几次

```
/** 累加器*/
function add() {
  var count = 0;
  function demo() {
    count++;
    console.log(count);
  }
  return demo;
}

var counter = add();
counter();
```

# 房贷利率太高能换银行贷款吗？

这个要视情况而定，如果购房者只是交了首付，还没有找银行正式签订贷款合同，在房贷还没有进入审批手续前，是可以更换贷款银行的。如果房贷利率太高可是房贷已经进入审批阶段，一般是不能中途换银行的。

当然如果房贷已经放款了，购房者后续也可以通过多种方法来降低利率，方法有以下这些：

**1、商转公**

如果一开始申请的是商业贷款，后续可以办理商转公，这样就可以降低贷款利率了，当然商转公也没有那么容易，一是要银行同意，二是要符合商转公的条件。

**2、更改还款方式**

房贷还款方式包括等额本息、等额本金，如果之前选择的等额本息，支付的利息会比较高，如果想要减少利息支出，可以考虑选择等额本金，等额本金的利息比等额本息要低一些，但是等额本金的缺点就是前期还款压力较大。

总的来说，房贷利率太高是否可以换银行要看房贷处于什么阶段，当然即便换不了银行，购房者后续还是有方法来降低利率的，不过实施起来不一定容易。

# Vue3

[Vue3的漏洞](https://www.vue-js.com/topic/61e622a4cbbfd1003b11fa19)

[前端框架设计理念与趋势](https://juejin.cn/post/7123178292865155102#heading-0)

## 常用的周边生态轮子

**PC UI**

- Element Plus
- Ant Design Vue
- Echarts
- Quasar
- Vuetify
- NativeUI
- Prime Vue

**Mobile UI**

- Ionic Vue
- Vant
- Varlet

**国际化**

- vue-i18n
- i18next

**其他生态**

- VueUse：针对vue3 composition api的工具库
- lodash.js
- moment:解析、校验、操作、显示日期和时间
- validator.js：表单验证
- nuxt3
- Animate.css：动画库
- mescroll.js：滚动插件
- swiper：轮播图
- day.js
- vue-draggable：拖拽
- vue-qr：生成二维码
- vue-cropper：图片裁剪
- vue-lazyload：图片懒加载
- clipboard.js：复制粘贴

# 设计模式

《JavaScript设计模式与开发实践》

《JavaScript设计模式核⼼原理与应⽤实践》

**其他**

https://github.com/mynane/PDF/blob/master/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.pdf

https://tb-tech.oss-cn-hangzhou.aliyuncs.com/The%20Complete%20Works%20of%20Tao%20Technology%202022.pdf

**发布订阅模式**

通俗理解：

> 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。
>
> 小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。

有三个要点：

- `发布者`：dep 对象
- `缓存列表`：dep.subscribers
- `发布消息`：dep.notify()

1. 首先要指定好谁充当发布者（比如售楼处）
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）

# gupiao

ETF的T+0交易
主要分为两种：直接T+0和变相T+0。
1.当前跨境ETF（恒生国企ETF、恒生ETF）、债券ETF、黄金ETF、货币ETF基本都可以实现直接T+0交易。
2、变相T+0，是指T日买入的ETF虽然T日不可以卖出，但却可以T日赎回，赎回得到的份额T日可以卖出。反之，T日买入的股票T日可以申购ETF份额，申购得到的份额可以T日卖出。比如上证50ETF

集合竞价
9:15—9:20：这五分钟是开放式集合竞价，可以委托买进和卖出的单子。这段时间是可以撤单的，因此这个时间段你看到的活跃个股的成交量基本上都是假的，因为很多大单是故意挂的，他们会在9:19:30之后撤单，根据开盘价的最大成交量原则，撤单后成交量最大的价格会被打下来很多。

9:20—9:25：这个时间段交易所接受申报，同样可以委托买进和卖出的单子，但是不可以撤单，因此这个时间段你看到的委托单子是真实的。但是!成交价未必，别忘了开盘价的形成是最大成交量原则，如果真正的大资金想要出货，他会在9:24:30之后挂真正的大卖单，价格会瞬间被打下来很多

9:25—9:30：新规则之后，这个时间段交易所不接受买卖申报和撤单。但是，在交易软件你依然可以下单，只是这个委托暂时会被存放到券商的系统里，等到9:30开盘之后，券商会按照下单的时间传送到交易所。

14:57-15:00：深市的股票在这个阶段进行集合竞价形成收盘价，这个时间只能接受买进和卖出申报，不能撤单。

# Webpack

[掘金站内 webpack 优秀文章汇总](https://juejin.cn/post/6844903986185650190)

# Vue Test Utils

- [使用 TDD 开发组件 --- Notification](https://juejin.cn/post/6844904013503152141#heading-19)
- [【element3-开发日记】手摸手教你重写 Button 组件](https://juejin.cn/post/6898959238576472077#heading-0)

# SolidJS

## SolidJS是什么

号称支持现代前端特性：**JSX**、**Fragments**、**Context**、**Portals**、**Suspense**、**Streaming SSR**、**Error Boundaries**、**并发渲染**等现代功能。

又一个摒弃 虚拟DOM，跟 Svelte 一样走编译型路线的框架，没了虚拟DOM 运行时，又通过优秀的响应式系统保证更新颗粒度非常小，性能爆表。和 Svelte 不同的是 Solid 直接借用了 React 社区的 JSX 来编写模板，没有像 Vue Svelte 那样去自定义模板语法。总体来讲 React 有的 API 大部分都能在它里面找到，甚至包括 React 18 的 useTransition，SuspenseList. 另外不提供 Class 组件玩法，所有的组件都是函数组件，且该组件函数只会执行一次。内置了 For 组件来替代 map 来优化性能。支持自定指令等

## 使用

```
import { render } from 'solid-js/web';
import { createSignal, createEffect } from 'solid-js';

const Counter = () => {
  const [getCount, setCount] = createSignal(0);
  const add = () => setCount(getCount() + 1);
  createEffect(() => {
    console.log('count is change:', getCount());
  });

  return (
    <button type='button' onClick={add}>
      {getCount()}
    </button>
  );
};

render(() => <Counter />, document.getElementById('root'));
```

**SolidJS**不仅打包体积小，性能也是 **Number 1**

参照[js-framework-benchmark](https://link.juejin.cn/?target=https%3A%2F%2Fkrausest.github.io%2Fjs-framework-benchmark%2Findex.html) 跑分结果：截图https://juejin.cn/post/7018846783203704863#heading-1

## 特点

### 平衡了 jsx 与 template 的利弊

**jsx** 和 **template** 的优缺点：

> jsx
>
> - 优点：作为`js`的语法糖拥有高度灵活性，可以随意编写
> - 缺点：因为过于灵活在 **编译阶段** 很难分析操作意图
>
> template
>
> - 优点：因为语法有限制，大部分带有 **操作意图（v-if、v-for）** 的代码都可以在 **编译阶段**被识别以做优化
> - 缺点：写法受限，大部分情况下不如`jsx`灵活

**Vue3** 对比 **Vue2** 性能之所以实现了一个质的飞跃，这其中就离不开 **编译阶段优化**。

> 1、 比如在**编译阶段**标记出`template`中永远不会变化的节点作为**静态节点**存储，将来更新时直接绕过他们；
>
> 2、提前对`v-if、v-for`这一类**区块**做区分，将来diff时绕过不必要的判断；
>
> 3、绑定`props`时记录哪些**属性**可能会变，将来 **diff** 时只对比“可能会变化的动态节点和属性”，跳过“永远不会变化的节点和属性”。
>
> 除此之外还有**缓存事件处理程序**等等

但JSX就不能识别操作意图，主要是写法太灵活。如果每种情况都去判断一遍，那么 **编译阶段** 将会非常复杂且耗时，另外显得也非常麻瓜。

```
v-if的写法就有三种：
// 写法1
return status === 1 ? <span>通过</span> : status === 2 ? <span>拒绝</span> : null;
// 写法2
return (
  <>
    {status === 1 && <span>通过</span>}
    {status === 2 && <span>拒绝</span>}
  </>
);
// 写法3
switch (status) {
  case 1:
    return <span>通过</span>;
  case 2:
    return <span>拒绝</span>;
}
```

**SolidJS** 采用的方案是：在 **JSX** 的基础上做了一层规范，中文译名为 [控制流](https://link.juejin.cn/?target=https%3A%2F%2Fwww.solidjs.com%2Fdocs%2Flatest%2Fapi%23%E6%8E%A7%E5%88%B6%E6%B5%81)。写法上类似某种预设的组件，用于**编译阶段**优化。这样在**编译阶段**就可以做**意图分析**，提前知道这是在**做按条件渲染**，然后编译成对应的**dom操作**即可。

SolidJS小结：

> - 即借鉴了 **template** 更容易做编译阶段优化的优势
> - 又保留了 **JSX** 的灵活性

### No Dom Diff

**No Dom Diff** 是说 **SolidJS**在**更新粒度**方面，摒弃了**虚拟dom**，采用**节点级更新**。

目前前端主流的几种方案：

- 应用级更新：状态更新会引起整个应用`render`，具体渲染哪些内容取决于**协调**的结果。代表作有 **React**(因为 **React** 每次更新都会重新走一遍更新流程，做这些限制是为了获取到完整的**VDom树/Fiber树**，通过 **diff新旧两棵树**来决定真正更新哪些组件，所以 **React** 并不是**组件级更新**)
- 组件级更新：状态更新时只会引起绑定了该状态的组件渲染，具体渲染哪些内容同样取决于**协调**的结果。代表作有**vue2.x**
- 节点级更新：状态更新时直接触法绑定该状态的节点更新，也就是**指向型更新**。代表作有**vue1.x**、**Svelte**、**SolidJS**

而**SolidJS**对于三大对象均采用**简单对象**存储，另外不需要**递归观察**，所以占用内存非常少。对于**如何更新dom**，具体的做法是：在**编译阶段**提前生成类似 `insert`、`update`、`delete`的**dom操作**方法，将来更新时直接调用。

### 重·编译时

- 提前生成节点渲染方法

刚才说到 **SolidJS** 在 **jsx** 中借鉴了部分 **template** 的规范写法，在编译阶段 **分析意图**，提前生成对应的**dom操作方法**

- 按需打包，缩小体积

这一步也就是 **tree-shaking**，只打包用到的模块，近一步缩小打包资源体积。

### 轻·运行时

由于没有了**diff**这一大规模计算，使得运行时代码更轻量，所以**SolidJS**在更新时也更**简洁**。

**SolidJS** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

**React v16** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

### 不被顺序限制的 hook

说到前端框架中的 **Hook**，最先将这个方案落地的是**React**，但由于**React**一直推崇 **immutable** 思想，每次更新必须重新走一遍整个树的更新流程，使得 **React Hook** 不可以在条件循环中使用，否则**可能**使渲染结果受到影响。

后来尤大发布了**Vue3.0**，伴随而来的一大特性是**Composition API**，俗称**Vue3 hook**，由于**Vue2**以后都采用**组件级**的**更新粒度**，再加上**响应式原理**采用的是**自动收集依赖**，所以**Vue3 hook**不会有顺序/条件的限制，另外还可以嵌套使用。

**SolidJS**的**响应式原理**主要借鉴了**React Hook**的思想，同时也保留了**Vue3**的**依赖收集模型**，所以用起来非常丝滑。

### 其他

- 脚手架：**degit**，内部集成了 **vite**。
- 支持`TS`且**类型**友好
- 现代前端框架大部分特性：`Fragments`、`Portals`、`Context`、`Suspense`、`事件委托`、`SSR`等等

**参考**

- [比React还Vue3的框架SolidJS](https://juejin.cn/post/7018846783203704863#heading-1)

# Vue与React

## 心智负担

**React的心智负担**

不能在条件语句中使用，`useMemo` 和 `useCallback` 需要显式指定依赖，解决子组件重新渲染可能还需要配合 `React.memo` 使用等等。虽然有对应的 `eslint-plugin` 可以帮助填充依赖，但是依赖项一旦很多，代码的可能读会非常差。现在普遍的观点是计算量大的再用 `useMemo`, 而 `useCallback` 能不用就不用。因为这点优化对性能的影响是微乎其微的，99% 的情况下都不会出现问题，等到出现问题的时候再进行优化也不迟。

**Vue的心智负担**

> 定义状态

ref定义的变量使用时，需要.value。虽然有了 `$ref` 语法糖，但最新已经废弃了。解构 `props` 也会出现响应丢失的问题，还要使用 `toRefs` 来解决。

> 插槽

因为在 `react` 中万物皆 `props`。Vue中需要具名插槽和作用于插槽等。

> props 和 emits 的定义

属性 和 事件 还需要分成 defineProps 和 defineEmits 两个 api。反观 react，还是万物皆 props 。

> 侦听 watch

watch监听对象里的某个属性时，第一个参数还需要是一个函数。还分为好多种，watch、watchPostEffect、watchSyncEffect、watchEffect。watch 的第三个参数又有很多属性。

> 渲染函数

`vue3` 提供了一个 `h` 函数，但还是很难用,还不如tsx。

> typescript 支持

存在语法限制。给 `defineProps` 定义的 ts 类型，不能从其它文件导入，只能写在这个文件里。想分开写到别的文件，只能不使用 ts 来定义类型，要使用 `defineProps` 的第一个参数来指定类型，这样才能从别的文件导入了。这就是为什么大多数组件库没有使用 ts 来定义类型的原因，这样定义的类型要用 `ExtractPropTypes` 来提取 ts 类型。

> breaking change

`vue2` 升级到 `vue3` 是不兼容的，旧项目升级是很麻烦的。反观 `react`，几乎是没什么影响。

# Vue3源码

**生态整理**

> **构建工具**： nuxt3: 一款基于`Vue3`的混合开发框架。 vite: 前端开发与构建工具.
>
> **工具库**： vueuse: 针对vue3 composition api的工具库。
>
> **路由管理库**： vue-router4
>
> **状态管理库**： pinia
>
> ------
>
> **组件库**:
>
> **UI框架**: [element plus](https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2F)、[ant design vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.antdv.com%2F)、[quasar](https://link.juejin.cn?target=https%3A%2F%2Fquasar.dev%2F)、[vuetify3beta](https://link.juejin.cn?target=https%3A%2F%2Fnext.vuetifyjs.com%2Fen%2Fgetting-started%2Finstallation%2F)、[naive ui](https://link.juejin.cn?target=https%3A%2F%2Fwww.naiveui.com%2Fen-US%2Fos-theme)、[prime vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.primefaces.org%2F)
>
> **移动端**: [ionic](https://link.juejin.cn?target=https%3A%2F%2Fionicframework.com%2F)、[vant](https://link.juejin.cn?target=https%3A%2F%2Fyouzan.github.io%2Fvant%2F%23%2Fen-US)、[varlet](https://link.juejin.cn?target=https%3A%2F%2Fmadewithvuejs.com%2Fvarlet-ui)、[nutui](https://link.juejin.cn?target=https%3A%2F%2Fnutui.jd.com%2F%23%2Fstart)、[waveui](

# Vite性能优化

[记一次Vite打包优化](https://developer.aliyun.com/article/1166403)

三部曲：

- Network 分析
- Lighthouse 分析
- Bundle 分析

# 数据结构-1亿数据中访问某数据

先来看一下都有哪些题目：

- 如何从大量的 URL 中找出相同的 URL？（百度）
- 如何从大量数据中找出高频词？（百度）
- 如何找出某一天访问百度网站最多的 IP？（百度）
- 如何在大量的数据中找出不重复的整数？（百度）
- 如何在大量的数据中判断一个数是否存在？（腾讯）
- 如何查询最热门的查询串？（腾讯）
- 如何统计不同电话号码的个数？（百度）
- 如何从 5 亿个数中找出中位数？（百度）
- 如何按照 query 的频度排序？（百度）
- 如何找出排名前 500 的数？（腾讯）

答案呢？往下看~

## 1. 如何从大量的 URL 中找出相同的 URL？

**题目描述**

给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。

**解答思路**

每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。

> 5,000,000,000 * 64B ≈ 5GB * 64 = 320GB

由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用**分治策略**，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。

**思路如下**：

首先遍历文件 a，对遍历到的 URL 求 `hash(URL) % 1000`，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。

接着遍历 ai( `i∈[0,999]`)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。

**方法总结**

1. 分而治之，进行哈希取余；
2. 对每个子文件进行 HashSet 统计。

## 2. 如何从大量数据中找出高频词？

**题目描述**

有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。

**解答思路**

由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用**分治策略**，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。

**思路如下**：

首先遍历大文件，对遍历到的每个词x，执行 `hash(x) % 5000`，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。

接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 `map.put(x, 1)`；若存在，则执行 `map.put(x, map.get(x)+1)`，将该词频数加 1。

上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个**小顶堆**来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个**小顶堆**，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为**小顶堆**，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 3. 如何找出某一天访问百度网站最多的 IP？

**题目描述**

现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。

**解答思路**

这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。

> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 4. 如何在大量的数据中找出不重复的整数？

**题目描述**

在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

**解答思路**

**方法一：分治法**

与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。

**方法二：位图法**

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 `[0,7]` 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0
复制代码
```

然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：

```
0 0 0 0 1 0 1 0
复制代码
```

依次遍历，结束后，位数组是这样的：

```
0 1 1 0 1 1 1 0
复制代码
```

每个为 1 的位，它的下标都表示了一个数：

```arduino
for i in range(8):
    if bits[i] == 1:
        print(i)
复制代码
```

这样我们其实就已经实现了排序。

对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。

**那么对于这道题**，我们用 2 个 bit 来表示各个数字的状态：

- 00 表示这个数字没出现过；
- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；
- 10 表示这个数字出现了多次。

那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：

遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。

**方法总结**

**判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 5. 如何在大量的数据中判断一个数是否存在？

**题目描述**

给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？

**解答思路**

**方法一：分治法**

依然可以用分治法解决，方法与前面类似，就不再次赘述了。

**方法二：位图法**

40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。

我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。

**方法总结**

**判断数字是否存在、判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 6. 如何查询最热门的查询串？

**题目描述**

搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。

假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）

**解答思路**

每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。

**方法一：分治法**

分治法依然是一个非常实用的方法。

划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。

方法可行，但不是最好，下面介绍其他方法。

**方法二：HashMap 法**

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。

**思路如下**：

首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 `O(N)`。

接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。

遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 `O(Nlog10)`。

**方法三：前缀树法**

方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。

**思路如下**：

在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。

最后依然使用小顶堆来对字符串的出现次数进行排序。

**方法总结**

前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。

## 7. 如何统计不同电话号码的个数？

**题目描述**

已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。

**解答思路**

这道题本质还是求解**数据重复**的问题，对于这类问题，一般首先考虑位图法。

对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

**思路如下**：

申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。

**方法总结**

求解数据重复问题，记得考虑位图法。

## 8. 如何从 5 亿个数中找出中位数？

**题目描述**

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 `(N+1)/2` 个数；当样本数为偶数时，中位数为 第 `N/2` 个数与第 `1+N/2` 个数的均值。

**解答思路**

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)`。这里使用其他方法。

**方法一：双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。

若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

```ini
class MedianFinder {
    
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        minHeap = new PriorityQueue<>(Integer::compareTo);
    }
    
    public void addNum(int num) {
        if (maxHeap.isEmpty() || maxHeap.peek() > num) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        if (size1 - size2 > 1) {
            minHeap.offer(maxHeap.poll());
        } else if (size2 - size1 > 1) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    public double findMedian() {
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        
        return size1 == size2 
            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2
            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());
    }
}
复制代码
```

> 见 LeetCode No.295：[leetcode.com/problems/fi…](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.com%2Fproblems%2Ffind-median-from-data-stream%2F)

以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法**适用于数据量较小的情况**。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。

**方法二：分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

> **提示**，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。

对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

> **注意**，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。

**方法总结**

分治法，真香！

## 9. 如何按照 query 的频度排序？

**题目描述**

有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。

**解答思路**

如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。

**方法一：HashMap 法**

如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。

**方法二：分治法**

分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 `hash(query) % 10` 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。

接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。

**方法总结**

- 内存若够，直接读入进行排序；
- 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。

## 10. 如何找出排名前 500 的数？

**题目描述**

有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？

**解答思路**

对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：

首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。

接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。

重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。

> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

```ini
import lombok.Data;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * @author https://github.com/yanglbme
 */
@Data
public class DataWithSource implements Comparable<DataWithSource> {
    /**
     * 数值
     */
    private int value;

    /**
     * 记录数值来源的数组
     */
    private int source;

    /**
     * 记录数值在数组中的索引
     */
    private int index;

    public DataWithSource(int value, int source, int index) {
        this.value = value;
        this.source = source;
        this.index = index;
    }

    /**
     *
     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改
     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆
     */
    @Override
    public int compareTo(DataWithSource o) {
        return Integer.compare(o.getValue(), this.value);
    }
}


class Test {
    public static int[] getTop(int[][] data) {
        int rowSize = data.length;
        int columnSize = data[0].length;

        // 创建一个columnSize大小的数组，存放结果
        int[] result = new int[columnSize];

        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();
        for (int i = 0; i < rowSize; ++i) {
            // 将每个数组的最大一个元素放入堆中
            DataWithSource d = new DataWithSource(data[i][0], i, 0);
            maxHeap.add(d);
        }

        int num = 0;
        while (num < columnSize) {
            // 删除堆顶元素
            DataWithSource d = maxHeap.poll();
            result[num++] = d.getValue();
            if (num >= columnSize) {
                break;
            }

            d.setValue(data[d.getSource()][d.getIndex() + 1]);
            d.setIndex(d.getIndex() + 1);
            maxHeap.add(d);
        }
        return result;

    }

    public static void main(String[] args) {
        int[][] data = {
                {29, 17, 14, 2, 1},
                {19, 17, 16, 15, 6},
                {30, 25, 20, 14, 5},
        };

        int[] top = getTop(data);
        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]
    }
}
复制代码
```

**方法总结**

求 TopK，不妨考虑一下堆排序？