# CSS

## flex=1代表什么，用于什么场景

- flex：1 适用等分布局，在尺寸不足时依然与其他元素保持等分，会优先压缩自身
- flex：auto 适用基于内容动态适配的布局，挤压其他元素的空间

# VueReactAngular

## 框架原理

**不用去在意 Vue 和 React 哪个好**，这种比较没什么意义，**重要的是哪个适合自己/团队，能为自己/团队实现价值**。

卡颂大佬在《React 设计原理》中，提出了一个观点：现代前端框架的实现原理都可以用以下公式进行概括：

**UI = f(state)**

其中：

- state —— 当前的视图的状态
- f —— 框架内部的运行机制
- UI —— 宿主环境的视图

**如何描述 UI**

前端领域经过长期发展，形成了两种主流的 UI 描述方案：

- JSX
- template

JSX 是 Meta（原 Facebook）提出的一种 **ECMAScript 的语法糖**，增强了代码的可读性，但其实最终 JSX 在运行时会被转换成浏览器能够识别的标准 ECMAScript 语法。

template 模板的历史更加久远，它是前后端未分离的时代，已经有的产物，它扩充的是 HTML 语法。

**数据驱动**

框架内部运行机制的实现，可以概括为以下两个步骤：

1. 根据 state 计算出 UI 变化，如， Vue 和 React 通过对比变化前后的 VNode，知道需要更新哪些元素
2. 根据 UI 变化，执行具体宿主（如浏览器）的 API。

> 为什么需要分离成两个步骤？
>
> 前端框架通常会抽离出一套抽象的元素操作的 API，例如：新增/删除/移动元素、修改元素属性等原子操作。不会直接操作浏览器 DOM。这样为了做到平台无关

**按 state 变化后，引起框架的 UI 变更的抽象层级**，作为分类依据，可以将框架分为三类：

- 应用级框架：数据变化 > 应用变化 > 比对应用 > 更新元素
- 组件级框架：数据变化 > 组件变化 > 比对组件 > 更新元素
- 元素级框架：数据变化 > 元素变化 > 更新元素

无论哪种路径，都是从最开始的数据变化，到最终的更新元素。只是**不同框架，能够监听的变化层级不同，从而有了不同的处理**

框架能够监听的层级越抽象，就需要**花费更多的时间用于比对变化**。例如应用级框架，需要比对整个应用前后的变化。

在我们常见的框架中：

- React 属于应用级框架
- Vue 属于组件级框架
- Svelte 属于元素级框架

**前端框架用到的技术**

- 响应式：实现了细粒度的更新，是组件级应用的一种实现
- Virtual DOM：最终目的是快速找出一组 UI 元素中变化的部分，应用级和组件级框架需要使用。元素级框架由于直接指导变化的元素，因此不需要
- AOT 预编译优化：使用模板的框架，能从 AOT 预编译优化中受益，因为模板的结构固定，容易分析。JSX 则难以优化，除非约束 JSX 的灵活性

> 响应式

这是一种**自动追踪依赖的技术**，它用于自动追踪依赖的状态，当状态改变时进行更新。

> Virtual DOM

VDOM 有以下优点：

- 相对于 DOM 有体积优势
- 多平台渲染能力

VDOM 可以多平台渲染能力，但反过来，多平台渲染能力，不一定需要 VDOM

VDOM 的最终目的，其实是用于 Diff，计算出 UI 中变化的部分。但刚好又可以用于多平台渲染。

> AOT 预编译优化

现在前端框架一般都有编译这一步骤，用于：

- 代码转换，如：ts 编译为 js，Vue 将 vue 文件转换成 js
- 编译优化
- 代码压缩、打包

编译有两个执行时机：

- 构建时编译（AOT，预编译）
- 运行时编译（JIT，即时编译）

它们的区别如下：

- AOT 可以提前进行编译，用户直接运行编译后的代码，可以减少首屏时间。而 **JIT 则会消耗更多时间用于编译**
- JIT 的应用代码**体积会更大**，因为需要包含编译的相关逻辑

因此，在大多数情况下，我们使用 AOT 更多。不过有些框架（例如 Vue）会同时提供了 AOT 和 JIT 两种使用方式，以应对一些特殊的情况。



# 计算机网络

## websocket

**Web 实时推送技术对比**

| 方式               | 类型          | 技术实现                                                     | 优点                                                         | 缺点                                                         | 适用场景                     |
| ------------------ | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------- |
| 轮询Polling        | client→server | 客户端循环请求                                               | 1、实现简单 2、 支持跨域                                     | 1、浪费带宽和服务器资源 2、 一次请求信息大半是无用（完整http头信息） 3、有延迟 4、大部分无效请求 | 适于小型应用                 |
| 长轮询Long-Polling | client→server | 服务器hold住连接，一直到有数据或者超时才返回，减少重复请求次数 | 1、实现简单 2、不会频繁发请求 3、节省流量 4、延迟低          | 1、服务器hold住连接，会消耗资源 2、一次请求信息大半是无用    | WebQQ、Hi网页版、Facebook IM |
| 长连接iframe       | client→server | 在页面里嵌入一个隐蔵iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。 | 1、数据实时送达 2、不发无用请求，一次链接，多次“推送”        | 1、服务器增加开销 2、无法准确知道连接状态 3、IE、chrome等一直会处于loading状态 | Gmail聊天                    |
| WebSocket          | server⇌client | new WebSocket()                                              | 1、支持双向通信，实时性更强 2、可发送二进制文件3、减少通信量 | 1、浏览器支持程度不一致 2、不支持断开重连                    | 网络游戏、银行交互和支付     |

**websocket特点**

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据
- 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了

# JS

## JS绑定解除事件

- 第一种
  - 缺点：HTML与js代码紧密耦合。如果要更换 事件，就要改动两个地方:HTML代码和JS代码，这就不利于后期代码的维护。
- 第二种
  - 优点：它最大的优点是就是兼容性很好，所有浏览器都支持
  - 缺点：同一个 dom 元素上，on 只能绑定一个同类型事件，后者会覆盖前者，不同类型的事件可以绑定多个。有一个问题，无法允许团队不同人员对同一元素监听同一事件但做出不用的响应
- 第三种
  - 优点：它们可以支持绑定多个同类型事件
  - 缺点：兼容性并不好,它们只兼容相对应的浏览器才有用。

```
<!-- 第一种 直接在标签里绑定 -->
<button id="btn" onclick="handleClick()">
  自定义函数
</button>

<script>
 // 利用 DOM0 进行绑定
  var btn = document.getElementById('btn')
  btn.onclick = handleClick()
  
  // 利用 DOM3 进行绑定
  btn.addEventListener('click', handleClick)
</script>
```



## JS异步编程的六种方案

参考：[异步编程方案](https://github.com/ljianshu/Blog/issues/53)

- 回调函数（Callback）
- 事件监听
- 发布订阅
- Promise/A+
- 生成器Generators/ yield
- async/await

**回调函数**
致命的弱点，就是容易写出回调地狱（Callback hell）。

- 优点：简单、容易理解和实现
- 缺点：不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪

```
ajax(url, () => {
    // 处理逻辑
})
```

**事件监听**

这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

- 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"，有利于实现模块化。
- 缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

**发布订阅**

我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。

- 优点：与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

**Promise/A+**

Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。

**生成器Generators/ yield**

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。

- 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
- Generator 函数除了状态机，还是一个遍历器对象生成函数。
- 可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。
- yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。

**async/await**

它可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：

- async/await是基于Promise实现的，它不能用于普通的回调函数。
- async/await与Promise一样，是非阻塞的。
- async/await使得异步代码看起来像同步代码，这正是它的魔力所在。

## ES

### ES7新特性

- Array.prototype.includes()

**Array.prototype.includes()**

查询给定字符串是否包含一个字符

### ES8新特性

- Async/Await
- Object.values()，Object.entries()

**Async/Await**

这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。

**Object.values()，Object.entries()**

作为遍历一个对象的补充手段，供for...of循环使用

### ES9新特性

- for await of

**for await of**

for of方法能够遍历具有Symbol.iterator接口的同步迭代器数据，但是不能遍历异步迭代器。

for await of可以用来遍历具有Symbol.asyncIterator方法的数据结构，也就是异步迭代器，且会等待前一个成员的状态改变后才会遍历到下一个成员，相当于async函数内部的await。

### ES10新特性

- Array.prototype.flat()
- String.trimStart 和 String.trimEnd

**Array.prototype.flat()**

将多维数组打平，flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

```
newArray = arr.flat(depth) // depth是指定要提取嵌套数组的结构深度，默认值为 1
```

**String.trimStart 和 String.trimEnd**

移除开头和结尾的空格。

trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。

trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。

### ES2020新特性

- 可选链操作符
- 空位合并操作符
- Promise.allSettled

**可选链操作符**

```
let nestedProp = obj && obj.first && obj.first.second;
let nestedProp = obj?.first?.second;
```

**空位合并操作符**

空位合并操作符，用 ?? 表示

```
let c = a ? a : b // 方式1
let c = a || b // 方式2
缺点：它都会覆盖所有的假值，如a(0, '', false)，这些值可能是在某些情况下有效的输入，但会执行b
```

```
let c = a ?? b;
// 等价于let c = a !== undefined && a !== null ? a : b;
```

**Promise.allSettled**

使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是reject,这会导致页面中该三个区域数据全都无法出来，这个状况我们是无法接受。

Promise.allSettled跟Promise.all类似, 其参数接受一个Promise的数组, 返回一个新的Promise, **唯一的不同在于, 它不会进行短路**, 也就是说当Promise全部处理完成后,我们可以拿到每个Promise的状态, 而不管是否处理成功。

### ES2021/ES12新特性

候选提案

- String.prototype.replaceAll()
- Promise.any
- 逻辑运算符和赋值表达式
- 数值分隔符
- WeakRef and Finalizers

**Promise.any**

Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise。

`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是不会因为某个 `Promise` 变成rejected状态而结束。

## 作用域-执行上下文

**执行上下文**

定义：执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。

- 它包含**三部分**
  - 变量对象（VO）
  - 作用域链（词法作用域）
  - this 指向

- 它的**类型**：
  - 全局执行上下文
  - 函数执行上下文
  - eval 执行上下文

> - 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
> - 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
> - Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。

- 代码执行**过程**：
  - 创建 **全局上下文**（global EC）
  - 全局执行上下文（caller）**自上而下** 逐行执行。遇到函数时，**函数执行上下文**（callee）被 push 到执行栈顶
  - 函数执行上下文被激活，成为 active EC，开始执行函数中的代码，caller 被挂起
  - 函数执行完后，callee 被 pop 移除出执行栈，控制权交还给全局上下文（caller）继续执行

包括三个阶段：**创建阶段→执行阶段→回收阶段**

1.创建阶段

当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

- 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。
- 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
- 确定this指向：包括多种情况，下文会详细说明

在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。

另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。

2.执行阶段

执行变量赋值、代码执行

3.回收阶段

执行上下文出栈等待虚拟机回收执行上下文

**作用域与执行上下文**

JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段。解释阶段确定作用域规则，执行阶段确定上下文。太妙了

解释阶段：

- 词法分析
- 语法分析
- 作用域规则确定

执行阶段：

- 创建执行上下文
- 执行函数代码
- 垃圾回收

> 作用域和执行上下文之间最大的区别是：
> **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

## 作用域-变量对象(VO/AO/GO)

**变量提升**

- 变量声明提升
- 函数声明提升

> 有个细节必须注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。

```
// 变量声明提升
console.log(a)// undefined
var a = 10

// 函数声明提升
function test() {
    foo(); // Uncaught TypeError "foo is not a function"
    bar(); // "this will run!"
    var foo = function () { // function expression assigned to local variable 'foo'
        alert("this won't run!");
    }
    function bar() { // function declaration, given the name 'bar'
        alert("this will run!");
    }
}
test();

// 复杂点例子
function test(arg){
    // 1. 形参 arg 是 "hi"
    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function
    console.log(arg);  
    var arg = 'hello'; // 3.var arg 变量声明被忽略， arg = 'hello'被执行
    function arg(){
 console.log('hello world') 
    }
    console.log(arg);  
}
test('hi');
/* 输出：
function arg(){
    console.log('hello world') 
    }
hello 
*/
```

## 彻底搞懂this

小结：

- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window
- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象
- 在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例
- call、apply和bind：this 是第一个参数
- 箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。

## 函数式编程

**概述**

- 函数式编程：一个函数的返回值，仅仅依赖于参数的值，而不会因为其他外部的状态而不同。
- 命令式编程：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。
- 声明式编程：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。

```
// 函数式
function test(a) {
  return a + 1;
}

//命令式
var CEOs = [];
for(var i = 0; i < companies.length; i++){
    CEOs.push(companies[i].CEO)
}

//声明式
var CEOs = companies.map(c => c.CEO);
```

函数式编程有两个基本特点：

- 通过函数来对数据进行转换
- 通过串联多个函数来求结果

**特点**

- 无状态(引用透明)
- 数据不可变(没有副作用)
- 纯函数
- 惰性执行

1.无状态(引用透明)

> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。

2.数据不可变(没有副作用)

> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。

3.纯函数

具有2个特点

- 无状态： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。
- 数据不可变： 不修改全局变量，不修改入参。

4.惰性执行

所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 `convertName` 产生实际的结果。

# Vue3

## Hooks-迭代2

- 方式一：export default导出单一函数，导入参数，导出函数和出参
- 方式二：参考大崔哥的新写法(同一vue和js文件共享数据)--推荐
- 方式三：返璞归真，结合1和2，进化到hooks本质--强强强推荐

**方式一：export default导出单一函数，导入参数，导出函数和出参**

App.vue

```js
<template>
   <p>{{ num1 }}</p>
   <p>{{ num2 }}</p>
   <p>{{ addNum }}</p>
</template>
<script lang="ts" setup>
const num1 = ref(2)
const num2 = ref(1)
// 方式一
import {useAdd} from './useAdd.ts'     //引入自动hook 
const { addNum, addFn } = useAdd({ num1, num2 })
addFn(num1.value, num2.value)
</script>
```

@/service/useAdd.ts

```
import { ref, watch } from 'vue';
export const useAdd= ({ num1, num2 })  =>{
 // 入参数
    const addNum = ref(0)
     watch([num1, num2], ([num1, num2]) => {
        addFn(num1, num2)
    })
    const addFn = (num1, num2) => {
        addNum.value = num1 + num2
    }
    return {
     // 出参
        addNum,
        // 出函数
        addFn
    }
}
```

**方式二：参考大崔哥的新写法(同一vue和js文件共享数据)--推荐**

- Flow.vue--渲染页面(引入index.ts)

- index.ts-总入口

- tabs.ts--顶部tab业务

- cardBLine.ts--卡片业务

- dialog.ts--弹窗业务

  @/view/Flow.vue--渲染页面

```
import { initAll, diaConfirm } from '@/services/reviewFlow';

const tabs = reactive([]);
const tab = ref();
const cardBLine = ref({});
const dia = ref({});
initAll({ tabs, tab, cardBLine, dia });
```

@/services/index.ts-总入口

```
import { initTabs } from './tabs';
import { initCardBLine } from './cardBLine';
export { initDialog, diaConfirm } from './dialog';

export function initAll(params) {
  initTabs(params.tabs, params.tab);
  initCardBLine(params.cardBLine);
  initDialog(params.dia);
}
```

@/services/tabs.ts--顶部tab业务

```
import * as myApi from '@/services/myApi';

// 分解的产品线
let tabs = [];
let tab = {};

export async function initTabs(tabsReactive, tabRef) {
  declareTag(tabsReactive, tabRef);
  await loadTabs();
  loadTab();
}
function declareTag(tabsReactive, tabRef) {
  // 1.初始化-变量
  tabs = tabsReactive;
  tab = tabRef;
}

async function loadTabs() {
  // 载入tabs
  tabs.length = 0;
  const res = [];
  res.forEach((r) => {
    tabs.push(createTab(r));
  });
}

function createTab(item) {
  // 创建tab
  const result = {
    label: item.pbiNameCn,
    value: item.pbiId,
    product: getProduct(item.pbiId), // 有联动查询
    ...item,
  };
  return result;
}

async function getProduct(id) {
  const res = await myApi.baseLine_querBaseLine();
  return res;
}

function loadTab() {
  // 载入
  const i = tabs.findIndex((t) => t.showFlag === '1');
  // showFlag 0是查看，1是编辑
  tab.value = tabs[i === -1 ? 0 : i];
}
```

@/services/cardBLine.ts--卡片业务

```
import * as myApi from '@/services/myApi';

// 基线对标卡片
let cardBLine = {};

export async function initCardBLine(cardBLineRef) {
  declareTag(cardBLineRef);
  await loadCardBLine();
  setCardBLine();
}
function declareTag(cardBLineRef) {
  // 1.初始化-变量
  cardBLine = cardBLineRef;
}

function loadCardBLine() {
  // 2.载入
  const cbData = { a: 1, b: 2 };
  cardBLine.value = createCardBaseLine(cbData);
}

export function createCardBaseLine(cbData) {
  return {
    prop: 'baseLine',
    label: cbData.a,
    data: cbData.b,
  };
}
async function setCardBLine(result?) {
  // 设值基线对标
  let p0 = result ? result.benchmarkStatus : '';
  setValue(cardBLine.value, 'mark', p0);
  // 未接纳
  if (p0 === 'DIC_MARK_STATUS_003') {
    const markI = cardBLine.value.findIndex((d) => d.prop === 'mark');
    cardBLine.value.splice(markI + 2, 1);
  }
}

export function setValue(prop, val) {
  // 正常设值
  const c1 = cardBLine.value.find((c) => c.prop === prop);
  if (!c1) {
    return;
  }
  c1.value = val;
}
function saveCardBLine() {
  // 保存数据
  const param = collectCardBLine();
  myApi.baseLine_saveBaseLine(param);
}

function collectCardBLine() {
  // 收集数据
  const benchmarkStatus = findValue(cardBLine, 'mark');
  return {
    benchmarkStatus,
  };
}

export function findValue(card, prop) {
  // 正常获取
  return cardBLine.value.data.find((c) => c.prop === prop)?.value;
}

export async function btnToOtherHandle(cb = cardBLine.value) {
  // 可以自己调用，或第三方调用
  await myApi.flow_transfer(cb);
}
```

@/services/dialog.ts--弹窗业务

```
import { btnToOtherHandle } from './tabs';

// 弹窗信息
let dia = {};

export async function initDialog(diaRef) {
  declareTag(diaRef);
  loadDia();
}

function declareTag(diaRef) {
  // 1.初始化-变量
  dia = diaRef;
}

function loadDia() {
  // 2.载入
  dia.value = createDia('transfer');
}

function createDia(type) {
  const t = {
    transfer: {
      dVis: false,
      dType: 'transfer',
      dTitle: '转他人审批',
      dClass: 'transfer',
      dCont: {
        val: '',
      },
    },
  };
  return t[type];
}

export async function btnToOther() {
  // 转给他人审批
  dia.value.dVis = true;
}

export async function diaConfirm(cardBLine) {
  // 弹窗确认
  const { dType } = dia.value;
  if (dType === 'transfer') {
    dia.value.dVis = false;
    btnToOtherHandle(cardBLine);
  }
}
```

**方式三：返璞归真，结合1和2，进化到hooks本质--强强强推荐**

@/view/Flow.vue--渲染页面

```
<script setup>
import { userFlow } from '@/services/userFlow';
const {tabs,tab,cardBLine,dia,diaConfirm} = userFlow()
</script>

<template>
<Tab v-model:tab="tab" :tabs="tabs"></Tab>
<CardBaseLine v-model:card="cardBLine"></CardBaseLine>
<VDialog v-model:dVis="dia.dVis" v-bind="dia" @oprate="diaConfirm(dia)">
      <div>
        <span>转给</span>
        <VUser v-model:user="dia.dCont"></VUser>
      </div>
    </VDialog>
<template>
```

@/services/userFlow.ts-总入口

```
import { useTabs } from './useTabs';
import { useCardBLine } from './useCardBLine';
export { userDialog } from './userDialog';

export async function userFlow() {
 const {tabs,tab} =await useTabs();
 const {cardBLine} =await useCardBLine();
 const {dia,diaConfirm} =await userDialog();
  return {tabs,tab,cardBLine,dia,diaConfirm}
}
```

@/services/useTabs.ts--顶部tab业务

```
import * as myApi from '@/services/myApi';

// 分解的产品线
let tabs = reactive([]);
let tab = ref();

export async function  useTabs() {
  async function initTabs(){
   watchOnce(
    () => tab.value,
    (value) => {
      // 其他操作
    },
  )
    await loadTabs();
   loadTab();
  }
  async function loadTabs() {
  // 载入tabs
  tabs.length = 0;
  const res = [];
  res.forEach((r) => {
    tabs.push(createTab(r));
  });
}

function createTab(item) {
  // 创建tab
  const result = {
    label: item.pbiNameCn,
    value: item.pbiId,
    product: getProduct(item.pbiId), // 有联动查询
    ...item,
  };
  return result;
}

async function getProduct(id) {
  const res = await myApi.baseLine_querBaseLine();
  return res;
}

function loadTab() {
  // 载入
  const i = tabs.findIndex((t) => t.showFlag === '1');
  // showFlag 0是查看，1是编辑
  tab.value = tabs[i === -1 ? 0 : i];
}

  initTabs()
  return {
   tabs,tab
  }
}
```

@/services/useCardBLine.ts--卡片业务

```
import * as myApi from '@/services/myApi';

// 基线对标卡片
let cardBLine = ref();

export async function useCardBLine() {
  async function initCardBLine(){
     await loadCardBLine();
     setCardBLine();
  }
  function loadCardBLine() {
  // 2.载入
  const cbData = { a: 1, b: 2 };
  cardBLine.value = createCardBaseLine(cbData);
}

 function createCardBaseLine(cbData) {
  return {
    prop: 'baseLine',
    label: cbData.a,
    data: cbData.b,
  };
}
 function setCardBLine(result?) {
  // 设值基线对标
  let p0 = result ? result.benchmarkStatus : '';
  setValue(cardBLine.value, 'mark', p0);
  // 未接纳
  if (p0 === 'DIC_MARK_STATUS_003') {
    const markI = cardBLine.value.findIndex((d) => d.prop === 'mark');
    cardBLine.value.splice(markI + 2, 1);
  }
}

 function setValue(prop, val) {
  // 正常设值
  const c1 = cardBLine.value.find((c) => c.prop === prop);
  if (!c1) {
    return;
  }
  c1.value = val;
}
function saveCardBLine() {
  // 保存数据
  const param = collectCardBLine();
  myApi.baseLine_saveBaseLine(param);
}

function collectCardBLine() {
  // 收集数据
  const benchmarkStatus = findValue(cardBLine, 'mark');
  return {
    benchmarkStatus,
  };
}

 function findValue(card, prop) {
  // 正常获取
  return cardBLine.value.data.find((c) => c.prop === prop)?.value;
}

 async function btnToOtherHandle(cb = cardBLine.value) {
  // 可以自己调用，或第三方调用
  await myApi.flow_transfer(cb);
}

  initCardBLine()
  return {cardBLine,btnToOtherHandle}
}
```

@/services/userDialog.ts--弹窗业务

```
// 弹窗信息
let dia = ref();

export async function userDialog() {
  function initDialog(){
     loadDia();
  }
  function loadDia() {
  // 2.载入
  dia.value = createDia('transfer');
}

function createDia(type) {
  const t = {
    transfer: {
      dVis: false,
      dType: 'transfer',
      dTitle: '转他人审批',
      dClass: 'transfer',
      dCont: {
        val: '',
      },
    },
  };
  return t[type];
}

 async function btnToOther() {
  // 转给他人审批
  dia.value.dVis = true;
}

 async function diaConfirm(cardBLine) {
  // 弹窗确认
  const { dType } = dia.value;
  if (dType === 'transfer') {
    dia.value.dVis = false;
  }
}
  
  initDialog()
  return {dia,diaConfirm}
}
```

# vue2

## 组件库开发的难点

1. 数据通信：Vue 组件之间的数据通信可以使用 props、emit、provide/inject 等方式实现。但是，对于复杂的组件结构和组件之间的数据交互，数据通信可能会比较困难。
2. 组件复杂度和扩展性：当组件的结构和逻辑变得复杂时，开发和维护组件就变得更加困难。需要通过合理的组件拆分、代码抽象和模块化等方式来降低组件的复杂度，提高可读性和可维护性。如拆分子组件，slot插槽扩展
3. 生命周期和钩子函数：Vue 组件有很多生命周期函数和钩子函数，需要熟悉它们的执行顺序和作用，以便在组件开发过程中能够正确地处理组件的状态和行为。
4. 性能优化：当组件的渲染次数过多、数据量过大时，会影响应用的性能。需要通过组件懒加载、异步渲染、缓存数据等方式来优化组件的性能，提高应用的响应速度。

# Http缓存

**强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304**

关键参数

> - Expires
>   - 缓存过期时间。HTTP1.0的产物，会将浏览器的Expires 时间与服务器系统时间对比，Expires=max-age + 请求时间。
> - Cache-Control
>   - max-age：表示缓存内容将在xxx秒后失效
>   - no-cache：不使用强缓存(走协商缓存)，需要与服务器验证缓存是否新鲜
>   - no-store：禁止使用所有缓存（包括协商缓存），每次都向服务器请求最新的资源
>   - private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
>   - public：响应可以被中间代理、CDN 等缓存
>   - must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
> - Pragma 
>   - Pragma 只有一个属性值，就是 no-cache,不使用强缓存



# 如何用chatgpt提升前端开发效率

**问题解答和指导**：`ChatGPT`可以帮助回答与前端开发相关的问题。当你在编写代码的时候，当一时忘记了某个API怎么用，就可以向`ChatGPT`提问，并获得解答和指导，甚至还会给出一些更加深入且性能更好的应用。这可以帮助更快地解决问题和理解前端开发中的概念。

**代码片段和示例**：`ChatGPT`可以帮助你生成常见的前端代码片段和示例。你可以描述你想要实现的功能或解决的问题，然后向`ChatGPT`请求相关代码片段。这样，您可以更快地获得一些基础代码，从而加快开发速度。

**自动生成文档**：`ChatGPT`可以帮助你生成前端代码的文档。你可以描述一个函数、组件或类，并向`ChatGPT`请求生成相关的文档注释。这可以帮助您更轻松地为你的代码添加文档，提高代码的可读性和可维护性。

**问题排查和调试**：在开发过程中，您可能会遇到问题或错误。您可以向`ChatGPT`描述您遇到的问题，或者直接把代码交给它，并请求帮助进行排查和调试。`ChatGPT`可以提供一些建议和指导，帮助您更快地找到问题的根本原因并解决它们。

**学习资源和最新信息**：`ChatGPT`可以为你提供关于前端开发的学习资源和最新信息。你可以向`ChatGPT`询问关于前端开发的最佳实践、最新的框架或库、前端设计原则等方面的问题。这可以帮助我们不断学习和更新自己的前端开发知识，从而提高效率。

# JS

## 一维数组转为二维数组

```
function convertTo2DArray(arr, chunkSize) {
      var result = [];
      for (var i = 0; i < arr.length; i += chunkSize) {
        result.push(arr.slice(i, i + chunkSize));
      }
      return result;
}
 var inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];
 // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
 var outputArray = convertTo2DArray(inputArray, 3);
```



# Vue3

## Hooks

- 方式一：export default导出单一函数，导入参数，导出函数和出参
- 方式二：参考大崔哥的新写法(同一vue和js文件共享数据)--强烈推荐

**方式一：export default导出单一函数，导入参数，导出函数和出参**

App.vue

```js
<template>
   <p>{{ num1 }}</p>
   <p>{{ num2 }}</p>
   <p>{{ addNum }}</p>
</template>
<script lang="ts" setup>
const num1 = ref(2)
const num2 = ref(1)
// 方式一
import {useAdd} from './useAdd.ts'     //引入自动hook 
const { addNum, addFn } = useAdd({ num1, num2 })
addFn(num1.value, num2.value)
</script>
```

@/service/useAdd.ts

```
import { ref, watch } from 'vue';
export const useAdd= ({ num1, num2 })  =>{
 // 入参数
    const addNum = ref(0)
     watch([num1, num2], ([num1, num2]) => {
        addFn(num1, num2)
    })
    const addFn = (num1, num2) => {
        addNum.value = num1 + num2
    }
    return {
     // 出参
        addNum,
        // 出函数
        addFn
    }
}
```

**方式二：参考大崔哥的新写法(同一vue和js文件共享数据)--强烈推荐**

Task.vue

```
<script setup lang="ts">
import { ref,onBeforeMount } from 'vue';
import { initListTag } from '@/service/task.ts'

// 注意listTags只能在当前vue文件和当前ts文件下共享
let lists =reactive({})
onBeforeMount(async () => {
   initLists(lists)
})
</script>
<template>
<div v-for="(listTag,i) in lists.listTags" :key="'listTags'+i" @click="listTag.loadTasks(listTag.id)">{{ listTag.label }}</div>
</template>
```

@/service/task.ts

```
import { ref } from 'vue';
import * as myapi from '@/service/myapi';
let lists = {}

 export async function initLists(
  listsReactive
) {
  // 0.初始化
  declareListTag(listsReactive)
  await loadTags()
}

 function declareListTag(
  listsReactive
) {
  // 1.初始化-变量
  lists.listTags = []
}

export async function loadTags() {
  // 2.初始化-填充tags
  const res= await myapi.getTasksByTags()
  lists.listTags= res.map(r=>{
   return createListTag(r.name, r.color, r.parentTagId || undefined, r.id)
  })
}

export function createListTag(name, color?, parentTagId?, id = 0){
  // 3.初始化-创建tag
  return {
    id,
    name,
    color: color || '',
    parentTagId: parentTagId || null,
    loadTasks: () => {
      getTaskId(id)
    },
  }
}

function getTaskId(){
 return myapi.getTasksByTagId(id)
}
export async function addListTag(tag) {
  // 添加tag等其他逻辑处理,此处可以拿到listTags变量
  const pIndex = await myapi.addTag(tag.name, tag.parentTagId, tag.color)
  if (pIndex)
    tag.id = pIndex
  lists.listTags.push(tag)
}
```



# VueUse

是一款基于组合式API的函数集合。

## 指南

核心包括9种函数：

- 动画（Animation）—包含易于使用的过渡、超时和计时函数
- 浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等
- 组件（Component）— 为不同的组件方法提供简写
- Formatters – 提供反应时间格式化功能
- 传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件
- 状态（State ）—管理用户状态（全局、本地存储、会话存储）
- 实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等
- Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者

## 常用的5大函数

### useVModel

简化了 v-model 绑定

```
<div v-model="isPop"></div>
import { useVModels } from '@vueuse/core';
const props = defineProps({
  isPop: {
    default: false,
  }})
const { isPop } = useVModels(props, emits);
const emits = defineEmits(['update:isPop']);
// 修改值
isPop.value = true
```

### onClickOutside

关闭模态

```
<button @click="open = true"> Open Popup </button>
  <div class="popup" v-if='open'>
  我是弹窗
  </div>
 import { onClickOutside } from '@vueuse/core'
 const open = ref(false) // state of our popup
const popup = ref() // template ref
onClickOutside(popup, () => {
  open.value  = false
})
```

### useTransition 

允许我们在一行内平滑地转换数值

步骤：

> - 创建我们的 `count` ref并将其初始化为零
> - 使用 `useTransition` 创建 `output` ref(设置持续时间和转换类型)
> - 更改 `count` 的值

```
<template>
  <h2> 
    <p> Join over </p>
    <p> {{ Math.round(output) }}+ </p>
    <p>Developers </p>
  </h2>
</template>

<script setup>
import { ref } from 'vue'
import { useTransition, TransitionPresets } from '@vueuse/core'
const source = ref()
const output = useTransition(source, {
  duration: 3000,
  transition: TransitionPresets.easeOutExpo,
})
source.value = 5000
</script>
```



### useRefHistory 

`useRefHistory` 跟踪对Ref所做的每一个改变，并将其存储在一个数组中。这使我们能够轻松地为我们的应用程序提供撤销和重做功能。

### useIntersectionObserver

在确定两个元素是否重叠时，[Intersection Observers ](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FIntersectionObserver)非常强大。一个很好的用例是检查元素当前是否在视口中可见。

# **vue3 **

vue2和vue3的生命周期都放在原理篇里

## **生命周期**

截图：https://www.jianshu.com/p/3657015c35e9和https://blog.csdn.net/navysir8/article/details/122882918和https://www.cnblogs.com/qingheshiguang/p/14677198.html

## Vapor Mode

Vapor Mode是一种替代编译策略，受到Solid的启发，我们一直在进行实验。使用相同的Vue SFC，Vapor Mode将其编译为JavaScript输出，与当前基于Virtual DOM的输出相比，它更具有性能、内存占用和运行时支持代码方面的优势。尽管它仍处于早期阶段，拥有以下优点：

- 1、Vapor模式旨在用于性能是主要关注点的用例。它是选择性的，不会影响现有的代码库。
- 2、您将能够将Vapor组件子树嵌入到任何现有的Vue 3应用程序中。理想情况下，我们希望在组件级别实现细粒度选择，这意味着可以在同一个应用程序中自由混合Vapor和非Vapor组件。
- 3、仅使用Vapor组件构建应用程序允许您从构建包中删除虚拟DOM运行时，从而显着减少基线运行时大小。
- 4、为了实现最佳性能，Vapor模式将仅支持Vue功能的子集。特别地，Vapor模式组件将仅支持Composition API和<script setup>。然而，这个受支持的子集在Vapor和非Vapor组件之间将完全相同。

不同框架的编译策略对比：

- 🚀 React编译之后是`Jsx`函数返回的`虚拟DOM`
- 🚀 Vue编译之后是`render`函数返回的`虚拟DOM`
- 🚀 SolidJS编译之后返回的`真实DOM`字符串
- 🚀 Svelte编译之后返回的是`真实DOM`片段

> 粗颗粒度：`React`由于架构机制决定了每当状态发生改变，从当前组件开始一直到叶子组件重新加载。
>
> 中颗粒度：`Vue`由于给每个组件建立了`watchEffect`监听机制，每当组件依赖的状态发生改变，当前组件重新加载。
>
> 细颗粒度：`SolidJS`和`Svelte`由于在编译之后就确定了当状态发生改变`UI`随之变化的关系，所以仅仅是具体`DOM`的重新加载。

对于组件更新时：

- `React`在当前组件状态发生变化时，从当前组件开始，包括子组件都被重新加载了。
- `Vue`仅仅是当前组件重新加载。
- `SolidJS`、`Svelte`仅仅是重新加载对应的`DOM`！

在项目比较小时，`SolidJS`、`Svelte`的优势不会很明显，

但是当面对大型项目时，`React`和`Vue`的性能短板就显露出来了。

`Vapor mode`可以在给定相同的`Vue SFC`前提下，与当前基于`虚拟DOM`的输出相比，`Vapor Mode`将其编译成性能更高、使用更少内存且需要更少运行时支持代码的`JavaScript`输出。

# Echarts

## 常见问题

- [Echarts常见问题及解决方法](https://bbchin.com/archives/echart-cases#%E5%89%8D%E8%A8%80)

## 如何处理大量数据渲染

设置datazoom，类似分页效果

## 如何动态适配容器宽高

window.resize

window.resizeObserver

echart.resize()

## 文件超长如何处理

对formatter显示的文字长度做个截断展示，如a.slice(0,5)+'...'

## 切换图表卡顿

原因：可能内存溢出了

解决：echarts.clear()和echarts.dispose()

> `echarts.clear()`是清空当前实例，会移除实例中所有的组件和图表。类似v-show
>
> `echarts.dispose()`是销毁实例，销毁后实例无法再被使用。类似v-if

# ElelemtUI

## 如何实现table组件自定义功能

开启slot插槽功能

## 如何覆盖组件样式

使用样式穿透

## popover组件二次封装

自定义虚拟手动触发

```
v-model:visible="isPop"
```

是否将内容插入到body

```
:teleported="false" 
```

## 国际化配置

```
import zhCn from 'element-plus/es/locale/lang/zh-cn';
import en from 'element-plus/es/locale/lang/en';

<el-config-provider :locale="locale"> // zhCn : en
    <router-view v-if="comStore.leaf" />
     <div v-else class="noPermit">
         <span>抱歉，您暂无访问权限！</span>
     </div>
</el-config-provider>
```



# 书单

《JavaScript高级程序设计》

《Javascript权威指南》

《图解HTTP》

《数据结构与算法JavaScript描述》

《JavaScript设计模式》

# 房贷利率太高能换银行贷款吗？

这个要视情况而定，如果购房者只是交了首付，还没有找银行正式签订贷款合同，在房贷还没有进入审批手续前，是可以更换贷款银行的。如果房贷利率太高可是房贷已经进入审批阶段，一般是不能中途换银行的。

当然如果房贷已经放款了，购房者后续也可以通过多种方法来降低利率，方法有以下这些：

**1、商转公**

如果一开始申请的是商业贷款，后续可以办理商转公，这样就可以降低贷款利率了，当然商转公也没有那么容易，一是要银行同意，二是要符合商转公的条件。

**2、更改还款方式**

房贷还款方式包括等额本息、等额本金，如果之前选择的等额本息，支付的利息会比较高，如果想要减少利息支出，可以考虑选择等额本金，等额本金的利息比等额本息要低一些，但是等额本金的缺点就是前期还款压力较大。

总的来说，房贷利率太高是否可以换银行要看房贷处于什么阶段，当然即便换不了银行，购房者后续还是有方法来降低利率的，不过实施起来不一定容易。

# Vue3

[Vue3的漏洞](https://www.vue-js.com/topic/61e622a4cbbfd1003b11fa19)

[前端框架设计理念与趋势](https://juejin.cn/post/7123178292865155102#heading-0)

## 常用的周边生态轮子

**PC UI**

- Element Plus
- Ant Design Vue
- Echarts
- Quasar
- Vuetify
- NativeUI
- Prime Vue

**Mobile UI**

- Ionic Vue
- Vant
- Varlet

**国际化**

- vue-i18n
- i18next

**其他生态**

- VueUse：针对vue3 composition api的工具库
- lodash.js
- moment:解析、校验、操作、显示日期和时间
- validator.js：表单验证
- nuxt3
- Animate.css：动画库
- mescroll.js：滚动插件
- swiper：轮播图
- day.js
- vue-draggable：拖拽
- vue-qr：生成二维码
- vue-cropper：图片裁剪
- vue-lazyload：图片懒加载
- clipboard.js：复制粘贴

# 设计模式

《JavaScript设计模式与开发实践》

《JavaScript设计模式核⼼原理与应⽤实践》

**其他**

https://github.com/mynane/PDF/blob/master/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.pdf

https://tb-tech.oss-cn-hangzhou.aliyuncs.com/The%20Complete%20Works%20of%20Tao%20Technology%202022.pdf

**发布订阅模式**

通俗理解：

> 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。
>
> 小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。

有三个要点：

- `发布者`：dep 对象
- `缓存列表`：dep.subscribers
- `发布消息`：dep.notify()

1. 首先要指定好谁充当发布者（比如售楼处）
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）

# gupiao

ETF的T+0交易
主要分为两种：直接T+0和变相T+0。
1.当前跨境ETF（恒生国企ETF、恒生ETF）、债券ETF、黄金ETF、货币ETF基本都可以实现直接T+0交易。
2、变相T+0，是指T日买入的ETF虽然T日不可以卖出，但却可以T日赎回，赎回得到的份额T日可以卖出。反之，T日买入的股票T日可以申购ETF份额，申购得到的份额可以T日卖出。比如上证50ETF

集合竞价
9:15—9:20：这五分钟是开放式集合竞价，可以委托买进和卖出的单子。这段时间是可以撤单的，因此这个时间段你看到的活跃个股的成交量基本上都是假的，因为很多大单是故意挂的，他们会在9:19:30之后撤单，根据开盘价的最大成交量原则，撤单后成交量最大的价格会被打下来很多。

9:20—9:25：这个时间段交易所接受申报，同样可以委托买进和卖出的单子，但是不可以撤单，因此这个时间段你看到的委托单子是真实的。但是!成交价未必，别忘了开盘价的形成是最大成交量原则，如果真正的大资金想要出货，他会在9:24:30之后挂真正的大卖单，价格会瞬间被打下来很多

9:25—9:30：新规则之后，这个时间段交易所不接受买卖申报和撤单。但是，在交易软件你依然可以下单，只是这个委托暂时会被存放到券商的系统里，等到9:30开盘之后，券商会按照下单的时间传送到交易所。

14:57-15:00：深市的股票在这个阶段进行集合竞价形成收盘价，这个时间只能接受买进和卖出申报，不能撤单。

# Webpack

[掘金站内 webpack 优秀文章汇总](https://juejin.cn/post/6844903986185650190)

# Vue Test Utils

- [使用 TDD 开发组件 --- Notification](https://juejin.cn/post/6844904013503152141#heading-19)
- [【element3-开发日记】手摸手教你重写 Button 组件](https://juejin.cn/post/6898959238576472077#heading-0)

# SolidJS

## SolidJS是什么

号称支持现代前端特性：**JSX**、**Fragments**、**Context**、**Portals**、**Suspense**、**Streaming SSR**、**Error Boundaries**、**并发渲染**等现代功能。

又一个摒弃 虚拟DOM，跟 Svelte 一样走编译型路线的框架，没了虚拟DOM 运行时，又通过优秀的响应式系统保证更新颗粒度非常小，性能爆表。和 Svelte 不同的是 Solid 直接借用了 React 社区的 JSX 来编写模板，没有像 Vue Svelte 那样去自定义模板语法。总体来讲 React 有的 API 大部分都能在它里面找到，甚至包括 React 18 的 useTransition，SuspenseList. 另外不提供 Class 组件玩法，所有的组件都是函数组件，且该组件函数只会执行一次。内置了 For 组件来替代 map 来优化性能。支持自定指令等

## 使用

```
import { render } from 'solid-js/web';
import { createSignal, createEffect } from 'solid-js';

const Counter = () => {
  const [getCount, setCount] = createSignal(0);
  const add = () => setCount(getCount() + 1);
  createEffect(() => {
    console.log('count is change:', getCount());
  });

  return (
    <button type='button' onClick={add}>
      {getCount()}
    </button>
  );
};

render(() => <Counter />, document.getElementById('root'));
```

**SolidJS**不仅打包体积小，性能也是 **Number 1**

参照[js-framework-benchmark](https://link.juejin.cn/?target=https%3A%2F%2Fkrausest.github.io%2Fjs-framework-benchmark%2Findex.html) 跑分结果

<img src="/img/image-20230614065546092.png" alt="image-20230614065546092" style="zoom:80%;" />

## 特点

### 平衡了 jsx 与 template 的利弊

**jsx** 和 **template** 的优缺点：

> jsx
>
> - 优点：作为`js`的语法糖拥有高度灵活性，可以随意编写
> - 缺点：因为过于灵活在 **编译阶段** 很难分析操作意图
>
> template
>
> - 优点：因为语法有限制，大部分带有 **操作意图（v-if、v-for）** 的代码都可以在 **编译阶段**被识别以做优化
> - 缺点：写法受限，大部分情况下不如`jsx`灵活

**Vue3** 对比 **Vue2** 性能之所以实现了一个质的飞跃，这其中就离不开 **编译阶段优化**。

> 1、 比如在**编译阶段**标记出`template`中永远不会变化的节点作为**静态节点**存储，将来更新时直接绕过他们；
>
> 2、提前对`v-if、v-for`这一类**区块**做区分，将来diff时绕过不必要的判断；
>
> 3、绑定`props`时记录哪些**属性**可能会变，将来 **diff** 时只对比“可能会变化的动态节点和属性”，跳过“永远不会变化的节点和属性”。
>
> 除此之外还有**缓存事件处理程序**等等

但JSX就不能识别操作意图，主要是写法太灵活。如果每种情况都去判断一遍，那么 **编译阶段** 将会非常复杂且耗时，另外显得也非常麻瓜。

```
v-if的写法就有三种：
// 写法1
return status === 1 ? <span>通过</span> : status === 2 ? <span>拒绝</span> : null;
// 写法2
return (
  <>
    {status === 1 && <span>通过</span>}
    {status === 2 && <span>拒绝</span>}
  </>
);
// 写法3
switch (status) {
  case 1:
    return <span>通过</span>;
  case 2:
    return <span>拒绝</span>;
}
```

**SolidJS** 采用的方案是：在 **JSX** 的基础上做了一层规范，中文译名为 [控制流](https://link.juejin.cn/?target=https%3A%2F%2Fwww.solidjs.com%2Fdocs%2Flatest%2Fapi%23%E6%8E%A7%E5%88%B6%E6%B5%81)。写法上类似某种预设的组件，用于**编译阶段**优化。这样在**编译阶段**就可以做**意图分析**，提前知道这是在**做按条件渲染**，然后编译成对应的**dom操作**即可。

SolidJS小结：

> - 即借鉴了 **template** 更容易做编译阶段优化的优势
> - 又保留了 **JSX** 的灵活性

### No Dom Diff

**No Dom Diff** 是说 **SolidJS**在**更新粒度**方面，摒弃了**虚拟dom**，采用**节点级更新**。

目前前端主流的几种方案：

- 应用级更新：状态更新会引起整个应用`render`，具体渲染哪些内容取决于**协调**的结果。代表作有 **React**(因为 **React** 每次更新都会重新走一遍更新流程，做这些限制是为了获取到完整的**VDom树/Fiber树**，通过 **diff新旧两棵树**来决定真正更新哪些组件，所以 **React** 并不是**组件级更新**)
- 组件级更新：状态更新时只会引起绑定了该状态的组件渲染，具体渲染哪些内容同样取决于**协调**的结果。代表作有**vue2.x**
- 节点级更新：状态更新时直接触法绑定该状态的节点更新，也就是**指向型更新**。代表作有**vue1.x**、**Svelte**、**SolidJS**

而**SolidJS**对于三大对象均采用**简单对象**存储，另外不需要**递归观察**，所以占用内存非常少。对于**如何更新dom**，具体的做法是：在**编译阶段**提前生成类似 `insert`、`update`、`delete`的**dom操作**方法，将来更新时直接调用。

### 重·编译时

- 提前生成节点渲染方法

刚才说到 **SolidJS** 在 **jsx** 中借鉴了部分 **template** 的规范写法，在编译阶段 **分析意图**，提前生成对应的**dom操作方法**

- 按需打包，缩小体积

这一步也就是 **tree-shaking**，只打包用到的模块，近一步缩小打包资源体积。

### 轻·运行时

由于没有了**diff**这一大规模计算，使得运行时代码更轻量，所以**SolidJS**在更新时也更**简洁**。

**SolidJS** 在更新时的**js调用栈**如图：

<img src="/img/image-20230614065648667.png" alt="image-20230614065648667" style="zoom:80%;" />

**React v16** 在更新时的**js调用栈**如图：

<img src="/img/image-20230614065722172.png" alt="image-20230614065722172" style="zoom:80%;" />

### 不被顺序限制的 hook

说到前端框架中的 **Hook**，最先将这个方案落地的是**React**，但由于**React**一直推崇 **immutable** 思想，每次更新必须重新走一遍整个树的更新流程，使得 **React Hook** 不可以在条件循环中使用，否则**可能**使渲染结果受到影响。

后来尤大发布了**Vue3.0**，伴随而来的一大特性是**Composition API**，俗称**Vue3 hook**，由于**Vue2**以后都采用**组件级**的**更新粒度**，再加上**响应式原理**采用的是**自动收集依赖**，所以**Vue3 hook**不会有顺序/条件的限制，另外还可以嵌套使用。

**SolidJS**的**响应式原理**主要借鉴了**React Hook**的思想，同时也保留了**Vue3**的**依赖收集模型**，所以用起来非常丝滑。

### 其他

- 脚手架：**degit**，内部集成了 **vite**。
- 支持`TS`且**类型**友好
- 现代前端框架大部分特性：`Fragments`、`Portals`、`Context`、`Suspense`、`事件委托`、`SSR`等等

**参考**

- [比React还Vue3的框架SolidJS](https://juejin.cn/post/7018846783203704863#heading-1)

# Vue与React

## 心智负担

**React的心智负担**

不能在条件语句中使用，`useMemo` 和 `useCallback` 需要显式指定依赖，解决子组件重新渲染可能还需要配合 `React.memo` 使用等等。虽然有对应的 `eslint-plugin` 可以帮助填充依赖，但是依赖项一旦很多，代码的可能读会非常差。现在普遍的观点是计算量大的再用 `useMemo`, 而 `useCallback` 能不用就不用。因为这点优化对性能的影响是微乎其微的，99% 的情况下都不会出现问题，等到出现问题的时候再进行优化也不迟。

**Vue的心智负担**

> 定义状态

ref定义的变量使用时，需要.value。虽然有了 `$ref` 语法糖，但最新已经废弃了。解构 `props` 也会出现响应丢失的问题，还要使用 `toRefs` 来解决。

> 插槽

因为在 `react` 中万物皆 `props`。Vue中需要具名插槽和作用于插槽等。

> props 和 emits 的定义

属性 和 事件 还需要分成 defineProps 和 defineEmits 两个 api。反观 react，还是万物皆 props 。

> 侦听 watch

watch监听对象里的某个属性时，第一个参数还需要是一个函数。还分为好多种，watch、watchPostEffect、watchSyncEffect、watchEffect。watch 的第三个参数又有很多属性。

> 渲染函数

`vue3` 提供了一个 `h` 函数，但还是很难用,还不如tsx。

> typescript 支持

存在语法限制。给 `defineProps` 定义的 ts 类型，不能从其它文件导入，只能写在这个文件里。想分开写到别的文件，只能不使用 ts 来定义类型，要使用 `defineProps` 的第一个参数来指定类型，这样才能从别的文件导入了。这就是为什么大多数组件库没有使用 ts 来定义类型的原因，这样定义的类型要用 `ExtractPropTypes` 来提取 ts 类型。

> breaking change

`vue2` 升级到 `vue3` 是不兼容的，旧项目升级是很麻烦的。反观 `react`，几乎是没什么影响。

# Vue3源码

**生态整理**

> **构建工具**： nuxt3: 一款基于`Vue3`的混合开发框架。 vite: 前端开发与构建工具.
>
> **工具库**： vueuse: 针对vue3 composition api的工具库。
>
> **路由管理库**： vue-router4
>
> **状态管理库**： pinia
>
> ------
>
> **组件库**:
>
> **UI框架**: [element plus](https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2F)、[ant design vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.antdv.com%2F)、[quasar](https://link.juejin.cn?target=https%3A%2F%2Fquasar.dev%2F)、[vuetify3beta](https://link.juejin.cn?target=https%3A%2F%2Fnext.vuetifyjs.com%2Fen%2Fgetting-started%2Finstallation%2F)、[naive ui](https://link.juejin.cn?target=https%3A%2F%2Fwww.naiveui.com%2Fen-US%2Fos-theme)、[prime vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.primefaces.org%2F)
>
> **移动端**: [ionic](https://link.juejin.cn?target=https%3A%2F%2Fionicframework.com%2F)、[vant](https://link.juejin.cn?target=https%3A%2F%2Fyouzan.github.io%2Fvant%2F%23%2Fen-US)、[varlet](https://link.juejin.cn?target=https%3A%2F%2Fmadewithvuejs.com%2Fvarlet-ui)、[nutui](https://link.juejin.cn?target=https%3A%2F%2Fnutui.jd.com%2F%23%2Fstart)、[waveui](

# Vite性能优化

[记一次Vite打包优化](https://developer.aliyun.com/article/1166403)

三部曲：

- Network 分析
- Lighthouse 分析
- Bundle 分析

# 数据结构-1亿数据中访问某数据

先来看一下都有哪些题目：

- 如何从大量的 URL 中找出相同的 URL？（百度）
- 如何从大量数据中找出高频词？（百度）
- 如何找出某一天访问百度网站最多的 IP？（百度）
- 如何在大量的数据中找出不重复的整数？（百度）
- 如何在大量的数据中判断一个数是否存在？（腾讯）
- 如何查询最热门的查询串？（腾讯）
- 如何统计不同电话号码的个数？（百度）
- 如何从 5 亿个数中找出中位数？（百度）
- 如何按照 query 的频度排序？（百度）
- 如何找出排名前 500 的数？（腾讯）

答案呢？往下看~

## 1. 如何从大量的 URL 中找出相同的 URL？

**题目描述**

给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。

**解答思路**

每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。

> 5,000,000,000 * 64B ≈ 5GB * 64 = 320GB

由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用**分治策略**，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。

**思路如下**：

首先遍历文件 a，对遍历到的 URL 求 `hash(URL) % 1000`，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。

接着遍历 ai( `i∈[0,999]`)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。

**方法总结**

1. 分而治之，进行哈希取余；
2. 对每个子文件进行 HashSet 统计。

## 2. 如何从大量数据中找出高频词？

**题目描述**

有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。

**解答思路**

由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用**分治策略**，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。

**思路如下**：

首先遍历大文件，对遍历到的每个词x，执行 `hash(x) % 5000`，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。

接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 `map.put(x, 1)`；若存在，则执行 `map.put(x, map.get(x)+1)`，将该词频数加 1。

上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个**小顶堆**来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个**小顶堆**，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为**小顶堆**，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 3. 如何找出某一天访问百度网站最多的 IP？

**题目描述**

现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。

**解答思路**

这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。

> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 4. 如何在大量的数据中找出不重复的整数？

**题目描述**

在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

**解答思路**

**方法一：分治法**

与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。

**方法二：位图法**

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 `[0,7]` 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0
复制代码
```

然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：

```
0 0 0 0 1 0 1 0
复制代码
```

依次遍历，结束后，位数组是这样的：

```
0 1 1 0 1 1 1 0
复制代码
```

每个为 1 的位，它的下标都表示了一个数：

```arduino
for i in range(8):
    if bits[i] == 1:
        print(i)
复制代码
```

这样我们其实就已经实现了排序。

对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。

**那么对于这道题**，我们用 2 个 bit 来表示各个数字的状态：

- 00 表示这个数字没出现过；
- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；
- 10 表示这个数字出现了多次。

那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：

遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。

**方法总结**

**判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 5. 如何在大量的数据中判断一个数是否存在？

**题目描述**

给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？

**解答思路**

**方法一：分治法**

依然可以用分治法解决，方法与前面类似，就不再次赘述了。

**方法二：位图法**

40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。

我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。

**方法总结**

**判断数字是否存在、判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 6. 如何查询最热门的查询串？

**题目描述**

搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。

假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）

**解答思路**

每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。

**方法一：分治法**

分治法依然是一个非常实用的方法。

划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。

方法可行，但不是最好，下面介绍其他方法。

**方法二：HashMap 法**

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。

**思路如下**：

首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 `O(N)`。

接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。

遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 `O(Nlog10)`。

**方法三：前缀树法**

方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。

**思路如下**：

在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。

最后依然使用小顶堆来对字符串的出现次数进行排序。

**方法总结**

前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。

## 7. 如何统计不同电话号码的个数？

**题目描述**

已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。

**解答思路**

这道题本质还是求解**数据重复**的问题，对于这类问题，一般首先考虑位图法。

对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

**思路如下**：

申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。

**方法总结**

求解数据重复问题，记得考虑位图法。

## 8. 如何从 5 亿个数中找出中位数？

**题目描述**

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 `(N+1)/2` 个数；当样本数为偶数时，中位数为 第 `N/2` 个数与第 `1+N/2` 个数的均值。

**解答思路**

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)`。这里使用其他方法。

**方法一：双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。

若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

```ini
class MedianFinder {
    
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        minHeap = new PriorityQueue<>(Integer::compareTo);
    }
    
    public void addNum(int num) {
        if (maxHeap.isEmpty() || maxHeap.peek() > num) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        if (size1 - size2 > 1) {
            minHeap.offer(maxHeap.poll());
        } else if (size2 - size1 > 1) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    public double findMedian() {
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        
        return size1 == size2 
            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2
            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());
    }
}
复制代码
```

> 见 LeetCode No.295：[leetcode.com/problems/fi…](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.com%2Fproblems%2Ffind-median-from-data-stream%2F)

以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法**适用于数据量较小的情况**。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。

**方法二：分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

> **提示**，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。

对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

> **注意**，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。

**方法总结**

分治法，真香！

## 9. 如何按照 query 的频度排序？

**题目描述**

有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。

**解答思路**

如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。

**方法一：HashMap 法**

如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。

**方法二：分治法**

分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 `hash(query) % 10` 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。

接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。

**方法总结**

- 内存若够，直接读入进行排序；
- 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。

## 10. 如何找出排名前 500 的数？

**题目描述**

有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？

**解答思路**

对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：

首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。

接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。

重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。

> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

```ini
import lombok.Data;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * @author https://github.com/yanglbme
 */
@Data
public class DataWithSource implements Comparable<DataWithSource> {
    /**
     * 数值
     */
    private int value;

    /**
     * 记录数值来源的数组
     */
    private int source;

    /**
     * 记录数值在数组中的索引
     */
    private int index;

    public DataWithSource(int value, int source, int index) {
        this.value = value;
        this.source = source;
        this.index = index;
    }

    /**
     *
     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改
     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆
     */
    @Override
    public int compareTo(DataWithSource o) {
        return Integer.compare(o.getValue(), this.value);
    }
}


class Test {
    public static int[] getTop(int[][] data) {
        int rowSize = data.length;
        int columnSize = data[0].length;

        // 创建一个columnSize大小的数组，存放结果
        int[] result = new int[columnSize];

        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();
        for (int i = 0; i < rowSize; ++i) {
            // 将每个数组的最大一个元素放入堆中
            DataWithSource d = new DataWithSource(data[i][0], i, 0);
            maxHeap.add(d);
        }

        int num = 0;
        while (num < columnSize) {
            // 删除堆顶元素
            DataWithSource d = maxHeap.poll();
            result[num++] = d.getValue();
            if (num >= columnSize) {
                break;
            }

            d.setValue(data[d.getSource()][d.getIndex() + 1]);
            d.setIndex(d.getIndex() + 1);
            maxHeap.add(d);
        }
        return result;

    }

    public static void main(String[] args) {
        int[][] data = {
                {29, 17, 14, 2, 1},
                {19, 17, 16, 15, 6},
                {30, 25, 20, 14, 5},
        };

        int[] top = getTop(data);
        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]
    }
}
复制代码
```

**方法总结**

求 TopK，不妨考虑一下堆排序？

# 前言

由于 **vue3.2** 版本的发布，`<script setup>` 的实验性标志已经去掉，这说明这个语法提案已经正式开始使用，并且我个人对这个方案表示非常喜欢，其他的**更新**[1]请自行了解。到目前为止，我认为 vue3 已经完全可以用于生产环境。在此将我的开发体验，总结至此，分享给大家。

我认为前端架构核心工作是定制一套适合当前业务需求的解决方案，从而降低需求的增加而带来的技术实现的复杂度。下面我将从 16 个方向，逐渐带领大家搭建一套属于你自己的脚手架，制定一套合理的解决方案，为项目打下良好的基础，与同伴形成合适的开发习惯。

# 1.搭建脚手架

使用 `vue-cli` 或 `vite` ，通过一系列的配置，初始化一个开发模板，无需从零开始搭建开发环境，可以有效的提升开发效率，相信也是大多数开发者接手一个新项目所使用的一种方式。尽管官方提供的脚手架已经足够优秀，但未必是真正符合我们自己团队的使用习惯，所以从官方的基础上，开发一款属于我们自己的脚手架，能更多的提升开发效率。

## 1.1 前端脚手架应具备哪些功能？

- 减少重复的初始化工作，不需要再复制其他类似的项目删除无关代码，或从零搭建一个项目。
- 可以根据团队需求，使用简单的交互操作生成相应的目录结构和文件。
- 统一团队的开发习惯、代码风格，保证构建结果的一致性。
- 完整的使用文档，降低新人上手、开发和后期维护成本。

## 1.2 如何开发一款自己的脚手架？

提到构建前端工程化中脚手架，相信大家已经看过不少文章，几年前我也曾经写过一篇关于**脚手架构建的文章**[69]，随便搜一下关键词可以看到很多相关的文章，在这里不做太多的介绍，主要讲一些这些文章中很少提到的如何根据选项生成文件。

## 1.3 如何根据选项生成文件？

说实话我也不知道大佬们是怎么根据各种配置编译成相应的文件，这块希望大家踊跃发言，寻求一种更佳高效简洁的方式。在这里跟大家分享一下我的方案：

交互方面，搭建过脚手架的同学一定知道 **inquirer**[70]，这个库可以很方便的通过交互式操作获取到我们选择的一些自定义配置参数。那么问题来了，如何通过这些配置相应的创建对应的文件呢？

这里我推荐使用 **EJS**[71] + **Prettier**[72] 生成代码，通过 **fs-extra**[73] 写入最终的文件。

- **EJS**

**EJS** 是一款 JavaScript 模板引擎，我们可以通过传入参数，生成对应的代码串，例如创建一个 `package.ejs` 用来生成 `package.json` 中，如果我们选择使用了 `scss` 作为 CSS 预处理器，然后将 `sass` 和 `stylelint-scss` 作为项目的安装依赖：

```
<% if (precss === 'scss') { -%>
  "sass": "1.26.5",
  "stylelint-scss": "^3.20.1",
<% } -%>
```

模板引擎可以帮你通过参数生成代码，它并不会限制你生成任何类型的代码文件，因为我们生成的是纯代码，最后通过读取 `.ejs` 文件对应生成相应的类型文件即可。

- **Prettier**

**Prettier** 是一款代码格式化工具，相信大家对它并不陌生。使用 EJS 生成的目的还是给开发人员阅读和编辑，所以生成的代码应该符合最终的格式要求，因为后续我们会为脚手架添加 ESLint 和 StyleLint 等工具，刚刚创建的项目里面一堆红线报错可是十分不友好的。

```
import prettier = require("prettier");
prettier.format(code, { parser: 'json' }))
```

`parser` 是 prettier 的解析器，常见的 typescript、css、less、json 等文件都可以进行格式化。

# 2.基于 vite 的搭建基础模板

最早搭建 vue3 脚手架的时候，我选择的用 vue/cli 搭建，因为生态不健全，有些基于 webpack 的功能无法使用，但现在 vite 生态已经比较完善了，所以重构脚手架，由 webpack 转向 vite，这一步极大的提升了开发体验。

## 2.1 创建基本模板项目

```
npm init vite@latest
yarn create vite
pnpm create vite
```

然后按照提示操作即可，vite 提供的选项很少，只有 vue 或 vue + ts，不像 vue/cli 提供那么多的配置方式，所以剩下的东西需要我们手动配置。

当然 vite 也提供了很多模板，但是我认为做加法比做减法更加容易，在众多的模板中很难找到适合我们自己的。

## 2.2 常用插件推荐

这里先简单了解几个好用的 vite 插件：

- **unplugin-vue-components**[74]：组件的按需自动导入。
- **vite-plugin-svg-icons**[75]：用于生成 svg 雪碧图。
- **vite-plugin-compression**[76]：使用 gzip 或者 brotli 来压缩资源。

为什么只推荐这么几个插件？因为 `vite` 对许多 `webpack` 需要安装的 `loader` 或 `plugin` 都有着天生的支持，比如 less、sass、typescript，后续会在相应的章节说明用法。

# 3.使用 Typescript

**vue2.x 版本对 TypeScript 的支持是硬伤**，而 TypeScript 对大型项目的保障能力是被普遍认可的。这一点在 vue3.x 版本中得到了非常友好的支持。

> Vite 天然支持引入 `.ts` 文件。

这里对 tsconfig.json 做了一些修改：

```
{
  "compilerOptions": {
    "types": ["vite/client"],
    "baseUrl": "src",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "exclude": ["node_modules"]
}
复制代码
```

> 在初期使用 typeScript 的时候，很多人都很喜欢使用 any 类型，把 typeScript 写成了 anyScript ，虽然使用起来很方便，但是这就失去了 typeScript 的类型检查意义了，当然写类型的习惯是需要慢慢去养成的，不用急于一时。

# 4.配置环境变量

vite 提供了两种模式：具有开发服务器的开发模式（development）和生产模式（production）。

这里我们可以建立 4 个 `.env` 文件，一个通用配置和三种环境：开发、测试、生产。

## 4.1 配置模式

```
NODE_ENV=development # 开发模式
NODE_ENV=production # 生产模式
复制代码
```

- .env 通用配置，我个人喜欢把他当作项目的配置文件，例如项目的 title，此文件不对应任何模式。
- .env.development 开发环境，使用 development 模式。
- .env.staging 测试环境，因为要部署到测试服务器，或本地使用 serve 命令预览，所以使用 production 模式。
- .env.production 生产环境，因为要部署到测试服务器，或本地使用 serve 命令预览，所以使用 production 模式。

package.json 内 script 需要增加 staging 命令

```
"script": {
  "build": "vue-tsc --noEmit && vite build",
  "staging": "vue-tsc --noEmit && vite build --mode staging",
  "serve": "vite preview --host"
}
复制代码
```

## 4.2 常用的环境变量

推荐使用以下常见的三个变量：

- **VITE_APP_BASE_URL**

接口请求地址。

通常后端会区分三种环境，部署在不同的地址下。

- **VITE_APP_STATIC_URL**

静态资源地址。

> 静态资源我是不建议你直接放在项目中，这会导致项目仓库变得巨大。

本地开发和测试环境我会选在使用本地搭建的静态资源服务器，你可以找后端运维的同学帮你搭建，或者你使用 http-server 在本地启动一个服务器也可以。生产环境建议上传至 OSS。

- **VITE_PUBLIC_PATH**

构建资源公共路径。

这个与 vue/cli 中的 publicPath 同理，有的时候你构建的项目并不是存放在跟路径下，例如 `http://ip:port/{项目名}`。

## 4.3 封装静态资源文件

如果你配置了 VITE_APP_STATIC_URL 静态资源环境变量，那么你需要封装以下两个东西：

- 根据环境返回实际的资源地址函数。
- 方便使用的静态资源组件。

**baseStaticUrl.ts**

```
// 处理静态资源链接
export default function baseStaticUrl(src = '') {
  const { VITE_APP_STATIC_URL } = import.meta.env;
  if (src) {
    return `${VITE_APP_STATIC_URL}${src}`;
  }
  return VITE_APP_STATIC_URL as string;
}
复制代码
```

**静态资源组件**

静态资源主要有图片、音频和视频三种常见的形式。

- 通过 src 写入相对的路径，使用上述的函数来补全完整的路径，即可在不同的环境下使用不同地址的静态资源。
- 通过 type 传入图片、音频和视频的类型。
- autoplay 是解决以视频为背景的情况下，视频无法自动播放的问题。

```
<script lang="ts" setup>
import { computed, ref, Ref, withDefaults, onMounted, watch } from 'vue';
import { baseStaticUrl } from '@/libs/utils';
import useDevice from '@/hooks/useDevice';

interface Props {
  src?: string;
  type?: string;
  autoplay?: boolean;
}
const props = withDefaults(defineProps<Props>(), {
  src: '',
  type: 'img',
  autoplay: true,
});

const envSrc = computed(() => baseStaticUrl(props.src));
// 处理视频自动播放（解决 chrome 无法自动播放的问题）
const { deviceType } = useDevice();
const poster = computed(() =>
  deviceType.value === 'desktop' ? '' : baseStaticUrl(props.src),
);
const videoRef: Ref<HTMLVideoElement | null> = ref(null);

// 解决移动端视频无法自动播放的问题
function videoAutoPlay() {
  if (props.type === 'video' && videoRef.value !== null) {
    videoRef.value.src = baseStaticUrl(props.src);
  }
  if (props.autoplay && videoRef.value) {
    videoRef.value.oncanplay = () => {
      if (videoRef.value) videoRef.value.play();
    };
  }
}

// 自动播放视频
onMounted(() => { videoAutoPlay();});
// 监听视频 src，如果存在则自动播放

watch(envSrc, () => { if (videoRef.value) videoRef.value.play(); });
</script>

<script lang="ts">
export default { name: 'StaticFile' };
</script>

<template>
  <img v-if="type === 'img'" :src="envSrc" />
  <video ref="videoRef" v-else-if="type === 'video'" muted :poster="poster" />
  <audio v-else :src="envSrc" />
</template>
复制代码
```

## 4.4 封装 `SVG` 的图标组件

svg 图标比较小，而且都是可读的 xml 文本，所以我们把它直接放在项目中即可，通过 `vite-plugin-svg-icons` 插件，实现自动引入 svg 图标。

配置 vite.config.ts：

```
plugins: [
  viteSvgIcons({
    iconDirs: [resolve(process.cwd(), 'src/assets/icons')],
    symbolId: 'icon-[dir]-[name]',
  }),
]
复制代码
```

封装一个 vue 组件：

```
<script setup lang="ts">
import { computed, withDefaults } from 'vue';

interface Props {
  prefix?: string;
  name?: string;
  color?: string;
}

const props = withDefaults(defineProps<Props>(), {
  prefix: 'icon',
  name: '',
  color: '#000',
});

const symbolId = computed(() => `#${props.prefix}-${props.name}`);
</script>

<template>
  <svg aria-hidden="true">
    <use :xlink:href="symbolId" :fill="color" />
  </svg>
</template>
复制代码
```

首先将下载的 .svg 图标放入 @/assets/icons 文件夹下

```
<svg-icon name="" color="" />
复制代码
```

- name 放置在 @/assets/icons 文件夹下的文件名。
- color 颜色填充，使用此项会默认覆盖图标颜色。

# 5.按需自动引入组件

**unplugin-vue-components**[77] 是一款非常强大的插件（极力推荐），核心功能就是帮助你自动按需引入组件，Tree-shakable，只注册你使用的组件。这里说一下他的两个核心使用方式和配置方式。

> 此插件不仅支持 vue3，同时也支持 vue2，并且支持 Vite、Webpack、Vue CLI、Rollup。

## 5.1 安装与配置

安装：

```
npm i unplugin-vue-components -D
复制代码
```

配置：

```
// vite.config.ts
import Components from 'unplugin-vue-components/vite'

export default defineConfig({
  plugins: [
    Components({ /* options */ }),
  ],
})
复制代码
```

这里的 options 可以配置一些选项，后面提到的组件库注册会使用到。

## 5.2 改变全局组件注册方式

我们通常将全局的组件封装在 `@/src/components` 中，然后通过 `app.component()` 注册全局组件。使用此插件后，无需手写注册，直接在模板中使用组件即可：

这里引入官方的示例：

```
<template>
  <div>
    <HelloWorld msg="Hello Vue 3.0 + Vite" />
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>
复制代码
```

自动编译为：

```
<template>
  <div>
    <HelloWorld msg="Hello Vue 3.0 + Vite" />
  </div>
</template>

<script>
import HelloWorld from './src/components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
</script>
复制代码
```

## 5.3 自动引入组件库

在使用组件库时，常规组件我们也会注册到全局，如果使用局部注册由于页面中会使用到多个组件，会非常麻烦，所以这个功能绝佳，例如我们使用 ant-design-vue 组件库。

直接在模板中使用即可，无需手动注册或局部引用：

```
<template>
  <a-button>按钮</a-button>
</template>
复制代码
```

当然，你还需要在 vite 中引入它的解析器：

```
import Components from 'unplugin-vue-components/vite'
import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  plugins: [
    Components({
      resolvers: [
        AntDesignVueResolver(),
      ]
    })
  ],
})
复制代码
```

目前支持的解析器，根据你的喜好去选择：

- **Ant Design Vue**[78]
- **Element Plus**[79]
- **Element UI**[80]
- **Headless UI**[81]
- **IDux**[82]
- **Naive UI**[83]
- **Prime Vue**[84]
- **Vant**[85]
- **VEUI**[86]
- **Varlet UI**[87]
- **View UI**[88]
- **Vuetify**[89]
- **VueUse Components**[90]
- **Quasar**[91]

# 6.样式

项目中最好使用通用样式，可以创建 `src/styles` 目录存放，这里推荐一些分类：

```
styles
  ├── antd # 组件库样式覆盖，命名自取，这里以 ant design 为例
  ├── color.less # 颜色
  ├── index.less # 入口
  ├── global.less # 公共类
  ├── transition.less # 动画相关
  └── variable.less # 变量
复制代码
```

## 6.1 预设基础样式

相信用过 **normalize**[92] 的同学不在少数，它可以重置 css 样式，使各浏览器效果保持一致。后面的章节会提到 tailwind.css，它内置了预设样式重置的功能，与 normalize 还是有一定的区别，有兴趣的同学可以**了解一下**[93]。

## 6.2 CSS 预处理器

虽然 vite 原生支持 less/sass/scss/stylus，但是你必须手动安装他们的预处理器依赖，例如：

```
npm install -D less
复制代码
```

如何选择预处理器？

推荐使用你是所使用的组件库的样式语言，因为 css 预处理器学会一种后，入手其他几乎没有学习成本。

## 6.3 开启 scoped

没有加 scoped 属性，会编译成全局样式，造成全局污染。

```
<style scoped></style>
复制代码
```

## 6.4 深度选择器

有时我们可能想明确地制定一个针对子组件的规则。

如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 >>> 操作符。有些像 Sass 之类的预处理器无法正确解析 >>>。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 >>> 的别名，同样可以正常工作。

# 7.布局

页面整体布局是一个产品最外层的框架结构，往往会包含导航、页脚、侧边栏等。在页面之中，也有很多区块的布局结构。在真实项目中，页面布局通常统领整个应用的界面，有非常重要的作用，所以单独拆分出来也是非常有必要的。

在脚手架中，所有的通用布局组件都应该放在 src/layouts 中，这种封装比较简单，这里就不贴代码了，大家按照自己实际情况自行发挥，在此仅提供一下封装思路。

## 7.1 常规的布局

**BasicLayout**

基础页面布局，包含了头部导航，侧边栏等。

**BlankLayout**

空白的布局。

## 7.2 特殊的布局

**RouteLayout**

如果你的项目在路由切换中需要对某些二级页面进行缓存，那么推荐你创建一个 RouteLayout，通过路由 `meta` 中的配置，返回 `router-view` 或者使用 `keep-alive` 包裹的 `router-view`。

**UserLayout**

用于用户登录注册等页面抽离出来。

**PageLayout**

基础布局，包含了面包屑等信息，内含 slot。

# 8.集成 Tailwind.css

**Tailwind.css**[94] 在我第一次看到它的时候，内心是比较反感的，但实际上手之后又觉得真香。从 vue2 项目中，我已经引入了 tailwind，整体的开发结果就是，基本很少再使用 `<style>` 标签去转本定义一些 class 和样式，毕竟起名字这种事，一个是涉及到规范，一个是涉及到英语。如果你选择 tailwind，CSS 预处理器的作用就会显得微乎其微，因为你无需再自定定义各种变量和 mixins。

总体来说，学习成本并不高，花上两个小时足够上手，记住不用死记硬背那些类名。

## 8.1 效率提升

很多人总是说样式要与 HTML 分离，现在为什么又要提倡 tailwind 这种与 HTML 紧密结合的工具？这是因为现在使用 vue 这类框架已经高度组件化，样式分离是为了方便复用和维护，但在组件化面前样式分离只能是降低开发效率。

下面介绍一下 tailwind 提供了哪些提升效率的功能：

- 提供了大量的功能类，极大的提高了可维护性。
- 响应式设计，各种设备一把梭。
- 悬停、焦点和其它状态。
- 深色模式。
- 支持配置，例如颜色方面很难做到跟你的设计师统一。
- 不用为起名字而纠结???

## 8.2 JIT 模式

如果你的环境支持 postcss8（ vue/cli 构建的 vue2 项目是 postcss7 ），那么 **JIT** 模式直接带你起飞。

- 超快的构建速度。
- 支持变体，你甚至可以这么写 `sm:hover:active:disabled:opacity-75`。
- 支持任意样式，例如 `md:top-[-113px]`。
- 开发和生产环境结果是一致的，（我在 vue2 项目中就遇到过组件库构建结果不一致的问题）。

如果你使用 vscode 那你一定要安装 **Tailwind CSS IntelliSense**[95] 插件，它可以自动补全类名，显著降低学习成本。

## 8.3 关于打包体积

使用默认配置，未压缩是 **3739.4kB** ，Gzip压缩 是 293.9kB，Brotli压缩 是 73.2kB。这似乎看起来很大，这是因为 tailwind 提供了成千上万的功能类，其中绝大部分你不会使用到。

当构建生产时，你应该使用 purge 选项来 **tree-shake** 优化未使用的样式，并优化您的最终构建大小当使用 Tailwind 删除未使用的样式时，很难最终得到超过 **10kb** 的压缩 CSS。

还有一点，`Atom CSS` 极大的提升了样式的复用程度，从而直接降低了构建体积。

# 9.vuex 替代方案 pinia

由于 `vuex 4` 对 typescript 的支持让人感到难过，所以状态管理弃用了 vuex 而采取了 **pinia**[96]。

忘记在哪看到，尤大好像说 **pinia**[97] 可能会代替 vuex，所以请放心使用。

## 9.1 为什么采用 Pinia ?

- **Pinia** 的 API 设计非常接近 `Vuex 5` 的**提案**[98]。（作者是 Vue 核心团队成员）
- 无需像 `Vuex 4` 自定义复杂的类型来支持 typescript，天生具备完美的类型推断。
- 模块化设计，你引入的每一个 store 在打包时都可以自动拆分他们。
- 无嵌套结构，但你可以在任意的 store 之间交叉组合使用。
- **Pinia** 与 **Vue devtools** 挂钩，不会影响 Vue 3 开发体验。

下面简单的介绍一下如何使用 Pinia，并对比 vuex 有哪些区别与注意事项，具体请参考**官方文档**[99]。

## 9.2 创建 Store

Pinia 已经内置在脚手架中，并且与 vue 已经做好了关联，你可以在任何位置创建一个 store：

```
import { defineStore } from 'pinia'

export const useUserStore = defineStore({
  id: 'user',
  state: () =>({}),
  getters: {},
  actions: {}
})
复制代码
```

这与 Vuex 有很大不同，它是标准的 Javascript 模块导出，这种方式也让开发人员和你的 IDE 更加清楚 store 来自哪里。

Pinia 与 Vuex 的区别：

- **id** 是必要的，它将所使用 store 连接到 devtools。
- 创建方式：`new Vuex.Store(...)`(vuex3)，`createStore(...)`(vuex4)。
- 对比于 vuex3 ，state 现在是一个**函数返回对象**。
- 没有 **mutations**，不用担心，state 的变化依然记录在 devtools 中。

## 9.3 State

创建好 store 之后，可以在 state 中创建一些属性了：

```
state: () => ({ name: 'codexu', age: 18 })
复制代码
```

将 store 中的 state 属性设置为一个函数，该函数返回一个包含不同状态值的对象，这与我们在组件中定义数据的方式非常相似。

在模板中使用 store：

现在我们想从 store 中获取到 name 的状态，我们只需要使用以下的方式即可：

```
<h1>{{userStore.name}}</h1>

const userStore = useUserStore()
return { userStore }
复制代码
```

注意这里并不需要 `userStore.state.name`。

虽然上面的写法很舒适，但是你一定不要用解构的方式去提取它内部的值，这样做的话，会失去它的响应式：

```
const { name, email } = useUserStore()
复制代码
```

## 9.4 Getters

Pinia 中的 getter 与 Vuex 中的 getter 、组件中的计算属性具有相同的功能，传统的函数声明使用 this 代替了 state 的传参方法，但箭头函数还是要使用函数的第一个参数来获取 state ，因为箭头函数处理 this 的作用范围：

```
getters: {
  nameLength() {
    return this.name.length
  },
  nameLength: state => state.name.length,
  nameLength: ()=> this.name.length ❌ 
}
复制代码
```

## 9.5 Actions

这里与 Vuex 有极大的不同，Pinia 仅提供了一种方法来定义如何更改状态的规则，**放弃 mutations 只依靠 Actions**，这是一项重大的改变。

Pinia 让 Actions 更加的灵活：

- 可以通过**组件**或其他 **action** 调用
- 可以从**其他 store** 的 action 中调用
- 直接在商店实例上调用
- 支持**同步**或**异步**
- 有任意数量的参数
- 可以包含有关如何更改状态的逻辑（也就是 vuex 的 mutations 的作用）
- 可以 `$patch` 方法直接更改状态属性

```
actions: {
  async insertPost(data){
    await doAjaxRequest(data);
    this.name = '...';
  }
}
复制代码
```

## 9.6 Devtools

脚手架已内置下面的代码，这将添加 devtools 支持：

```
import { createPinia, PiniaPlugin } from 'pinia'

Vue.use(PiniaPlugin)
const pinia = createPinia()
复制代码
```

时间旅行功能貌似已经可以使用了，这块后续会关注。

# 10.基于 mitt 处理组件间事件联动

如果你曾经是 Vue2.x 的开发者，那么请阅读下面引用**官方文档**[100]的一段话：

> 我们从实例中完全移除了 `$on`、`$off` 和 `$once` 方法。`$emit` 仍然包含于现有的 API 中，因为它用于触发由父组件声明式添加的事件处理函数。
>
> 在 Vue 3 中，已经不可能使用这些 API 从组件内部监听组件自己发出的事件了，该用例暂没有迁移的方法。但是该 eventHub 模式可以被替换为实现了事件触发器接口的外部库，例如 `mitt` 或 `tiny-emitter`。

## 10.1 为什么选择 mitt ？

- 足够小，仅有 200bytes。
- 支持全部事件的监听和批量移除。
- 无依赖，不论是什么框架都可以直接使用。

## 10.2 严重警告

我们已经无法在项目中使用 **eventBus**，仅推荐你在**特殊场合**下使用 mitt，**它并不是开发的常态**，你一定要确保知道自己在做什么？否则你的项目将难以维护！！！

## 10.3 如何使用 mitt ？

在使用 mitt 前建议请阅读**官方文档**[101]：

脚手架默认提供一个可以直接使用的对象：

```
import emitter from '@/libs/emitter';
复制代码
```

当然你也可以引入已经安装好的 mitt：

```
import mitt from 'mitt'

const emitter = mitt()
复制代码
```

mitt 提供了非常简单的 API，下面代码是官方演示：

```
// listen to an event
emitter.on('foo', e => console.log('foo', e) )

// listen to all events
emitter.on('*', (type, e) => console.log(type, e) )

// fire an event
emitter.emit('foo', { a: 'b' })

// clearing all events
emitter.all.clear()

// working with handler references:
function onFoo() {}
emitter.on('foo', onFoo)   // listen
emitter.off('foo', onFoo)  // unlisten
复制代码
```

# 11.异步请求

绝大多数项目想必逃脱不了接口的对接，如果你的项目存在大量的接口，我建议做到以下几点：

- 封装请求。
- 统一的 API 接口管理。
- Mock 数据功能（根据需求斟酌使用）。

上述的主要目的就是在帮助我们简化代码和利于后期的更新维护。

## 11.1 基于 axios 的封装

相信开发过 vue2 项目的同学已经对 axios 非常熟悉的，在这里提供一些封装的思路：

- 通过 `import.meta.env.VITE_APP_BASE_URL` 获取环境变量，配置 `baseURL`，如果接口存在多个不同域名，可以通过 js 变量控制。
- 设置 `timeout` 请求超时、断网情况处理。
- 设置**请求头**，携带 `token`。
- **异常拦截处理**，后端通过你携带的 `token` 判断你是否过期，如果返回 `401` 你可能需要跳转到登录页面，并提示需要重新登录。
- **响应拦截**，通常后端返回 code、data、msg，如果是请求正常，我们可以直接返回 data 数据，如果是异常的 code，我们也可以在这里直接弹出报错提示。
- **无感刷新 token**，如果你的 token 过期，可以通过后端返回的 refreshToken 调用刷新接口，获取新的 token。当然这里涉及到很多细节，例如终端请求、重新发送请求、重新请求列队。
- **中断请求**，例如页面切换时，我们要中断正在发生的请求。

**相关代码（仅供参考）**[102]

## 11.2 为 axios 增加泛型的支持

到目前为止，axios 请求返回的类型是 any，这时我们对请求后的数据进行操作时，没有享受到 ts 带来的类型提示，这显然不符合我们的预期。

这时我们要做的就是重新声明 axios 模块：新建一个 shims.d.ts，然后在调用时加上泛型。

```
import { AxiosRequestConfig } from 'axios';

declare module 'axios' {
  export interface AxiosInstance {
    <T = any>(config: AxiosRequestConfig): Promise<T>;
    request<T = any>(config: AxiosRequestConfig): Promise<T>;
    get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    head<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
  }
}
复制代码
```

做好这一步后，你就必须在创建接口时，声明请求相应数据的类型。

## 11.3 封装更方便的 useRequest

设想一下，编写请求代码时，我们通常会定义这么几个变量：

- **data**: 储存请求数据
- **loading**: 请求加载状态

尤其是 loading，我们需要在请求前设置为 true，请求结束后设置为 false。

上面的封装方式，是对基础的功能封装，因为我们在使用 vue3，所以可以进行再一次的封装成为 **hook**，我们使用起来会更加方便。

例如下面这个样子：

使用 useRequest 定义一个接口：

```
export default getUserInfo(id) {
  return useRequest({
    method: 'get',
    url: '/api/user',
    params: { id }
  })
}
复制代码
```

使用此接口：

```
const { data, loading } = getUserInfo();
复制代码
```

> 注意这里的 data 是响应式的。

这是我想到的一种思路，目前还没有做很好的封装，**相关代码仅供参考**[103]，你也可以借鉴一些成熟方案，比如 vueuse 中的 **useFetch**[104]，但是他是基于 Fetch API 设计的，并不符合我的预期要求，有更好的方案请大家在下面留言。

## 11.4 统一的 API 接口管理

自从前端和后端分家之后，前后端接口对接就成为了常态，而对接接口的过程就离不开接口文档，比较主流就是 Swagger，但是如何在前端项目中更好的去管理跟后端对接的接口呢？

在 src 目录中 创建 api 目录，内部目录应按照后端制定的模块创建。

每个模块中创建多个 ts 文件，一个接口应对应一个 ts 文件，其中包含了以下内容：

- 请求**参数**的类型声明。
- 响应**数据**的类型声明。
- 返回定义好的请求函数（url、method、params、data 等）。

统一去定义和管理 API 接口，只要后端规范的命名和你认真的写好类型声明，对前端来说 typescript 就是最好的接口文档。

## 11.5 mock

vite 使用 mock 数据非常简单，你可以使用 **vite-plugin-mock**[105] 插件，如果你了解 mockjs，你可以快速上手。

# 12.路由

路由和菜单是组织起一个应用的关键骨架。

## 12.1 创建路由三部曲

通常一个项目需要做到这几步：

- 使用 **createRouter** 创建路由，这时候根据需求选择 **Hash** 路由或者 **History** 路由。
- 根据业务需求**配置路由**，注意这里很可能就用到前文提到过的**布局组件**。
- 如果有权限相关的业务，你需要创建 **permission.ts** 在路由钩子触发时做一些事情。

> 如果你的页面比较多，建议你创建 routes 目录，分模块声明路由。

**参考代码**[106]

## 12.2 使用 meta 丰富你的路由

vue-router4.x 支持 typescript，配置路由的类型是 RouteRecordRaw，这里 meta 可以让我们有更多的发挥空间，这里提供一些参考：

- title: string; 页面标题，通常必选。
- icon?: string; 图标，一般配合菜单使用。
- auth?: boolean; 是否需要登录权限。
- ignoreAuth?: boolean; 是否忽略权限。
- roles?: RoleEnum[]; 可以访问的角色
- keepAlive?: boolean; 是否开启页面缓存
- hideMenu?: boolean; 有些路由我们并不想在菜单中显示，比如某些编辑页面。
- order?: number; 菜单排序。
- frameUrl?: string; 嵌套外链。

> 这里只提供一些思路，每个项目多多少少会涉及到这些问题，具体如何实现请查阅资料自行解决。

# 13.项目性能与细节优化

## 13.1 开启 gzip

开启 gzip 可以极大的压缩静态资源，对页面加载的速度起到了显著的作用。

使用 **vite-plugin-compression**[107] 可以 **gzip** 或 **brotli** 的方式来压缩资源，这一步需要服务器端的配合，vite 只能帮你打包出 `.gz` 文件。此插件使用简单，你甚至无需配置参数，引入即可。

## 13.2 页面载入进度条

页面路由切换时，附带一个加载进度条会显得非常友好，不至于白屏时间过长，让用户以为页面假死。

这时候我们可以用到 **nprogress**[108]，在路由切换时开启和关闭：

```
import NProgress from 'nprogress';

router.beforeEach(async (to, from, next) => {
  NProgress.start();
});

router.afterEach((to) => {
  NProgress.done();
});
复制代码
```

## 13.3 Title

在不同的路由下显示不同的标题是常规的操作，我们可以通过路由钩子获取 meta 中的 title 属性改变标签页上的 title。

你可以使用 vueuse 提供的 **useTitle**[109]，或者 window.document.title 自行封装。

你也可以通过环境变量将你的主标题拼接在路由标题的后面：

```
const { VITE_APP_TITLE } = import.meta.env;
复制代码
```

## 13.4 解决移动端使用 vh 的问题

有兴趣的同学可以尝试一下 chrome 移动端浏览器上的 100vh，是真正的视口高度的 100% 嘛。

为了解决这一问题，我们可以通过 postCss 插件解决。

安装 **postcss-viewport-height-correction**[110] 插件：

```
npm install -D postcss-viewport-height-correction
复制代码
```

在 postcss.config.js 中增加 plugin：

```
module.exports = {
  plugins: {
    'postcss-viewport-height-correction': {},
  },
}
复制代码
```

添加这一段 js 代码在全局，你可以直接添加在 index.html 上即可：

```
const customViewportCorrectionVariable = 'vh';
function setViewportProperty(doc) {
  let prevClientHeight;
  const customVar = `--${customViewportCorrectionVariable || 'vh'}`;
  function handleResize() {
    const { clientHeight } = doc;
    if (clientHeight === prevClientHeight) return;
    requestAnimationFrame(function updateViewportHeight() {
      doc.style.setProperty(customVar, `${clientHeight * 0.01}px`);
      prevClientHeight = clientHeight;
    });
  }
  handleResize();
  return handleResize;
}
window.addEventListener('resize', setViewportProperty(document.documentElement));
复制代码
```

## 13.5 可以常驻的 JavaScript 库

- 前文提到过的 **vueuse**[111]，非常强大，强烈建议尝试。
- **lodash**[112]，用了都说好，早用早下班。

# 14.代码风格与流程规范

## 14.1 ESLint

不管是多人合作还是个人项目，代码规范都是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。

这里推荐使用 **airbnb** 规范。

**配置参考**[113]

## 14.2 StyleLint

尽管前文提到过 tailwind，可以让你几乎不写 css，但是涉及到团队协作，这一点也要严谨。

StyleLint 是一个强大的、现代化的 CSS 检测工具, 与 ESLint 类似, 是通过定义一系列的编码风格规则帮助我们避免在样式表中出现错误，配合编辑器的自动修复，可以很好的统一团队项目 css 风格。

**配置参考**[114]

## 14.3 代码提交规范

在多人协作的背景下，git 仓库和 workflow 的作用很重要。而对于 commit 提交的信息说明存在一定规范，现使用 **commitlint** + **husky** 规范 git commit -m "" 中的描述信息。我们都知道，在使用 git commit 时，git 会提示我们填入此次提交的信息。可不要小看了这些 commit，团队中规范了 commit 可以更清晰的查看每一次代码提交记录，还可以根据自定义的规则，自动生成 changeLog 文件。

**提交格式（注意冒号后面有空格）：**

```
<type>[optional scope]: <description>
复制代码
```

- type ：用于表明我们这次提交的改动类型。
- optional scope：可选，用于标识此次提交主要涉及到代码中哪个模块。
- description：一句话描述此次提交的主要内容，做到言简意赅。

**Type 类型**

- build：编译相关的修改，例如发布版本、对项目构建或者依赖的改动
- chore：其他修改, 比如改变构建流程、或者增加依赖库、工具等
- ci：持续集成修改
- docs：文档修改
- feat：新特性、新功能
- fix：修改bug
- perf：优化相关，比如提升性能、体验
- refactor：代码重构
- revert：回滚到上一个版本
- style：代码格式修改, 注意不是 css 修改
- test：测试用例修改

关于 commitlint + husky 的配置文章有很多，大同小异，请根据自己的实际情况配置。

# 15.编写使用文档

做到这一步，你的整个脚手架开发已经接近于尾声，但是你做了这么多，你的同事并不知道如何使用，甚至你过一段时间也会忘记，所以你必须养成良好的编写文档习惯。

## 15.1 使用 vitepress 搭建文档

这里我推荐使用 vuepress 或者 vitepress，说实话你只写文档 vitepress 会让你更舒服，因为它很快。

**vitepress**[115] 很适合构建博客网站、技术文档，就是因为它可以直接用 markdown 进行书写，所有写过博客的人，都应该对它不陌生。一个 .md 文件，即可生成一张页面，十分方便。

创建一个 vitepress 文档实在是太过于简单，你可以参考官方文档，或者参考我的**文档**[116]。

## 15.2 文档部署

如果你的团队可以帮助你搭建 CI/CD 自动部署是再好不过了，如果没有这个条件，你也可以通过 github 提供的 actions 功能，完成自动部署。

**代码参考**[117]

# 16.插件

如果你想更痛快的用上述功能，建议你安装下面的插件。

## 16.1 VSCode 插件

- **Vue Language Features \(Volar\)**[118]，你现在查 Volar 可能找不到，你需要的是这个。
- **Vue 3 Snippets**[119]，vue3 快捷输入。
- **Tailwind CSS IntelliSense**[120]，tailwind 代码提示。
- **Stylelint**[121]
- **Prettier - Code formatter**[122]
- **ESLint**[123]

## 16.2 Chrome 插件

- **Vue.js devtools**[124]，你当然要安装支持 vue3 的版本，而且此版本对 pinia 支持的也非常友好。

# 架构演进前言

[大公司如何部署前端项目](https://www.zhihu.com/question/20790576)

随着业务的不断发展，业务架构也越来越复杂。传统的功能被拆分成不同的模块，出现了中间件、中台等概念。代理服务、负载均衡、数据库分表、异地容灾、缓存、CDN、消息队列、安全防护等技术应用越来越广泛，增加了Web开发和运维的复杂度。

客户端的形态越来越多，除了Web之外iOS、Android等其他场景也出现在Web服务的客户端场景。

较早的关系型数据库MySQL、PostgreSQL等已经不能满足需求，出现了Redis/Memcached缓存数据库等一类满足特定需求的数据库。

为了满足特定的业务需求，出现了Lucene/Solr/Elasticsearch搜索应用服务器，Kafka/RabbitMQ/ZeroMQ消息系统，Spark计算引擎，Hive数据仓库平台等不同的基础架构。

 **中间件**

中间件是独立的软件程序，用于管理计算资源和网络通信。常用的功能有过滤IP、合并接口、合并端口、路由、权限校验、负载均衡、反向代理等。

**分布式**

随着数据量的不断提高，单台设备难以承载这样的访问量，同时不同功能也被拆分到不同的应用中，于是出现了提高业务复用及整合的分布式服务框架(RPC)。

**云服务**

云计算诞生之前，大部分计算资源是处于“裸金属”状态的物理机，运维人员选择对应规格的硬件，建设机房的 IDC 网络，完成服务的提供，投入硬件基础建设和维护的成本很高。云服务出现之后，使用者可以直接购买云主机，基础设施由供应商管理，这种方式也被称作 IaaS (Infrastructure-as-a-Service) 。

随着架构的继续发展，应用的运行更加细粒度，部署环境容器化，各个功能拆成微服务或是Serverless的架构。

**1.Serverless**

Serverless 架构由两部分组成，即 Faas (Function-as-a-Service) 和 BaaS (Backend-as-a-Service) 。

FaaS是运行平台，用户上传需要执行的逻辑函数如一些定时任务、数据处理任务等到云函数平台，配置执行条件触发器、路由等等，就可以通过云平台完成函数的执行。

BaaS包含了后端服务组件，它基于 API 完成第三方服务，主要是数据库、对象存储、消息队列、日志服务等等。

**2.微服务**

微服务起源于2005年Peter Rodgers博士在云端运算博览会提出的微Web服务 (Micro-Web-Service)，根本思想类似于Unix的管道设计理念。2014年，由Martin Fowler与 James Lewis共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯 (HTTP API) 。

微服务是一种应用于组件设计和部署架构的软件架构风格。它利用模块化的方式组合出复杂的大型应用程序：

- 各个服务功能内聚，实现与接口分离。
- 各个服务高度自治、相互解耦，可以独立进行部署、版本控制和容量伸缩。
- 各个服务之间通过 API 的方式进行通信。
- 各个服务拥有独立的状态，并且只能通过服务本身来对其进行访问。

随着微服务技术的不断发展，这种思想也被应用到了前端。2018年，第一个微前端工具single-spa出现在github。而后出现了基于single-spa的框架qiankun。

 **3.API网关**

API网关是一个服务器，客户端只需要使用简单的访问方式，统一访问API网关，由API网关来代理对后端服务的访问，同时由于服务治理特性统一放到API网关上面，服务治理特性的变更可以做到对客户端透明，一定程度上实现了服务治理等基础特性和业务服务的解耦，服务治理特性的升级也比较容易实现。

**CI/CD**

持续集成 (Continuous Integration, CI) 是让开发人员将工作集成到共享分支中的过程。频繁的集成有助于解决隔离，减少每次提交的大小，以降低合并冲突的可能性。

持续交付 (Continuous Deployment, CD) 是持续集成的扩展，它将构建从集成测试套件部署到预生产环境。这使得它可以直接在类生产环境中评估每个构建，因此开发人员可以在无需增加任何工作量的情况下，验证bug修复或者测试新特性。

# CI/CD实践

## **前言**

CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。

具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。

## **CI 持续集成（Continuous Integration）**

现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为“合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。

持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。

## **CD 持续交付（Continuous Delivery）**

完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。

在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。

## **CD 持续部署（Continuous Deployment）**

对于一个成熟的 CI/CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。

实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI/CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI/CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。

## **Docker** [官网](https://www.docker.org.cn/index.html)

Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、 bare metal、OpenStack 集群和其他的基础应用平台。

**Docker通常用于如下场景：**

- web应用的自动化打包和发布；
- 自动化测试和持续集成、发布；
- 在服务型环境中部署和调整数据库或其他的后台应用；
- 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。

Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。

## **Jenkins** [官网](https://www.jenkins.io/zh/)

Jenkins是开源CI&CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。

Jenkins 有一个功能强大的扩展和插件系统，允许开发人员编写影响 Jenkins 几乎每个方面行为的插件。 即使是大部分“核心”功能都是以扩展的形式编写的 — 扩展也可以由插件提供。

一些比较明显的扩展点包括 SCM implementations：将 Git、Subversion 或 Perforce 等 SCM 集成到 Jenkins 中; build steps：提供从方便的用户界面到配置构建工具、到发送电子邮件等所有内容; 还有 authentication realms：将 Jenkins 与单点登录系统或外部用户目录（如 LDAP 或 Active Directory）集成。

Jenkins如何使用 npm去组合构建简单的 Node.js 和 React 应用 ，[详细教程](https://www.jenkins.io/zh/doc/tutorials/build-a-node-js-and-react-app-with-npm/)。

Jenkins被许多公司使用，其中包括Facebook，Sony，Netflix，Tumblr，Yahoo，eBay等。Jenkins具有易于安装，配置，丰富的插件可用性，可扩展性以及可在不同计算机上分发的版本。

## **CircleCI** [官网](https://circleci.com/)

CircleCI提供轻松的设置和维护，没有任何困难。这是一个基于云的系统，这意味着不需要专用服务器，也不需要维护/管理具有免费计划的服务器，甚至对于企业帐户也是如此。

CircleCI可以与GitHub，Amazon EC2，Appfog，dotCloud等集成，并被Facebook，Spotify，Kickstarter，RedBull，Harvest和Teespring等许多公司使用。CircleCI属性（如Github集成）社区成员最强调快速构建，轻松设置，松弛集成，Docker支持和出色的客户支持。

**CircleCI特性：**

- CircleCI是一个基于云的系统 – 不需要专用服务器，您无需管理它。 但是，它还提供了一个本地解决方案，允许您在私有云或数据中心中运行它；
- 即使是商业帐户，它也有免费计划；
- Rest API – 您可以访问项目，构建和工件（artifacts）。构建的结果将是工件或工件组。 工件可以是已编译的应用程序或可执行文件（例如，android APK）或元数据（例如，关于测试`成功的信息）；
- CircleCI 缓存必要的安装（requirements installation）。 它会检查第三方依赖项，而不是持续安装所需的环境；
- 您可以触发SSH模式访问容器并进行自己的调查（如果出现任何问题）；
- 这是一个完整的开箱即用解决方案，需要最少的配置\调整。

## **Jenkins和CircleCI之间的主要区别**

- Jenkins可以通过多线程支持多个作业，而CircleCI内置了对并行性的支持，可以通过项目设置来实现。
- 在Jenkins中，使用存储在Jenkins服务器中的设置的Web UI配置构建，而在CircleCI中，可以使用“ circle.yaml”文件构建作业。
- CircleCI具有调试“通过SSH调试”的最佳功能，这使调试更加容易，而Jenkins我们需要通过单击Jobs进行手动调试。
- CircleCI会在没有警告的情况下更改环境，这是一个问题，而在Jenkins中，只有在用户指示时它才会更改。
- 在Jenkins中，我们可以使用专用服务器缓存Docker映像，而在CircleCI中，我们不能缓存Docker映像。
- 在Jenkins中，将使用Jenkins凭据和插件对机密进行加密，而在CircleCI中，我们没有Jenkins这样的安全性。

## **GitLab** [官网](https://about.gitlab.com/)

GitLab是Ruby开发的自托管的Git项目仓库，可通过Web界面访问公开的或者私人的项目。

它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。

|   **工具**    |       **描述**       |
| :-----------: | :------------------: |
|  **jenkins**  |  搭建 CI / CD 服务   |
| **verdaccio** |    搭建npm私有库     |
|   **yapi**    | 搭建 api mock server |
|   **mongo**   |  暂时就提供给yapi的  |
|   **nginx**   |     做基本的代理     |

# 