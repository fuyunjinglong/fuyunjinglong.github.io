# Flow静态类型检测器

- [Flow官网](https://flow.org/en/docs/install/)
- [Flow中文网](https://zhenyong.github.io/flowtype/docs/getting-started.html#_)
- [Flow中文攻略](https://flowjs.judysocute.com/startup/installation)

## 安装编译器

首先，你需要一个编译器来剔除`Flow`的类型注解。你可以选择`Babel`或`flow-remove-types`.

### Babel

`Babel`是一个支持`Flow`的`Javascript`编译器。`Babel`我们通俗的理解就是把现在浏览器不支持的新特性（比如：ES6）转换为可以支持的ES5语法，从而使我们能在项目中体测新标准带来的福利。`Babel`使用我们`Flow`代码，并剔除所有的类型注解。

首先得安装 `babel-cli` 或 `babel-preset-flow`

npm环境

```undefined
npm install --save-dev babel-cli babel-preset-flow
```

新建一个 `.babelrc`文件，并在 `presets`属性里设置 `flow`

```javascript
{
  "presets": ["flow"]
}
```

如果你的源代码在 `src` 目录里，你可以将这些代码编译到另一个目录中

npm环境

```undefined
./node_modules/.bin/babel src/ -d lib/
```

当然，在 `package.json`配置运行

```javascript
{
  "name": "my-project",
  "main": "lib/index.js",
  "scripts": {
    "build": "babel src/ -d lib/"
  }
}
```

### flow-remove-types

`flow-remove-types`是一个简单去掉类型注释的命令行工具，他是一个不需要 `Babel` 支持的轻量级代替 `Babel`的工具。

首行安装 `flow-remove-types`

```undefined
npm install --save-dev flow-remove-types
```

如果你的源代码在 `src` 目录里，你可以将这些代码编译到另一个目录中

```undefined
./node_modules/.bin/flow-remove-types src/ -d lib/
```

在 `package.json`配置运行

```javascript
{
  "name": "my-project",
  "main": "lib/index.js",
  "scripts": {
    "build": "flow-remove-types src/ -d lib/"
  }
}
```

## 安装 Flow

把`npm`包安装到`devDependency`上

```undefined
npm install --save-dev flow-bin
```

在 `package.json` 的 `scripts` 里添加 `"flow"`

```javascript
{
  "name": "my-flow-project",
  "version": "1.0.0",
  "devDependencies": {
    "flow-bin": "^0.86.0"
  },
  "scripts": {
    "flow": "flow"
  }
}
```

首先运行

```undefined
npm run flow init
```

在第一次运行了 `init` 后，运行

```undefined
npm run flow
```

/src/index.js

```
// @flow
function square(n: number): number {
  return n * n;
}

square(2);


```



# CSS

## CSS实现节流

实现过程：

1. 函数节流是一个非常常见的优化方式，可以有效避免函数过于频繁的执行
2. CSS 的实现思路和 JS 不同，重点在于在于找到和该场景相关联的属性
3. CSS 实现“节流”其实就是控制一个动画的精准控制，假设有一个动画控制按钮从**禁用**->**可点击**的变化，每次点击时让这个动画重新执行一遍，在执行的过程中，一直处于**禁用**状态，这样就达到了“节流”的效果
4. 还可以通过 transition 的回调函数动态设置按钮禁用态
5. 这种实现的好处在于禁用逻辑和业务逻辑是完全解耦的

```
<button onclick="console.log('保存1')">我是“普通”保存</button>
<button class="throttle" onclick="console.log('保存2')">我是“节流”保存</button>

  body{
    display: grid;
    place-content: center;
    height: 100vh;
    margin: 0;
    gap: 15px;
    background: #f1f1f1;
}
button{
  user-select: none;
}
.throttle{
  opacity: .99;
  transition: opacity 2s;
}
.throttle:not(:disabled):active{
  opacity: 1;
  transition: 0s;
}

document.addEventListener('transitionstart', function(ev){
      ev.target.disabled = true
    })
    document.addEventListener('transitionend', function(ev){
      ev.target.disabled = false
    })
```



## 优秀代码实践

### 巧用not选择器

> 有些情况下`所有`的元素都需要某些样式，唯独`最后一个`不需要，这时候使用not选择器将会特别方便

```
li:not(:last-child){
  border-bottom: 1px solid #ebedf0;
}
```

### 使用flex布局实现智能固定底部

> 内容不够时，`规则说明`要处于底部，内容足够多时，`规则说明`随着内容往下沉，大家一定也遇到过类似的需求，使用flex巧妙实现布局。

```
<div class="container">
  <div class="main">我是内容区域</div>
  <div class="footer">规则说明</div>
</div>

 .container{
  height: 100vh;
  /* 关键css处 */
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.main{
  /* 关键css处 */
  flex: 1;
  background-image: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
}
.footer{
  padding: 15px 0;
  text-align: center;
  color: #ff9a9e;
  font-size: 14px;
}
```

### 画三角形

```
<div class="box">
  <div class="box-inner">
    <div class="triangle bottom"></div>
    <div class="triangle right"></div>
    <div class="triangle top"></div>
    <div class="triangle left"></div>
  </div>
</div>

.triangle {
  display: inline-block;
  margin-right: 10px;
  /* 基础样式 */
  border: solid 10px transparent;
}
  /*下*/
.triangle.bottom {
  border-top-color: #0097a7;
}
  /*上*/
.triangle.top {
  border-bottom-color: #b2ebf2;
}
/*左*/
.triangle.left {
  border-right-color: #00bcd4;
}
/*右*/
.triangle.right {
  border-left-color: #009688;
}
```

### 画小箭头

```
<div class="box">
  <div class="box-inner">
    <div class="arrow bottom"></div>
    <div class="arrow top"></div>
    <div class="arrow right"></div>
    <div class="arrow left"></div>
  </div>
</div>

.arrow {
    display: inline-block;
    margin-right: 10px;
    /* 基础样式 */
    width: 0;
    height: 0;
    /* 基础样式 */
    border: 16px solid;
    border-color: transparent #CDDC39 transparent transparent;
    position: relative;
  }

  .arrow::after {
    content: "";
    position: absolute;
    /* 通过位移覆盖背景 */
    right: -20px;
    top: -16px;
    border: 16px solid;
    border-color: transparent #fff transparent transparent;
  }
  /*下*/
  .arrow.bottom {
    transform: rotate(270deg);
  }
  /*上*/
  .arrow.top {
    transform: rotate(90deg);
  }
  /*左*/
  .arrow.left {
    transform: rotate(180deg);
  }
  /*右*/
  .arrow.right {
    transform: rotate(0deg);
  }
```

### 禁止选择文本

```
user-select: none;
```

### 文本超出

单行文本超过部分显示省略号

```
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

多行文本超过部分显示省略号

```
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
word-break: break-all;
```

若使用vue，则可使用下面这种方式

```
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
overflow: hidden;
word-break: break-all;
```

### 网页呈现哀悼模式

```
body{
  filter: grayscale(1);
}
```



# JS

## 为什么要**用setTimeout来模拟setInterval的行为**？

这里用setInerval不是更方便吗？

```
setTimeout(function(){··· }, n); // n毫秒后执行function
setInterval(function(){··· }, n); // 每隔n毫秒执行一次function
```

可以看看setInterval有什么缺点：

> 再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。

```
setInterval(function, N)  
//即：每隔N秒把function事件推到消息队列中
```

截图:https://www.vue-js.com/topic/61e13ee5cbbfd1003b11f98b

上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果。

综上所述，setInterval有两个缺点：

1. 使用setInterval时，某些间隔会被跳过；
2. 可能多个定时器会连续执行；

可以这么理解：**每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)**。因而我们一般用setTimeout模拟setInterval，来规避掉上面的缺点。

# 后台给你10w数据

https://www.vue-js.com/topic/61e56bd4cbbfd1003b11fa09

# Vue3

[Vue3的漏洞](https://www.vue-js.com/topic/61e622a4cbbfd1003b11fa19)

[前端框架设计理念与趋势](https://juejin.cn/post/7123178292865155102#heading-0)

## 常用的周边生态轮子

**PC UI**

- Element Plus
- Ant Design Vue
- Echarts
- Quasar
- Vuetify
- NativeUI
- Prime Vue

**Mobile UI**

- Ionic Vue
- Vant
- Varlet

**国际化**

- vue-i18n
- i18next

**其他生态**

- VueUse：针对vue3 composition api的工具库
- lodash.js
- moment:解析、校验、操作、显示日期和时间
- validator.js：表单验证
- nuxt3
- Animate.css：动画库
- mescroll.js：滚动插件
- swiper：轮播图
- day.js
- vue-draggable：拖拽
- vue-qr：生成二维码
- vue-cropper：图片裁剪
- vue-lazyload：图片懒加载
- clipboard.js：复制粘贴

# 设计模式

《JavaScript设计模式与开发实践》

《JavaScript设计模式核⼼原理与应⽤实践》

**其他**

https://github.com/mynane/PDF/blob/master/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.pdf

https://tb-tech.oss-cn-hangzhou.aliyuncs.com/The%20Complete%20Works%20of%20Tao%20Technology%202022.pdf

**发布订阅模式**

通俗理解：

> 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。
>
> 小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。

有三个要点：

- `发布者`：dep 对象
- `缓存列表`：dep.subscribers
- `发布消息`：dep.notify()

1. 首先要指定好谁充当发布者（比如售楼处）
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）

# gupiao

ETF的T+0交易
主要分为两种：直接T+0和变相T+0。
1.当前跨境ETF（恒生国企ETF、恒生ETF）、债券ETF、黄金ETF、货币ETF基本都可以实现直接T+0交易。
2、变相T+0，是指T日买入的ETF虽然T日不可以卖出，但却可以T日赎回，赎回得到的份额T日可以卖出。反之，T日买入的股票T日可以申购ETF份额，申购得到的份额可以T日卖出。比如上证50ETF

集合竞价
9:15—9:20：这五分钟是开放式集合竞价，可以委托买进和卖出的单子。这段时间是可以撤单的，因此这个时间段你看到的活跃个股的成交量基本上都是假的，因为很多大单是故意挂的，他们会在9:19:30之后撤单，根据开盘价的最大成交量原则，撤单后成交量最大的价格会被打下来很多。

9:20—9:25：这个时间段交易所接受申报，同样可以委托买进和卖出的单子，但是不可以撤单，因此这个时间段你看到的委托单子是真实的。但是!成交价未必，别忘了开盘价的形成是最大成交量原则，如果真正的大资金想要出货，他会在9:24:30之后挂真正的大卖单，价格会瞬间被打下来很多

9:25—9:30：新规则之后，这个时间段交易所不接受买卖申报和撤单。但是，在交易软件你依然可以下单，只是这个委托暂时会被存放到券商的系统里，等到9:30开盘之后，券商会按照下单的时间传送到交易所。

14:57-15:00：深市的股票在这个阶段进行集合竞价形成收盘价，这个时间只能接受买进和卖出申报，不能撤单。

# Webpack

[掘金站内 webpack 优秀文章汇总](https://juejin.cn/post/6844903986185650190)

# Vue Test Utils

- [使用 TDD 开发组件 --- Notification](https://juejin.cn/post/6844904013503152141#heading-19)
- [【element3-开发日记】手摸手教你重写 Button 组件](https://juejin.cn/post/6898959238576472077#heading-0)

# SolidJS

## SolidJS是什么

号称支持现代前端特性：**JSX**、**Fragments**、**Context**、**Portals**、**Suspense**、**Streaming SSR**、**Error Boundaries**、**并发渲染**等现代功能。

又一个摒弃 虚拟DOM，跟 Svelte 一样走编译型路线的框架，没了虚拟DOM 运行时，又通过优秀的响应式系统保证更新颗粒度非常小，性能爆表。和 Svelte 不同的是 Solid 直接借用了 React 社区的 JSX 来编写模板，没有像 Vue Svelte 那样去自定义模板语法。总体来讲 React 有的 API 大部分都能在它里面找到，甚至包括 React 18 的 useTransition，SuspenseList. 另外不提供 Class 组件玩法，所有的组件都是函数组件，且该组件函数只会执行一次。内置了 For 组件来替代 map 来优化性能。支持自定指令等

## 使用

```
import { render } from 'solid-js/web';
import { createSignal, createEffect } from 'solid-js';

const Counter = () => {
  const [getCount, setCount] = createSignal(0);
  const add = () => setCount(getCount() + 1);
  createEffect(() => {
    console.log('count is change:', getCount());
  });

  return (
    <button type='button' onClick={add}>
      {getCount()}
    </button>
  );
};

render(() => <Counter />, document.getElementById('root'));
```

**SolidJS**不仅打包体积小，性能也是 **Number 1**

参照[js-framework-benchmark](https://link.juejin.cn/?target=https%3A%2F%2Fkrausest.github.io%2Fjs-framework-benchmark%2Findex.html) 跑分结果：截图https://juejin.cn/post/7018846783203704863#heading-1

## 特点

### 平衡了 jsx 与 template 的利弊

**jsx** 和 **template** 的优缺点：

> jsx
>
> - 优点：作为`js`的语法糖拥有高度灵活性，可以随意编写
> - 缺点：因为过于灵活在 **编译阶段** 很难分析操作意图
>
> template
>
> - 优点：因为语法有限制，大部分带有 **操作意图（v-if、v-for）** 的代码都可以在 **编译阶段**被识别以做优化
> - 缺点：写法受限，大部分情况下不如`jsx`灵活

**Vue3** 对比 **Vue2** 性能之所以实现了一个质的飞跃，这其中就离不开 **编译阶段优化**。

> 1、 比如在**编译阶段**标记出`template`中永远不会变化的节点作为**静态节点**存储，将来更新时直接绕过他们；
>
> 2、提前对`v-if、v-for`这一类**区块**做区分，将来diff时绕过不必要的判断；
>
> 3、绑定`props`时记录哪些**属性**可能会变，将来 **diff** 时只对比“可能会变化的动态节点和属性”，跳过“永远不会变化的节点和属性”。
>
> 除此之外还有**缓存事件处理程序**等等

但JSX就不能识别操作意图，主要是写法太灵活。如果每种情况都去判断一遍，那么 **编译阶段** 将会非常复杂且耗时，另外显得也非常麻瓜。

```
v-if的写法就有三种：
// 写法1
return status === 1 ? <span>通过</span> : status === 2 ? <span>拒绝</span> : null;
// 写法2
return (
  <>
    {status === 1 && <span>通过</span>}
    {status === 2 && <span>拒绝</span>}
  </>
);
// 写法3
switch (status) {
  case 1:
    return <span>通过</span>;
  case 2:
    return <span>拒绝</span>;
}
```

**SolidJS** 采用的方案是：在 **JSX** 的基础上做了一层规范，中文译名为 [控制流](https://link.juejin.cn/?target=https%3A%2F%2Fwww.solidjs.com%2Fdocs%2Flatest%2Fapi%23%E6%8E%A7%E5%88%B6%E6%B5%81)。写法上类似某种预设的组件，用于**编译阶段**优化。这样在**编译阶段**就可以做**意图分析**，提前知道这是在**做按条件渲染**，然后编译成对应的**dom操作**即可。

SolidJS小结：

> - 即借鉴了 **template** 更容易做编译阶段优化的优势
> - 又保留了 **JSX** 的灵活性

### No Dom Diff

**No Dom Diff** 是说 **SolidJS**在**更新粒度**方面，摒弃了**虚拟dom**，采用**节点级更新**。

目前前端主流的几种方案：

- 应用级更新：状态更新会引起整个应用`render`，具体渲染哪些内容取决于**协调**的结果。代表作有 **React**(因为 **React** 每次更新都会重新走一遍更新流程，做这些限制是为了获取到完整的**VDom树/Fiber树**，通过 **diff新旧两棵树**来决定真正更新哪些组件，所以 **React** 并不是**组件级更新**)
- 组件级更新：状态更新时只会引起绑定了该状态的组件渲染，具体渲染哪些内容同样取决于**协调**的结果。代表作有**vue2.x**
- 节点级更新：状态更新时直接触法绑定该状态的节点更新，也就是**指向型更新**。代表作有**vue1.x**、**Svelte**、**SolidJS**

而**SolidJS**对于三大对象均采用**简单对象**存储，另外不需要**递归观察**，所以占用内存非常少。对于**如何更新dom**，具体的做法是：在**编译阶段**提前生成类似 `insert`、`update`、`delete`的**dom操作**方法，将来更新时直接调用。

### 重·编译时

- 提前生成节点渲染方法

刚才说到 **SolidJS** 在 **jsx** 中借鉴了部分 **template** 的规范写法，在编译阶段 **分析意图**，提前生成对应的**dom操作方法**

- 按需打包，缩小体积

这一步也就是 **tree-shaking**，只打包用到的模块，近一步缩小打包资源体积。

### 轻·运行时

由于没有了**diff**这一大规模计算，使得运行时代码更轻量，所以**SolidJS**在更新时也更**简洁**。

**SolidJS** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

**React v16** 在更新时的**js调用栈**如图：截图https://juejin.cn/post/7018846783203704863#heading-3

### 不被顺序限制的 hook

说到前端框架中的 **Hook**，最先将这个方案落地的是**React**，但由于**React**一直推崇 **immutable** 思想，每次更新必须重新走一遍整个树的更新流程，使得 **React Hook** 不可以在条件循环中使用，否则**可能**使渲染结果受到影响。

后来尤大发布了**Vue3.0**，伴随而来的一大特性是**Composition API**，俗称**Vue3 hook**，由于**Vue2**以后都采用**组件级**的**更新粒度**，再加上**响应式原理**采用的是**自动收集依赖**，所以**Vue3 hook**不会有顺序/条件的限制，另外还可以嵌套使用。

**SolidJS**的**响应式原理**主要借鉴了**React Hook**的思想，同时也保留了**Vue3**的**依赖收集模型**，所以用起来非常丝滑。

### 其他

- 脚手架：**degit**，内部集成了 **vite**。
- 支持`TS`且**类型**友好
- 现代前端框架大部分特性：`Fragments`、`Portals`、`Context`、`Suspense`、`事件委托`、`SSR`等等

**参考**

- [比React还Vue3的框架SolidJS](https://juejin.cn/post/7018846783203704863#heading-1)

# Vue与React

## 心智负担

**React的心智负担**

不能在条件语句中使用，`useMemo` 和 `useCallback` 需要显式指定依赖，解决子组件重新渲染可能还需要配合 `React.memo` 使用等等。虽然有对应的 `eslint-plugin` 可以帮助填充依赖，但是依赖项一旦很多，代码的可能读会非常差。现在普遍的观点是计算量大的再用 `useMemo`, 而 `useCallback` 能不用就不用。因为这点优化对性能的影响是微乎其微的，99% 的情况下都不会出现问题，等到出现问题的时候再进行优化也不迟。

**Vue的心智负担**

> 定义状态

ref定义的变量使用时，需要.value。虽然有了 `$ref` 语法糖，但最新已经废弃了。解构 `props` 也会出现响应丢失的问题，还要使用 `toRefs` 来解决。

> 插槽

因为在 `react` 中万物皆 `props`。Vue中需要具名插槽和作用于插槽等。

> props 和 emits 的定义

属性 和 事件 还需要分成 defineProps 和 defineEmits 两个 api。反观 react，还是万物皆 props 。

> 侦听 watch

watch监听对象里的某个属性时，第一个参数还需要是一个函数。还分为好多种，watch、watchPostEffect、watchSyncEffect、watchEffect。watch 的第三个参数又有很多属性。

> 渲染函数

`vue3` 提供了一个 `h` 函数，但还是很难用,还不如tsx。

> typescript 支持

存在语法限制。给 `defineProps` 定义的 ts 类型，不能从其它文件导入，只能写在这个文件里。想分开写到别的文件，只能不使用 ts 来定义类型，要使用 `defineProps` 的第一个参数来指定类型，这样才能从别的文件导入了。这就是为什么大多数组件库没有使用 ts 来定义类型的原因，这样定义的类型要用 `ExtractPropTypes` 来提取 ts 类型。

> breaking change

`vue2` 升级到 `vue3` 是不兼容的，旧项目升级是很麻烦的。反观 `react`，几乎是没什么影响。

# Vue3源码

**生态整理**

> **构建工具**： nuxt3: 一款基于`Vue3`的混合开发框架。 vite: 前端开发与构建工具.
>
> **工具库**： vueuse: 针对vue3 composition api的工具库。
>
> **路由管理库**： vue-router4
>
> **状态管理库**： pinia
>
> ------
>
> **组件库**:
>
> **UI框架**: [element plus](https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2F)、[ant design vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.antdv.com%2F)、[quasar](https://link.juejin.cn?target=https%3A%2F%2Fquasar.dev%2F)、[vuetify3beta](https://link.juejin.cn?target=https%3A%2F%2Fnext.vuetifyjs.com%2Fen%2Fgetting-started%2Finstallation%2F)、[naive ui](https://link.juejin.cn?target=https%3A%2F%2Fwww.naiveui.com%2Fen-US%2Fos-theme)、[prime vue](https://link.juejin.cn?target=https%3A%2F%2Fwww.primefaces.org%2F)
>
> **移动端**: [ionic](https://link.juejin.cn?target=https%3A%2F%2Fionicframework.com%2F)、[vant](https://link.juejin.cn?target=https%3A%2F%2Fyouzan.github.io%2Fvant%2F%23%2Fen-US)、[varlet](https://link.juejin.cn?target=https%3A%2F%2Fmadewithvuejs.com%2Fvarlet-ui)、[nutui](https://link.juejin.cn?target=https%3A%2F%2Fnutui.jd.com%2F%23%2Fstart)、[waveui](

# Vite性能优化

[记一次Vite打包优化](https://developer.aliyun.com/article/1166403)

三部曲：

- Network 分析
- Lighthouse 分析
- Bundle 分析

# 数据结构-1亿数据中访问某数据

先来看一下都有哪些题目：

- 如何从大量的 URL 中找出相同的 URL？（百度）
- 如何从大量数据中找出高频词？（百度）
- 如何找出某一天访问百度网站最多的 IP？（百度）
- 如何在大量的数据中找出不重复的整数？（百度）
- 如何在大量的数据中判断一个数是否存在？（腾讯）
- 如何查询最热门的查询串？（腾讯）
- 如何统计不同电话号码的个数？（百度）
- 如何从 5 亿个数中找出中位数？（百度）
- 如何按照 query 的频度排序？（百度）
- 如何找出排名前 500 的数？（腾讯）

答案呢？往下看~

## 1. 如何从大量的 URL 中找出相同的 URL？

**题目描述**

给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。

**解答思路**

每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。

> 5,000,000,000 * 64B ≈ 5GB * 64 = 320GB

由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用**分治策略**，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。

**思路如下**：

首先遍历文件 a，对遍历到的 URL 求 `hash(URL) % 1000`，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。

接着遍历 ai( `i∈[0,999]`)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。

**方法总结**

1. 分而治之，进行哈希取余；
2. 对每个子文件进行 HashSet 统计。

## 2. 如何从大量数据中找出高频词？

**题目描述**

有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。

**解答思路**

由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用**分治策略**，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。

**思路如下**：

首先遍历大文件，对遍历到的每个词x，执行 `hash(x) % 5000`，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。

接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 `map.put(x, 1)`；若存在，则执行 `map.put(x, map.get(x)+1)`，将该词频数加 1。

上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个**小顶堆**来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个**小顶堆**，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为**小顶堆**，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 3. 如何找出某一天访问百度网站最多的 IP？

**题目描述**

现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。

**解答思路**

这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。

> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。

**方法总结**

1. 分而治之，进行哈希取余；
2. 使用 HashMap 统计频数；
3. 求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

## 4. 如何在大量的数据中找出不重复的整数？

**题目描述**

在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

**解答思路**

**方法一：分治法**

与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。

**方法二：位图法**

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。

假设我们要对 `[0,7]` 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：

```
0 0 0 0 0 0 0 0
复制代码
```

然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：

```
0 0 0 0 1 0 1 0
复制代码
```

依次遍历，结束后，位数组是这样的：

```
0 1 1 0 1 1 1 0
复制代码
```

每个为 1 的位，它的下标都表示了一个数：

```arduino
for i in range(8):
    if bits[i] == 1:
        print(i)
复制代码
```

这样我们其实就已经实现了排序。

对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。

**那么对于这道题**，我们用 2 个 bit 来表示各个数字的状态：

- 00 表示这个数字没出现过；
- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；
- 10 表示这个数字出现了多次。

那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：

遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。

**方法总结**

**判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 5. 如何在大量的数据中判断一个数是否存在？

**题目描述**

给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？

**解答思路**

**方法一：分治法**

依然可以用分治法解决，方法与前面类似，就不再次赘述了。

**方法二：位图法**

40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。

我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。

**方法总结**

**判断数字是否存在、判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 6. 如何查询最热门的查询串？

**题目描述**

搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。

假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）

**解答思路**

每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。

**方法一：分治法**

分治法依然是一个非常实用的方法。

划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。

方法可行，但不是最好，下面介绍其他方法。

**方法二：HashMap 法**

虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。

**思路如下**：

首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 `O(N)`。

接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。

遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 `O(Nlog10)`。

**方法三：前缀树法**

方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。

**思路如下**：

在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。

最后依然使用小顶堆来对字符串的出现次数进行排序。

**方法总结**

前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。

## 7. 如何统计不同电话号码的个数？

**题目描述**

已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。

**解答思路**

这道题本质还是求解**数据重复**的问题，对于这类问题，一般首先考虑位图法。

对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

**思路如下**：

申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。

**方法总结**

求解数据重复问题，记得考虑位图法。

## 8. 如何从 5 亿个数中找出中位数？

**题目描述**

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 `(N+1)/2` 个数；当样本数为偶数时，中位数为 第 `N/2` 个数与第 `1+N/2` 个数的均值。

**解答思路**

如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)`。这里使用其他方法。

**方法一：双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。

若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

```ini
class MedianFinder {
    
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        minHeap = new PriorityQueue<>(Integer::compareTo);
    }
    
    public void addNum(int num) {
        if (maxHeap.isEmpty() || maxHeap.peek() > num) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        if (size1 - size2 > 1) {
            minHeap.offer(maxHeap.poll());
        } else if (size2 - size1 > 1) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    public double findMedian() {
        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        
        return size1 == size2 
            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2
            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());
    }
}
复制代码
```

> 见 LeetCode No.295：[leetcode.com/problems/fi…](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode.com%2Fproblems%2Ffind-median-from-data-stream%2F)

以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法**适用于数据量较小的情况**。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。

**方法二：分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

> **提示**，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。

对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

> **注意**，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。

**方法总结**

分治法，真香！

## 9. 如何按照 query 的频度排序？

**题目描述**

有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。

**解答思路**

如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。

**方法一：HashMap 法**

如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。

**方法二：分治法**

分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 `hash(query) % 10` 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。

接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。

**方法总结**

- 内存若够，直接读入进行排序；
- 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。

## 10. 如何找出排名前 500 的数？

**题目描述**

有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？

**解答思路**

对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：

首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。

接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。

重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。

> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。

```ini
import lombok.Data;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * @author https://github.com/yanglbme
 */
@Data
public class DataWithSource implements Comparable<DataWithSource> {
    /**
     * 数值
     */
    private int value;

    /**
     * 记录数值来源的数组
     */
    private int source;

    /**
     * 记录数值在数组中的索引
     */
    private int index;

    public DataWithSource(int value, int source, int index) {
        this.value = value;
        this.source = source;
        this.index = index;
    }

    /**
     *
     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改
     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆
     */
    @Override
    public int compareTo(DataWithSource o) {
        return Integer.compare(o.getValue(), this.value);
    }
}


class Test {
    public static int[] getTop(int[][] data) {
        int rowSize = data.length;
        int columnSize = data[0].length;

        // 创建一个columnSize大小的数组，存放结果
        int[] result = new int[columnSize];

        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();
        for (int i = 0; i < rowSize; ++i) {
            // 将每个数组的最大一个元素放入堆中
            DataWithSource d = new DataWithSource(data[i][0], i, 0);
            maxHeap.add(d);
        }

        int num = 0;
        while (num < columnSize) {
            // 删除堆顶元素
            DataWithSource d = maxHeap.poll();
            result[num++] = d.getValue();
            if (num >= columnSize) {
                break;
            }

            d.setValue(data[d.getSource()][d.getIndex() + 1]);
            d.setIndex(d.getIndex() + 1);
            maxHeap.add(d);
        }
        return result;

    }

    public static void main(String[] args) {
        int[][] data = {
                {29, 17, 14, 2, 1},
                {19, 17, 16, 15, 6},
                {30, 25, 20, 14, 5},
        };

        int[] top = getTop(data);
        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]
    }
}
复制代码
```

**方法总结**

求 TopK，不妨考虑一下堆排序？