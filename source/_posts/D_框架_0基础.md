---
title: 0基础
date: 2023-03-01 06:33:16
categories:
- D_框架和类库
toc: true # 是否启用内容索引

---

# canvas和svg技术

1. 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。
2. 从渲染模式上来说，Canvas属于 **即时模式**，而SVG则是 **保留模式** ,这两种模式的区别可以参见 cshao 的博文： http://www.lifelaf.com/blog/?p=354。
3. 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。
4. 从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的**Javascript** API对整个画布进行操作的，而SVG则是基于**XML**元素的。
5. 从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。
6. 关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。关于SVG和Canvas的运行场景可参考MSCN关于 **[如何为您的网站在Canvas和SVG之间做出选择](http://msdn.microsoft.com/zh-cn/ie/hh377884)**：
7. 从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索

![image-20220124072950469](/img/image-20220124072950469.png)

# DevOps

DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化，它促进开发和运营团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中。

DevOps有助于提高组织提供应用程序和服务的速度。它使组织能够更好地为客户服务，并在市场中更有竞争力。

**为什么需要DevOps？**

在DevOps之前：

●　开发和运营团队完全孤立。

●　测试和部署是在设计构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。

●　在不使用DevOps的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。

●　手动代码部署会导致生产中出现人为错误

●　开发和运营团队有各自的时间表，不同步导致进一步的延误。

在DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。

**DevOps原则**

```
1、以客户为中心的行动： DevOps团队必须采取以客户为中心的行动，因为他们应该不断投资于产品和服务。

2、端到端的责任： DevOps团队需要提供性能支持，直到它们终止为止。这提高了产品的责任水平和质量。

3、持续改进： DevOps文化专注于持续改进，以尽量减少浪费。它不断加快提供的产品或服务的改进。

4、自动化一切：自动化是DevOps流程的重要原则。这不仅适用于软件开发，也适用于整个基础架构环境。

5、作为一个团队工作：在DevOps文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。

6、监控和测试所有内容： DevOps团队拥有强大的监控和测试程序非常重要。
```

# Echart

## clear和dispose

clear:清空绘画内容，清空后实例可用,不会删除实例

dispose：释放图表实例，释放后实例不再可用。

## 渲染百万数据

### 全量渲染改增量

虽然这并不能解决拖动时的卡顿(因为仍旧需要遍历所有点),但能将每秒渲染的全量数据从百万改成几百个的增量数据，至少能给CPU放个假。

官方API提供[appendData](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fecharts%2Fissues%2F7625)方法。

研究了下Echarts的实现，其在填入数据时做了diff，而G每次填入的都是在原有数据基础上新增一秒数据，所以在diff算法的加持下，早就是增量渲染了。

### 懒加载

走投无路之下，便想砍掉几张图表。

G支持的性能数据颇多，同时需要绘制很多张图表。

但实际上电脑屏幕并不足够大，展示给用户的可视范围并不大，我们可以只实时渲染用户所见的部分，其余部分通过监听滚轮，鼠标，键盘的操作，当其可视时，再进行渲染。

可以看到一帧的时间已经达到了100ms+，其中占据较多时间的是Echart.setOption这个函数。实际上，Echarts在渲染单张图表时表现还是不错的，一般能做到20ms内，但因为我们图表共有数十张，10*10=100。改成滚动时加载之后帧渲染便好了极多。

### `sampling`降采样

实际上，我们可以注意到，G上的一个折线图，一般占用的像素宽度大概只有700到1500，就算是百万个点，能展示出来的也不过寥寥，这里便大有文章可做。

ECharts 有 [提供 ](https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Foption.html%23series-line.sampling)`sampling`[ 降采样功能](https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Foption.html%23series-line.sampling) ，其中有max，min，avg以及lttb等。使用G进行性能测试的同学很多时候，都是需要观测离群值的，所以max，min以及avg势必会丢弃很多细节，没法使用。


可以看出，使用了lttb算法之后，细节和趋势都保留的非常好，而且每帧渲染耗时更是从之前的成百上千降至50ms内，相当给力。