---
title: 组件库开发技巧
date: 2022-04-24 06:33:16
categories:
- D_框架和类库
toc: true # 是否启用内容索引
---

# 1.组件库通用设计方案

## 分散维护 VS 集中维护

问题:组件库的代码放在一起，还是分散在各个仓库？

Antd 、Material-UI、 React-UI 采用集中式管理等等。

**集中管理**

优点：方便组件统一管理，开发时不需要在多个仓库之间切换，而且预览效果只需运行跟项目，而不是为每个组件开启一个端口进行预览。

缺点：

- 引用默认是载入全部，虽然可以通过配置方式避免，（Antd 还提供了 webpack 插件做这个事情），但安装时必须全量。
- 无法对每个组件做更细粒度的版本控制。
- 协作开发困难，每个人都要搭建一套全环境，提 pr 也具有不少难度

**分散管理**

优点：对比集中管理的缺点。

缺点：

无法在同一个项目中观察全局，修改组件后引发的连带风险无法观察，组件之间引用需要发布或者 mock，不直观，甚至组件之间的版本关联、依赖分析都没法有效进行管理。

Fit 组件库在设计时，**分散部署+集中维护**。

- 建立根项目 Root，用来做整体容器，顺便还可以当对外网站
- 建立 Group，并在其中建立多个组件仓库
- 开发时只要用到项目 Root，根据依赖文件编写脚本自动拉取每个仓库中的内容
- 主要负责人拉取全部子项目仓库，子组件维护者只需要下载对应组件
- 发布时独立发布每个组件
- 管理时，统一管理所有组件

## package 版本统一

组件的依赖版本号需要统一，比如 fit-input ,fit-checkbox,fit-auto-complete 都依赖了 lodash，但因为先后开发时隔久远，安装时分别依赖了 2.x 3.x 4.x，当别人一起使用你最新版的时候，就会无辜的额外增加了两个 lodash 文件大小。

React 的版本都不可靠，之前就遇到过一半组件留在 0.14.x ，一半新组件装了 15.x 的情况，直接导致了线上编译后项目出错，因为多个 React 组件不能同时兼容。

因为项目开发时组件在一起，使统一版本号成为可能。我们将所有依赖到的组件都安装在 Root 项目中，每个组件的 package.json 由脚本自动生成，这个脚本需要静态扫描每个组件的 Import 或 require 语法，分析到依赖的模块后，使用根目录的版本号，填写在组件的 package.json 中，核心代码如下：

![image-20220424070908759](/img/image-20220424070908759.png)

先收集每个组件中的依赖， 如果在根目录的 package.json 中找到了，就使用根目录的版本号。

完整代码仓库：https://github.com/fex-team/fit/blob/master/scripts/module-manage/utils/upgrade-dependencies.js

## 依赖联动

依赖联动是指，fit-button 更新了代码，如果 fit-table 依赖了 fit-button，那么其也要发布一个版本，更新 fit-button 依赖的版本号。

除了依赖第三方模块，组件之间可能也有依赖，如果将模块分散维护，想更新一下依赖模块都需要发布+下载，非常消耗时间，而且依赖联动根本没法做。集中维护使用 webpack 的 alias 方案，在 typescript 找不到引用，总之不想找麻烦就不能写 hack 的代码。

回到 Fit 组件库结构，因为所有组件都被下载到了 Root 仓库下，因此组件之间的引用也自然而然的使用了相对路径，这样组件更新麻烦的问题迎刃而解，唯一需要注意的是，发布后，将所有引入非本组件目录的引用，替换成为 npm 名称，例如：

```
// 源码的内容
import Button from '../../../button'
// 发布时，通过编译脚本替换为
import Button from 'fit-button'
```

依赖联动，需要在发布时，扫描所有组件，找出所有有更新的组件，并生成一项依赖配置，最后将所有更新、或者被依赖的组件统一升级版本号加入发布队列。

依赖联动主要考虑到，主模块的连带升级，如果由于依赖模块小版本改动造成，那么依赖模块升级小版本其实为了 fix bug。如果业务模块升级了这个主模块，就要强制升级依赖模块到最新版解决那个 bug，如果以 ^ 打头就不强制了，不过这只是一种希望修复bug的方案，对灵活性有一定影响。

对与B的不兼容升级，对A来说发一个patch就可以，因为A对B兼容了，B不直接暴露给用户，就算用户安装了B模块，不需要升级版本，可以两个版本B模块共存。

# 2.组件库常用方式

## 独立化组件+私有 npm 仓库

> 项目外部组件化,企业内部私有npm仓库+本地跨项目包引用

优

- 私有包托管在内部服务器或者单独的服务器上
- 对于下载，发布，有对应的权限管理

劣（npm link能适当缓减本地联调压力）

- 版本号过多，版本号传递过程中的繁琐
- 组件库与项目间调试困难
- 需要规范的组件化开发与npm包管理学习成本

## monorepo

> 在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo

- 区分子项目依赖和公有依赖
- 体积大，重复依赖 ，考验团队

## github/@dependencies

将组件代码托管在git上，利用git搭建内部私有库。

同方案1，便易搭建但版本管理较差

参考：

[组件设计方案]: https://segmentfault.com/a/1190000022000712

# 3.组件库管理方案

- npm公共管理方式
- 私有仓库管理：Npm 私库、Git Subtree
- Lerna进阶工具

**npm私仓**

优点：

1. 和日常npm install操作相同，简单易用

2. 一次架设成本，后续直接使用即可，人员更换及人员水平变动没有影响

3. 组件修改发布后，所有项目都能使用，并且可以指定版本

缺点

1. 日常开发不便，需要将组件更新发布任何项目更新组件版本后才能看到效果

**Git Subtree**

优点

1. 跟git的多人协作同理，关联后一个项目更新所有项目都可以收到推送

2. 无需更改现有工程目录

3. 组件更新所见即所得，调试效果拉满

 缺点

1. 多人协作，多项目关联，随意性较高，可能改本项目无意间影响了所有项目，因此使用必须给所有成员做培训说明
2. 需要一定git相关知识，并且命令较长相对复杂

**Lerna进阶工具**

作为组件库使用方，我希望能在在历史项目里按需去引入某一个或几个组件，然后，也希望在新项目能够以合包的形式引入（效率考量）。另外，我也希望在未来一些迭代研发的项目中，如果没有集中的研发投入而需要去独立维护部分的组件时，我可以仅升级其中一个组件，而不用升级合包导致所有东西都升级了

所以我们采用的分包的开发模式（Monorepo），分包的解决方案用的是 Lerna 这一个比较成熟的第三方解决方案。

按照这个思路，每一个组件都是一个子包，每个子包有自己的独立版本，然后根据一定的逻辑把部分子包合起来，合并成一个 Bundle（合包），比如说 main，合包也有自己的独立版本。

# 4.组件库维护经验

最早、最彻底的把后端模块思维引入到前端，所以 React 组件生态迅速壮大。

## 分散部署 VS 集中维护

到底把组件库的代码放在一起，还是分散在各个仓库？

调查发现 Antd 是将所有组件都写入一个项目中，这样方便组件统一管理，开发时不需要在多个仓库之间切换，而且预览效果只需运行跟项目，而不是为每个组件开启一个端口进行预览。

但是集中管理有一些弊端。

- 引用默认是载入全部，虽然可以通过配置方式避免，（Antd 还提供了 webpack 插件做这个事情），但安装时必须全量。
- 无法对每个组件做更细粒度的版本控制。
- 协作开发困难，每个人都要搭建一套全环境，提 pr 也具有不少难度。

分散维护的弊端更明显，无法在同一个项目中观察全局，修改组件后引发的连带风险无法观察，组件之间引用需要发布或者 mock，不直观，甚至组件之间的版本关联、依赖分析都没法有效进行管理。

最后采用了两者结合的方案，分散部署+集中维护的折中方式：

- 建立根项目 Root，用来做整体容器，顺便还可以当对外网站
- 建立 Group，并在其中建立多个组件仓库
- 开发时只要用到项目 Root，根据依赖文件编写脚本自动拉取每个仓库中的内容
- 主要负责人拉取全部子项目仓库，子组件维护者只需要下载对应组件
- 发布时独立发布每个组件
- 管理时，统一管理所有组件

## package 版本统一

 React 的版本都不可靠，之前就遇到过一半组件留在 0.14.x ，一半新组件装了 15.x 的情况，直接导致了线上编译后项目出错，因为多个 React 组件不能同时兼容，这只是不能并存的其中一个例子。

因为项目开发时组件在一起，使统一版本号成为可能。我们将所有依赖到的组件都安装在 Root 项目中，每个组件的 package.json 由脚本自动生成，这个脚本需要静态扫描每个组件的 Import 或 require 语法，分析到依赖的模块后，使用根目录的版本号，填写在组件的 package.json 中。

先收集每个组件中的依赖， 如果在根目录的 package.json 中找到了，就使用根目录的版本号。

## 依赖联动

依赖联动是指，fit-button 更新了代码，如果 fit-table 依赖了 fit-button，那么其也要发布一个版本，更新 fit-button 依赖的版本号。

因为所有组件都被下载到了 Root 仓库下，因此组件之间的引用也自然而然的使用了相对路径，这样组件更新麻烦的问题迎刃而解，唯一需要注意的是，发布后，将所有引入非本组件目录的引用，替换成为 npm 名称，例如：

```
// 源码的内容
import Button from '../../../button'
// 发布时，通过编译脚本替换为
import Button from 'fit-button'
```

依赖联动，需要在发布时，扫描所有组件，找出所有有更新的组件，并生成一项依赖配置，最后将所有更新、或者被依赖的组件统一升级版本号加入发布队列。

# 5.组件库开发的三大关键点

## 整体架构设计

- 单包架构
- 多包架构

**单包架构**

如Antd，所有的组件看成一个整体，一起打包发布。这叫做**单包架构**

- **优点**：它最大的优点是可以通过相对路径实现组件与组件的引用，公共代码之间的引用。
- **缺点**：缺点就是组件完全耦合在了一起，必须把它作为一个整体统一发包。就算只改一个组件的一个非常小的功能，都要对整个包发布更新。

**多包架构**

每个组件彼此独立，单独打包发布，单个仓库多个包，统一维护单独管理。多包架构在业界称之为 "Monorepo"。

Lerna针对包之间有依赖的场景做了一些特殊优化，开发模式下，它会把所有存在依赖关系的包通过软链的形式连在一起，就可以很方便的本地开发联调

```
├── lerna.json
 ├── package.json
 └── packages/ # 这里将存放所有子 repo 目录
    ├── project_1/  # 组件1的包
    │   ├── index.js
    │   ├── node_modules/
    │   └── package.json
    ├── project_2/   # 组件2的包
    │   ├── index.js
    │   ├── node_module/
    │   └── package.json
    ...
```

- **优点**：它最大的优势是组件发布灵活，并且天然支持按需使用，
- **缺点**：缺点就是组件与组件之间物理隔离。对于相互依赖，公共代码抽象等场景，就只能通过NPM包引用的方式来实现。

## 基础技术能力

**构建能力**

选择Webpack，Rollup Glup Grunt..... 构建组件库推荐Rollup， 构建项目推荐Webpack. 这里需要特别注意产物的格式要求，像我们常用的cjs, esm,umd格式。

你的组件考虑支持 node环境， 像需要支持ssr, 你就需要打包出 cjs格式

你的组件考虑支持 `<script >` 标签引用，, 你就需要打包出 umd格式

比如说：

- 组件库Bable的配置是否与项目中Babel的配置重复
- 依赖包是打包到产物中，还是使用项目中的依赖包。如:lodash, moment...
- 依赖包的样式是否打包到产物中以及Polyfill的配置

**文档**

你需要提供一个可以实时运行的文档服务。 包括支持静态内容的展示，以及可以查看源码的实施运行效果，这方面有很多优秀的开源库,比如 StoryBook&Styleguidist，Docz

## 对外文档服务

1. 可能是纯静态资源
2. 配到的CI怎么搭建