---
title: C_0框架及工具
date: 2021-11-03 06:33:16
categories:
- C_框架及工具
toc: true # 是否启用内容索引
---

# 2.canvas和svg技术

1. 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。
2. 从渲染模式上来说，Canvas属于 **即时模式**，而SVG则是 **保留模式** ,这两种模式的区别可以参见 cshao 的博文： http://www.lifelaf.com/blog/?p=354。
3. 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。
4. 从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的**Javascript** API对整个画布进行操作的，而SVG则是基于**XML**元素的。
5. 从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。
6. 关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。关于SVG和Canvas的运行场景可参考MSCN关于 **[如何为您的网站在Canvas和SVG之间做出选择](http://msdn.microsoft.com/zh-cn/ie/hh377884)**：
7. 从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索

![image-20220124072950469](/img/image-20220124072950469.png)

# 3.VUE

## 1.数据响应式

**数据响应式**

首先要了解vue的初始化

```js
/*初始化生命周期*/
initLifecycle(vm)
/*初始化事件*/
initEvents(vm)Object.defineProperty 
/*初始化render*/
initRender(vm)
/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
/*初始化props、methods、data、computed与watch*/
initState(vm)
initProvide(vm) // resolve provide after data/props
/*调用created钩子函数并且触发created钩子事件*/
callHook(vm, 'created')
```

**initState(vm)** 是用来初始化props,methods,data,computed和watch;**initState**中的**initData**为关键一步。

**initData**做了两件事：1将_data上面的数据代理到vm；2执行observe()，将所有data变成可观察的。

关键3步：

1）Observer.defineProperty劫持data中的每一个属性添加`getter`和`setter`即数据劫持

2）创建`dep`和`watcher`进行`依赖收集`和`派发更新`，即订阅发布

3）通过`diff`算法对比新旧vnode差异，通过`patch`即时更新DOM

简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。Observer与Dep是1对1，Dep和Watcher是多对多。

## **2.双向绑定**

- Vue是单向数据流，不是双向绑定
- Vue的双向绑定不过是语法糖，v-bind数据绑定 与 v-on处理函数绑定
- Object.definePropert是用来做响应式更新的

父组件

```
<AnalysisSub v-model="phoneInfo" :zip-code.sync="zipCode" />
或 <AnalysisSub :phone-info="phoneInfo" @change="val => (phoneInfo = val)"
    :zip-code="zipCode"  @update:zipCode="val => (zipCode = val)"/>
```

子组件

```
<template>
  <div>
    <input
      :value="phoneInfo.phone"
      type="number"
      placeholder="手机号"
      @input="handlePhoneChange"
    />
    <input
      :value="zipCode"
      type="number"
      placeholder="邮编"
      @input="handleZipCodeChange"
    />
  </div>
</template>
<script>
export default {
  name: "PersonalInfo",
  model: {
    prop: "phoneInfo", // 默认 value
    event: "change" // 默认 input
  },
  props: {
    phoneInfo: Object,
    zipCode: String
  },
  methods: {
    handlePhoneChange(e) {
      this.$emit("change", {
        ...this.phoneInfo,
        phone: e.target.value
      });
    },
    handleZipCodeChange(e) {
      this.$emit("update:zipCode", e.target.value);
    }
  }
};
</script>
```

```
允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。
在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。
v-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景。引入sync标记。这种双向的改变可以灵活控制，但是会带来维护上的复杂性
```

**Object.defineProperty 与 Proxy**

1.Object.defineProperty：
只能对属性进行劫持，需要递归遍历对象的每个属性，执行Object.defineProperty把每一层对象数据都变成响应式的（如果定义的响应式数据过于复杂，会有很大的性能负担）
不能检测对象属性的添加和删除（需要重新遍历）
2.Proxy
在getter中去递归响应式，真正访问到的内部对象才会变成响应式，而不是无脑递归，提升了性能
劫持的是整个对象，能检测到对象属性的添加和删除

## 1.2Vue虚拟dom和diff算法

原理：虚拟dom和diff算法

**虚拟DOM**

好处：

1. 减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom，同时也使得数据驱动视图
2. 为函数式UI编程提供可能（React核心思想）
3. 可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex

虚拟DOM就是一个普通的JavaScript对象，包含了`tag`、`props`、`children`三个属性。

真实dom非常复杂，包括各种属性和事件方法等。

简单场景下真实dom效率高，复杂场景下，操作虚拟dom效率高。

**diff算法**

虚拟DOM + Diff算法才是vue提高性能的关键，**Diff算法是一种对比算法**，**执行差异化补丁更新**。对比两者是`旧虚拟DOM和新虚拟DO`。

Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:`深度优先算法`。 时间复杂度:`O(n)`。

直到oldNodeStart>=oldNodeEnd&&newNodeStart>=newNodeEnd不符合条件，diff算法才最终结束。

vue的diff算法参考了`snabbdom`(https://github.com/snabbdom/snabbdom)是著名的虚拟DOM库，diff算法的鼻祖。

![image-20211012230610276](/img/image-20211012230610276.png)

1.patch中的sameVnode方法：判断是否为相同节点：依据key和tag标签名

- 是：继续执行`patchVnode方法`进行深层比对
- 否：没必要比对了，直接整个节点替换成`新虚拟节点`

*key值是否一样*；*标签名是否一样*；*否都为注释节点*；*是否都定义了data*

2.patchVnode：更新节点

- 判断`newVnode`和`oldVnode`是否指向同一个对象，如果是，那么直接`return`
- 如果他们都是文本节点并且不相等，那么将`el`的文本节点设置为`newVnode`的文本节点。
- 如果`oldVnode`有子节点而`newVnode`没有，则删除`el`的子节点
- 如果`oldVnode`没有子节点而`newVnode`有，则将`newVnode`的子节点真实化之后添加到`el`
- 如果两者都有子节点，则执行`updateChildren`函数比较子节点，这一步很重要

3.`updateChildren`：首尾指针法

> **「双端比较的算法」**过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较.

oldNode头尾指针标记，newNode头尾指针标记。

oldNode与newNode指针逐个比较，如果判定相同节点，则执行patchVnode更新节点。

否则以newNode的key去oldNode中寻找等key值，如果找到key相等的，再比较sameVnode，如果相同，则patchVnode更新节点，否则插入节点。如果没有找到key相等的，则插入节点。

如果结束后，oldNodeStart>=oldNodeEnd，那么就需要删除旧节点中部分节点。newNodeStart>=newNodeEnd，那么需要新增新节点中的部分节点。

## 1.3组件通信传值

1.slot插槽传值

2.privide和inject

provide 和 inject 绑定并不是可响应的。简单类型不可响应。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。

父组件：

provide(){
  return{
    test:this.activeData
  }
},
data() {
  return {
    activeData:{name:'halo'},
  }
}
mounted(){
  setTimeout(()=>{
    this.activeData.name = 'world';
  },3000)
}

子孙任意组件：

```dart
export default {
  inject:['test'],
}
```

## 1.4接口权限-路由权限-菜单权限-按钮权限

[控制到按钮级别怎么做？](https://github.com/febobo/web-interview/issues/29)

**接口权限**

接口权限目前一般采用`jwt`的形式来验证，没有通过的话一般返回`401`，跳转到登录页面重新进行登录

登录完拿到`token`，将`token`存起来，通过`axios`请求拦截器进行拦截，每次请求的时候头部携带`token`

**路由权限**

> **方案一**

初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验

缺点：加载所有的路由，菜单信息写死在前端，不易维护，菜单跟路由耦合

> **方案二**

初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制

登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用`addRoutes`添加路由

缺点：全局路由守卫里，每次路由跳转都要做判断；菜单跟路由耦合

**菜单权限**

菜单权限可以理解成将页面与理由进行解耦

> **方案一**

菜单与路由分离，菜单由后端返回.

缺点:菜单需要与路由做一一对应，前端添加了新功能

>方案二

菜单和路由都由后端返回.

缺点：全局路由守卫里，每次路由跳转都要做判断。前后端的配合要求高

**按钮权限**

> **方案一**

按钮权限也可以用`v-if`判断

但是如果页面过多，每个页面页面都要获取用户权限`role`和路由表里的`meta.btnPermissions`，然后再做判断

这种方式就不展开举例了

> **方案二**

通过自定义指令进行按钮权限的判断

**参考文献**

- https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw
- https://segmentfault.com/a/1190000020887109
- https://juejin.cn/post/6844903648057622536#heading-6

## 1.5修饰符

表单修饰符：lazy；trim；number

事件修饰符

- .stop：阻止事件冒泡
- .native：绑定原生事件，使触发组件和触发标签一样
- .once：事件只执行一次
- .self ：将事件绑定在自身身上，相当于阻止事件冒泡
- .prevent：阻止默认事件
- .caption：用于事件捕获
- .once：只触发一次
- .keyCode：监听特定键盘按下
- .right：右键

## 1.7vue源码分析

**1.Vue的编译渲染过程**

template => ast => render函数 => VDOM => 真实DOM

- 先将template解析成抽象语法树（ast）
- 将ast编译成（complier）成render函数
- 将render函数渲染（render）成虚拟DOM
- 最后将虚拟DOM渲染成真实DOM

**runtime-with-compiler**

```
new Vue({
  el:'#app',
  components:{APP},
  template:'<APP/>'
})
```

渲染过程：template ==> ast ==> render ==> vdom ==> UI

**runtime-only**

```
new Vue({
  el:'#app',

  render: h=>h(APP)
})
```

渲染过程：render ==> vdom ==> UI

| runtime-compiler                     | runtime-only           |
| :----------------------------------- | :--------------------- |
| 体积更大（有compiler代码）           | 体积更小               |
| 有Vue.compilerAPI                    | 无Vue.compilerAPI      |
| 可以使用template模板、render函数渲染 | 只能使用render函数渲染 |

- 若只使用指令、数据绑定等，此时写template比写render函数更容易理解并方便，则需使用Runtime + Compiler构建的Vue库
- 挂载DOM元素的HTML被提取出来作为模板，则需使用Runtime + Compiler构建的Vue库

**本质**

runtime-with-compiler的打包入口文件是src/platforms/web/entry-runtime-with-compiler.js

runtime-only的打包入口文件是src/platforms/web/entry-runtime.js

runtime-with-compiler调用了runtime-only的$mount,并原形重写其方法。

**打包流程**

![image-20220113072406138](/img/image-20220113072406138.png)

## 1.8**methods和watch、computed**

watch和computed都是对数据的监听只有数据发生变化时才会触发。

***watch更擅长一对多***：就是主要监听一个可以影响多个数据的数据，watch比computed更强大。因为它能处理异步。
**computed擅长多对一**：主要监听多个数据影响一个数据的数据，一定要return

**methods**是通过事件驱动来执行函数的是被动的，watch、computed是当监听的数据发生变化时主动执行这个函数。

methods的运算是没有缓存的，computed运算是有缓存的。

## 1.9keep-alive原理

**1.定义**

keep-alive是一个抽象组件：它是一个vNode虚拟节点，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

**2.功能**

`include`定义缓存白名单，keep-alive会缓存命中的组件；`exclude`定义缓存黑名单，被命中的组件将不会被缓存；`max`定义缓存组件上限，超出上限使用[LRU的策略](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FLRU)置换缓存数据。`include`优先级比`exclude`更高。

**3.源码分析**

**(1.1)初始化过程：**

1. 获取keep-alive包裹的组件及组件名。
2. 根据设置的黑白名单，判断缓存是否命中，命中则使用缓存，否则直接创建或销毁组件。核心函数pruneCacheEntry
3. 根据组件ID和tag生成缓存Key，value为componentInstance组件实例的键值对。
4. 键值对超过max长度，使用LRU最近最少使用策略删除。
5. 设置keepAlive为true即标记为激活状态,patch期间渲染组件，mounted等生命周期过滤

```
// src/core/components/keep-alive.js
export default {
  name: 'keep-alive',
  abstract: true, // 判断当前组件虚拟dom是否渲染成真实dom的关键

  props: {
    include: patternTypes, // 缓存白名单
    exclude: patternTypes, // 缓存黑名单
    max: [String, Number] // 缓存的组件实例数量上限，使用LRU最近最少使用的组件删除
  },
//核心是cache和keys，keys里默认值是tagname。
//这两个属性没有声明到可视化的data中,静态属性声明可以减少数据监听的开销
  created () {
    this.cache = Object.create(null) // 缓存虚拟dom的key和实例的映射
    this.keys = [] // 缓存的虚拟dom的key键集合
  },

  destroyed () {
  //销毁时，更新cache
    for (const key in this.cache) { // 删除所有的缓存
      pruneCacheEntry(this.cache, key, this.keys)
    }
  },

  mounted () {
    // 实时监听黑白名单的变动
    this.$watch('include', val => {
      pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
      pruneCache(this, name => !matches(val, name))
    })
  },

  render () {
    // 先省略...
  }
}

```

核心render函数

```
  // src/core/components/keep-alive.js
  render () {
    const slot = this.$slots.default
    const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象
    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions
    if (componentOptions) { // 存在组件参数
      // check pattern
      const name: ?string = getComponentName(componentOptions) // 组件名,name:'VBase'
      const { include, exclude } = this
      if ( // 条件匹配
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
      //没有匹配到，则直接返回节点
        return vnode
      }

      const { cache, keys } = this
      const key: ?string = vnode.key == null // 定义组件的缓存key
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
        : vnode.key
      if (cache[key]) { // 已经缓存过该组件
      //将缓存的组件，赋值给你要渲染的新的组件
        vnode.componentInstance = cache[key].componentInstance
        // make current key freshest
        //删除并添加key
        remove(keys, key)
        keys.push(key) // 调整key排序
      } else {
        cache[key] = vnode // 缓存组件对象
        keys.push(key)
        // prune oldest entry
        //如果超过max最大缓存组件的长度，使用LRU策略，删除第一个
        if (this.max && keys.length > parseInt(this.max)) { // 超过缓存数限制，将第一个删除
          pruneCacheEntry(cache, keys[0], keys, this._vnode)
        }
      }

      vnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到
    }
    return vnode || (slot && slot[0])
  }

```

**(1.2)actived生命周期流程：**

patch阶段调用invokeInsertHook，执行activateChildComponent递归调用自组建的active生命周期。所以先执行子组件的active，然后是父组件的active.

deactivated也是类似。标记为失活状态。

4.使用场景

```
<keep-alive include="a,b">
  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->
  <component :is="view"></component>
</keep-alive>

<!-- 动态判断 -->
<keep-alive :include="includedComponents">
  <router-view></router-view>
</keep-alive>

<keep-alive>
    <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>

```

- 首页是A页面
- B页面跳转到A，A页面需要缓存
- C页面跳转到A，A页面不需要被缓存

```
{
    path: '/',
    name: 'A',
    component: A,
    meta: {
        keepAlive: true // 需要被缓存
    }
}

export default {
    data() {
        return {};
    },
    methods: {},
    beforeRouteLeave(to, from, next) {
         // 设置下一个路由的 meta
        to.meta.keepAlive = true;  // B 跳转到 A 时，让 A 缓存，即不刷新
        next();
    }
};

export default {
    data() {
        return {};
    },
    methods: {},
    beforeRouteLeave(to, from, next) {
        // 设置下一个路由的 meta
        to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新
        next();
    }
};


```

**4.vue的渲染过程**

![image-20211212174443165](/img/image-20211212174443165.png)

- Vue在渲染的时候先调用原型上的`_render`函数将组件对象转化为一个**VNode实例**；而`_render`是通过调用`createElement`和`createEmptyVNode`两个函数进行转化。
- 完成VNode实例化后，Vue调用原型上的`_update`函数把VNode渲染为真实DOM，这个过程又是通过调用`__patch__`函数完成的。

keep-alive刚好就发生在patch期间。abstract: true也导致了vue渲染时，不会生成真正的实例。

## 1.10v-if产生的内存泄漏问题

v-if 绑定到 false 的值，但是实际上 dom 元素在隐藏的时候没有被真实的释放掉。

比如下面的示例中，我们加载了一个带有非常多选项的选择框，然后我们用到了一个显示/隐藏按钮，通过一个 v-if 指令从虚拟 DOM 中添加或移除它。这个示例的问题在于这个 v-if 指令会从 DOM 中移除父级元素，但是我们并没有清除由 js文件中新添加的 DOM 片段，从而导致了内存泄漏。

## 1.11父组件监听子组件的生命周期

**1.使用on和on和emit**

自定义事件方式

**2.callhook钩子函数**

```
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...

相关源码
vm._self = vm
initLifecycle(vm) // 初始化生命周期
initEvents(vm) // 初始化事件
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
//callHook具体实现，就是自定义事件
export function callHook (vm: Component, hook: string) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook] // 选项当中的生命周期函数
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

## 1.12$nexttick原理

**1.概述**

在下次 `DOM` 更新循环结束之后执行延迟回调。`nextTick`主要使用了宏任务和微任务。根据执行环境分别尝试采用

- Promise
- MutationObserver
- setImmediate
- 如果以上都不行则采用setTimeout

定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

**2.源码分析**

nextTick源码主要分为两块：

- 1.能力检测
- 2.根据能力检测以不同方式执行回调队列

**(2.1)能力检测**

Event Loop分为宏任务（macro task）以及微任务（ micro task），不管执行宏任务还是微任务，完成后都会进入下一个tick，并在两个tick之间执行UI渲染。

宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务。

nextTick在能力检测这一块，就是遵循的这种思想。

```
//首先，检测浏览器是否支持setImmediate，不支持就使用MessageChannel，再不支持只能使用效率最差但是兼容性最好的setTimeout了。
//之后，检测浏览器是否支持Promise，如果支持，则使用Promise来执行回调函数队列，毕竟微任务速度大于宏任务。如果不支持的话，就只能使用宏任务来执行回调函数队列。
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // 如果支持，宏任务（ macro task）使用setImmediate
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
  // 同上
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  // 都不支持的情况下，使用setTimeout
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

**(2.2)执行回调函数队列**

总体流程是:接收回调函数，将回调函数推入回调函数队列中。

```
// 回调函数队列
const callbacks = []
// 异步锁
let pending = false

// 执行回调函数
function flushCallbacks () {
  // 重置异步锁
  pending = false
  // 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份，清空回调函数队列
  const copies = callbacks.slice(0)
  callbacks.length = 0
  // 执行回调函数队列
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

...

// 我们调用的nextTick函数
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  // 将回调函数推入回调队列
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  // 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  // $flow-disable-line
  // 2.1.0新增，如果没有提供回调，并且支持Promise，返回一个Promise
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}

```

有2个关键点：

*如何保证只在接收第一个回调函数时执行异步方法？*

nextTick源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。

当然执行flushCallbacks函数时有个难以理解的点，即：*为什么需要备份回调函数队列？执行的也是备份的回调函数队列*？

因为，会出现这么一种情况：nextTick套用nextTick。如果flushCallbacks不做特殊处理，直接循环执行回调函数，会导致里面nextTick中的回调函数会进入回调队列。这就相当于，下一个班车的旅客上了上一个班车。

**3.自己实现简易的nextTick**

在简易版的nextTick中，通过nextTick接收回调函数，通过setTimeout来异步执行回调函数。通过这种方式，可以实现在下一个tick中执行回调函数，即在UI重新渲染后执行回调函数。

```
let callbacks = []
let pending = false

function nextTick (cb) {
    callbacks.push(cb)

    if (!pending) {
        pending = true
        setTimeout(flushCallback, 0)
    }
}

function flushCallback () {
    pending = false
    let copies = callbacks.slice()
    callbacks.length = 0
    copies.forEach(copy => {
        copy()
    })
}

```



# 4.vue,react,angular比较

**1三大框架介绍**
 **1)angular**
 **历史**:2012开始1.0版本，16年升级2.0版本。新版本支持es6和ts。
 **基本特点**：
 双向绑定；
 依赖注入；
 基于ts的组件；
 良好的应用架构；
 工具生态完整，angular-cli用于创建、开发、测试等。有整套的解决方案，适合大型项目。
 **缺点**：中文文档较少，框架较重，学习成本高。
 **2)react**
 **历史**：2013年facebook发布版本。2015年版本稳定，同年发布reacr-native。
 **基本特点**：
 虚拟dom，跨浏览器兼容，性能较好；
 组件化，代码复用;
 JSX,js语法的扩展，模板简单、直接、语义化。
 单项数据流：数据流清晰，组件状态更可控。
 **缺点**：
 本身只是view，大型项目需要加上React Router和Redux。
 **3)VUE**
 **历史**：
 2015年1.0版本发布，同年vue-router、vuex、vue-cli出现，标志从一个视图层发展成一个渐进式框架。
 2016年vue2.0发布，引入虚拟dom，性能大幅提升。
 2019年vue2.0公布源码。
 **基本特点**：
 渐进式、轻量级框架;
 简单易用;
 双向数据绑定;
 组件化;
 轻量高效(使用虚拟dom，压缩后只有20kb)
 **缺点**：
 vue不支持IE8，生态比较差(语法提示不友好，插件数量比较少)

**2.vue和react比较**

工程实践上，由于耦合性、代码组织灵活性、平滑升级、测试、重构让我们最终放弃了 Vue。在 Vue 中你操作的是定义好的对象，React 中你操作的是一个函数。所谓前端开发，本质就是在编写下面几个函数。显然，React 对此的抽象更为彻底。

```
S = async(A1)
S = sync(A2)
UI = f(S)
```

**相同点：**

(1)都使用Virtural DOM

(2)都使用组件化思想，流程基本一致

(3)都是响应式，推崇单向数据流

(4)都有成熟的社区，都支持服务端渲染

Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法.不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数,

Vue和React通用流程：vue template/react jsx -> render函数 -> 生成VNode -> 当有变化时，新老VNode diff -> diff算法对比，并真正去更新真实DOM。

**差异点：**

**(1)核心思想不同**

Vue早期定位是尽可能的降低前端开发的门槛，Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集和派发更新）。

React早期口号是Rethinking Best Practices。想要做的是用更好的方式去颠覆前端开发方式，推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其稳定性（无副作用即对主函数（调用者）没有附加影响）和可测试性（输入相同，输出一定相同）。

(1.1)核心思想不同导致写法差异

Vue推崇template。React推崇JSX、HOC、all in js

(1.2)api差异

Vue定位简单易上手，基于template模板 + options API。比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api。

`React本质上核心只有一个Virtual DOM + Diff算法`，所以API非常少，知道setState就可以开发。

(1.3)社区差异

`由于Vue定义简单易上手，能快速解决问题，所以很多常见的解决方案，是Vue官方主导开发和维护`。比如状态管理库Vuex、路由库Vue-Router、脚手架Vue-CLI、Vutur工具等。属于那种大包大揽，遇到某类通用问题，只需要使用官方给出的解决方案即可。

React只关注底层，上层应用解决方案基本不插手。连最基础的状态管理早期也只是给出flow单向数据流思想，大部分都丢给社区去解决。比如状态管理库方面，有redux、mobx、redux-sage、dva等一大堆（选择困难症犯了），所以这也造就了React社区非常繁荣。

(1.4)未来升级方向不同

Vue依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。Vue3核心更新内容可以看到：template语法基本不变、options api只增加了setup选项（composition api）、基于依赖收集（Proxy）的数据可变。

`React的函数式编程这个基本盘不会变`。React核心思想，是把UI作为Basic Type，比如String、Array类型，然后经过render处理，转换为另外一个value（纯函数）。从React Hooks可以看出，React团队致力于组件函数式编程，（纯组件，无class组件），尽量减少副作用（减少this，this会引起副作用）。

**(2)组件实现不同**

`Vue源码实现是把options挂载到Vue核心类上，然后再new Vue({options})拿到实例`（vue组件的script导出的是一个挂满options的纯对象而已）。所以options api中的this指向内部Vue实例，对用户是不透明的，所以需要文档去说明this.$slot、this.$xxx这些api。

React内部实现比较简单，直接定义render函数以生成VNode，而`React内部使用了四大组件类包装VNode`，不同类型的VNode使用相应的组件类处理，职责划分清晰明了,用户透明。

**(3)响应式原理不同**

Vue2和Vue3响应式原理基本一致，都是基于依赖收集，不同的是Vue3使用Proxy.

```
Vue依赖收集，自动优化，数据可变。
Vue递归监听data的所有属性,直接修改。
当数据改变时，自动找到引用组件重新渲染。

React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。
当数据改变时，以组件为根目录，默认全部重新渲染
```

**(4)diff算法不同**

Vue基于snabbdom库，它有较好的速度以及模块机制。`Vue Diff使用双向链表，边对比，边更新DOM。`

`React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM`。

**(5)事件机制不同**

```
Vue原生事件使用标准Web事件
Vue组件自定义事件机制，是父子组件通信基础
Vue合理利用了snabbdom库的模块插件

React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。
React组件上无事件，父子组件通信使用props
```

**Vue与React的区别小结**

- vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；
- `props`是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；
- 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；
- 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；
- vue使用`插槽`分发内容，使得可以混合父组件的内容与子组件自己的模板；
- vue多了`指令系统`，让模版可以实现更丰富的功能，而React只能使用JSX语法；
- Vue增加的语法糖`computed`和`watch`，而在React中需要自己写一套逻辑来实现；
- react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。
- react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些，比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。
- react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin

# 5.vue2.0与vue3.0差别

Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 。它为后续做服务端渲染以及跨端框架 Weex 提供了基础。

Vue2.0很多需要解决的痛点,比如源码自身的维护性，数据量大后带来的渲染和更新的性能问题.

Vue3.0从**源码、性能和语法 API** 三个大的方面优化框架，vue3是一个比较好符合开源标准的工程化解决方案。

**1.源码优化**

**(1)代码管理方式**

Vue.js 2.x

```
源码托管在 src 目录
src
├── compiler        # 编译相关
├── core            # 核心代码
├── platforms       # 不同平台的支持
├── server          # 服务端渲染
├── sfc             # .vue 文件解析
├── shared          # 共享代码
```

Vue.js 3.0
monorepo 把这些模块拆分到不同的目录中，每个模块有各自的API类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。

```
@vue
├── compiler-core
│   ├── LICENSE
│   ├── README.md
│   ├── dist
│   │   ├── compiler-core.cjs.js
│   │   ├── compiler-core.cjs.prod.js
│   │   ├── compiler-core.d.ts
│   │   └── compiler-core.esm-bundler.js
│   ├── index.js
│   └── package.json
├── compiler-dom
```

(1)类型检查

Vue.js 2.x
使用Flow做类型检查，Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，它可以以非常小的成本对已有的 JavaScript 代码迁入，非常灵活。但是Flow 对于一些复杂场景类型的检查，支持得并不好。

Vue.js 3.0
使用 TypeScript 重构了整个项目。TypeScript提供了更好的类型检查，能支持复杂的类型推导。

**2.性能优化**

(1)源码体积优化

Vue.js 3.0
移除一些冷门的 feature(比如 filter、inline-template 等)；
引入 tree-shaking 的技术，减少打包体积；

Vue.js 2.x
Vue.js 2.x是采用数据劫持结合发布者-订阅者模式的方式来达到数据响应效果的。

```
Object.defineProperty(data, 'a',{  get(){    // track  },  set(){    // trigger  }})
```

Vue.js 2.x 内部是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter.但这个 API 有一些缺陷:

- 它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法；
- 对于嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。如果我们定义的响应式数据过于复杂，这就会有相当大的性能损耗；

为了解决上述 2 个问题，Vue.js 3.0 使用了 Proxy API 做数据劫持，它的内部是这样的：

```
observed = new Proxy(data, {  get() {    // track  },  set() {    // trigger  }})
```

使用了 Proxy API 做数据劫持，它劫持的是整个对象，对于对象的属性的增加和删除都能检测到。

Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理 。

(2)编译优化

Vue.js 2.x
通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树。这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。

Vue.js 3.0
通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关。

**3.语法 API 优化** 

(1)逻辑组织 优化

Vue.js 2.x
在 Vue.js 2.x版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API。Options API 的设计是按照 methods、computed、data、props 这些不同的选项进行分类。和一个逻辑点相关的代码可能写在多个Option里，非常分散，如果需要修改一个逻辑点，就需要在单个文件中不断切换和寻找。

Vue.js 3.0
Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。

(2)逻辑复用优化

Vue.js 2.x
我们通常会用 mixins 去复用逻辑。使用单个 mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。
每个 mixin 都可以定义自己的props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突；
对组件而言，如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰；

Vue.js 3.0
使用 hook 函数，整个数据来源清晰了，也不会出现命名冲突的问题。

(3)更好的类型支持

因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了。不像 Options API 所有的东西使用 this。

(4)tree-shaking 友好

tree-shaking有一个两个要求,必须是import导入,必须是单个函数或常量导出

Vue.js 2.x
直接导出的是整个vue实例，如果我们只是简单的用某一些功能的话就有点累赘。

Vue.js 3.0
用到的函数可以通过import声明，对“按需加载”有更好的支持。

注意
Composition API 属于 API 的增强，它并不是 Vue.js 3.0组件开发的范式，如果组件足够简单，可以使用 Options API

# 5vue封装自己的组件库并npm发布

# 6.NodeJS

它是运行在服务端的js代码。它是一个运行环境，没有它npm,webpack等都无法运行。

# 7.DevOps

DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化，它促进开发和运营团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中。

DevOps有助于提高组织提供应用程序和服务的速度。它使组织能够更好地为客户服务，并在市场中更有竞争力。

**为什么需要DevOps？**

在DevOps之前：

●　开发和运营团队完全孤立。

●　测试和部署是在设计构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。

●　在不使用DevOps的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。

●　手动代码部署会导致生产中出现人为错误

●　开发和运营团队有各自的时间表，不同步导致进一步的延误。

在DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。

**DevOps原则**

```
1、以客户为中心的行动： DevOps团队必须采取以客户为中心的行动，因为他们应该不断投资于产品和服务。

2、端到端的责任： DevOps团队需要提供性能支持，直到它们终止为止。这提高了产品的责任水平和质量。

3、持续改进： DevOps文化专注于持续改进，以尽量减少浪费。它不断加快提供的产品或服务的改进。

4、自动化一切：自动化是DevOps流程的重要原则。这不仅适用于软件开发，也适用于整个基础架构环境。

5、作为一个团队工作：在DevOps文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。

6、监控和测试所有内容： DevOps团队拥有强大的监控和测试程序非常重要。
```

# 8.顶级开发工具

- CSS代码生成器

- - CSS3 Generator
  - 终极CSS Generator
  - CSS Grid布局生成器

- 静态站点生成器

- - Next.js
  - Gatsby

- SVG 优化器

- - SVGOMG
  - SVG Optimizers

- 动画库

- - Animate.css
  - GreenSock (GSAP)
  - Anime.js

- 跨浏览器测试

- - Caniuse
  - Am I Responsive?
  - Responsive Web Design Checker
  - BrowserStack

- 代码协作和游乐场

- - GitHub
  - CodePen
  - JSFiddle
  - SoloLearn
  - jsrun.net

# 9.Echart

## 9.1clear和dispose

clear:清空绘画内容，清空后实例可用,不会删除实例

dispose：释放图表实例，释放后实例不再可用。

## 9.2Echart渲染百万数据

### 全量渲染改增量

虽然这并不能解决拖动时的卡顿(因为仍旧需要遍历所有点),但能将每秒渲染的全量数据从百万改成几百个的增量数据，至少能给CPU放个假。

官方API提供[appendData](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fapache%2Fecharts%2Fissues%2F7625)方法。

研究了下Echarts的实现，其在填入数据时做了diff，而G每次填入的都是在原有数据基础上新增一秒数据，所以在diff算法的加持下，早就是增量渲染了。

### 懒加载

走投无路之下，便想砍掉几张图表。

G支持的性能数据颇多，同时需要绘制很多张图表。

但实际上电脑屏幕并不足够大，展示给用户的可视范围并不大，我们可以只实时渲染用户所见的部分，其余部分通过监听滚轮，鼠标，键盘的操作，当其可视时，再进行渲染。

可以看到一帧的时间已经达到了100ms+，其中占据较多时间的是Echart.setOption这个函数。实际上，Echarts在渲染单张图表时表现还是不错的，一般能做到20ms内，但因为我们图表共有数十张，10*10=100。改成滚动时加载之后帧渲染便好了极多。

### `sampling`降采样

实际上，我们可以注意到，G上的一个折线图，一般占用的像素宽度大概只有700到1500，就算是百万个点，能展示出来的也不过寥寥，这里便大有文章可做。

ECharts 有 [提供 ](https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Foption.html%23series-line.sampling)`sampling`[ 降采样功能](https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Foption.html%23series-line.sampling) ，其中有max，min，avg以及lttb等。使用G进行性能测试的同学很多时候，都是需要观测离群值的，所以max，min以及avg势必会丢弃很多细节，没法使用。


可以看出，使用了lttb算法之后，细节和趋势都保留的非常好，而且每帧渲染耗时更是从之前的成百上千降至50ms内，相当给力。