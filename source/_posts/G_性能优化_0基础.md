---
title: 0基础
date: 2021-11-07 06:33:16
categories:
- G_性能优化
toc: true # 是否启用内容索引
---

# 1.基础概念

## 预研问题

**为什么css要放在头部加载？**

如果放在头部，CSSOM和DOM Tree合并完成后，进行一次layout布局和paint绘制。如果是放在body中，DOM Tree构建render tree时layout、paint一次，合并完成后再来一次layout、paint，重复进行一次布局，体验不好，可能还抖动。

**为什么js要放在body后面？**
图片的加载和渲染会阻塞DOM构建？
不会，
**DOM解析完才开始出现页面？**
不是，
**首屏时间根据什么来判定？**

**雅虎前端优化35军规**

### 优化总策略

优化策略大体可以这样：

**两个层面**

- 网络层面
- 浏览器渲染层面

**多端协作**

- 内核（比如浏览器）
- 中间件（web 服务器、数据库服务器等等）
- 外壳（比如[应用外壳](https://developers.google.com/web/updates/2015/11/app-shell)，PWA）
- 前端（资源压缩、代码执行、首评优化 内容优化）
- 后端（负载均衡、架构优化、并行优化、异步优化、算法优化、缓存优化）

**四种途径**

- 延迟（执行、加载）
- 按需（加载，例如从一个组件库加载一个组件）
- 缓存（资源）
- 预备（提前执行、加载，例如 Chrome 当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。prefetch 和 preload ）

**基本路线**

- 缓存
- 发送请求
- 服务端响应
- 页面解析与处理
- 静态资源优化
- `运行时`性能
- 预`加载`

## 性能优化体验指标

**(0).发展与演进**

**FCP**：首次内容渲染，用户请求url到页面出现第一个元素，页面首次绘制文本、图片、非空白 Canvas 或 SVG ，**即白屏时间**。
**FMP**：首次有效渲染，用户请求url到主要有意义内容渲染,没有严格定义，目前采用LCP。**即首屏时间**
**TTI**:可交互时间，用户请求url到用户可输入交互吗，对应的用户关注点是 **可以使用吗**

性能提升到1.2s，提升了80%。

A类极致性能：1s,2s,3s；
B类通用性能：2s,3s,5s;
C类较差性能能接受：3s,5s,8s;
D类不可接受：>3s,>5s,>8s

对应指标如下：

![image-20220524191242711](/img/image-20220524191242711.png)

> 是否在加载？FP/FCP
>
> 是否内容有用？FMP
>
> 是否可以使用？TTI
>
> 是否使用起来流畅？Long Tasks

- 是否在加载：**FP/FCP**。可以提示给到用户说明页面正在加载中，这时候应该页面从白屏阶段变成一些页面框架。为了提升首屏加载时间可以通过骨架屏的方式，在获取服务端数据前提前进行页面渲染。
- 是否内容有用：**FMP**。一般页面会有一些核心元素，又称为Hero元素，例如播放网站，播放器往往就是核心元素，在这个核心元素渲染出现时候才能告诉用户这个页面是否对他有价值。为了提升FMP，可以在核心渲染路径上优先保证核心元素的渲染，后置其他信息的渲染。
- 是否可以使用：**TTI**。这时候通常是指页面可以接受用户操作响应，页面加载完成的时间。
- 是否使用流畅：**Long Tasks**。在用户使用过程中，例如点击、滑动等等操作时候，是否能够保证页面的及时响应。通常情况下我们需要保证FPS在60以上，这样用户不会感受到明显的迟钝感，所以单次JS Long Task执行时间需要在 1s/60 = 16ms以内。

**其他指标如，Google三大核心指标：LCP,FID,CLS**或**雅虎35军规**

它们分别代表着：加载、交互、视觉稳定性.

<img src="/img/image-20220605155502770.png" alt="image-20220605155502770" style="zoom: 67%;" />

```
Largest Contentful Paint (LCP): 测量加载性能。为了能提供较好的用户体验，LCP指标建议页面首次加载要在2.5s内完成。
First Input Delay (FID): 测量交互性能。为了提供较好用户体验，交互时间建议在100ms或以内。
Cumulative Layout Shift (CLS): 测量视觉稳定性。为了提供较好用户体验，页面应该维持CLS在0.1或以内。
```

**(1)参数含义**

- FCP [First Contentful Paint 首次内容绘制](https://link.segmentfault.com/?enc=zpgy9w%2BZ407X66TCi2LZAw%3D%3D.HJv52cWKcQHfwSciM2Nwd1yzBt9R9b%2FYKDYiqpVo3FQ%3D)
- FMP First Meaningful Paint有意义内容绘制
- TTI [Time to Interactive 可交互时间](https://link.segmentfault.com/?enc=N2kP7a3xCaeYZbM8qMJaAg%3D%3D.omzdeMX41W0IJWh1MOAJl78e5XBkiykNXbGSx9aXHL0%3D)
- LCP [Largest Contentful Paint 最大内容绘制](https://link.segmentfault.com/?enc=tn7drI%2Bco%2FrKfxtE7WCX1A%3D%3D.gxjPhxn2z8mQYWb3%2BB1PHPgZPIFhpXKmOHL3%2Bt76d4Y%3D)
- FID
- CLS [Cumulative Layout Shift 累积布局偏移](https://link.segmentfault.com/?enc=Fb%2BHMf1fuf8ArdXf5DVyVQ%3D%3D.K1DU76IUMJAGfXhS4B5ZQlOH7KBZnlmsNAY2onVUqBs%3D)
- TBT [Total Blocking Time 总阻塞时间](https://link.segmentfault.com/?enc=CPbpVSe1ZcPuEceJfo%2FSuQ%3D%3D.hiSfYjd5Nw2lCRsBo5OIRYGhu4uU%2BnXAefG%2BcV%2BitJI%3D)

**指标介绍**

(1.0)FP

页面第一次绘制像素的时间(页面开始加载到某一块内容显示在页面上的时间)

(1.1)FCP

首次内容绘制，标记的是浏览器渲染第一帧内容 **DOM** 的时间点，浏览器首次渲染任何文本，图像（包括背景图像），`SVG` 或者 `<canvas>` 等元素。

如何改善 FCP

- 加速或减少 HTTP 请求消耗
- 延迟加载
- 压缩体积
- 浏览器渲染原理，减少阻塞渲染 的 JS、CSS

(1.2)FMP

近似等于LCP，首次有效绘制，标记主角元素渲染完成的时间点，主角元素可以是视频网站的视频控件，内容网站的页面框架也可以是资源网站的头图等。

(1.3)TTI

Time to Interactive (TTI)，从页面加载到可视化呈现、页面初始化脚本已经加载，并且可以可靠地快速响应用户的时间

(1.4)LCP

最大内容绘制，LCP（Largest Contentful Paint），用于记录视窗内最大的元素绘制的时间(页面开始加载到最大文本块内容或图片显示在页面中的时间)。表示`可视区“内容”最大的可见元素开始出现在屏幕上`的时间点

(1.5)FID

首次输入延迟，FID（First Input Delay），记录由于主线程繁忙导致用户首次输入的延迟时间。 Google 推荐响应用户交互在 100ms 以内(用户首次与网站进行交互(例如点击一个链接、按钮、js自定义控件)到浏览器真正进行响应的时间)。

(1.6)CLS

累计位移偏移，CLS（Cumulative Layout Shift），它能衡量页面是否排版稳定。记录了页面上非预期的位移波动(从页面开始加载到状态变为隐藏过程中，发生不可预期的layout shifts的累积分数)。页面移动会经常发生在资源异步加载、或者DOM元素动态添加到已存在的页面元素上面。这些元素有可能是图片、视频、第三方广告或小图标等。

```
let cls = 0;
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    if (!entry.hadRecentInput) {
      cls += entry.value;
      console.log('Current CLS value:', cls, entry);
    }
  }
}).observe({type: 'layout-shift', buffered: true});
```

(1.7)TBT

阻塞总时间，TBT（Total Blocking Time），记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。

(1.8)秒开率

低于1s内的数据占比即是秒开率，例如手淘的页面秒开率基本都达到80%以上。

(1.9)TTFB

浏览器从请求页面开始到接收第一字节的时间，这个时间段包括 DNS 查找、TCP 连接和 SSL 连接

(2.0)DCL（DOMContentLoaded Event）

当 `DOMContentLoaded` 事件触发时，仅当 `DOM` 加载完成，不包括样式表，图片（譬如如果有 async 加载的脚本就不一定完成）。

**(2)performance API**

<img src="/img/image-20220605154916096.png" alt="image-20220605154916096" style="zoom:80%;" />

左边部分代表的是网络传输层面的过程，右边部分代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析、DOM 树构建、布局、绘制等。

- **查找域名**：开始查找域名到查找结束，计算公式为（domainLookupEnd - domainLookupStart）
- **建立连接**：开始发出连接请求到连接成功，计算公式为（connectEnd - connectStart）
- **请求文档**：开始请求文档到开始接收文档，计算公式为（responseStart - requestStart）
- **接收文档**：开始接收文档到文档接收完成，计算公式为（responseEnd - responseStart）
- **domready**：开始解析文档到 DOMContentLoaded 事件被触发,计算公式为（domContentLoadedEventStart - domLoading）
- **load 事件持续**：load 事件被触发到 load 事件完成，计算公式为（loadEventEnd - loadEventStart）
- **完全加载**：开始解析文档到文档完全加载，计算公式为（domComplete - domLoading）
- **首屏加载**：开始解析文档到首屏加载完毕，计算公式为（firstscreenready - domLoading）
- **完全加载【全过程】**：此次浏览最开始时刻到完全加载完毕,计算公式为（domComplete - navigationStart）
- **首屏加载【全过程】**：此次浏览最开始时刻到首屏加载完毕,计算公式为（firstscreenready - navigationStart）

```
cosnt {
	fetchStart,//开始访问
	requestStart,//请求开始
	responseStart,//响应开始
	responseEnd,//响应结束
	domInteractive,//dom可交互时间点，即dom的event事件可绑定时间点
	domContentLoadedEventEnd,//dom加载完毕
	loadEventEnd//所有资源加载完毕，包括js，css,图片加载
} = performance.timing
```

**(3)指标计算**

```
const paint=performance.getEntriesByType('paint')
//FCP，原生js的performance
指标FCP=paint[1].startTime
//FMP，原生js的PerformanceObserver的API
new PerformanceObserver((entryList,observer)=>{
	指标FMP=entryList.getEntries()[0];
	observer.disconnect();//断开监视
}).observe({entryTypes:['element']})
//TTI
指标TTI=domInteractive-fetchStart //整一个可交互时间


ttfb(白屏时间) = responseStart - navigationStart ||0
DCL(dom加载时间)=domContentLoadedEventEnd-fetchStart
Load(页面加载时间)=loadEventEnd-fetchStart
tcp(连接时间) = connectEnd - connectStart || 0,
FP(第一次绘制像素时间)=paint[0].startTime
//LCP，mutationObserver微任务
new PerformanceObserver((entryList,observer)=>{
	entryList=entryList.getEntries()
	LCP=entryList[entryList.length-1]//取队列的最后一个元素
	observer.disconnect();//断开监视
}).observe({entryTypes:['largest-contentful-paint']})
//FID
new PerformanceObserver((entryList,observer)=>{
	firstInput=entryList.getEntries()[0]//取队列的第一个元素
	if(!firstInput) return;
	FID=firstInput.processingStart-firstInput.startTime;
	observer.disconnect();//断开监视
}).observe({type:['first-input'],buffered:true})
```

**(4)针对测量指标优化思路**

LCP优化

```
服务端响应时间
Javascript和CSS引起的渲染卡顿
资源加载时间
客户端渲染
```

FID优化

```
减少第三方代码的影响
减少Javascript的执行时间
最小化主线程工作
减小请求数量和请求文件大小
```

CLS优化

```
图片或视屏元素有大小属性，或者给他们保留一个空间大小，设置width、height，或者使用unsized-media feature policy。
不要在一个已存在的元素上面插入内容，除了相应用户输入。
使用animation或transition而不是直接触发布局改变。
```

**(5)实验室测量与现场测量**

实验测量采用Google的Lighthouse 提供开源 CI 工具 [Lighthouse CI](https://link.segmentfault.com/?enc=3heDceUevy8O6mKbgGJ1%2Fg%3D%3D.qsN1oX7ivX5IafNi1z%2FoMQ2s5FG85bMEFSMuqTxdxJeWF8UWRm%2BSKdXYyij%2Fo0GU)，现场测量采用数据上报。

## 浏览器输入url

pc->正向代理(电信、VPN)->CDN(100%使用到)-反向代理(阿里云，源站的代理人)->源站

<img src="/img/image-20220605154916096.png" alt="image-20220605154916096" style="zoom:80%;" />

- url地址解析，补全域名。
- 搜索本地DNS缓存记录，Chrome1分钟 缓存1000条DNS解析结果。否则域名解析为ip(DNS是基于UDP,查找域名，不需要建立3次握手，快)。
- 通过ip路由寻址，三次握手建立tcp连接。
- 负载均衡器
- 发送http请求。
- 服务器处理请求，浏览器接收HTTP响应。
- 渲染页面，构建dom树。
- 关闭TCP连接（四次挥手）。

1.首先url解析，url本质是统一资源定位符

默认补齐协议http，或默认补齐www.

protocol，协议头，譬如有http，加密的https，ftp等
host，主机域名或IP地址
port，端口号（通常端口号不常见是因为大部分的都是使用默认的端口所以隐藏，如HTTP默认端口80，HTTPS默认端口443。）
path，目录路径
query，即查询参数
fragment，即#后的hash值，一般用来定位到某个位置

2.DNS域名解析
域名解析的过程实际是将域名还原为IP地址的过程。先检查本地host文件，再找本地dns，再向上查找。按根域服务器 ->顶级域,.com->第二层域，baidu.com->子域，www.baidu.com的顺序找到IP地址。

3.TCP连接
通过三次握手协议进行连接

3.5负载均衡器

*Nginx是一款高性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。*

负载均衡的方法很多，Nginx负载均衡、LVS-NAT、LVS-DR等。

以Nginx负载均衡为例，Nginx有4种类型的模块：**core、handlers、filters、load-balancers**。

这里讲述下负责负载均衡的模块**load-balancers**和负责执行一系列过滤操作的**filters**模块。

Nginx默认支持 RR轮转法 和 ip_hash法 这2种分配算法。前者会从头到尾一个个轮询所有Web服务器，而后者则对源IP使用hash函数确定应该转发到哪个Web服务器上。还有其他的分配算法，如fair：这种算法会选择相应时间最短的Web服务器。url_hash：这种算法会使得相同的url发送到同一个Web服务器

而Filter的功能可以理解成先把前一步生成的结果处理一遍，再返回给浏览器。比如可以将前面没有压缩的网页用gzip压缩后再返回给浏览器。



4.发送http请求

排队等待，一个域名下最多6个连接。HTTP请求包含请求行、请求头、请求体三部分。默认不会断开，keep-alive保持下次传输时，复用上次创建的链接

```css
Accept: 接收类型，表示浏览器支持的MIME类型
（对标服务端返回的Content-Type）
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
Content-Type：客户端发送出去实体内容的类型
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
Cookie: 有cookie并且同域访问时会自动带上
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
Host：请求的服务器URL
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
User-Agent：用户客户端的一些必要信息，如UA头部等
```

5.服务端响应

1xx：指示信息–表示请求已接收，继续处理。

2xx：成功–表示请求已被成功接收、理解、接受。

3xx：重定向–要完成请求必须进行更进一步的操作。

4xx：客户端错误–请求有语法错误或请求无法实现。

5xx：服务器端错误–服务器未能实现合法的请求。

响应头主要由Cache-Control、 Connection、Date、Pragma等组成。
响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。
常用的响应头部（部分）：

```dart
Access-Control-Allow-Headers: 服务器端允许的请求Headers
Access-Control-Allow-Methods: 服务器端允许的请求方法
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
Content-Type：服务端返回的实体内容的类型
Date：数据从服务器发送的时间
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
Last-Modified：请求资源的最后修改时间
Expires：应该在什么时候认为文档已经过期,从而不再缓存它
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
ETag：请求变量的实体标签的当前值
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
Server：服务器的一些相关信息
```

![image-20211111191739887](/img/image-20211111191739887.png)

## html渲染流程

- 解析HTML标签，构建DOM树
- 解析CSS标签，并构建CSSOM样式规则树
- 调用js引擎处理script标记、绑定事件、修改DOM树/CSS树
- 将DOM和CSSOM合并成一个Render dom渲染树;
- 根据渲染树来布局（Layout回流/reflow重绘），来计算每个节点的几何信息
- 调用渲染引擎绘制render树（paint），绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite）

GUI渲染线程,JS引擎线程,事件触发线程,定时器触发线程,异步http请求线程

Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。

Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。

**(0)特有名称**

```
CSS 加载完成
Parse Stylesheet：解析样式表，构建出 CSSOM
Recalculate Style：重新计算样式，确定样式规则
Layout：根据计算结果进行布局，确定元素的大小和位置
Update Layer Tree：更新渲染层树
Paint：根据 Layer Tree 绘制页面（位置、大小、颜色、边框、阴影等）
Composite Layers：组合层，浏览器将图层合并后输出到屏幕
```

**(1)避免回流和重绘**

避免回流：虚拟dom；
读写分离：统一读，统一写，如fastdom的measure读，mutate写
css使用contain:layout

**(2)css解析规则**
从左向右解析，遍历所有的子孙节点;
从有向左解析，只遍历需要的节点，不会编辑全部节点;
**(3)js加载和执行机制**
js脚本会阻塞DOM加载即DOMContentLoad。我们的页面渲染不是等所有dom构建完才渲染，而是构建一部分渲染一部分，否则效率就太低了。
**(4)图片加载机制**
解析html，遇到img标签，构建dom树。加载样式，解析样式，构建cssom样式规则树。然后合并为渲染树，布局，再绘制

**(5)涉及主要线程**

- Renderer进程：包括3个线程。合成线程（Compositor Thread）、主线程（Main Thread）、Compositor Tile Worker。
- GPU进程：只有GPU线程，负责接收从Renderer进程中的Compositor Thread传过来的纹理，显示到屏幕上。

```
可以分为以下几步：
.主线程将页面分成若干图层（后文中会提及 Update Layer Tree）
.栅格线程分别对每一个层进行栅格化处理
.合成线程将栅格化的图块合并成一个页面
```

**Compositor Thread**

这个线程既负责接收浏览器传来的垂直同步信号，也负责接收OS传来的用户交互，比如滚动、输入、点击、鼠标移动等等。Compositor Thread会直接负责处理这些输入，然后转换为对layer的位移和处理，并将新的帧直接commit到GPU Thread，从而直接输出新的页面。

**Main Thread**

JS的执行、Recalculate Style、Update Layer Tree、Paint、Composite Layers等等。

主线程的顺序始终都是：Input Event Handler->requestAnimationFrame->ParseHtml->ReculateStyles->Layout->Update Layer Tree->Paint->Composite->commit->requestIdleCallback，只能从前往后，例如，必须先是ReculateStyles，然后Layout、然后Paint。但是，如果它只需要做最后一步Paint，那么这就是它全部要做的事情，不会再发生前面的ReculateStyles和Layout。

`transform` 和 `opacity` 可以直接触发合成，但是 `left` 和 `top` 却会触发Layout、Paint、Composite3个动作。所以transform是更好的方案。

**Compositor Tile Worker**

由合成线程产生一个或多个worker来处理光栅化的工作。



## 埋点数据上报

**(1)埋点方式**

代码埋点、可视化埋点、无痕埋点三种

- 代码埋点也叫手动埋点属于侵入式埋点，由开发手动在代码内植入预埋点，完全由开发控制埋点的位置时间和触发机制。
- 可视化埋点即以业务代码为输入，通过可视化系统配置埋点，最后以耦合的形式输出业务代码和埋点代码。
- 无痕埋点即无差别地对全局所有事件和页面加载生命周期等进行拦截全埋点。

(1.1)代码埋点

如百度统计、友盟、TalkingData、Google Analytics、Sensors Analytics等都提供了这一方案。

(1.2)可视化埋点

方案有Mixpanel、TalkingData、诸葛IO、腾讯MTA，Sensors AnalyticsV1.3+等

(1.3)无埋点

[Heap](https://link.segmentfault.com/?enc=iZuow9eN0X18OVBkprvJXA%3D%3D.Rn%2FAixuc18oKEM5cS92DpyZYOsFJiTN%2B9tUv%2FSzbxWw%3D)、百度（点击猴子）、GrowingIO等
与可视化埋点又类似，二者的区别就是可视化埋点先通过界面配置哪些控件的操作数据需要收集；“无埋点”则是先尽可能收集所有的控件的操作数据，然后再通过界面配置哪些数据需要在系统里面进行分析。

**(2)具体操作**

```
(2.1)利用<script>标签的 src 属性上报

工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 <script> 节点，将指标信息拼接成 url param 的形式，通过 <script> 标签的 src 属性发起请求，将数据上报到服务器。

(2.2)利用<img>标签的 src 属性上报

- 跨域友好
- 执行过程无阻塞
- 使用image时，部分浏览器内页面关闭不会影响数据上报
- gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节

(2.3)利用 HTML5 Beacon API 进行数据上报

Beacon API 允许开发者发送少量错误分析和上报的信息,优点：

- 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行
- 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页
- 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理
```



# 2.性能分析监控工具

## Performance

![image-20211219215308332](/img/image-20211219215308332.png)

**(1)Personmance面板简介**
三大区域：网页性能总览图(FPS、CPU);网络面板(瀑布图)，主线程(火焰图)等；数据详情及汇总面板
网页性能总览图：**蓝色**表示解析htmlLoading；**黄色**表示js相关；**紫色**表示渲染相关；绿色表示绘制相关；

**(2)三步法定位性能问题**
网页性能总览图,Main主线程Task任务图上有红色箭头标记网络性能瓶颈的地方。
熟语：在瀑布下用火焰烤饼
(2.1)饼图
Idle：白色空闲时间
Scripting：黄色js脚本加载时间
Rendering：紫色渲染加载
Painting:绿色绘制时间
(2.2)瀑布图
网络请求和文件下载信息

蓝色：html加载

黄色：js脚本资源加载
紫色：css资源加载
绿色：img等资源加载
灰色：api接口请求
每一个请求本质就是http请求过程，分为4段：
浅色线段：请求建立连接时间，从客户端发送请求到建立tcp连接，比如网络问题，nginx转发问题
浅色柱子TTFB：客户端请求第一个字节到客户端收到第一个字节的时间，比如：后台处理任务时间过长
深色柱子：客户端下载第一个字节到最后一个字节的时间
浅色线段：等待主线程处理时间即浏览器拿到所有资源到交给主线程处理的等待时间，比如：主线程有很多任务，某些js脚本执行时间过长
(2.3)火焰图
脚本执行、样式计算、布局计算、绘制等等。
任务队列，每个任务又分为若然子任务，有红色箭头标记长任务，run time。找到最长的长任务，可能就是存在性能瓶颈的地方。
这个Task还不是Event Loop，表示当前主线程忙碌，无法响应用户交互。Run Microtasks 则确实是在一次任务的末尾执行的微任务。
Task之间的白色就是Idle空闲时间,可能是资源加载时间过长引起的。
当我们点开调用栈观察时，可以看到源码中的回调函数以及对应的源码位置。
比如：LongTask里有一个二维码绘制的函数drawQrCode。耗时比较久，但是其实只需要鼠标移入才需要显示的，没必要做到首页加载。

**(3)性能分析图详解**

主要分为3个部分

![image-20211107232411254](/img/image-20211107232411254.png)

**区域1：网页性能总览图**
总览图包含 FPS（每秒帧数情况，越大越好）、CPU（CPU占用情况）、NET（网络资源情况）、HEAP（JS占用情况）一共四项指标。

**区域2：各项指标的区块图**

![image-20211107232617810](/img/image-20211107232617810.png)

1Network：表示每个服务器资源的加载情况，**瀑布图**。

main:表示每个task执行的时间，以及子任务的执行时间，**火焰图**，x轴表示时间轴，每个条形代表一个事件，越宽代表花费时间越长。y轴表示调用堆栈，高的事件调用低的事件。

2Frames：表示每幅帧的运行情况。

3Timings：上图中有 4 条虚线，分别表示如下。
（1）DCL（DOMContentLoaded）表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发。
（2）FP（First Paint）首屏绘制，页面刚开始渲染的时间。
（3）FCP（First Contentful Paint）首屏内容绘制，首次绘制任何文本，图像，非空白canvas 或 SVG 的时间点。
（4）FMP（First Meaningful Paint）首屏有意义的内容绘制，这个“有意义”没有权威的规定，本质上是通过一种算法来猜测某个时间点可能是 FMP。有的理解为是最大元素绘制的时间，即同LCP（Largest Contentful Paint ）。
其中 FP、FCP、FMP 是同一条虚线，三者时间不一致。比如首次渲染过后，有可能出现 JS 阻塞，这种情况下 FCP 就会大于 FP。
（5）L（Onload）页面所有资源加载完成事件。
（6）LCP（Largest Contentful Paint ）最大内容绘制，页面上尺寸最大的元素绘制时间。

**区域3：数据统计与汇总**

**bottom-up**

执行的事件，可以看到各活动占用的时间。**Self Time** 表示直接花费的时间，**Total Time**表示在该活动和其所有子活动花费的时间。可以看到该事件是执行的微任务，包含了重新计算样式+布局+调用方法+[请求状态改变](https://www.w3school.com.cn/ajax/ajax_xmlhttprequest_onreadystatechange.asp)+解析html。

![image-20211107232703176](/img/image-20211107232703176.png)

**Call Tree**

调用树，查看[根活动](https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#root-activities)（根活动是那些导致浏览器做一些工作的活动。例如，当单击一个页面时，浏览器会触发一个`Event`作为根 Activity 的 Activity。这`Event`可能会导致处理程序执行，等等。其在Main,call Tree 、Event Log都是最高级）。

**Event log**

浏览器在每一帧里，都会执行：

```js
Schedule Style Recalculation` -> `Recalculate Style` -> `Update Layer Tree` -> `Paint` -> `Composite Layers
```

- JavaScipt：JavaScript 实现动画效果，DOM 元素操作等。（Demo 3没有 js ，故这一步没有）
- Style（Schedule Style Recalculation、Recalculate Style）：确定每个 DOM 元素应该应用什么 CSS 规则，重新计算样式。
- Layout（Update Layer Tree）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow，即回流
- Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。这个过程会触发对元素的绘制，rePaint，即重绘
- Composite（渲染层合并，Composite Layers）：按照合理的顺序合并图层然后显示到屏幕上。
  

## Lighthouse

## web-vitals 库

Google官方提供了一个web-vitals库,可以测量google性能三大指标LCP,FID,CLS。

```
import {getCLS, getFID, getLCP} from 'web-vitals';

function sendToAnalytics(metric) {
  const body = JSON.stringify(metric);
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  (navigator.sendBeacon && navigator.sendBeacon('/analytics', body)) ||
      fetch('/analytics', {body, method: 'POST', keepalive: true});
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);

```

## [web-report-sdk](https://github.com/wangweianger/web-report-sdk)

## [web-monitoring](http://hubing.online:8083/#/sys/5cb68708838abf131c718ed1/index)

# 3.优化手段

提高网站的性能，很多的手段，比如，浏览器访问优化，CDN加速，反向代理，分布式缓存，使用集群，代码和数据结构的优化，存储性能的优化等

## HTML

最精简的dom，减少DOM元素的数量（否则会加重页面layout的压力）;
在循环结束时，一次性写入；
选择dom，尽量迅速缩小选择范围，使用id选择器；
批量修改dom使用DocumentFragment；

尽量少用iframe，优点：引入缓慢的第三方内容，安全沙箱，并行下载脚本。缺点:代价高，白屏，阻塞页面加载，非语义。

## CSS

最精简的css;合并内嵌css（不然计算量会很大）;
最小化回流layout和重绘paint；
选择器的优先级也是有开销的；

尽量减少层级，less嵌套规范也是如此;
使用class选择器而不是标签选择器，可以减少匹配次数;
按需加载css，适用移动端PC动态配置;
降低CSS对渲染的阻塞,如利用GPU进行完成动画，transform属性;
使用flex布局，可以提高性能，容器有决定元素大小，顺序，间隔，对齐功能，横向纵向都有考虑；

属性读写分离，先读后写；

通过切换 class 或者 style.csstext 属性去批量操作元素样式；

DOM 元素离线更新：当对 DOM 进行相关操作时，例、appendChild 等都可以使用 Document Fragment 对象进行离线操作；

将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示；

压缩 DOM 的深度，一个渲染层内不要有过深的子元素，少用 DOM完成页面样式，多使用伪元素或者 box-shadow 取代；

图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流；

选择link标签，舍弃@import

```js
<link href="CSSurl路径" rel="stylesheet" type="text/css" />

<style type="text/css">
@import url(CSS文件路径地址);
</style>

link和import语法结构不同;
link属于XHTML标签，而@import完全是css提供的一种方式;
link还可以定义RSS，定义rel连接属性。@import只能加载CSS。
link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再加载。
@import可以在css中再次引入其他样式表，比如创建一个主样式表，在主样式表中再引入其他的样式表。@import会产生多个css文件。
```



## Image资源等

(1)图片和路由的懒加载、第三方插件按需引入、使用keep-alive;

延迟加载图像，原理:img标签设置默认src颜色背景图，设置data-src真实图。通过事件监听可视窗口区域，加载真实图到src;
图片格式webp。loading="lazy"原生属性懒加载，缺点不太好控制。渐进式图片，从模糊到清晰。响应式图片，根据屏幕像素点动态加载图片大小；

1. Lazy loading加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。
2. Lazy loading加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。
3. Lazy loading加载没有缓冲，滚动即会触发新的图片资源加载。
4. Lazy loading加载在窗口resize尺寸变化时候也会触发，例如屏幕高度从小变大的时候。
5. Lazy loading加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。

(2)使用CSS Sprite雪碧图加载，横向排列一般都比纵向排列的最终文件小。

(3)使用webp格式文件

## JavaScript

(0)babel-loader` `@babel/preset-env` `core-js` `@babel/core等js兼容性的处理

(1)async和defer标记，相同和不同;

```
情况一：正常情况<script src="script.js"></script>
没有 defer 或 async，浏览器会立即加载并执行指定的脚本

情况二：有 async的，解析完js脚本后会立即执行，与html解析过程异步同时执行

情况三：有defer的，解析完js脚本后不会执行，而是在DOMContentLoaded 事件触发之前开始执行。也是异步。

```

![image-20211201070616431](/img/image-20211201070616431.png)



尽量减少DOM访问；

把脚本放在底部；

把JavaScript和CSS放到外面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数；

压缩JavaScript和CSS，如启用了gzip模块；

(2)preload和prefetch

preload主要用于预加载当前页面需要的资源；而prefetch主要用于加载将来页面可能需要的资源；

## TS

开始添加简单类型，后面开始泛型

## Webpack优化

**(0)版本及分析工具**

(0.1)webpack-bundle-analyzer打包分析神器；
(0.2)speed-measure-webpack-plugin分析整个打包时长，以及每个 loader 和每个 plugins 

(0.3)webpack4较webpack3

- `v8` 引擎带来的优化（`for of` 替代 `forEach`、`Map` 和 `Set` 替代 `Object`、`includes` 替代 `indexOf`）
- 默认使用更快的 `md4 hash` 算法
- `webpack AST` 可以直接从 `loader` 传递给 `AST`，减少解析时间

- 增加了mode配置，development | production，production配置默认启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。
- splitChunks替代了CommonChunksPlugin
- MiniCssExtractPlugin取代ExtractTextWebpackPlugin
- 代码分割，支持动态import，而不是用system.import或者require.ensure
- vue-loader，使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader
- UglifyJsPlugin，使用optimization.minimize为true就行

(0.4)webpack5较webpack4

- 内置 terser-webpack-plugin,mode=“production” 配置自动开启js压缩，自动开启 tree-shaking。而webpack4需要安装 terser-webpack-plugin。

- 内置 cache 缓存机制，cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。wepback4需要npm install hard-source-webpack-plugin -D

- 5需要webpack serve 启动服务。日志不好。4可以webpack-dev-server 启动服务

- raw-loader 将文件导入为字符串，asset/source 替换 raw-loader（导出源代码）

  url-loader 将文件作为 data url 内联到 bundle文件中，asset/inline 替换 url-loader （导出 url）

  file-loader 将文件发送到输出目录中，asset/resource 替换 file-loader(发送单独文件)

- 5.2版本以后提供npx webpack全局命令，支持全局操作,原理：当前目录下查找node_module,如果没有用，则下载webpack

**(1)module，chunk 和 bundle关系**
其实就是同一份逻辑代码在不同转换场景下的取了三个名字，直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。

devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的。 比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ； 而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。**–save**会把依赖包名称添加到package.json文件**dependencies**键下，**–save-dev**则添加到package.json文件**devDependencies**键下

**(1.1)打包后文件分析**

- app.js:就是app.vue文件 
- mainfest.js:一些异步加载的实现方法
- vender.js:vue核心功能被打包到这里
- chunk.js:主要的页面路由被打包编译在此

**(1.2)原理**

- 从入口文件开始，分析整个个应用的依赖树
- 将每个依赖模块包装起来，放到一个数组中，等待被调用
- 执行模块加载方法，确定模块之间以互相调用
- 把执行入口文件的逻辑放在一个立即执行函数汇总，参数就是模块数组

大致流程：

![image-20211215065353682](/img/image-20211215065353682.png)

打包后的文件：

```
1)首先是一个自执行函数
2)参数通过对象形式传递，key是文件路径，value是函数，eval()表示执行字符串代码。eval执行vaule函数字符串。
3)如果有多个依赖文件，最终会打包成一个文件
4)__webpack_require__最重要，模拟了require方法，将所有的引入合并成一个文件
5)通过递归的方式不断调用自己__webpack_require__，检查自己的依赖关系
(function(modules){
    //module缓存对象
    var installedModules = {};
    //require函数精髓
    function __webpack_require__(moduleId){
        //检查module是否在cache中
        if(installedModules[moduleId]){
            return installedModules[moduleId].exports;
        }
        //若不在cache中则新建module并放入cache中
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
        };
        //执行module函数
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        //标记module已经加载
        module.loaded = true;
        //返回module的导出模块
        return module.exports;
    }

    //暴露modules对象（__webpack_modules__）
    __webpack_require__.m = modules;
    //暴露modules缓存
    __webpack_require__.c = installedModules;
    //设置webpack公共路径__webpack_public_path__
    __webpack_require__.p = "";
    //读取入口模块并且返回exports导出
    return __webpack_require__(0);

})([function(module, exports, __webpack_require__){ /*模块Id为0*/
    var text = __webpack_require__(1);
    console.log(text);
},function(module, exports){ /*模块Id为1*/
    module.exports = 'Hello world';
}]);
```

**事件流机制**

webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 `Tapable`。

`Tapable` 也是一个小型的 library，核心原理就是一个`订阅发布模式`。

```
//  广播事件
compiler.apply('event-name', params)
compilation.apply('event-name', params)

// 监听事件
compiler.plugin('event-name', function (params) {})
compilation.plugin('event-name', function (params) {})
```

`Tapable` 还统一暴露了三个方法给插件

- tap：可以注册同步钩子和异步钩子。
- tapAsync：回调方式注册异步钩子。
- tapPromise：Promise 方式注册异步钩子。

**(2)优化手段**

```
let path = require("path");
let HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports = {//webpack 是node中的一个模块 CommonJs
  devServer: {//静态服务器的配置
    port: 3000,
    progress: true,//进度提哦啊
    contentBase: "./dist",//静态资源路径
    compress:true//是否压缩Gzip
  },
  mode: "production",//环境
  entry: "./src/index.js",
  output: {
    filename: "bundle[hash:8].js",//设置hash之后会解决浏览器缓存问题
    path: path.resolve(__dirname, "dist")//解析 会把相对路径解析成绝对路径
  },
  plugins: [
    new HtmlWebpackPlugin({//打包的时候 自动把html打包到dist目录
      template: "./src/index.html",
      filename: "index.html",
      minify:{
        removeAttributeQuotes:true,//去除双引号
        collapseWhitespace:true//单行压缩
      },
      hash:true//是否加hash后缀
    })
  ]
};

```

**终极目的：体积更小、速度更快**。

大牛：自带优化和自定义优化

**(2.1)自带优化:**

**1)使用Tree-Shaking删除死代码；**

Tree Shaking表面意为“摇树”，摇落枯萎的树叶。
DCE（Dead Code Elimination）消除无用js代码。Tree-Shaking 目前只适用于 ESModule模块化的代码，不适用commonjs。通过静态分析将无用代码打上标记，然后删除标记的无用代码。配置usedExports: true,配置mode：production生产环境。或者配置terser-webpack-plugin

**2)scope-hositing作用域提升**

变量->结果，简单的计算，直接输出结果，不再把变量进行打包。new ModuleConcatenationPlugin()开启scope-hositing

**(2.2)自定义优化**

**速度提升：**

a.使用happypack-loader多线程打包，注意: 如果体积较小会使打包时间更长

原理：每次 `webapck` 解析一个模块，`HappyPack` 会将它及它的依赖分配给 `worker` 线程中。处理完成之后，再将处理好的资源返回给 `HappyPack` 的主进程，从而加快打包速度。

b.中间缓存优化，HardSourceWebpackPlugin,大约提升90%的构建速度

动态链接库dll 配置将会被移除，因为 Webpack 4 的打包性能足够好的，dll 没有在 Vue ClI 里继续维护的必要了。动态链接库就是把大的js包，进行独立打包。

**体积更小：**

使用最新且稳定的版本；
缩小打包文件缩小范围；

压缩html

抽取并压缩样式文件；

优化图片资源加载；

代码分割；

**1)使用最新且稳定的版本；**

**2)缩小打包文件缩小范围；**

1)cacheDirectory开启babel缓存，提高二次构建速度，缓存loader执行结果；

```
这里存在一个问题：当文件名没有发生变化的时候，同名文件都是走缓存。会导致修改内容与实际展示内容不一致。
解决办法：使用hash命名，通过更换文件名来判断哪些文件需要更新。
hash值可分为（hash、chunkhash、contenthash）这里使用contenthash较为合理
hash：每次 wepack 打包时会生成一个唯一的 hash 值。
chunkhash：根据 模块 生成的 hash 值。隶属于同一个 模块 的 hash 值一样
contenthash：根据文件的内容生成 hash 值，可以保证不同文件 hash 值唯一性
```

2)优化 module.noParse,不解析依赖打包，externals编译后不打包
3)优化 resolve.modules，默认值为 ['node_modules']，会逐层查找第三方模块，直接指定绝对路径，更快速查找；
4)优化 resolve.extensions ,默认值为 ['.wasm', '.mjs', '.js', '.json'],修改为js,ts，更快速匹配文件；

6)排除对于语言包的打包,比如moment，排除多余语言，new webpack.IgnorePlugin(/\.\/locale/,/moment/),

**3)压缩html**

html-webpack-plugin,`html-webpack-plugin` 会自动将单独打包的样式文件通过link标签引入

**4)抽取并压缩样式文件；**

1)使用 mini-css-extract-plugin 替代`style-loader`，提取js中的css成单独文件
2)使用 optimize-css-assets-plugin 压缩 CSS

3)postcss-loader` `postcss-preset-env等css兼容性的处理

**4)优化图片资源加载；**

1)使用 url-loader 减少 http 请求,图片转为内置base64URI

**5)代码分割；**

**5.1)entry 配置多入口**
module.exports = {
  entry: {
    a: './a.js',
    b: './b.js'
  }
}
通过多个入口文件实现,分割成多个文件
**5.2)动态加载**

(1)vue的异步路由组件

{ path: '/home', name: 'home', component: resolve => **require**(['@/components/home'],resolve) },

(2)es6语法路由懒加载

const 组件名=() => import('组件路径');

// 指定了相同的webpackChunkName，会合并打包成一个js文件

const Home = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home')

const Index = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/index')

(3)webpack提供的require.ensure() 

{ path: '/home', name: 'home', component: r => require.ensure([], () => r(require('@/components/home')), 'demo') }

这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件

(4)同步引入的非懒加载

import react from 'react'//此为同步

**5.3)抽取公共代码 使用 splitChunks 配置**

```js
module.exports = {
    // ...
    optimization: {
        splitChunks: {
            chunks: 'async', // 三选一： "initial" | "all" | "async" (默认)
            minSize: 30000, // 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk 的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了
            maxSize: 0, // 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests < maxSize < minSize
            minChunks: 1, // 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小
            maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了
            maxInitialRequests: 3, // 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了
            automaticNameDelimiter: '~', // 打包文件名分隔符
            name: true, // 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个
            cacheGroups: {
                vendors: {
                    test: /[\\/]node_modules[\\/]/, // 正则规则，如果符合就提取 chunk
                    priority: -10 // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级
                },
                default: {
                    minChunks: 2,
                    priority: -20, // 优先级
                    reuseExistingChunk: true // 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个
                }
            }
        }
    }
};

```

**拆分合并规则**：
a.命名规则：vendor~a~b.js。vendor前缀表示命中缓存，a-b表示a和b有相同模块合并。cacheGroups表示缓存组，被命中的缓存组模块，会以vendor为前缀。
b.如果都是异步代码，都会被默认拆分出来打包成独立文件。相同模块会自动合并，命名后缀均为a_lodash.js。
c.如果都是同步代码，在"async"模式下，不拆分不合并;在“initial或all”模式下，会拆分且合并；vendors_a-b_lodash.js。
d.如果是一同步一异步代码，在"async"模式下，同步代码不拆分不合并;在"initial"模式下，会拆分同步代码，但是同步代码与异步代码相同模块不会合并；在"all"模式下，会拆分且合并。

```js
/* a.js */
import react from 'react';
import $ from 'jquery';
import(/* webpackChunkName: "a_lodash" */ 'lodash');
const a = 'I am a.js';
export default a;

/* b.js */
import $ from 'jquery';
import(/* webpackChunkName: "b-react" */ 'react');
import(/* webpackChunkName: "b-lodash" */ 'lodash');

const b = 'I am b.js';
export default b;
```

**(3)loader文件解析器**

**(3.0)原理**

loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等、语法分析及转换，然后交由下一环节进行处理，所有载入的模块最终都会经过moduleFactory处理，转成javascript可以识别和运行的代码，从而完成模块的集成。

以处理SCSS文件为例：

- SCSS源代码会先交给`sass-loader`把SCSS转换成CSS；
- 把`sass-loader`输出的CSS交给`css-loader`处理，找出CSS中依赖的资源、压缩CSS等；
- 把`css-loader`输出的CSS交给`style-loader`处理，转换成通过脚本加载的JavaScript代码；

先`sass-loader`再`css-loader`再`style-loader`，每个`Loader`会链式的顺序执行， 第一个Loader将会拿到需处理的原内容，上一个`Loader`处理后的结果会传给下一个接着处理。

```js
module：{
rule:[
	{
    test:'css,style,babel'// cssstyle快速优化，babel将es6转es5,jsx转js
	loader:‘对应loader’
	}
]
}
```

**Loader的特点**

- 处理一个文件可以使用多个loader，loader的执行顺序是和本身的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行。
- 第一个执行的loader接收源文件内容作为参数，其他loader接收前一个执行的loader的返回值作为参数。最后执行的loader会返回此模块的JavaScript源码
- loader 可以是同步的，也可以是异步的。

**Loader API**

- `this.context`：当前处理文件的所在目录，假如当前`Loader`处理的文件是`/src/main.js`，则`this.context`就等于`/src`。
- `this.resource`：当前处理文件的完整请求路径，包括`querystring`，例如`/src/main.js?name=1`。
- `this.resourcePath`：当前处理文件的路径，例如`/src/main.js`。
- `this.resourceQuery`：当前处理文件的`querystring`。
- `this.target`：等于Webpack配置中的`Target`。
- `this.loadModule`：当`Loader`在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过`this.loadModule(request: string, callback: function(err, source, sourceMap, module))`去获得`request`对应文件的处理结果。
- `this.resolve`：像`require`语句一样获得指定文件的完整路径，使用方法为`resolve(context: string, request: string, callback: function(err, result: string))`。
- `this.addDependency`：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用`Loader`处理该文件。使用方法为`addDependency(file: string)`。
- `this.addContextDependency`：和`addDependency`类似，但`addContextDependency`是把整个目录加入到当前正在处理文件的依赖中。使用方法为`addContextDependency(directory: string)`。
- `this.clearDependencies`：清除当前正在处理文件的所有依赖，使用方法为`clearDependencies()`。
- `this.emitFile`：输出一个文件，使用方法为`emitFile(name: string, content: Buffer|string, sourceMap: {...})`。

**(3.1)babel编译器**

bebel-loader中核心的是，@babel-core核心包、@babel-preset-env预设。

babel是javascript语法的编译器。比如class，let,for...of promise等等这样的，低版本浏览器不支持，babel编译器将es6代码转换成浏览器能识别的代码。默认情况下对新的语法和API中的，新的语法进行转换。

在Babel执行编译的过程中，会从项目的根目录下的 .babelrc文件中读取配置。.babelrc是一个json格式的文件。
在.babelrc配置文件中，主要是对预设(presets) 和 插件(plugins) 进行配置。

**1)plugins插件**

该属性是告诉babel要使用那些插件，这些插件可以控制如何转换代码。

Babel默认只转换新的javascript语法，而不转换新的API，比如 Iterator, Generator, Set, Maps, Proxy, Reflect,Symbol,Promise 等全局对象。以及一些在全局对象上的方法(比如 Object.assign)都不会转码。
比如说，ES6在Array对象上新增了Array.form方法，Babel就不会转码这个方法，如果想让这个方法运行，必须使用 babel-polyfill来转换等。

*babel-polyfill* 的原理是当运行环境中并没有实现的一些方法，babel-polyfill会做兼容的API转换。缺点：它是通过向全局对象和内置对象的prototype上添加方法来实现的。造成全局空间污染。

*babel-runtime* 它是将es6编译成es5去执行。优点：它不会污染全局对象和内置对象的原型，比如说我们需要Promise，我们只需要import Promise from 'babel-runtime/core-js/promise'即可，这样不仅避免污染全局对象，但是如果我现在有100个文件甚至更多的话，我们需要一个个文件加import。

babel-plugin-transform-runtime：既能转换新的API，也能避免全局污染，还能保证polyfill只有一份。

```
{
  'plugins': [
    [
      'transform-runtime', 
      {
        'helpers': false,
        'polyfill': false,
        'regenerator': true,
        'moduleName': 'babel-runtime'
      }
    ]
  ]
}
helpers: 默认值为true，表示是否开启内联的babel helpers(即babel或者环境本来存在的某些对象方法函数)如：extends，etc这样的
在调用模块名字时将被替换名字。

polyfill：默认值为true，表示是否把内置的东西(Promise, Set, Map)等转换成非全局污染的。

regenerator：默认值为true，是否开启generator函数转换成使用regenerator runtime来避免污染全局域。

moduleName：默认值为 babel-runtime，当调用辅助 设置模块（module）名字/路径.
```

**2)presets预设**

**2.1)babel-preset-env**

比如：

babel-preset-es2015: 可以将es6的代码编译成es5.
babel-preset-latest: 支持现有所有ECMAScript版本的新特性。

开始时需要配置es8转es7,es7转es6等多个预设，优化为es2015一个全部支持，后来又优化为babel-preset-env ，它的功能类似于 babel-preset-latest，它会根据目标环境选择不支持的新特性来转译。

**2.2)babel-presets-stage-x**

官方预设(preset), 有两种，一个是按年份(babel-preset-es2017)，一个是按阶段(babel-preset-stage-0)。 这主要是根据TC39 委员会ECMASCRPIT 发布流程来制定的。

.babelrc配置

```
{
  "plugins": [
     [
      "transform-runtime",
      {
        "polyfill": false
      }
     ]
   ],
   "presets": [
     [
       "env",
       {
         "modules": false
       }
     ],
     "stage-2"
  ]
}
```

**(4)plugins插件**

**(4.0)原理**

plugin` 是一个扩展器，它丰富了 webpack 本身，针对是 `loader` 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。

**(4.1)urgiijsplugins**

压缩js文件，移除空格换行符等，htmlplugins优化html编译。webpack4取消了UglifyjsWebpackPlugin，使用minimize进行压缩。

拆包策略：

1. 基础类库：vue、react，react-redux，react-router
2. UI库：ElementUI、antd，antd-icons
3. 公共组件库：自定义的公共组件
4. 低频组件：echart
5. 业务代码

**(4.2)HtmlWebpackPlugin**

- 为html文件中引入的外部资源如`script`、`link`动态添加每次compile后的hash，防止引用缓存的外部文件问题
- 可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置**N**个`html-webpack-plugin`可以生成**N**个页面入口

```
HtmlWebpackPlugin原理：
将 webpack中`entry`配置的相关入口chunk  和  `extract-text-webpack-plugin`抽取的css样式   插入到该插件提供的`template`或者`templateContent`配置项指定的内容基础上生成一个html文件，具体插入方式是将样式`link`插入到`head`元素中，`script`插入到`head`或者`body`中。
```

**(5)手写webpack的loader或插件**

(5.1)自定义loader

分为同步loader和异步loader

```
webpack.config.js
const path = require('path');
module:{
	rules:[
		{
			test:/.js$/,
			use:[
				path.resolve(__dirname,'./loaders/replace.js')
			]
		}
	]
}

index.js
console.log('luwentest')

//同步loader,修改打包内容
replace.js
module.export = function(context){
//没有使用箭头函数，可能需要修改this指向
return context.replace(/luwentest/g,'luwenProduction')
}

asyncReplace.js
//异步loader
const sleep = num =>new Promise((resolve)=>{
	setTimeout(()=>{
		resolve();
	},num)
});
module.export = function(content){
//获取loader的异步回调函数
 cosnt callback= this.async();
 ;(async()=>{
 //立即执行函数
 await sleep(3000);
 content = context.replace(/luwentest/g,'luwenProduction')
 //执行回调函数，传入4个参数，第1个是error信息，2是内容，3，4未知
 callback(null,content);
 })();
}
```

5.2自定义plugin

必须条件：

- 必须是一个class类；
- 必须重写apply方法；
- 必须调用complier API来影响打包结果；

```
//在项目打包时，动态创建license证书
license-webpack-plugin.js
class LicenseWebpackPlugins{
	constructor(parmas){
		console.log(parmas);
	}
	apply(complier){
	 // 在emit阶段插入钩子函数，用于特定时机处理额外的逻辑；
    compiler.hooks.emit.tap('HelloPlugin', (compilation) => {
      // 在功能流程完成后可以调用 webpack 提供的回调函数；
    })
    // 如果事件是异步的，会带两个参数，第二个参数为回调函数，
    compiler.plugin('emit', function (compilation, callback) {
      // 处理完毕后执行 callback 以通知 Webpack
      // 如果不执行 callback，运行流程将会一直卡在这不往下执行
      callback()
    })
	//Compiler 代表了整个 Webpack 从启动到关闭的生命周期
	//Compilation 只是代表了一次新的编译，只要文件有改动，compilation 就会被重新创建。
	//tapAsync表示异步处理，接收2个参数，第1个参数是类名，第2个是函数，
	//第2个是函数,包括2个参数，第1个参数是compliation类似可编译对象实例，第2个是cb回调函数
		complier.hook.emit.tapAsync('LicenseWebpackPlugins',(compliation,cb)=>{
			compliation.assets['LICENSE']={
				source:function(){
					return 'xxxxx我的证书信息'
				}
			}
		})
	}
}
```

- 1.webpack 读取配置的过程中会先执行 `new HelloPlugin(options)` 初始化一个 `HelloPlugin` 获得其实例。
- 2.初始化 `compiler` 对象后调用 `HelloPlugin.apply(compiler)` 给插件实例传入 compiler 对象。
- 3.插件实例在获取到 `compiler` 对象后，就可以通过 `compiler.plugin` (事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 `compiler` 对象去操作 Webpack

**(6)未来打包工具优化**

(1.1)ESBuild

我的主基准测试会将 three.js 库复制 10 次并从头开始构建单个包，过程中没有任何缓存，从而模拟一个大型代码库。在这个基准测试中，esbuild 比我测试的其他 JavaScript 打包器（Webpack、Rollup、Parcel 和 FuseBox）**快 10-100 倍**。这个基准测试可以使用’make bench-three’来运行。

![image-20211215065025626](/img/image-20211215065025626.png)

目前支持：

- CommonJS 模块
- ES6 模块
- 使用’–bundle’与 ES6 模块的静态绑定打包
- 使用’–minify’完全压缩（空格、标识符和修饰符）
- 启用’–sourcemap’时，完全支持源映射
- .jsx 文件的 JSX 到 JavaScript 转换
- 通过’–define’进行编译时标识符替换
- 使用 package.json 中的’browser’字段进行路径替换
- 自动检测 tsconfig.json 中的’baseUrl’

为什么这么快：

- 它是用 Go 语言编写的，该语言可以编译为原生代码；
- 解析，打印和源映射生成全部完全并行化；
- 无需昂贵的数据转换，只需很少的几步即可完成所有操作；
- 编写代码时处处注意速度表现，并尽量避免不必要的配置。

(1.2)webpack性能瓶颈

1. `代码构建`
2. `代码压缩`

![image-20211215065505606](/img/image-20211215065505606.png)

1）代码构建

浏览器的很多包分析工具是用`C/C++`写的, 显然是要比 `webpack` 使用 `js` 去分析整个`依赖图谱`更具优势，速度上也是要快很多的。

2)代码压缩

目前最成熟的 js 压缩工具是 `UglifyJS`。

它会分析 js 的`代码语法树`， 理解代码含义，从而能做到诸如: 去掉无效代码，去掉日志输出代码，缩短变量名等优化。

`webpack` 使用的 `terser`, 是用 `js` 写的， 源自于最早的 `uglyfy.js` , 功能很丰富， 但是速度非常非常慢。

`vite` 选择的也是`Terser`。

虽然 `Terser` 相对`较慢`，但大多数情况下构建后的`文件体积更小`。

ESbuild 最小化混淆`更快`, 但构建后的文件`相对更大`。

1. Esbuild, 使用 `GO` 写的。
2. SWC， 是用 `Rust` 写的。

未来前端的编译工具，大概也会往这个方向走, 要么用 `Go` 写, 要么用 `Rust` 写，而不是把这种能形成`性能瓶颈`的东西用 `js` 来实现。

 看起来 webpack5 的速度比 webpack4 要慢，但这`不代表` webpack 5 不好。

![image-20211215065812474](/img/image-20211215065812474.png)

```
webpack 5` 里面 做了`大量的优化`， `甩掉了不少历史包袱
新特性：
Module Federation
Real Content Hash
```

**(7)vueloader工作原理**

(1.1)完整流程

.vue 单文件文件组件类型的文件（下文简称 **SFC**）。Webpack 需要增加 vue-loader 和 vueLoaderPlugin 对 SFC 进行支持。入参 source 是 SFC 源码，经过处理逻辑后，输出 export default 的代码字符串。

![image-20211222073047966](/img/image-20211222073047966.png)

(1.2)SFC 的输入和输出

![image-20211222073237881](/img/image-20211222073237881.png)

(1.3)template、script、style 代码块切分

 template、script、style 代码块在输出结果中已经转化为对应的 import 逻辑。这一步是 vue-loader 调用了 @vue/component-compiler-utils 的 parse 函数进行解析后，分别生成了对应的 import 逻辑.

![image-20211222073348756](/img/image-20211222073348756.png)

(1.4)VueLoaderPlugin 的作用

vue&type=template 的作用是什么?

**Plugin 的作用**，主要有以下两条：

- 能够 hook 到在每个编译(compilation)中触发的所有关键事件。
- 在插件实例的 apply 方法中，**可以通过 compiler.options 获取 Webpack 配置，并进行修改**。

VueLoaderPlugin 通过**第二个特性**，在初始化阶段，对 module.rules 进行动态修改。

VueLoaderPlugin 的处理流程中，修改了 module.rules，在原来的基础上加入了 pitcher 和 cloneRules 。这一步的作用是：新增的 rule ，能识别形如 ?vue&type=template 的 querystring，让不同语言的代码块匹配到对应的 rule。

![image-20211222073538232](/img/image-20211222073538232.png)

(1.5)SFC 转化流程

每个代码块都导出了对应逻辑，我们以 script 块为例，结合第二节的 PitcherLoader 再次进行转化.

![image-20211222073711287](/img/image-20211222073711287.png)

(1.6)再次执行 VueLoader

在 PitchLoader 的转化结果中，还是会以 vue-loader 作为第一个处理的 loader，但 vue-loader 不是一开始就转化过了吗 ？与第一次不同的是，这次 vue-loader 的作用，仅仅是**把 SFC 中语法块的源码提取出来，并交给后面的 loader 进行处理**。

![image-20211222073804134](/img/image-20211222073804134.png)





参考文章：

webpack 优秀中文文章链接
《深入浅出 Webpack》链接
浅谈 webpack 性能优化链接
webpack5中文文档链接

## VUE优化

**1.运行时性能优化**
(1)v-show和v-if，computed和watch

(2)扁平化store数据结构

(3)v-for遍历为item添加key，v-for遍历避免同时使用v-if
(4)提取公共css和公共组件
(5)第三方库按需引入
(6)使用v-slot:slotName，而不是slot="slotName";
通过编译后的代码可以发现，旧的写法是将插槽内容作为 children 渲染的，会在父组件的渲染函数中创建，插槽内容的依赖会被父组件收集（name 的 dep 收集到父组件的渲染 watcher），而新的写法将插槽内容放在了 scopedSlots 中，会在子组件的渲染函数中调用，插槽内容的依赖会被子组件收集（name 的 dep 收集到子组件的渲染 watcher），最终导致的结果就是：当我们修改 name 这个属性时，旧的写法是调用父组件的更新（调用父组件的渲染 watcher），然后在父组件更新过程中调用子组件更新（prePatch => updateChildComponent），而新的写法则是直接调用子组件的更新（调用子组件的渲染 watcher）。
这样一来，旧的写法在更新时就多了一个父组件更新的过程，而新的写法由于直接更新子组件，就会更加高效，性能更好，所以推荐始终使用v-slot:slotName语法。
(7)使用非相应式数据 Object.freeze() 适用于展示的场景

(8)[vue-virtual-scroll-list](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftangbc%2Fvue-virtual-scroll-list) 和 [vue-virtual-scroller](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAkryum%2Fvue-virtual-scroller) 都是解决这类问题的开源项目

(9)组件懒加载

**2.加载时性能优化**

(1)利用服务端渲染（SSR）和预渲染（Prerender）来优化加载性能

(2)通过组件懒加载优化超长应用内容加载性能

## 网络层面

**(1)cdn**
使用cdn的方式外部加载一些资源，比如vue-router、axios等Vue的周边插件，在webpack.config.js里面，externals里面设置一些不必要打包的外部引用模块。然后在入门文件index.html里面通过cdn的方式去引入需要的插件。

淘宝的图片访问，有98%的流量都走了CDN缓存。只有2%会回源到源站，节省了大量的服务器资源。

**内容分发网络**（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。
CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速

借用阿里云官网的例子，来简单介绍CDN的工作原理。
假设通过CDN加速的域名为www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：

1. 当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。

2. LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。

3. 当授权DNS解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。

4. 域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。

5. LDNS获取DNS返回的解析IP地址。

6. 用户获取解析IP地址。

7. 用户向获取的IP地址发起对该资源的访问请求。

   如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。

   如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。

从这个例子可以了解到：
（1）CDN的加速资源是跟域名绑定的。
（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP
（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。

**(2)减少http请求数**

因为浏览器有6个并发的限制;**合并文件**、**CSS Sprites**、**行内图片（Base64编码）**

**(3)传输优化**

开启Gzip压缩，有时候压缩率高达90%；

```
nginx 配置gzip段如下：
gzip on;
//该指令用于开启或关闭gzip模块(on/off)

gzip_min_length 1k;
//设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。

gzip_buffers 4 16k;
//设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。

gzip_http_version 1.1;
//识别http的协议版本(1.0/1.1)

gzip_comp_level 2;
//gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)

gzip_types text/plain application/x-javascript text/css application/xml
//匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。
gzip_vary on;
//和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
```

**(4)保持keepalive**

设置keepalive_timeout超时时间。keepalive_requests长连接最大请求数；

**(5)浏览器缓存和http缓存**

