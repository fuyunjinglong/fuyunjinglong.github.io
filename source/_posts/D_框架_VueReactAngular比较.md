---
title: VueReactAngular比较
date: 2023-03-01 07:33:16
categories:
- A_编码规范
toc: true # 是否启用内容索引
---

# 三大框架解析1

**1三大框架介绍**
 **1)angular**
 **历史**:2012开始1.0版本，16年升级2.0版本。新版本支持es6和ts。
 **基本特点**：
 双向绑定；
 依赖注入；
 基于ts的组件；
 良好的应用架构；
 工具生态完整，angular-cli用于创建、开发、测试等。有整套的解决方案，适合大型项目。
 **缺点**：中文文档较少，框架较重，学习成本高。
 **2)react**
 **历史**：2013年facebook发布版本。2015年版本稳定，同年发布reacr-native。
 **基本特点**：
 虚拟dom，跨浏览器兼容，性能较好；
 组件化，代码复用;
 JSX,js语法的扩展，模板简单、直接、语义化。
 单项数据流：数据流清晰，组件状态更可控。
 **缺点**：
 本身只是view，大型项目需要加上React Router和Redux。
 **3)VUE**
 **历史**：
 2015年1.0版本发布，同年vue-router、vuex、vue-cli出现，标志从一个视图层发展成一个渐进式框架。
 2016年vue2.0发布，引入虚拟dom，性能大幅提升。
 2019年vue2.0公布源码。
 **基本特点**：
 渐进式、轻量级框架;
 简单易用;
 双向数据绑定;
 组件化;
 轻量高效(使用虚拟dom，压缩后只有20kb)
 **缺点**：
 vue不支持IE8，生态比较差(语法提示不友好，插件数量比较少)

**2.vue和react比较**

工程实践上，由于耦合性、代码组织灵活性、平滑升级、测试、重构让我们最终放弃了 Vue。在 Vue 中你操作的是定义好的对象，React 中你操作的是一个函数。所谓前端开发，本质就是在编写下面几个函数。显然，React 对此的抽象更为彻底。

```
S = async(A1)
S = sync(A2)
UI = f(S)
```

**相同点：**

(1)都使用Virtural DOM

(2)都使用组件化思想，流程基本一致

(3)都是响应式，推崇单向数据流

(4)都有成熟的社区，都支持服务端渲染

Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法.不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数,

Vue和React通用流程：vue template/react jsx -> render函数 -> 生成VNode -> 当有变化时，新老VNode diff -> diff算法对比，并真正去更新真实DOM。

**差异点：**

**(1)核心思想不同**

Vue早期定位是尽可能的降低前端开发的门槛，Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集和派发更新）。

React早期口号是Rethinking Best Practices。想要做的是用更好的方式去颠覆前端开发方式，推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其稳定性（无副作用即对主函数（调用者）没有附加影响）和可测试性（输入相同，输出一定相同）。

(1.1)核心思想不同导致写法差异

Vue推崇template。React推崇JSX、HOC、all in js

(1.2)api差异

Vue定位简单易上手，基于template模板 + options API。比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api。

`React本质上核心只有一个Virtual DOM + Diff算法`，所以API非常少，知道setState就可以开发。

(1.3)社区差异

`由于Vue定义简单易上手，能快速解决问题，所以很多常见的解决方案，是Vue官方主导开发和维护`。比如状态管理库Vuex、路由库Vue-Router、脚手架Vue-CLI、Vutur工具等。属于那种大包大揽，遇到某类通用问题，只需要使用官方给出的解决方案即可。

React只关注底层，上层应用解决方案基本不插手。连最基础的状态管理早期也只是给出flow单向数据流思想，大部分都丢给社区去解决。比如状态管理库方面，有redux、mobx、redux-sage、dva等一大堆（选择困难症犯了），所以这也造就了React社区非常繁荣。

(1.4)未来升级方向不同

Vue依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。Vue3核心更新内容可以看到：template语法基本不变、options api只增加了setup选项（composition api）、基于依赖收集（Proxy）的数据可变。

`React的函数式编程这个基本盘不会变`。React核心思想，是把UI作为Basic Type，比如String、Array类型，然后经过render处理，转换为另外一个value（纯函数）。从React Hooks可以看出，React团队致力于组件函数式编程，（纯组件，无class组件），尽量减少副作用（减少this，this会引起副作用）。

**(2)组件实现不同**

`Vue源码实现是把options挂载到Vue核心类上，然后再new Vue({options})拿到实例`（vue组件的script导出的是一个挂满options的纯对象而已）。所以options api中的this指向内部Vue实例，对用户是不透明的，所以需要文档去说明this.$slot、this.$xxx这些api。

React内部实现比较简单，直接定义render函数以生成VNode，而`React内部使用了四大组件类包装VNode`，不同类型的VNode使用相应的组件类处理，职责划分清晰明了,用户透明。

**(3)响应式原理不同**

Vue2和Vue3响应式原理基本一致，都是基于依赖收集，不同的是Vue3使用Proxy.

```
Vue依赖收集，自动优化，数据可变。
Vue递归监听data的所有属性,直接修改。
当数据改变时，自动找到引用组件重新渲染。

React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。
当数据改变时，以组件为根目录，默认全部重新渲染
```

**(4)diff算法不同**

Vue基于snabbdom库，它有较好的速度以及模块机制。`Vue Diff使用双向链表，边对比，边更新DOM。`

`React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM`。

**(5)事件机制不同**

```
Vue原生事件使用标准Web事件
Vue组件自定义事件机制，是父子组件通信基础
Vue合理利用了snabbdom库的模块插件

React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。
React组件上无事件，父子组件通信使用props
```

**Vue与React的区别小结**

- vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；
- `props`是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；
- 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；
- 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；
- vue使用`插槽`分发内容，使得可以混合父组件的内容与子组件自己的模板；
- vue多了`指令系统`，让模版可以实现更丰富的功能，而React只能使用JSX语法；
- Vue增加的语法糖`computed`和`watch`，而在React中需要自己写一套逻辑来实现；
- react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。
- react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些，比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。
- react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin

# 三大框架解析2

## 简介

**angular**

诞生于2009年的Angular可以算得上Web前端三大主流框架中最完整的框架，它包含模板、数据双向绑定、路由、模块化、服务、过滤器、依赖注入等所有功能。虽然出现较早，但是因为其强大的功能，至今使用热度不减。对于刚开始前端初学者来讲，AngularJS完全基于HTML和JavaScript，因此无需学习其他语法或语言。使用TypeScript能够提高代码可维护性，有利于后期重构。
当然，Angular框架也不是完全没有缺点的。虽然双向数据流很方便，但是等业务复杂之后，你可能就搞不清楚数据流了。还有令人不开心的脏值检查，以及directive的封装并没有解决视图与数据关系完全分离的问题，有时候还要用$digist强制触发检测，当然，因为其由Google主导，小伙伴们还是不要选择了，毕竟Angular能搞定的，Vue也是完全能够胜任的。

**React**

React是一个开源的JavaScript库，由Facebook和一个大型开发者社区共同维护。广泛用于开发web应用程序的用户界面。React框架的主要功能是对DOM操作，声明式设计，更快的开发出Web应用系统。使用React框架，可以非常轻松地创建用户交互界面，为应用的每一个状态设计简洁的视图。甚至在数据改变时，React也可以高效地更新渲染界面。
虽然React框架本身比较容易理解，结构很清晰，就是由十几个API组成，然后异步渲染。但是很多人反映上手还是有一定的的难度的。React是单向数据流，代码写起来会较双向数据流的多一些，但是同样的排查问题时思路清晰很多。

**Vue**

Vue框架的最大优势就是简单易上手，同时它也是目前Web前端开发的最常使用的主流框架。Vue.js是用于构建交互式的Web 界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。从技术上讲， Vue.js集中在MVVM模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的DOM操作和输出格式被抽象出来成指令和过滤器。所以相比其它的MVVM框架，Vue.js更容易上手。
而且它能够开发单页面应用程序，还可以用作Web应用程序框架。Vue框架最大的优势就是能够在没有任何动作的情况下重新渲染，而且允许我们在需要时随时添加组件。

## React详解

**概述**

React（有时叫React.js或ReactJS），是一个为数据提供渲染为HTML视图的开源JavaScript 库。React视图通常采用包含以自定义HTML标记规定的其他组件的组件渲染。React为程序员提供了一种子组件不能直接影响外层组件（"data flows down"）的模型，数据改变时对HTML文档的有效更新，和现代单页应用中组件之间干净的分离。
它由Facebook、Instagram和一个由个人开发者和企业组成的社群维护。

**Fiber架构**

Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。
从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。
从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的"虚拟 DOM"。
一个 fiber 就是一个 JavaScript 对象，Fiber 的数据结构如下：

**Fiber 如何解决问题的**

Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个"执行单元"，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。

**Fiber 实现原理**

实现的方式是requestIdleCallback这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。
window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。
requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。
即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。
简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。
React 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。
作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。
作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。
每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性

**Fiber 架构核心**

Fiber 架构可以分为三层：

- Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler
- Reconciler 协调器 —— 负责找出变化的组件
- Renderer 渲染器 —— 负责将变化的组件渲染到页面上
  在新的架构模式下，工作流如下：
- 每个更新任务都会被赋予一个优先级。
- 当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；
- 此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。
- 当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。
  Fiber 架构的核心即是"可中断"、"可恢复"、"优先级"。

*Scheduler 调度器*
这个需要上面提到的requestIdleCallback，React 团队实现了功能更完备的 requestIdleCallback polyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。

*Reconciler 协调器*
在 React 15 中是递归处理虚拟 DOM 的，React 16 则是变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间

*React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？*
在 React 16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上的标记。

整个Scheduler与Reconciler的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

## Vue详解

**一、Vue生命周期**

Vue 主要实现了以下几个阶段：

1. 组件初始化，包括事件初始化、数据初始化、依赖注入初始化等；
2. 模板编译，即把 HTML 模板转化为可以被 Vue 利用的渲染函数，其中包括了虚拟 DOM 的概念；

3. DOM 挂载与更新，即把渲染函数的返回值映射为真实的 DOM ，复用或创建新的 DOM 节点；
4. 组件销毁，包括为了实现响应式而挂载的监听器、事件监听器等。

**二、响应式原理**

为了实现无侵入的响应式数据，Vue 使用了设计模式中的代理模式，在 2.x 系列借助 ES 5 对象方法 Object.defineProperty 对原始数据进行代理，在 3.x 系列中则使用 ES 6 Proxy 对象进行代理。ES 5 对象方法要求 ES 5 支持，因此 Vue 2.x 不支持 IE 8 以下的版本。ES 6 Proxy 要求 ES 6 支持，因此 Vue 3.x 无法支持 IE 11 。下文我们以目前广泛使用的 Vue 2.x 版本为例讲解数据响应式原理。
其中 Object.defineProperty 只能代理属性的 set/get 方法，而 ES 6 Proxy 可以代理 defineProperty/deleteProperty 等方法，能够更全面地代理数据的增删改查，规避了原来使用 Object.defineProperty 无法捕捉的情况。这也是为什么 Vue 3 使用 ES 6 Proxy 的原因。

**对象**

Vue无法检测对象属性的添加或移除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。

```
Vue.set(vm.someObject, 'b', 2)
```

这行语句的原理是虽然修改的是 b 属性的值，但是触发 someObject 的更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。

```
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

**数组**

在 JS 中，数组可以看作是一类特殊的对象，因此，对于数组而言 Vue 2.x不能检测以下数组的变动：
当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue；
当你修改数组的长度时，例如：vm.items.length = newLength；

但是数组新增元素的情况要比对象新增属性常用得多，因此有必要解决数组无法响应新增属性的问题。为此，Vue 把数组的方法都代理了，调用数组方法相当于 *Vue.set(...)*。因此，用数组的方法也可以使数组保持响应的。例如：

```
vm.items.splice(newLength)
```

**依赖收集**

依赖收集主要依赖两个数据结构实现，分别是 `Dep` 和 `Watcher` ，`Watcher` 封装观察者的信息，而 `Dep` 封装了依赖队列。每个响应式属性都有一个 `Dep` 维护其 `Watcher` 队列，当数据变化时逐个调用 `Dep` 队列中封装的 `Watcher` 实现视图更新。
其过程大致是渲染函数初始化 `Watcher` ，把重新渲染作为 `Watcher` 的回调，触发具体渲染，如果获取了响应式数据，则在 getter 里把 `Watcher` 收集到对应的 `Dep` 中。当事件触发了响应式数据更新，则在其 setter 里通知 `Dep` 中的 `Watcher` 触发视图更新。
读者在此处可能会对如何收集 `Watcher` 有疑问，毕竟 `Watcher` 和 getter 分别在两个过程中定义的，两者如何关联起来？答案是用了全局变量 `Dep.target` 在模块内形成了一个闭包。因此，如果页面上引用了两个 Vue （最常见的情况是创建库的时候把 Vue 打包进去了），响应式属性是无法在两个 Vue 中共享的，可能会造成难以定位的问题。

**响应时机**

由于 JS 是一个单线程的执行环境，也就是说每次只能执行一件事，意味着执行 JS 和更新 DOM 只能选一样执行。每次响应式属性变更时，如果都直接触发界面更新，那么在一个函数里对响应式数据进行大量更新时，就会出现“DOM 更新 - JS 执行 - DOM 更新…”的循环，如果 JS 执行较慢，就会出现卡顿，这显然不是我们想要的。因此，Vue 在更新 DOM 时是**异步**执行的。
只要侦听到数据变化，Vue  将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher  被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM  操作是非常重要的，在下一章虚拟 DOM 的时候会详细讲述。然后，在下一个的事件循环（在 JS 的术语里称为“tick”）中，Vue 刷新队列并执行实际（已去重的）工作。
值得注意的是，Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替，本质上是希望利用事件队列中的微任务在逻辑后进行视图更新。

**三、模板编译**

**渲染函数**

一般在使用 Vue 的时候都会使用 Vue 单文件组件里的 HTML 模板或者直接使用挂载元素的 HTML 模板，HTML 模板为视图提供了一种比 JS 代码更友好的表达形式。但是 Vue 的模板并不是完全是 HTML ，因为 HTML 本身不支持定义自定义组件，缺少这种扩展的机制，Vue 设计了一个编译器，输入通过类似的 HTML 的语法，输出为一个输出到虚拟 DOM 的函数，这个过程称为渲染，这个函数就是渲染函数。

渲染函数采用了构造器的设计模式，通过传入一个构建 VNode 的构造函数，开发者可以层次化地构建出虚拟 DOM 树。例如：

```
{
    render: function (createElement) {
      return createElement('div', [
        createElement('child', {
          // 在数据对象中传递 `scopedSlots`
          // 格式为 { name: props => VNode | Array<VNode> }
          scopedSlots: {
            default: function (props) {
              return createElement('span', props.text)
            }
          }
        })
      ])
    }
}
```

以上函数对应为 HTML 模板：

```
<div>
    <child v-slot="props">
        <span>{{ props.text }}</span>
    </child>
</div>
```

可以看到渲染函数实际上比 HTML 模板复杂而且不直观，但是它是驱动 Vue 模板优化的基本原理。

**虚拟DOM**

实际上，虚拟 DOM 是 React 社区提出来的一个概念。在 Vue 早期（大约 2.0 以前），Vue 也是没有使用虚拟 DOM 的。使用虚拟 DOM 的原因主要是直接操作 DOM 会带来重大的性能影响。
主要体现在两方面：

- DOM 节点的属性多，空间开销较大，频繁操作必定会带来性能问题：
- JS 是单线程语言，每次操作 DOM 都是阻塞操作，将会阻塞 JS 的执行，操作 DOM 的时候无法同时执行 JS ，执行 JS 的时候无法更新 DOM ，频繁地切换将会导致动画不能及时响应。更为重要的是，即使 DOM 没有属性值没有更新，但是设置 DOM 的属性值也将阻塞 JS 的执行。

**Diff 算法**

在介绍 Diff 算法前，需要了解一个关于浏览器渲染的概念：

- 回流（reflow）：当 DOM 的布局变化时，例如改变元素大小、位置或者增减元素，浏览器需要清楚当前 DOM 子树并应用重新计算的结果。

- 重绘（redraw）：当 DOM 的属性修改时，例如改变字体颜色，浏览器并不需要重新计算元素的布局，而只要重新绘制新样式。

  很显然回流比重绘更加耗费性能，因此我们在设计 Diff 算法时必须尽可能复用已有元素，避免频繁增减元素造成布局回流。

*算法实现*

虚拟 DOM 应用的核心算法就是 Diff 算法，其目标就是找出两个虚拟 DOM 树之间的最小化差异，好确定要更新的元素。Vue 2.x 的虚拟 DOM 实现主要参考 SnabbDOM ，其 Diff 算法主要有两个特点：

- 同级比较：对于给定两棵树，只比较同一级节点，如果节点类型不同则直接抛弃，重新构建。
- 就近复用：当两个节点类型相同，则复用节点，只修改节点的实例属性。

可以看到该算法主要是在实现简单的基础上尽可能复用节点，避免布局回流。

对于子节点集的比较则是希望找到没有同类型的最小集，为此，Diff 算法用了两个优化策略：

- 双指针比较：对列表的两端分别进行寻找，当两端的值不一致后，按新的前后两端和旧的前后两端比较（尽可能复用已知的索引）
- 按组件 key 寻找：当所有已知索引都无法匹配时，按 key 的散列表寻找，如果还找不到，只能遍历了。
  在实际应用中，新旧 DOM 树往往是比较接近的，因此双指针比较就可以很快地找出差异，剩下的部分再根据 key 或遍历寻找即可。

**四、插件原理**

Vue提供了几种扩展的方式，即：

- 添加全局方法或者property。如vue-custom-element；
- 添加全局资源：指令/过滤器/过渡等。如vue-touch；
- 通过全局混入来添加一些组件选项。如vue-router；
- 添加Vue实例方法，通过把它们添加到Vue.prototype上实现；

**开发插件**

Vue.js 的插件应该暴露一个 `install` 方法。这个方法的第一个参数是 `Vue` 构造器，第二个参数是一个可选的选项对象：

```
MyPlugin.install = function (Vue, options) {
    // 插件逻辑
}
```

当 Vue 使用时，将会被回调：

```
Vue.use(MyPlugin, options);
```

 这个策略也可以认为是一种**依赖反转**，也就是被调用方不需要知道调用方以何种方式引入。因为 Vue 出现的年代里，Webpack 方兴未艾，全局变量引入模块的方式还大行其道，而全局变量名往往会因为冲突而改变，因此使用这种依赖注入的方式能够很好地规避此类情况。

但在现今倡导 ES 模块和 tree-shaking 优化的视角下，实际上 Vue 这么设计是不够优雅的，因为插件将会被全局共享，难以去掉不必要的依赖。在 Vue 3.x 对此已经进行了整改。

## 技术选型建议

**大小**
开发框架的大小对未来应用的性能至关重要。框架和应用程序必须在应用程序开始正常工作之前加载。
在这方面，Angular 最复杂，有143KB。React 次之，有43KB，而 Vue.js只有23KB。除非你的应用特别大，并且包含了大量的组件，否则最好使用更小的结构。

**性能**
在 Web 项目中，性能与 DOM 密切相关：DOM 在浏览器/代码中表示 Web 页面。在发生更新时，你可以通过 DOM 控制 Web页面。
Vue、React和Angular的性能会因为任务的不同而有所差异，但在大多数情况下，它们都非常高效和快速。React和Vue都实现了 DOM。得益于其精心设计的结构，Vue提供了出色的性能和内存分配。这就是 React 和 Vue.js 优于Angular的地方：它们利用了虚拟 DOM。

**社区**
React 是世界上最流行的框架，这已不是什么秘密。它越来越受欢迎，因为它提供了真正的 Promise。React 的 Mental Model 看起来很可靠，其组件让创建用户界面变得更容易，API 灵活且富有表现力，整个项目给人的感觉是就应该那样。对 API 库的描述也友好，更容易给人留下良好的印象。
从那时起，React 库在基本概念和 API 方面就基本保持不变，但已经形成并发展出了一整套的知识和最佳实践，越来越多的人在使用它。Angular 因其优点而备受赞誉，并拥有大量的社区支持。遗憾的是，尽管 Vue.js 有很多好处，但它并没有像它的竞争对手那样被开发者所接受。
下面让我们从流行度和相关性两个方面比较下这三个框架：

- GitHub：目前，Vue.js 是最流行的框架，尽管它是最年轻的，这意味着越来越多的项目将使用它。
- 谷歌搜索：在谷歌搜索中，React 查询请求最多，紧随其后的是 Vue.js。目前最不受欢迎的是 Angular.js。Angular.js 的人气在下降，而 Vue.js 的人气却在上升。

**Vue、React 和 Angular：该选哪个？**

 为了选出最合适的库，你应该首先仔细分析这些框架并理解自己的需求。无论是有许多依赖项的现有项目，还是你想使用熟悉的库进行开发的新应用程序，Vue 都不会给你带来任何麻烦。你可以继续使用 Bootstrap 或 Bulma 这样的 CSS 框架，保留为јQuery 或 Backbone 编写的组件，集成你最喜欢的库执行 HTTP 请求，或使用 Promise 对象。

 要开始使用 Vue 进行编程，你所要做的就是将 Vue.js 库连接到 Web 页面。不需要复杂的组装工具！从头到尾开发一个原型只需要 1 到 2 周的时间，这让你能够尽早并经常地收集用户反馈。Vue 2 引入了服务器端渲染（SSR）支持。这让你可以最小化初期的数据加载，并根据需要请求新的视图和资源。与高效的组件缓存相结合，可以进一步减少流量消耗。
 React 库能够做一些令人惊叹的事情。因为整个用户界面都是用 JavaScript 定义的，所以你可以使用 JavaScript 的丰富功能在模板中执行各种操作。你只会受到 JavaScript 特性的限制，而不会受到模板框架特性的限制。当你想到完全用 JavaScript 定义的视觉效果时，你可能会想到很多引号、转义字符和 createElement 调用。别担心，React 库允许你（选择性地）使用可以与 JavaScript 代码共存的 HTML-like JSX 语法定义可视元素。
 React 与其他两个框架在以下理念上有所不同：
 与其说它是一个框架，不如说它是一个库（最初是为了处理 UI 而创建的），因为它不受框架的限制，所以它的功能更多——更适合专业人士，而不是初学者；在 Angular 中许多可以“开箱即用”的主要特性，在这里必须单独连接（这种方法有优点，也有缺点，对于初学者来说是缺点，因为需要做不必要的动作）；更多地面向 JavaScript 而不是 TypeScript（尽管每个版本对 TS 的支持都在增加）；更便于创建原生 Android 和 iOS 移动应用程序，拥有大量适用于各种场合的第三方库（多于 Angular）。
 Angular 已经被用在了许多规模最大、最复杂的 Web 应用程序中。

