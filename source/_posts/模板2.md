## 经典面试题

### 每种能力的最高报酬

题目：每种工作有难度和报酬，规定如下：class Job{public int hard;public int money;}。给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作，选工作的标准是难度不超过自身能力值，选择报酬最高的岗位。求返回int数组，表示每个人按照标准选择的最高报酬。

思路：

- 先将job数组按照难度值升序且报酬值降序排列，难度值相同的情况下，只保留最大报酬值的那个
- 在剩余数组中，逐一比较，如果难度值上升，报酬值也上升，这样的数据保留。否则，删除。

```
import java.util.*;
public class Problem07_ChooseWork {
    public static void main(String[] args) {
        List<Job> job = new ArrayList<Job>();
        Job job1 = new Job(1,1);
        Job job2 = new Job(2,5);
        Job job3 = new Job(4,4);
        Job job4 = new Job(5,7);
        Job job5 = new Job(8,8);
        job.add(job1);
        job.add(job2);
        job.add(job3);
        job.add(job4);
        job.add(job5);
        int[] ans = getMoneys((job.toArray(new Job[job.size()])),new int[]{1,2,3});
        System.out.println("结束");
    }
    public static class Job {
        public int money;
        public int hard;

        public Job(int m, int h) {
            money = m;
            hard = h;
        }
    }
    public static class JobComparator implements Comparator<Job> {
        @Override
        public int compare(Job o1, Job o2) {
            return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);
        }
    }

    public static int[] getMoneys(Job[] job, int[] ability) {
        Arrays.sort(job, new JobComparator());
        // key : 难度   value：报酬
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(job[0].hard, job[0].money);
        // pre : 上一份进入map的工作
        Job pre = job[0];
        for (int i = 1; i < job.length; i++) {
            if (job[i].hard != pre.hard && job[i].money > pre.money) {
                // hard值相同的只取一个，报酬也要递增，很巧妙
                pre = job[i];
                map.put(pre.hard, pre.money);
            }
        }
        // map中就是各个难度岗位的最高报酬值，接下来就是匹配目标值向下取整即不超过目标能力值的报酬。
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            // ability[i] 当前人的能力 <= ability[i]  且离它最近的
            Integer key = map.floorKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }
}
```

### 简单背包问题

题目：背包容量为w,一共有n袋零食，第i袋零食体积为v[i]>0.总体积不超过背包容量的情况下，一共有多少种零食放法(总体积为0也算是一种放法)

思路：

- 解法1：暴力递归的尝试过程
- 解法2：暴力递归改写的dp
- 解法3：另一种解法的dp

```
public class Code02_SnacksWays {
   public static int ways1(int[] arr, int w) {
      // 解法1：暴力递归的尝试过程
      return process(arr, 0, w);
   }
   // 从左往右的经典模型
   // 还剩的容量是rest，arr[index...]自由选择，
   // 返回选择方案
   // index ： 0～N，当前来到的零食索引值，表示纵坐标
   // rest : 0~w，当前还剩余的可用容积，表示横坐标
   public static int process(int[] arr, int index, int rest) {
      if (rest < 0) { // 没有容量了
         // -1 无方案的意思
         return 0;
      }
      // rest>=0,
      if (index == arr.length) { // 无零食可选
         return 1;
      }
      // rest >=0
      // 有零食index
      // index号零食，要 or 不要
      // index, rest
      // (index+1, rest)
      // (index+1, rest-arr[i])
      int next1 = process(arr, index + 1, rest); // 不要
      int next2 = process(arr, index + 1, rest - arr[index]); // 要
      return next1 + next2;
   }

   public static int ways2(int[] arr, int w) {
      // 解法2：暴力递归改简单动态规划，从下到上，从左到右改写。利用未使用容量求解
      // dp[i][j]中i：0～N中，第i个位置，剩余容量j的方法数
      int N = arr.length;
      int[][] dp = new int[N + 1][w + 1];
      // 从N袋零食后，无零食可选了，就是一种方法了
      for (int j = 0; j <= w; j++) {
         dp[N][j] = 1;
      }
      for (int i = N - 1; i >= 0; i--) {
         for (int j = 0; j <= w; j++) {
            dp[i][j] = dp[i + 1][j] + ((j - arr[i] >= 0) ? dp[i + 1][j - arr[i]] : 0);
         }
      }
      // 返回index号零食开始，容量还剩w的方法数
      return dp[0][w];
   }

   public static int ways3(int[] arr, int w) {
      // 解法3：暴力递归改简单动态规划，利用已使用容量求解，不太好理解就使用解法2.
      // dp[i][j]中i：0～N中，第i个位置，已使用的容量j的方法数
      int N = arr.length;
      int[][] dp = new int[N][w + 1];
      for (int i = 0; i < N; i++) {
         dp[i][0] = 1;
      }
      if (arr[0] <= w) {
         dp[0][arr[0]] = 1;
      }
      for (int i = 1; i < N; i++) {
         for (int j = 1; j <= w; j++) {
            dp[i][j] = dp[i - 1][j] + ((j - arr[i]) >= 0 ? dp[i - 1][j - arr[i]] : 0);
         }
      }
      int ans = 0;
      for (int j = 0; j <= w; j++) {
         ans += dp[N - 1][j];
      }
      return ans;
   }

   public static void main(String[] args) {
      int[] arr = { 4, 3, 2, 9 };
      int w = 8;
      System.out.println(ways1(arr, w));
      System.out.println(ways2(arr, w));
      System.out.println(ways3(arr, w));
   }
}
```

### 最长公共子串

题目：注意区分子串和子序列的不同。给定两个字符串str1和str2，求两个字符串的最长公共子串。

思路：动态规划的空间压缩技巧

- 解法1：直接填写dp表，并统计最大值，返回max和i.
- 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量

```
// 最长公共子串问题是面试常见题目之一
public class Code03_LongestCommonSubstringConquerByHeight {
    public static String lcs1(String str1, String str2) {
        // 解法1：直接填写dp表，并统计最大值，返回max和i.
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int[][] dp = getdp(chs1, chs2);
        int end = 0;
        int max = 0;
        // 遍历找到最大值
        for (int i = 0; i < chs1.length; i++) {
            for (int j = 0; j < chs2.length; j++) {
                if (dp[i][j] > max) {
                    end = i;
                    max = dp[i][j];
                }
            }
        }
        return str1.substring(end - max + 1, end + 1);
    }

    public static int[][] getdp(char[] str1, char[] str2) {
        // 填写dp表，dp[i][j]表示以str1的第i个字符结尾，以str2的第j个字符结尾的公共子串的长度
        int[][] dp = new int[str1.length][str2.length];
        // 对于第一列，只有ij对应的字符相等，长度才为1
        for (int i = 0; i < str1.length; i++) {
            if (str1[i] == str2[0]) {
                dp[i][0] = 1;
            }
        }
        // 对于第一行，只有ij对应的字符相等，长度才为1
        for (int j = 1; j < str2.length; j++) {
            if (str1[0] == str2[j]) {
                dp[0][j] = 1;
            }
        }
        // 其他的行列，就需要根据前面的值推导
        for (int i = 1; i < str1.length; i++) {
            for (int j = 1; j < str2.length; j++) {
                if (str1[i] == str2[j]) {
                    // 如果当前字符相同，则当前长度在前面的基础上+1.不相同，则默认为0
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
            }
        }
        return dp;
    }

    public static String lcs2(String s1, String s2) {
        // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量
        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
            return "";
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // 用行列两个变量简单记录，替代dp的二维表结构
        // 定义行索引
        int row = 0;
        // 定义列索引
        int col = str2.length - 1;
        int max = 0;
        int end = 0;
        // 遍历行索引(遍历行，遍历列)
        /*
         * --------<---
         * |
         * |
         * V
         * |
         * */
        while (row < str1.length) {
            // 局部变量i,j
            int i = row;
            int j = col;
            int len = 0;
            // 相当于斜着扫一遍
            while (i < str1.length && j < str2.length) {
                if (str1[i] != str2[j]) {
                    // 字符不相同，当前字符串的公共长度为0
                    len = 0;
                } else {
                    // 字符相同，则在前者的基础上累加。除非遇到不同，才置0.
                    len++;
                }
                if (len > max) {
                    // 每次都找到全局最大值
                    max = len;
                    end = i;
                }
                // 斜着扫一遍
                i++;
                j++;
            }
            if (col > 0) {
                // 遍历列
                col--;
            } else {
                // 遍历行
                row++;
            }
        }
        return s1.substring(end - max + 1, end + 1);
    }

    //  随机生成字符串
    public static String randomNumberString(int len, int range) {
        char[] str = new char[len];
        for (int i = 0; i < len; i++) {
            str[i] = (char) ((int) (Math.random() * range) + 'a');
        }
        return String.valueOf(str);
    }

    public static void main(String[] args) {
        long start;
        long end;
        String str1 = "zxcvbn";
        String str2 = "2e8ucvboi9u";
        start = System.currentTimeMillis();
        end = System.currentTimeMillis();
        // 解法1：直接填写dp表，并统计最大值，返回max和i.
        System.out.println("方法1结果 : " + lcs1(str1, str2) + " , 运行时间 : " + (end - start) + " ms");
        // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量
        System.out.println("方法2结果 : " + lcs2(str1, str2) + " , 运行时间 : " + (end - start) + " ms");
    }
}

```

### 最长公共子序列

题目：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。

- 解法1：暴力递归的尝试模型，leetcode超时
- 解法2：暴力递归改写dp。leetcode通过

```
// 这个问题leetcode上可以直接测
// 链接：https://leetcode.com/problems/longest-common-subsequence/
public class Code04_LongestCommonSubsequence {
    public static int longestCommonSubsequence1(String s1, String s2) {
        // 解法1：暴力递归的尝试模型，leetcode超时
        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
            return 0;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // 尝试
        return process1(str1, str2, str1.length - 1, str2.length - 1);
    }

    // str1[0...i]和str2[0...j]，这个范围上最长公共子序列长度是多少？
    // 可能性分类:
    // a) 最长公共子序列，不以str1[i]字符结尾、不以str2[j]字符结尾
    // b) 最长公共子序列，以str1[i]字符结尾、不以str2[j]字符结尾
    // c) 最长公共子序列，不以str1[i]字符结尾、以str2[j]字符结尾
    // d) 最长公共子序列，以str1[i]字符结尾、以str2[j]字符结尾
    // 注意：a)、b)、c)、d)并不是完全互斥的，他们可能会有重叠的情况
    // 但是可以肯定，答案不会超过这四种可能性的范围
    // 那么我们分别来看一下，这几种可能性怎么调用后续的递归。
    // a) 最长公共子序列，一定不以str1[i]字符结尾、也一定不以str2[j]字符结尾
    //    如果是这种情况，那么有没有str1[i]和str2[j]就根本不重要了，因为这两个字符一定没用啊
    //    所以砍掉这两个字符，最长公共子序列 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归)
    // b) 最长公共子序列，可能以str1[i]字符结尾、但是一定不以str2[j]字符结尾
    //    如果是这种情况，那么我们可以确定str2[j]一定没有用，要砍掉；但是str1[i]可能有用，所以要保留
    //    所以，最长公共子序列 = str1[0...i]与str2[0...j-1]的最长公共子序列长度(后续递归)
    // c) 最长公共子序列，一定不以str1[i]字符结尾、但是可能以str2[j]字符结尾
    //    跟上面分析过程类似，最长公共子序列 = str1[0...i-1]与str2[0...j]的最长公共子序列长度(后续递归)
    // d) 最长公共子序列，必须以str1[i]字符结尾、也必须以str2[j]字符结尾
    //    同时可以看到，可能性d)存在的条件，一定是在str1[i] == str2[j]的情况下，才成立的
    //    所以，最长公共子序列总长度 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归) + 1(共同的结尾)
    // 综上，四种情况已经穷尽了所有可能性。四种情况中取最大即可
    public static int process1(char[] str1, char[] str2, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            // str1[0..0]和str2[0..0]，都只剩一个字符了
            // 那如果字符相等，公共子序列长度就是1，不相等就是0
            return str1[i] == str2[j] ? 1 : 0;
        } else if (i == 0) {
            // 这里的情况为：
            // str1[0...0]和str2[0...j]，str1只剩1个字符了，但是str2不只一个字符
            // 因为str1只剩一个字符了，所以str1[0...0]和str2[0...j]公共子序列最多长度为1
            // 如果str1[0] == str2[j]，那么此时相等已经找到了！公共子序列长度就是1，也不可能更大了
            // 如果str1[0] != str2[j]，只是此时不相等而已，那么str2[0...j-1]上有没有字符等于str1[0]呢？不知道，所以递归继续找
            if (str1[i] == str2[j]) {
                return 1;
            } else {
                return process1(str1, str2, i, j - 1);
            }
        } else if (j == 0) {
            // 和上面的else if同理
            if (str1[i] == str2[j]) {
                return 1;
            } else {
                return process1(str1, str2, i - 1, j);
            }
        } else { // i != 0 && j != 0
            // 这里的情况为：
            // str1[0...i]和str2[0...i]，str1和str2都不只一个字符
            // 对应可能性a
            int p1 = process1(str1, str2, i - 1, j - 1);
            // 对应可能性c
            int p2 = process1(str1, str2, i - 1, j);
            // 对应可能性b
            int p3 = process1(str1, str2, i, j - 1);
            // 对应可能性d
            // 如果str1[i] == str2[j]，那么p3就求出来，参与pk
            // 如果str1[i] != str2[j]，那么让p3等于0，然后去参与pk，反正不影响
            int p4 = 0;
            if (str1[i] == str2[j]) {
                p4 = 1 + p1;
            }
            // 取p1,p2,p3,p4中的最大值
            return Math.max(Math.max(p1, p2), Math.max(p3, p4));
        }
    }

    public static int longestCommonSubsequence2(String s1, String s2) {
        // 解法2：暴力递归改写dp。leetcode通过
        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
            return 0;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        int N = str1.length;
        int M = str2.length;
        // dp[i][j]表示以str1以i结尾，str2以j结尾的最长公共子序列长度
        int[][] dp = new int[N][M];
        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
        for (int j = 1; j < M; j++) {
            dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
        }
        for (int i = 1; i < N; i++) {
            dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
        }
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < M; j++) {
                int p1 = dp[i - 1][j];
                int p2 = dp[i][j - 1];
                int p3 = dp[i-1][j - 1];
                int p4 = str1[i] == str2[j] ? (1 + p3) : 0;
                // 取p1,p2,p3,p4中的最大值填写到dp表
                dp[i][j] = Math.max(Math.max(p1, p2), Math.max(p3, p4));
            }
        }
        return dp[N - 1][M - 1];
    }

}
```

### 词频最大前K个字符串

题目：给定一个由字符串组成的数组String[] strs,给定一个正数K.返回词频最大的前K个字符串，假设结果是唯一的。

**思路**：先搞一个HashMap，遍历整个数组。

- 解法1：搞一个大根堆，然后遍历HashMap建立，最后从堆顶拿K个。
- 解法2：搞一个Size大小规定为K的小根堆，每次从HashMap里拿的时候直接跟栈顶比较，如果小于栈顶直接不考虑（即，进入小根堆的门槛），大于栈顶则丢掉栈顶，加入这个元素.最后的小根堆就是最大的前K个字符串。这个比较经典。

```
import java.util.*;
public class Code06_TopKTimes {
    public static void main(String[] args) {
        String[] s = {"abc","ab","ab","bc","ac","abc","ef","kisd","ef","ef"};
        printTopKAndRank(s,2);
    }
    public static class Node {
        public String str;
        public int times;

        public Node(String s, int t) {
            this.str = s;
            this.times = t;
        }
    }

    // 按照词频规则排序
    public static class  NodeComparator implements Comparator<Node> {
        @Override
        public int compare(Node o1, Node o2) {
            return o1.times - o2.times;
        }
    }

    // 解法2：创建小根堆，遍历剔除顶部值，最终留下的小根堆就是topk的字符串
    public static void printTopKAndRank(String[] arr, int topK) {
        if (arr == null || arr.length == 0 || topK < 1 || topK > arr.length) {
            return;
        }
        // 构建字符串和词频的键值对
        HashMap<String, Integer> map = new HashMap<>();
        for (String str : arr) {
            if (!map.containsKey(str)) {
                map.put(str, 1);
            } else {
                map.put(str, map.get(str) + 1);
            }
        }
        topK = Math.min(arr.length,topK);
        // 按照词频建立小根堆
        PriorityQueue heap = new PriorityQueue<>(new NodeComparator());
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            // 新建节点
            Node cur = new Node(entry.getKey(), entry.getValue());
            if (heap.size() < topK) {
                // 如果小根堆不足k个，直接添加
                heap.add(cur);
            } else {
                Node node = (Node)heap.peek();
                if (node.times < cur.times) {
                    // 如果当前值大于小根堆的顶部值，把当期值替换顶部值，小根堆内部heapfy
                    heap.poll();
                    heap.add(cur);
                }
            }
        }
        while(!heap.isEmpty()) {
            // 依次弹出所有的小根堆数据，刚好就是前K个最大词频字符串
            Node node = (Node)heap.poll();
            System.out.println(node.str);
        }
    }
}
```

### 词频最大的K个元素

题目：在实时数据流中找到最常使用的k个单词.实现*TopK*类中的三个方法:
`TopK(k)`, 构造方法
`add(word)`, 增加一个新单词
`topk()`, 得到当前最常使用的k个单词.

- 解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。

```
import java.util.*;
// 本题测试链接：https://www.lintcode.com/problem/top-k-frequent-words-ii/
// 以上的代码不要粘贴, 把以下的代码粘贴进java环境编辑器
// 把类名和构造方法名改成TopK, 可以直接通过
public class Code02_TopK {
    private Node[] heap;
    private int heapSize;
    // 词频表   key  abc   value  (abc,7)
    private HashMap<String, Node> strNodeMap;
    // 自己实现的动态小根堆-索引表
    private HashMap<Node, Integer> nodeIndexMap;
    private NodeHeapComp comp;
    // 自己实现的动态小根堆
    private TreeSet<Node> treeSet;

    public Code02_TopK(int K) {
        heap = new Node[K];
        heapSize = 0;
        strNodeMap = new HashMap<String, Node>();
        nodeIndexMap = new HashMap<Node, Integer>();
        comp = new NodeHeapComp();
        treeSet = new TreeSet<>(new NodeTreeSetComp());
    }

    public static class Node {
        public String str;
        public int times;
        public Node(String s, int t) {
            str = s;
            times = t;
        }
    }

    public static class NodeHeapComp implements Comparator<Node> {
        @Override
        public int compare(Node o1, Node o2) {
            return o1.times != o2.times ? (o1.times - o2.times) : (o2.str.compareTo(o1.str));
        }
    }

    public static class NodeTreeSetComp implements Comparator<Node> {
        @Override
        public int compare(Node o1, Node o2) {
            return o1.times != o2.times ? (o2.times - o1.times) : (o1.str.compareTo(o2.str));
        }
    }

    // 解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。
    public void add(String str) {
        if (heap.length == 0) {
            return;
        }
        // str   找到对应节点  curNode
        Node curNode = null;
        // 对应节点  curNode  在堆上的位置
        int preIndex = -1;
        if (!strNodeMap.containsKey(str)) {
            curNode = new Node(str, 1);
            strNodeMap.put(str, curNode);
            nodeIndexMap.put(curNode, -1);
        } else {
            curNode = strNodeMap.get(str);
            // 要在time++之前，先在treeSet中删掉
            // 原因是因为一但times++，curNode在treeSet中的排序就失效了
            // 这种失效会导致整棵treeSet出现问题
            if (treeSet.contains(curNode)) {
                treeSet.remove(curNode);
            }
            curNode.times++;
            preIndex = nodeIndexMap.get(curNode);
        }
        if (preIndex == -1) {
            if (heapSize == heap.length) {
                if (comp.compare(heap[0], curNode) < 0) {
                    treeSet.remove(heap[0]);
                    treeSet.add(curNode);
                    nodeIndexMap.put(heap[0], -1);
                    nodeIndexMap.put(curNode, 0);
                    heap[0] = curNode;
                    heapify(0, heapSize);
                }
            } else {
                treeSet.add(curNode);
                nodeIndexMap.put(curNode, heapSize);
                heap[heapSize] = curNode;
                heapInsert(heapSize++);
            }
        } else {
            treeSet.add(curNode);
            heapify(preIndex, heapSize);
        }
    }

    // 返回topK个最大的节点即最终的小根堆
    public List<String> topk() {
        ArrayList<String> ans = new ArrayList<>();
        for (Node node : treeSet) {
            ans.add(node.str);
        }
        return ans;
    }

    private void heapInsert(int index) {
        while (index != 0) {
            int parent = (index - 1) / 2;
            if (comp.compare(heap[index], heap[parent]) < 0) {
                swap(parent, index);
                index = parent;
            } else {
                break;
            }
        }
    }

    private void heapify(int index, int heapSize) {
        int l = index * 2 + 1;
        int r = index * 2 + 2;
        int smallest = index;
        while (l < heapSize) {
            if (comp.compare(heap[l], heap[index]) < 0) {
                smallest = l;
            }
            if (r < heapSize && comp.compare(heap[r], heap[smallest]) < 0) {
                smallest = r;
            }
            if (smallest != index) {
                swap(smallest, index);
            } else {
                break;
            }
            index = smallest;
            l = index * 2 + 1;
            r = index * 2 + 2;
        }
    }

    private void swap(int index1, int index2) {
        nodeIndexMap.put(heap[index1], index2);
        nodeIndexMap.put(heap[index2], index1);
        Node tmp = heap[index1];
        heap[index1] = heap[index2];
        heap[index2] = tmp;
    }
}
```

### 已知树的先序和中序，求后序

题目：已知一棵二叉树中没有重复节点，给定它的先序和中序遍历数组，求后序遍历数组。比如int[] pre={1,2,4,5,3,6,7},int[] in={4,2,5,1,6,3,7}返回{4,5,2,6,7,3,1}

- 解法1：暴力递归，每次查询树范围索引mid,不断左树右树递归，恢复pos数组
- 解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
public class Code01_PreAndInArrayToPosArray {
 public static class Node {
  public int value;
  public Node left;
  public Node right;

  public Node(int v) {
   value = v;
  }
 }

 public static int[] preInToPos1(int[] pre, int[] in) {
  // 解法1：暴力递归，每次查询树范围索引
  if (pre == null || in == null || pre.length != in.length) {
   return null;
  }
  int N = pre.length;
  int[] pos = new int[N];
  // 传入2个数组和索引值，将后序数组pos排好即可
  process1(pre, 0, N - 1, in, 0, N - 1, pos, 0, N - 1);
  return pos;
 }

 // 传入2个数组和索引值，将后序数组pos排好即可
 // L1...R1 L2...R2 L3...R3
 public static void process1(int[] pre, int L1, int R1, int[] in, int L2, int R2, int[] pos, int L3, int R3) {
  // 边界，索引值不对，直接返回
  if (L1 > R1) {
   return;
  }
  // 如果只有一个元素了，先序的第一个节点即根节点就是后续的最后一个节点
  if (L1 == R1) {
   pos[L3] = pre[L1];
   return;
  }
  // 首先，先序的第一个节点即根节点就是后续的最后一个节点。取出了根节点，然后就要取出左右节点范围
  pos[R3] = pre[L1];
  int mid = L2;
  for (; mid <= R2; mid++) {
   // 在中序数组中，找到对应头结点的索引。mid索引值大小就是区分左右节点的范围
   if (in[mid] == pre[L1]) {
    break;
   }
  }
  int leftSize = mid - L2;
  // [L1 + 1, L1 + leftSize]对应先序的左树，[L2, mid - 1]对应中序的左树，[L3, L3 + leftSize - 1]对应后序的左树。剩余的左树范围的pos后序数组继续填充
  process1(pre, L1 + 1, L1 + leftSize, in, L2, mid - 1, pos, L3, L3 + leftSize - 1);
  // ...右树，右树，右树。剩余的右树范围的pos后序数组继续填充
  process1(pre, L1 + leftSize + 1, R1, in, mid + 1, R2, pos, L3 + leftSize, R3 - 1);
 }

 public static int[] preInToPos2(int[] pre, int[] in) {
  // 解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出
  if (pre == null || in == null || pre.length != in.length) {
   return null;
  }
  int N = pre.length;
  // 缓存map
  HashMap<Integer, Integer> inMap = new HashMap<>();
  for (int i = 0; i < N; i++) {
   inMap.put(in[i], i);
  }
  int[] pos = new int[N];
  process2(pre, 0, N - 1, in, 0, N - 1, pos, 0, N - 1, inMap);
  return pos;
 }

 public static void process2(int[] pre, int L1, int R1, int[] in, int L2, int R2, int[] pos, int L3, int R3,
   HashMap<Integer, Integer> inMap) {
  if (L1 > R1) {
   return;
  }
  if (L1 == R1) {
   pos[L3] = pre[L1];
   return;
  }
  pos[R3] = pre[L1];
  // 直接取出索引值
  int mid = inMap.get(pre[L1]);
  int leftSize = mid - L2;
  process2(pre, L1 + 1, L1 + leftSize, in, L2, mid - 1, pos, L3, L3 + leftSize - 1, inMap);
  process2(pre, L1 + leftSize + 1, R1, in, mid + 1, R2, pos, L3 + leftSize, R3 - 1, inMap);
 }
 public static  void print(int[] arr){
  for(int i=0;i<arr.length;i++){
   System.out.print(arr[i]+" ");
  }
  System.out.println();
 }
 public static void main(String[] args) {
  int[] pre={1,2,4,5,3,6,7};
  int[] in={4,2,5,1,6,3,7};
  int[] ans1 = preInToPos1(pre, in);
  int[] ans2 = preInToPos2(pre, in);
  print(ans1);
  print(ans2);
 }
}
```

### 最长递增子序列

题目：给出数组{4,10,4,3,8,9}，求最长的递增子序列的长度。

思路：子序列可以不连续，但要按照原数组顺序。还要递增。所以{3,8,9}或{4,8,9}等等 长度为3.

- 解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做
- 解法2：ends数组辅助加速获取最大递增子序列的长度。

```java
// 本题测试链接 : https://leetcode.com/problems/longest-increasing-subsequence
public class Code03_LIS {
   public static void main(String[] args) {
      int[] arr={4,10,4,3,8,9};
      System.out.println(lengthOfLIS0(arr));
      System.out.println(lengthOfLIS1(arr));
   }
   public static int lengthOfLIS0(int[] arr) {
      // 解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做
      int [] dp = new int[arr.length];
      // 取dp数组最大值返回
      int dpMax = 0;
      for(int i=0;i<arr.length;i++){
         int max = 1;
         for(int j=0;j<i;j++){
            // 逐一比较,找到前面的所有序列的最大长度值
            // 固定i,j从0到i-1扫一遍，如果arr[i]>arr[j]，长度是dp[j]+1.否则长度就是1.记录全局最大值即可
            max=Math.max(max,arr[i]>arr[j]?dp[j]+1:1);
         }
         dp[i]=max;
         dpMax = Math.max(dpMax,max);
      }
      return dpMax;
   }
   public static int lengthOfLIS1(int[] arr) {
      // 解法2：ends数组辅助加速获取最大递增子序列的长度。
      if (arr == null || arr.length == 0) {
         return 0;
      }
      // ends数组,非常难以理解，它是一个递增数组。更新ends规则：要么更新，要么扩容添加。它用来加速获取最大递增子序列值，避免了双重循环。
      // ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾元素
      int[] ends = new int[arr.length];
      // 根据含义, 一开始ends[0] = arr[0]
      ends[0] = arr[0];
      // ends有效区范围是0...right，right往右为无效区
      // 所以一开始right = 0, 表示有效区只有0...0范围
      int right = 0;
      // 寻找 >= 当前数(arr[i])的最左位置，赋值给l
      int max = 1;
      for (int i = 1; i < arr.length; i++) {
         int l = 0;
         int r = right;
         // 在ends[l...r]范围上二分
         // 如果 当前数(arr[i]) > ends[m]，砍掉左侧
         // 如果 当前数(arr[i]) <= ends[m]，砍掉右侧
         // 整个二分就是在ends里寻找 >= 当前数(arr[i])的最左位置,即l
         // 如果存在l,则更新值。如果不存在l,则扩容添加
         // 比如存在l : ends = { 3, 5, 9, 12, 再往右无效}
         // 如果当前数为8, 从while里面出来时，l将来到2位置，ends更新为{ 3, 5, 8, 12, 再往右无效}
         // 比如不存在l : ends = { 3, 5, 9, 12, 再往右无效}
         // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，扩容到4位置，ends扩容添加为{ 3, 5, 9, 12, 13,再往右无效}
         while (l <= r) {
            int m = (l + r) / 2;
            if (arr[i] > ends[m]) {
               l = m + 1;
            } else {
               r = m - 1;
            }
         }
         // 从while里面出来，看l的位置
         // 如果l比right大，说明扩充了有效区，那么right变量要随之变大--->扩容
         // 如果l不比right大，说明l没有来到有效区的越界位置，right不变--->更新
         right = Math.max(right, l);
         // l的位置，就是当前数应该填到ends数组里的位置，更新或扩容添加，都要赋值
         ends[l] = arr[i];
         // 更新全局变量，一定是end中最大值的索引+1
         max = Math.max(max, l + 1);
      }
      return max;
   }
}
```

### **俄罗斯套娃信封**

题目：给一定数量的信封，带有整数对 `(w, h)` 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。
求最大的信封嵌套层数。

```java
输入：[[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：
最大的信封嵌套层数是 3 ([2,3] => [5,4] => [6,7])。

```

- 解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值

```
import java.util.Arrays;
import java.util.Comparator;
// 本题测试链接 : https://leetcode.com/problems/russian-doll-envelopes/
public class Code04_EnvelopesProblem {
 public static int maxEnvelopes(int[][] matrix) {
  // 解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值
  Envelope[] arr = sort(matrix);
  int[] ends = new int[matrix.length];
  ends[0] = arr[0].h;
  int right = 0;
  int l = 0;
  int r = 0;
  int m = 0;
  // 二分法，查找l
  for (int i = 1; i < arr.length; i++) {
   l = 0;
   r = right;
   while (l <= r) {
    m = (l + r) / 2;
    if (arr[i].h > ends[m]) {
     l = m + 1;
    } else {
     r = m - 1;
    }
   }
   right = Math.max(right, l);
   ends[l] = arr[i].h;
  }
  return right + 1;
 }

 public static class Envelope {
  public int l;
  public int h;

  public Envelope(int weight, int hight) {
   l = weight;
   h = hight;
  }
 }

 public static class EnvelopeComparator implements Comparator<Envelope> {
  @Override
  // l升序，h降序
  public int compare(Envelope o1, Envelope o2) {
   return o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h;
  }
 }

 public static Envelope[] sort(int[][] matrix) {
  Envelope[] res = new Envelope[matrix.length];
  for (int i = 0; i < matrix.length; i++) {
   res[i] = new Envelope(matrix[i][0], matrix[i][1]);
  }
  Arrays.sort(res, new EnvelopeComparator());
  return res;
 }
}

```

### 最大累加和

题目：给定一个数组arr,返回子数组的最大累加和

```java
// 本题测试链接 : https://leetcode.com/problems/maximum-subarray/
public class Code02_SubArrayMaxSum {
   public static int maxSubArray(int[] arr) {
    // 解法1：利用两个变量记录cur和max.
      if (arr == null || arr.length == 0) {
         return 0;
      }
      int max = Integer.MIN_VALUE;
      int cur = 0;
      for (int i = 0; i < arr.length; i++) {
      // 记录实时累加值
         cur += arr[i];
      // 比较获取全局最大值
         max = Math.max(max, cur);
      // 如果实时累加值为负数的，则前面的直接丢弃，从0重新开始累加计算
         cur = cur < 0 ? 0 : cur;
      }
      return max;
   }
}
```

### 二叉树转为双向链表

题目：将BST二叉搜索树转换为已排序的循环双向链表。可以将左右指针视为双向链表中上一个和下一个指针的同义词。

- 解法1：使用二叉树递归套路，利用中序遍历

```
// 本题测试链接 : https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/
public class Code04_BSTtoDoubleLinkedList {
   // 提交时不要提交这个类
   public static class Node {
      public int value;
      public Node left;
      public Node right;
      public Node(int data) {
         this.value = data;
      }
   }
   // 提交下面的代码
   public static Node treeToDoublyList(Node head) {
      // 解法1：使用二叉树递归套路，利用中序遍历
      if (head == null) {
         return null;
      }
      Info allInfo = process(head);
      // 因为是双向链表，最后还要首尾连接起来
      allInfo.end.right = allInfo.start;
      allInfo.start.left = allInfo.end;
      return allInfo.start;
   }

   // 组装头尾节点数据结构，头节点和尾节点
   public static class Info {
      public Node start;
      public Node end;
      public Info(Node start, Node end) {
         this.start = start;
         this.end = end;
      }
   }

   // 给定一个根节点为x的树，转化为链表后，返回头尾节点数据结构
   public static Info process(Node X) {
      if (X == null) {
         return new Info(null, null);
      }
      // 得到左子树的头尾节点
      Info lInfo = process(X.left);
      // 得到右子树的头尾节点
      Info rInfo = process(X.right);
      // 将x与左子树串起来
      X.left = lInfo.end;
      // 将x与右子树串起来
      X.right = rInfo.start;
      // 将左子树与x串起来
      if (lInfo.end != null) {
         lInfo.end.right = X;
      }
      // 将右子树与x串起来
      if (rInfo.start != null) {
         rInfo.start.left = X;
      }
      // 整体链表的头，继续往左子树找    lInfo.start != null ? lInfo.start : X
      // 整体链表的尾，继续往右子树找    rInfo.end != null ? rInfo.end : X
      return new Info(lInfo.start != null ? lInfo.start : X, rInfo.end != null ? rInfo.end : X);
   }
}
```

### **str1编辑成str2的最小代价**

题目：给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。

【举例】

str1="abc"，str2="adc"，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2

str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'，然后插入'd'是代价最小的，所以返回8

str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0

```java
public class Code03_EditCost {
   public static int minCost1(String s1, String s2, int ic, int dc, int rc) {
      // 解法1：直接写dp，dp[i][j]表示s1的前i个字符串变成s2的前j个字符串的最小代价
      if (s1 == null || s2 == null) {
         return 0;
      }
      char[] str1 = s1.toCharArray();
      char[] str2 = s2.toCharArray();
      int N = str1.length + 1;
      int M = str2.length + 1;
      int[][] dp = new int[N][M];
      // dp[0][0] = 0，不用任何操作
      // dp边界，从有字符串变成空，需要依次删除的代价
      for (int i = 1; i < N; i++) {
         dp[i][0] = dc * i;
      }
      // dp边界，从空变成有字符串，需要依次添加的代价
      for (int j = 1; j < M; j++) {
         dp[0][j] = ic * j;
      }
      /*s1变成s2,正常的四种情况
      * s1 0---i-1,i
      * s2 0---j-1,j
      * 1.如果s1的前i-1和s2的前j-1是相等的
      * a.s1[i]==s2[j],代价就是dp[i-1][j-1]
      * b.s1[i]!=s2[j],代价就是dp[i-1][j-1]+rc(一个替换的代价)
      * 2.如果s1的前i-1和s2的前j-1是不等的
      * c.s1[0---i]替换s2[0---j-1],代价是dp[i][j-1]+ic(一个新增的代价，因为从i变成了j-1,理论上字符变少了一个，所以最后要追加一个)
      * d.s1[0---i-1]替换s2[0---j],代价是dp[i-1][j]+dc(一个删除的代价，因为从i-1变成了j,理论上字符变多了一个，所以最后要删除一个)
      * */
      for (int i = 1; i < N; i++) {
         for (int j = 1; j < M; j++) {
            // 情况a,情况b
            dp[i][j] = dp[i - 1][j - 1] + (str1[i - 1] == str2[j - 1] ? 0 : rc);
            // 情况c
            dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
            // 情况d
            dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
         }
      }
      // 最后返回s1前N个字符串变成s2前M个字符串的代价。N个对应N-1的索引
      return dp[N - 1][M - 1];
   }
}
```

**str1删除成str2的最小个数字符**

题目：给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = "abcde"，s2 = "axbc"。返回 1

- 解法1：求出str2所有的子序列，然后按照长度排序，长度大的排在前面。然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。

```
public class Code04_DeleteMinCost {
 // 解法一
 // 求出str2所有的子序列，然后按照长度排序，长度大的排在前面。
 // 然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。
 // 分析：
 // 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。
 // 但是如果某一次考试给定的s2长度远大于s1，这么做就不合适了。
 public static int minCost1(String s1, String s2) {
  List<String> s2Subs = new ArrayList<>();
  // 递归求解s2的所有子序列
  process(s2.toCharArray(), 0, "", s2Subs);
  // 对所有子序列的长度按照降序排列
  s2Subs.sort(new LenComp());
  for (String str : s2Subs) {
   // 查看s2的所有子序列是否是s1的子串
   if (s1.indexOf(str) != -1) { // indexOf底层和KMP算法代价几乎一样，也可以用KMP代替
    // 只要找到了，那么删除的长度就是s2-当前子序列的长度
    return s2.length() - str.length();
   }
  }
  // 如果一个都没找到，说明要全删除
  return s2.length();
 }
 public static class LenComp implements Comparator<String> {
  @Override
  public int compare(String o1, String o2) {
   return o2.length() - o1.length();
  }
 }
}
```

### 求完全二叉树节点的个数

题目：要求时间复杂度低于O(N).

- ```
  解法1：递归套路，O(h2)即O((logN)2)，之前是O(n)
   * a.计算出最大深度，一直向左窜
   * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树
   * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树
   * d.直到某个节点来到最大深度，节点个数为1
  ```

```
//本题测试链接 : https://leetcode.cn/problems/count-complete-tree-nodes/
public class Code04_CompleteTreeNodeNumber {
    // 提交时不要提交这个类
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
    }

    /*
     * 解法1：递归套路，O(h2)即O((logN)2)，之前是O(n)
     * a.计算出最大深度，一直向左窜
     * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树
     * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树
     * d.直到某个节点来到最大深度，节点个数为1
     * */
    public static int countNodes(TreeNode head) {
        if (head == null) {
            return 0;
        }
        // 给定头结点，节点的所在层数，节点的树高度，返回节点个数
        return bs(head, 1, mostLeftLevel(head, 1));
    }

    // 当前来到node节点，node节点在level层，总层数是h
    // 返回node为头的子树(必是完全二叉树)，有多少个节点
    public static int bs(TreeNode node, int Level, int h) {
        // base case:说明节点来到了最后一层
        if (Level == h) {
            return 1;
        }
        // 判断节点的右子树的最左节点是否到达最后一层
        if (mostLeftLevel(node.right, Level + 1) == h) {
            // 如果到达最后一层，说明左子树是满的，继续递归右子树
            // 已知高度h计算节点个数：(2^h)-1,所以2^(h - Level)左树节点 -1 +1根节点
            return (1 << (h - Level)) + bs(node.right, Level + 1, h);
        } else {
            // 如果没有到达最后一层，说明右子树是满的，继续递归左子树
            // 2^(h - Level-1)右树节点 —1 +1根节点
            return (1 << (h - Level - 1)) + bs(node.left, Level + 1, h);
        }
    }

    // 如果node在第level层，求以node为头的子树，最大深度是多少。这是一个固定值
    // 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。定义根节点是第1层
    public static int mostLeftLevel(TreeNode node, int level) {
        // 因为是完全二叉树，所以可以左节点一直往下扎，计算树的高度
        while (node != null) {
            level++;
            node = node.left;
        }
        // 高度
        return level - 1;
    }
}
```

### LRU算法

LRU算法全称是最近最少使用算法（Least Recently Use），广泛的应用于缓存机制中。如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。所以顾名思义，LRU算法会选出最近最少使用的数据进行淘汰。

- 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)
- 解法2：基于LinkedHashMap实现的LRU

```
import java.util.HashMap;
// 本题测试链接 : https://leetcode.com/problems/lru-cache/
// 提交时把类名和构造方法名改成 : LRUCache
public class Code01_LRUCache {
    public Code01_LRUCache(int capacity) {
        cache = new MyCache<>(capacity);
    }
    private MyCache<Integer, Integer> cache;

    public int get(int key) {
        Integer ans = cache.get(key);
        return ans == null ? -1 : ans;
    }

    public void put(int key, int value) {
        cache.set(key, value);
    }
    public static class Node<K, V> {
        public K key;
        public V value;
        public Node<K, V> last;
        public Node<K, V> next;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    // 双向链表，LRU的关键，头结点是最不常使用，尾节点是最长使用。所以LRU是删除头结点，更新尾节点
    public static class NodeDoubleLinkedList<K, V> {
        private Node<K, V> head;
        private Node<K, V> tail;

        public NodeDoubleLinkedList() {
            head = null;
            tail = null;
        }

        // 现在来了一个新的node，请挂到尾巴上去
        public void addNode(Node<K, V> newNode) {
            if (newNode == null) {
                return;
            }
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                newNode.last = tail;
                tail = newNode;
            }
        }

        // 将当前节点挂到整个链表的尾巴上
        public void moveNodeToTail(Node<K, V> node) {
            if (tail == node) {
                return;
            }
            if (head == node) {
                // 如果要移动的节点是头结点
                // 当前节点的下一个节点变成新头
                head = node.next;
                // 头结点的上一节点指向空
                head.last = null;
            } else {
                // 如果要移动的节点是其他结点，那么这个节点前后节点要重新粘起来。如：当前节点的上一个节点的下一个指向当前节点的下一个节点。
                node.last.next = node.next;
                node.next.last = node.last;
            }
            // 当前节点的上一个节点指向老尾巴节点
            node.last = tail;
            // 老尾巴节点的下一个节点指向当前节点
            tail.next = node;
            // 当前节点的下一节点指向空
            node.next = null;
            // 新尾巴更新为当前节点
            tail = node;
        }

        // 双向链表删除头结点
        public Node<K, V> removeHead() {
            if (head == null) {
                return null;
            }
            // 先提取出返回值
            Node<K, V> res = head;
            // 调整头尾指针
            if (head == tail) {
                // 头尾节点相同，说明只有一个节点，直接全指向空
                head = null;
                tail = null;
            } else {
                // 说明至少有2个节点
                // 新头部指向当前节点下一个节点
                head = res.next;
                // 新头部的前一个节点指向空
                head.last = null;
                // 当前节点的下一个节点 断开
                res.next = null;
            }
            return res;
        }

    }

    // 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)
    public static class MyCache<K, V> {
        // map中key对应节点key，value对应节点的内存地址
        private HashMap<K, Node<K, V>> keyNodeMap;
        // 节点的双向链表
        private NodeDoubleLinkedList<K, V> nodeList;
        // LRU的容量
        private final int capacity;

        public MyCache(int cap) {
            keyNodeMap = new HashMap<K, Node<K, V>>();
            nodeList = new NodeDoubleLinkedList<K, V>();
            capacity = cap;
        }

        // 读取节点，更新链表尾巴
        public V get(K key) {
            if (keyNodeMap.containsKey(key)) {
                Node<K, V> res = keyNodeMap.get(key);
                // 节点移动到尾巴
                nodeList.moveNodeToTail(res);
                // 返回节点value值
                return res.value;
            }
            return null;
        }

        // 新增或更新节点，更新链表尾巴和更新哈希表
        public void set(K key, V value) {
            // 如果是更新节点，直接移动节点到链表尾巴
            if (keyNodeMap.containsKey(key)) {
                Node<K, V> node = keyNodeMap.get(key);
                node.value = value;
                // 直接移动节点到链表尾巴
                nodeList.moveNodeToTail(node);
            } else {
                // 如果是新增节点，直接添加到链表尾巴
                // 新增！注意先删除，再添加
                if (keyNodeMap.size() == capacity + 1) {
                    // 超出容量，移除头结点
                    removeMostUnusedCache();
                }
                Node<K, V> newNode = new Node<K, V>(key, value);
                keyNodeMap.put(key, newNode);
                nodeList.addNode(newNode);
            }
        }

        // 删除LRU缓存时，要删除链表头节点和哈希表中的节点
        private void removeMostUnusedCache() {
            Node<K, V> removeNode = nodeList.removeHead();
            keyNodeMap.remove(removeNode.key);
        }
    }
}
```

### Easy Equation

题目：求助

已知有n个整数，x1,x2,x3….xn.(1<=n<=10，0<=xi<=30)，以及m个整数a1,a2,a3….am(1<=m<=20,0<=ai<=25);
现在取出所有的a1,a2,a3…am.将他们随意分成n组，每组求和的值为b1,b2,b3…bn，然后成为x1,x2,x3…xn的系数。
（可以选择0个ai，组成一个对应的bj=0,但是数组a中的所有的ai必须选完）。
求满足b1*x1+b2*x2+b3*x3+…+bn*xn=s的分组方法数。其中s为输入的一个数据（0<=s<=20000）。
但是这个方法数也许会比较巨大,请输出分组方法数mod 1000000007 的结果。

```
输入：
4 4 68
1 2 4 8
1 2 4 8
输出：
3
```

```
public class 139 {
  public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
      int n = scanner.nextInt();
      int m = scanner.nextInt();
      int s = scanner.nextInt();
      int[] x = new int[n];
      int[] a = new int[m];
      for (int i = 0; i < n; i++) {
          x[i] = scanner.nextInt();
      }
      for (int i = 0; i < m; i++) {
          a[i] = scanner.nextInt();
      }
      // result[i] 表示取a前i个参数（后面参数视为0）所构成的等式的结果种数
      int[][] result = new int[m][s + 1];
      for (int i = 0; i < n; i++) {
          // 初始化第一行，表示取a中第一个参数构成的等式的的结果种数
          // 如x = {1,1,2,2} ，a={1,2}，那么 取a的第一个参数就构成的等式结果 为{0，2，2}
          result[0][x[i] * a[0]] += 1;
      }
      for (int i = 1; i < m; i++) {
          for (int j = 0; j <= s; j++) {
              for (int k = 0; k < n; k++) {
                  // 等式构成的结果减去增加的新项，无需管分组求和
                  // 因为(a1+a2) * x1 = a1*x1 + a2*x1，这里的a[i] * x[k]就是 a2*x1，index就是a1*x1
                  int index = j - a[i] * x[k];
                  if (index < 0) {
                      continue;
                  }
                  // 增加的新项构成的等式结果种树 就等于 index的结果+已经有的
                  result[i][j] += result[i - 1][index];
                  result[i][j] = result[i][j] % 1000000007;
              }
          }
      }
      System.out.println(result[m - 1][s]);
  }
}
```

## 推荐书

大话数据结构，算法图解

**视频**

[数据结构-浙江大学(opens new window)](https://www.bilibili.com/video/av18586085?from=search&seid=15275956372728133584)
[清华大学-邓俊辉MOOC数据结构与算法全套](https://www.bilibili.com/video/av49361421?from=search&seid=2756779141930403558)

# Vue3

## v-model

### **一、v-model原理**

v-model的原理就是: v-bind 和 v-on的语法糖

```
<input type="text" v-model="age">
<input type="text" v-bind="age" v-on:input="age = $event.target.value">
```

### **二、Vue2中双向绑定实现**

**1.v-bind**

通过自定义事件触发

```vue
// father.vue
<Son :ageValue="age" @changeInput="changeInput"/>

// Son.vue
<template>
  <div>
    <input type="text" v-model="sonAge" @input="changeInput">
  </div>
</template>
<script>
export default {
  props: {
    ageValue: {
      typeof: String
    }
  },
  data() {
    return {
      sonAge: ''
    }
  },
  methods: {
    changeInput() {
      this.$emit('changeInput', this.sonAge)
    }
  },
  /*
   为什么要监听:
   因为父组件传递过来属性, 可能有默认值,
   子组件的input需要根据默认值回显,或者别的地方需要
  */
  watch: {
    ageValue: {
      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数
      handler(val) {
        this.sonAge = val
      }
    }
  }
}
</script>
```

**2.sync修饰符**

```vue
// father.vue
<Son :ageValue.sync="age" />

// Son.vue
<template>
  <div>
    <input type="text" v-model="sonAge" @input="changeInput">
  </div>
</template>
<script>
export default {
  props: {
    ageValue: {
      typeof: String
    }
  },
  data() {
    return {
      sonAge: ''
    }
  },
  methods: {
    changeInput() {
      // this.$emit('changeInput', this.sonAge)
      // 这样父组件内的值也同时被更改,省略了监听事件这一步
      this.$emit('update:ageValue', this.sonAge)
    }
  },
  watch: {
    ageValue: {
      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数
      handler(val) {
        this.sonAge = val
      }
    }
  }
}
</script>
```

**3.v-model**

```vue
// father.vue
<Son v-model="age" />
<!-- <Son :age="age" @change="age = $event"></Son>-->

// Son.vue
<template>
  <div>
    <input type="text" v-model="sonAge" @input="changeInput">
  </div>
</template>
<script>
export default {
  props: {
    value: {
      typeof: String
    }
  },
  data() {
    return {
      sonAge: ''
    }
  },
  // 超级牛
  model: {
    prop: 'value',
    event: 'change'
  },
  methods: {
    changeInput() {
      this.$emit('change', this.sonAge)
    }
  },
  watch: {
    value: {
      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数
      handler(val) {
        this.sonAge = val
      }
    }
  }
}
</script>
```

### **三、Vue3中双向绑定实现**

**1.自定义事件**

```vue
// father.vue
<Son v-model="message" />

// Son.vue
<template>
  <div>
    <input type="text" :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
    />
  </div>
</template>
<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  props: ['modelValue'],
  emits: ['update:modelValue'],
})
</script>
```

**2.v-model结合computed计算属性**

```vue
// father.vue
<!-- 两个方法等价 -->
<!-- <Son :modelValue="message" @update:modelValue="message = $event" /> -->
<Son v-model="message" />

// Son.vue
<template>
  <div>
    <!-- 两个方法等价 -->
    <!-- <input type="text" :value="newValue" @input="newValue = $event.target.value" /> -->
    <input type="text" v-model="newValue" />
  </div>
</template>
<script lang="ts">
import { defineComponent, computed } from 'vue'
export default defineComponent({
  props: ['modelValue'],
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    const newValue = computed({
      // 子组件v-model绑定 计算属性, 一旦发生变化, 就会给父组件传递值
      get: () => props.modelValue,
      set: (nv) => {
        emit('update:modelValue', nv)
      }
    })
    return {
      newValue
    }
  }
})
</script>
```

**3.v-model结合watch**

```vue
<!-- 子组件 -->
<template>
  <input type="text" v-model="proxy" />
</template>

<script setup>
import { ref, watch } from "vue";
const emit = defineEmits();
const props = defineProps({
  modelValue: String,
});

const proxy = ref(props.modelValue);

watch(
  () => proxy.value,
  (v) => emit("update:modelValue",v)
);
</script>
```

**4.Hooks封装**

提取公用逻辑

```js
<template>
  <input type="text" v-model="proxy" />
</template>
<script setup>
import { ref, watch, computed } from "vue";
import { useVmodel } from "./hooks/useVmodel1";
const emit = defineEmits();
const props = defineProps({
  modelValue: String,
});
const proxy = useVmodel(props, emit);
</script>

// useVmodel1.js
import { ref, watch } from "vue";
export function useVmodel(props, emit) {
  const proxy = ref(props.modelValue);
  watch(
    () => proxy.value,
    (v) => emit("update:modelValue", v)
  );
  return proxy;
}
```

**5.v-model多个**

```vue
// father.vue
<Son v-model="message" v-model:title="title" />

// Son.vue
<template>
  <div>
    <!-- 两个方法等价 -->
    <!-- <input type="text" :value="newValue" @input="newValue = $event.target.value" /> -->
    <input type="text" v-model="newValue" />
    -
    <input type="text" v-model="newTitle" />
  </div>
</template>
<script lang="ts">
import { defineComponent, computed } from 'vue'
export default defineComponent({
  props: {
    // v-model默认的名字
    modelValue: {
      type: String
    },
    title: {
      //这里可以直接使用 v-model:title ,:号后面的名字
      type: String
    }
  },
  emits: ['update:modelValue', 'update:title'],
  setup(props, { emit }) {
    const newValue = computed({
      get: () => props.modelValue,
      set: (nv) => {
        console.log(nv)
        emit('update:modelValue', nv)
      }
    })

    const newTitle = computed({
      get: () => props.title,
      set: (nv) => {
        emit('update:title', nv)
      }
    })
    return {
      newValue,
      newTitle
    }
  }
})
</script>
```

### 四、vue2 对比 vue3的 v-model区别

**Vue2**

```js
// 父组件
<ChildComponent v-model = "title">
<ChildComponent :value="title"  @change="title = $event" />

// 子组件
export default {
  model: {
    prop: 'title', // v-model绑定的属性名称
    event: 'change' // v-model绑定的事件
  },
  props: {
    value: String, // value跟v-model无关
    title: { // title是跟v-model绑定的属性
      type: String,
      default: 'Default title'
    }
  },
  methods: {
    handle() {
      // 这里的 change, 对应 event
      this.$emit('change', 'xxx')
    }
  }
}
```

**Vue3**

```js
// 父组件
<!-- 两个方法等价 -->
<Son v-model="message" />
<!-- <Son :modelValue="message" @update:modelValue="message = $event" /> -->

// 子组件
export default defineComponent({
  props: {
    modelValue: {
      type: String
    }
  },
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    const newValue = computed({
      get: () => props.modelValue,
      set: (nv) => {
        console.log(nv)
        emit('update:modelValue', nv)
      }
    })

    return {
      newValue
    }
  }
})
```

**总结**

Vue2:

1. v-model: 会把 `value` 用作 prop 且把 `input` 用作 event;
2. 可以通过 `.sync`修饰符 指定传递名字
3. 支持model: 可以指定v-model的 value属性名 和 event事件名字

Vue3:

1. v-model: 不在绑定 value 而是 `modelValue`, 接受方法也不再是 input 而是 `update:modelValue`
2. 组件支持多个 v-model, 并且可以指定名字 v-model:名字

- 修改默认 prop 名和事件名
- 废除 model 选项和 .sync 修饰符
- 使用多个 v-model
- 自定义 v-model 修饰符

## watch、watchEffect区别

- 1、watch是惰性执行，也就是只有监听的值发生变化的时候才会执行，但是watchEffect不同，每次代码加载watchEffect都会执行（忽略watch第三个参数的配置，如果修改配置项也可以实现立即执行）
- 2、watch需要传递监听的对象，watchEffect不需要
- 3、watch只能监听响应式数据：ref定义的属性和reactive定义的对象，如果直接监听reactive定义对象中的属性是不允许的，除非使用函数转换一下
- 4、watchEffect如果监听reactive定义的对象是不起作用的，只能监听对象中的属性。

```js
  let count = ref(0)
    let countObj = reactive({count: 0})

    // 惰性，首次加载不执行
    watch(count, (newVal, oldVal) =>{console.log(newVal, oldVal)} )
    // watch 不能直接监听reactive里面的属性，只能监听ref、reactiveObject， function， array, 如果想监听reactive的某个属性，那么需要转换成函数
    watch(() => countObj.count, (newVal, oldVal) => {console.log(oldVal, newVal)}, {})
    watch (countObj, (newVal, oldVal) => {
      console.log(newVal, oldVal)
    })
    // 监听多个值，前面是监听数据的数组，后面的参数是两个数组，前面数组是变化后监听对象值的数组，后面是变化前监听对象值的数组
    watch ([countObj, count], ([oneNewName, twoNewName], [oneOldName, twoOldName]) => {
      console.log(oneNewName, oneOldName, twoNewName, twoOldName)
    })
    // watchEffect，和watch不一样，1、会立即执行，只要定义了就会执行。2、他只能监听某个值，监听对象不管用。3、不需要传递参数，会自动管制代码中的变量。4、没法获取newVal和oldVal
    const watchEf = watchEffect(() => {
      console.log(countObj.count)
    })
```

**watchEffect副作用函数**

定义：watchEffect的第三个参数是用于注册副作用清理的回调函数，该回调函数会在副作用函数下一次重新执行前调用，多用于取消重复请求、防抖、事件注册销毁等。

```js
// 取消重复请求
watch(source, async (old, new, OnCleanup) => {
  // 是否过期是标志
  let expired = false
  // 注册过期回调
  OnCleanup(()=> {
    expired = true
  })
 const res = await fetch('something')
 // 如果未过期，那么可以取res为finalData
 if (!expired) {
   finalData = res
 }
})

// 防抖
const id = ref(13)
watchEffect(onInvalidate => {
   // 异步请求
  const token = performAsyncOperation(id.value)
  // 如果id频繁改变，会触发失效函数，取消之前的接口请求
  onInvalidate(() => {
    // id has changed or watcher is stopped.
    // invalidate previously pending async operation
    token.cancel()
  })
})

// dom的事件监听和取消监听
onMounted(()=>{
  watchEffect((onInvalidate) => {
    document.querySelector('.btn').addEventListener('click', handleClick, false)
    onInvalidate(() => document.querySelector('.btn').removeEventListener('click', handleClick))
  })
})
```



## 生命周期

> Vue2--------------vue3
> beforeCreate  -> setup() // 开始创建组件之前，在`beforeCreate`和`created`之前执行。创建的是`data`和`method`
> created       -> setup()
> beforeMount   -> onBeforeMount // 组件挂载到节点上之前执行
> mounted       -> onMounted // 组件挂载完成后执行
> beforeUpdate  -> onBeforeUpdate //  组件更新之前执行
> updated       -> onUpdated // 组件更新完成之后执行
> beforeDestroy -> onBeforeUnmount // 组件卸载之前执行
> destroyed     -> onUnmounted // 组件卸载完成后执行
> activated     -> onActivated // 被包含在`<keep-alive>`中的组件，会多出两个生命周期钩子函数。被激活时执行。
> deactivated   -> onDeactivated // 比如从 A 组件，切换到 B 组件，A 组件消失时执行
> errorCaptured -> onErrorCaptured // 当捕获一个来自子孙组件的异常时激活钩子函数

**新增 onRenderTracked()和 onRenderTriggered()**

onRenderTracked()

> 直译过来就是`状态跟踪`，它会跟踪页面上所有响应式变量和方法的状态。只要页面有`update`的情况，他就会跟踪，然后生成一个`event`对象。

onRenderTriggered()

> 直译过来是`状态触发`，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。 与`watch`相似。
>
> event 对象属性的详细介绍：
>
> - key 那边变量发生了变化
> - newValue 更新后变量的值
> - oldValue 更新前变量的值
> - target 目前页面中的响应变量和函数

## setup语法糖就是香

- 组件自动注册
- 组件核心 API
- 属性和方法直接使用

**组件自动注册**

它会自动以文件名为主，也就是不用再写`name`属性了

**组件核心 API**

1.使用 props

通过`defineProps`指定当前 props 类型，获得上下文的props对象。示例：

```vue
<script setup>
  import { defineProps } from 'vue'
  const props = defineProps({
    title: String,
  })
</script>
```

2.使用 emits

使用`defineEmit`定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例：

```vue
<script setup>
  import { defineEmits } from 'vue'
  const emit = defineEmits(['change', 'delete'])
</script>
```

3.获取 slots 和 attrs

可以通过`useContext`从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了`useAttrs`和`useSlots`。示例：

```vue
// 旧
<script setup>
  import { useContext } from 'vue'
  const { slots, attrs } = useContext()
</script>

// 新
<script setup>
  import { useAttrs, useSlots } from 'vue'
  const attrs = useAttrs()
  const slots = useSlots()
</script>
```

4.defineExpose API

传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 `template`模板，谁都不能访问内部的数据和方法。

如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。示例：

```vue
<script setup>
 import { defineExpose } from 'vue'
 const a = 1
 const b = 2
 defineExpose({
     a
 })
</script>
```

**属性和方法直接使用**

定义的属性和方法无需返回，可以直接使用

## Vue3标准模板

**模板工具：**

- `编程语言`：**TypeScript 4.x 、JavaScript**
- `前端框架`：**Vue 3.x**
- `构建工具`：**Vite 2.x**
- `UI 框架`：**Element Plus**
- `图标工具`：**icones**
- `CSS预编译`：**Sass**
- `CSS框架`：**Windi CSS**
- `HTTP工具`：**Axios**
- `路由管理`：**Vue Router 4.x**
- `状态管理`：**Pinia**
- `代码规范`：**EditorConifg、Prettier、ESLint、Airbnb JavaScript Style Guide**
- `提交规范`：**husky、Commitlint 、lint-staged**

- `实现自动按需加载`（**`墙裂推荐`**）：**unplugin-auto-import、unplugin-vue-components、unplugin-icons**
- `实现 SVG图标 的组件化`：**vite-svg-loader**
- `让各种 API 支持响应式`：**VueUse**
- `让加载页面时有所反馈`：**NProgress**
- `支持 markdown`：**vite-plugin-md**
- vetur -> volar:对于 vue3 的支持，`vetur` 很明显的不如 `volar`，这边建议小伙伴们禁用vuetur而使用volor

**模板代码目录结构：**

- `.husky`：用来放husky 钩子的配置文件夹
- `.vscode`：用来放项目中的 vscode 配置
- `presets`：用来放 vite 插件的 plugin 配置
- `public`：用来放一些诸如 页头icon 之类的公共文件，会被打包到dist根目录下
- `src`：用来放项目代码文件
- `api`：用来放http的一些接口配置
- `assets`：用来放一些 CSS 之类的静态资源
- `components`：用来放 Vue 组件
- `layout`：用来放项目的布局
- `router`：用来放项目的路由配置
- `store`：用来放状态管理Pinia的配置
- `utils`：用来放项目中的工具方法类
- `views`：用来放项目的.vue视图

#

# 调用堆栈

## 执行栈

执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的**所有执行上下文**。

因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文**栈**（Execution context stack，ECS）来**管理**执行上下文。

当 JavaScript 初始化的时候会向执行上下文栈压入一个**全局**执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。

**一、执行上下文**

执行上下文总共有三种类型

- **全局执行上下文**：只有一个，浏览器中的全局对象就是 window 对象，`this` 指向这个全局对象。
- **函数执行上下文**：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
- **Eval 函数执行上下文**： 指的是运行在 `eval` 函数中的代码，很少用而且不建议使用。

**二、执行上下文的创建**

分为2个阶段：

- 创建阶段
- 执行阶段

**1.创建阶段**

分为3部分：

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
- 3、**VariableEnvironment（变量环境）** 组件被创建。

**(1)This Binding**

- **全局**执行上下文中，`this` 的值指向全局对象，在浏览器中`this` 的值指向 `window`对象，而在`nodejs`中指向这个文件的`module`对象。
- **函数**执行上下文中，`this` 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、`new`绑定、箭头函数，具体内容会在【this全面解析】部分详解。

**(2)词法环境**

分为2部分：

- **环境记录**：存储变量和函数声明的实际位置
- **对外部环境的引用**：可以访问其外部词法环境

词法环境有两种**类型**

- 1、**全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。
- 2、**函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

**(3)变量环境**

变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。



**2.执行阶段**

完成对所有变量的分配，执行代码，函数出栈

**参考**

[理解 Javascript 执行上下文和执行栈](https://juejin.im/post/5bdfd3e151882516c6432c32)

## 变量对象

例子一：**变量提升**

```js
foo;  // undefined
var foo = function () {
    console.log('foo1');
}

foo();  // foo1，foo赋值

var foo = function () {
    console.log('foo2');
}

foo(); // foo2，foo重新赋值
```

例子二：**函数提升**

```js
foo();  // foo2
function foo() {
    console.log('foo1');
}

foo();  // foo2

function foo() {
    console.log('foo2');
}

foo(); // foo2
```

例子三：声明优先级，**函数 > 变量**

```js
foo();  // foo2
var foo = function() {
    console.log('foo1');
}

foo();  // foo1，foo重新赋值

function foo() {
    console.log('foo2');
}

foo(); // foo1
```

上面三个例子中，第一个例子是变量提升，第二个例子是函数提升，第三个例子是函数声明优先级高于变量声明。

有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

答案是 执行上下文栈的变化不一样。

第一段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

第二段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

**讨论题**

```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x  // --> undefined
b.x  // --> {n: 2}
```

答案已经写上面了，这道题的关键在于

- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。
- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`

**参考**

[JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)

## 内存空间

JS内存空间分为**栈(stack)**、**堆(heap)**、**池(一般也会归类为栈中)**。 其中**栈**存放基本变量，**堆**存放应用对象(引用地址存放在栈，真实变量在堆)，**池**存放常量，所以也叫常量池。

**几个问题**

问题1：

```js
var a = 20;
var b = a;
b = 30;
// 这时a的值是多少？
```

问题2：

```js
var a = { name: '前端开发' }
var b = a;
b.name = '进阶';
// 这时a.name的值是多少
```

问题3：

```js
var a = { name: '前端开发' }
var b = a;
a = null;
// 这时b的值是多少
```

现在来解答一下，三个问题的答案分别是`20`、`‘进阶’`、`{ name: '前端开发' }`

- 对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。
- 对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改`b.name`的值后，相应的`a.name`也就发生了改变。
- 对于问题3，首先要说明的是`null`是基本类型，`a = null`之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。

**JS的内存生命周期**

- 1、分配你所需要的内存
- 2、使用分配到的内存（读、写）
- 3、不需要时将其释放、归还

# **从内存来看 null 和 undefined 本质的区别是什么？**

**解答**：

给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。

给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值

# 闭包

**定义**

闭包是指有权访问另外一个函数作用域中的变量的函数。

关键在于2点：

- 是函数
- 能够访问函数作用域外的变量

**三个特性**

- 闭包可以访问当前函数以外的变量
- 即使外部函数已经返回，闭包仍能访问外部函数定义的变量
- 闭包可以更新外部变量的值

```
// 闭包可以访问当前函数以外的变量
function getOuter(){
  var date = '815';
  function getDate(str){
    console.log(str + date);  //访问外部的date
  }
  return getDate('今天是：'); //"今天是：815"
}
getOuter();
// 即使外部函数已经返回，闭包仍能访问外部函数定义的变量
function getOuter(){
  var date = '815';
  function getDate(str){
    console.log(str + date);  //访问外部的date
  }
  return getDate;     //外部函数返回
}
var today = getOuter();
today('今天是：');   //"今天是：815"
today('明天不是：');   //"明天不是：815"
// 闭包可以更新外部变量的值
function updateCount(){
  var count = 0;
  function getCount(val){
    count = val;
    console.log(count);
  }
  return getCount;     //外部函数返回
}
var count = updateCount();
count(815); //815
count(816); //816
```

**一个简单例子**

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); // foo指向函数f
foo();     // 调用函数f()
```

简要的执行过程如下：

1. 进入全局代码，创建全局执行上下文，全局执行上下文**压入执行上下文栈**
2. 全局执行**上下文初始化**
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行**上下文初始化**，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行**上下文初始化**，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

那么**问题**来了， 函数f 执行的时候，checkscope 函数上下文已经被销毁了，那函数f是如何获取到scope变量的呢？

> 函数f 执行上下文维护了一个作用域链，会指向指向`checkscope`作用域。
>
> 所以指向关系是当前作用域 --> `checkscope`作用域--> 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的**关键**。

**一个闭包题**

```
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

如果知道闭包的，答案就很明显了，都是3

如果要依次输出索引值，解决：改成闭包，方法就是`data[i]`返回一个函数，并访问变量`i`

```
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
      return function(){
          console.log(i);
      }
  })(i);
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```

循环结束后的全局执行上下文没有变化。

执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：因为闭包执行上下文中贮存了变量`i`，所以根据作用域链会在`globalContext.VO`中查找到变量`i`,并输出0。

**一、作用域**

**1.变量提升**

```js
var scope="global";
function scopeTest(){
    console.log(scope);
    var scope="local"  
}
scopeTest(); //undefined
```

上面的代码输出是`undefined`，这是因为局部变量`scope`变量提升了，等效于下面

```js
var scope="global";
function scopeTest(){
    var scope;
    console.log(scope);
    scope="local"  
}
scopeTest(); //undefined
```

**注意**，如果在局部作用域中忘记var，那么变量就被声明为全局变量。

**2.没有块级作用域**

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); // 3
data[1](); // 3
data[2](); // 3
```

**闭包**

```
function createClosure(){
    var name = "jack";
    return {
        setStr:function(){
            name = "rose";
        },
        getStr:function(){
            return name + ":hello";
        }
    }
}
var builder = new createClosure();
builder.setStr();
console.log(builder.getStr()); //rose:hello
```

**面试题**

由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。

如果想以下代码按照预期输出索引值，怎么办？

```
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); // 3
data[1](); // 3
data[2](); // 3
```

**方法1：立即执行函数**

```js
for (var i = 0; i < 3; i++) {
    (function(num) {
        setTimeout(function() {
            console.log(num);
        }, 1000);
    })(i);
}
// 0
// 1
// 2
```

**方法2：返回一个匿名函数赋值**

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (num) {
      return function(){
          console.log(num);
      }
  })(i);
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```

无论是**立即执行函数**还是**返回一个匿名函数赋值**，原理上都是因为变量的按值传递，所以会将变量`i`的值复制给实参`num`，在匿名函数的内部又创建了一个用于访问`num`的匿名函数，这样每个函数都有了一个`num`的副本，互不影响了。

**方法3：使用ES6中的let**

```js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

解释下**原理**：

```js
var data = [];// 创建一个数组data;

// 进入第一次循环
{ 
 let i = 0; // 注意：因为使用let使得for循环为块级作用域
            // 此次 let i = 0 在这个块级作用域中，而不是在全局环境中
    data[0] = function() {
     console.log(i);
 };
}
```

# New一个对象发生了什么

**模拟实现**

当代码 `new Foo(...)` 执行时，会发生以下事情：

1. 一个继承自 `Foo.prototype` 的新对象被创建。
2. 使用指定的参数调用构造函数 `Foo` ，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 `new Foo()`，也就是没有指定参数列表，`Foo` 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。

**模拟实现第一步**

`new` 是关键词，不可以直接覆盖。这里使用 `create` 来模拟实现 `new` 的效果。

`new` 返回一个新对象，通过 `obj.__proto__ = Con.prototype` 继承构造函数的原型，同时通过 `Con.apply(obj, arguments)`调用父构造函数实现继承，获取构造函数上的属性（【进阶3-3期】）。

实现代码如下

```js
// 第一版
function create() {
 // 创建一个空的对象
    var obj = new Object(),
 // 获得构造函数，arguments中去除第一个参数
    Con = [].shift.call(arguments);
 // 链接到原型，obj 可以访问到构造函数原型中的属性
    obj.__proto__ = Con.prototype;
 // 绑定 this 实现继承，obj 可以访问到构造函数中的属性
    Con.apply(obj, arguments);
 // 返回对象
    return obj;
};
```

测试一下

```js
// 测试用例
function Car(color) {
    this.color = color;
}
Car.prototype.start = function() {
    console.log(this.color + " car start");
}

var car = create(Car, "black");
car.color;
// black

car.start();
// black car start
```

完美！

**模拟实现第二步**

上面的代码已经实现了 80%，现在继续优化。

构造函数返回值有如下三种情况：

- 1、返回一个对象
- 2、没有 `return`，即返回 `undefined`
- 3、返回`undefined` 以外的基本类型

**情况1**：返回一个对象

```js
function Car(color, name) {
    this.color = color;
    return {
        name: name
    }
}

var car = new Car("black", "BMW");
car.color;
// undefined

car.name;
// "BMW"
```

实例 `car` 中只能访问到**返回对象中的属性**。

**情况2**：没有 `return`，即返回 `undefined`

```js
function Car(color, name) {
    this.color = color;
}

var car = new Car("black", "BMW");
car.color;
// black

car.name;
// undefined
```

实例 `car` 中只能访问到**构造函数中的属性**，和情况1完全相反。

**情况3**：返回`undefined` 以外的基本类型

```js
function Car(color, name) {
    this.color = color;
    return "new car";
}

var car = new Car("black", "BMW");
car.color;
// black

car.name;
// undefined
```

实例 `car` 中只能访问到**构造函数中的属性**，和情况1完全相反，结果相当于没有返回值。

**所以**需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 `obj`对象。

所以实现代码如下：

```js
// 第二版
function create() {
 // 1、获得构造函数，同时删除 arguments 中第一个参数
    Con = [].shift.call(arguments);
 // 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性
    var obj = Object.create(Con.prototype);
 // 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
 // 4、优先返回构造函数返回的对象
 return ret instanceof Object ? ret : obj;
};
```

# 高阶函数-柯里化

**一、定义**

函数柯里化又叫部分求值，维基百科中对柯里化 (Currying) 的定义为：

> 在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

用大白话来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。使用一个简单的例子来介绍下，最常用的就是 add 函数了。

```js
// 木易杨
const add = (...args) => args.reduce((a, b) => a + b);

// 传入多个参数，执行 add 函数
add(1, 2) // 3

// 假设我们实现了一个 currying 函数，支持一次传入一个参数
let sum = currying(add);
// 封装第一个参数，方便重用
let addCurryOne = sum(1);
addCurryOne(2) // 3
addCurryOne(3) // 4
```

**二、实际应用**

- 1.延迟计算：部分求和，bind函数
- 2.动态创建函数：添加监听addEvent、惰性函数
- 3.参数复用：

**1.延迟计算**

```
const add = (...args) => args.reduce((a, b) => a + b);

// 简化写法
function currying(func) {
    const args = [];
    return function result(...rest) {
        if (rest.length === 0) {
          return func(...args);
        } else {
          args.push(...rest);
         return result;
        }
    }
}

const sum = currying(add);
sum(1,2)(3); // 未真正求值
sum(4);    // 未真正求值
sum();     // 输出 10
```

**bind函数**

```
let obj = {
  name: 'muyiy'
}
const fun = function () {
  console.log(this.name);
}.bind(obj);

fun(); // muyiy

// bind底层原因也是柯里化的实现
Function.prototype.bind = function (context) {
    var self = this;
    // 第 1 个参数是指定的 this，截取保存第 1 个之后的参数
  // arr.slice(begin); 即 [begin, end]
    var args = Array.prototype.slice.call(arguments, 1); 

    return function () {
        // 此时的 arguments 是指 bind 返回的函数调用时接收的参数
        // 即 return function 的参数，和上面那个不同
       // 类数组转成数组
        var bindArgs = Array.prototype.slice.call(arguments);
       // 执行函数
        return self.apply( context, args.concat(bindArgs) );
    }
}
```

**2.动态创建函数**

每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断。这种情况下就非常适合使用柯里化方案来处理

```js
// 简化写法
function addEvent (type, el, fn, capture = false) {
    if (window.addEventListener) {
        el.addEventListener(type, fn, capture);
    }
    else if(window.attachEvent){
        el.attachEvent('on' + type, fn);
    }
}
```

但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。

```js
const addEvent = (function(){
    if (window.addEventListener) {
        return function (type, el, fn, capture) {
            el.addEventListener(type, fn, capture);
        }
    }
    else if(window.attachEvent){
        return function (type, el, fn) {
            el.attachEvent('on' + type, fn);
        }
    }
})();
```

上面这种实现方案就是一种典型的柯里化应用，在第一次的 `if...else if...` 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。

**当然可以使用惰性函数来实现**这一功能，原理很简单，就是重写函数。

```js
function addEvent (type, el, fn, capture = false) {
   // 重写函数
    if (window.addEventListener) {
        addEvent = function (type, el, fn, capture) {
            el.addEventListener(type, fn, capture);
        }
    }
    else if(window.attachEvent){
        addEvent = function (type, el, fn) {
            el.attachEvent('on' + type, fn);
        }
    }
   // 执行函数，有循环爆栈风险
   addEvent(type, el, fn, capture); 
}
```

第一次调用 `addEvent` 函数后，会进行一次环境判断，在这之后 `addEvent` 函数被重写，所以下次调用时就不会再次判断环境，可以说很完美了。

**3.参数复用**

```
// 改造前
function isArray(obj) { 
    return Object.prototype.toString.call(obj) === '[object Array]';
}
function isNumber(obj) {
    return Object.prototype.toString.call(obj) === '[object Number]';
}
[1, 2, 3].toString(); // "1,2,3"
'123'.toString(); // "123"

// 改造后
const toStr = Function.prototype.call.bind(Object.prototype.toString);
toStr([1, 2, 3]);  // "[object Array]"
toStr('123');   // "[object String]"
```

**三、实现 currying 函数**

```js
function currying(fn, length) {
  length = length || fn.length;  // 注释 1
  return function (...args) {   // 注释 2
    return args.length >= length // 注释 3
     ? fn.apply(this, args)   // 注释 4
      : currying(fn.bind(this, ...args), length - args.length) // 注释 5
  }
}

// Test
const fn = currying(function(a, b, c) {
    console.log([a, b, c]);
});

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

- 注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度
- 注释 2：currying 包裹之后返回一个新函数，接收参数为 `...args`
- 注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度
- 注释 4：满足要求，执行 fn 函数，传入新函数的参数
- 注释 5：不满足要求，递归 currying 函数，新的 fn 为 `bind` 返回的新函数（`bind` 绑定了 `...args` 参数，未执行），新的 length 为 fn 剩余参数的长度

# Vue3.0入门_3

## 生命周期的变化

整体来看，变化不大，只是名字大部分需要 + `on`，功能上类似。使用上 Vue3 组合式 API 需要先引入；Vue2 选项 API 则可直接调用，如下所示。

| Vue2.x        | Vue3            |
| :------------ | :-------------- |
| beforeCreate  | Not needed*     |
| created       | Not needed*     |
| beforeMount   | onBeforeMount   |
| mounted       | onMounted       |
| beforeUpdate  | onBeforeUpdate  |
| updated       | onUpdated       |
| beforeDestroy | onBeforeUnmount |
| destroyed     | onUnmounted     |

**Tips：** `setup`是围绕`beforeCreate`和`created`生命周期钩子运行的，所以不需要显式地去定义。

## 多根节点

Vue3 支持了多根节点组件，也就是`fragment`。

Vue2中，编写页面的时候，我们需要去将组件包裹在`<div>`中，否则报错警告

## 异步组件

Vue3 提供 `Suspense`组件，允许程序在等待异步组件时渲染兜底的内容，如 loading ，使用户体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：`default`和`fallback`。`Suspense`确保加载完异步内容时显示默认插槽，并将`fallback`插槽用作加载状态。

```vue
<tempalte>
   <suspense>
     <template #default>
       <todo-list />
     </template>
     <template #fallback>
       <div>
         Loading...
       </div>
     </template>
   </suspense>
</template>
```

## Teleport

Vue3 提供`Teleport`组件可将部分DOM移动到 Vue app之外的位置。比如项目中常见的`Dialog`组件。

```vue
<button @click=dialogVisible = true>点击</button>
<teleport to=body>
   <div class=dialog v-if=dialogVisible>
   </div>
</teleport>
```

## 组合式API

Vue2 是 `选项式API（Option API）`，一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期函数等），导致代码的可读性变差，需要上下来回跳转文件位置。Vue3 `组合式API（Composition API）`则很好地解决了这个问题，可将同一逻辑的内容写到一起。解决了 Vue2 `Mixin`的存在的命名冲突和数据来源不清，不同组件间配置化使用不够灵活。

除了增强了代码的可读性、内聚性，组合式API 还提供了较为完美的逻辑复用性方案，举个🌰，如下所示公用鼠标坐标案例。

```js
// main.vue
<template>
  <span>mouse position {{x}} {{y}}</span>
</template>
<script setup>
import { ref } from  vue 
import useMousePosition from  ./useMousePosition 
const {x, y} = useMousePosition()
}
</script>

// useMousePosition.js
import { ref, onMounted, onUnmounted } from  vue 
function useMousePosition() {
  let x = ref(0)
  let y = ref(0)
  function update(e) {
    x.value = e.pageX
    y.value = e.pageY
  }
  onMounted(() => {
    window.addEventListener( mousemove , update)
  })
  onUnmounted(() => {
    window.removeEventListener( mousemove , update)
  })
  return {
    x,
    y
  }
}
</script>
```

## 响应式原理

Vue2 响应式原理基础是`Object.defineProperty`；Vue3 响应式原理基础是`Proxy`。

### Object.defineProperty

基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。
**Tips：** `writable` 和 `value` 与 `getter` 和 `setter` 不共存。

```js
let obj = {}
let name =  瑾行 
Object.defineProperty(obj,  name , {
  enumerable: true, // 可枚举（是否可通过for...in 或 Object.keys()进行访问）
  configurable: true, // 可配置（是否可使用delete删除，是否可再次设置属性）
  // value:   , // 任意类型的值，默认undefined
  // writable: true, // 可重写
  get: function() {
    return name
  },
  set: function(value) {
    name = value
  }
})
```

Vue2核心源码

```js
function defineReactive(obj, key, val) {
  // 一 key 一个 dep
  const dep = new Dep()
  
  // 获取 key 的属性描述符，发现它是不可配置对象的话直接 return
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) { return }
  
  // 获取 getter 和 setter，并获取 val 值
  const getter = property && property.get
  const setter = property && property.set
  if((!getter || setter) && arguments.length === 2) { val = obj[key] }
  
  // 递归处理，保证对象中所有 key 被观察
  let childOb = observe(val)
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    // get 劫持 obj[key] 的 进行依赖收集
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val
      if(Dep.target) {
        // 依赖收集
        dep.depend()
        if(childOb) {
          // 针对嵌套对象，依赖收集
          childOb.dep.depend()
          // 触发数组响应式
          if(Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
    }
    return value
  })
  // set 派发更新 obj[key]
  set: function reactiveSetter(newVal) {
    ...
    if(setter) {
      setter.call(obj, newVal)
    } else {
      val = newVal
    }
    // 新值设置响应式
    childOb = observe(val)
    // 依赖通知更新
    dep.notify()
  }
}
```

Vue2响应式缺陷：无法监听对象或数组新增、删除的元素。
Vue2 方案：针对常用数组原型方法`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`进行了hack处理；提供`Vue.set`监听对象/数组新增属性。对象的新增/删除响应，还可以`new`个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。

### Proxy

`Proxy`是ES6新特性，通过第2个参数`handler`拦截目标对象的行为。相较于`Object.defineProperty`提供语言全范围的响应能力，消除了局限性。

基本用法：创建对象的代理，从而实现基本操作的拦截和自定义操作。

 Vue3 的源码 reactive.ts 

```js
function createReactiveObject(target, isReadOnly, baseHandlers, collectionHandlers, proxyMap) {
  ...
  // collectionHandlers: 处理Map、Set、WeakMap、WeakSet
  // baseHandlers: 处理数组、对象
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}
```

如baseHandlers.ts 为例，使用Reflect.get而不是`target[key]`的原因是receiver参数可以把this指向getter调用时，而非Proxy构造时的对象。

```js
// 依赖收集
function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    ...
    // 数组类型
    const targetIsArray = isArray(target)
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
    // 非数组类型
    const res = Reflect.get(target, key, receiver);
    
    // 对象递归调用
    if (isObject(res)) {
      return isReadonly ? readonly(res) : reactive(res)
    }

    return res
  }
}
// 派发更新
function createSetter() {
  return function set(target: Target, key: string | symbol, value: unknown, receiver: Object) {
    value = toRaw(value)
    oldValue = target[key]
    // 因 ref 数据在 set value 时就已 trigger 依赖了，所以直接赋值 return 即可
    if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
      oldValue.value = value
      return true
    }

    // 对象是否有 key 有 key set，无 key add
    const hadKey = hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    return result
  }
}
```

## 虚拟DOM

Vue3 相比于 Vue2 虚拟DOM 上增加`patchFlag`字段。我们借助`Vue3 Template Explorer`来看。

```html
<div id=app>
  <h1>技术摸鱼</h1>
  <p>今天天气真不错</p>
  <div>{{name}}</div>
</div>
```

渲染函数如下:

```js
import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from vue

const _withScopeId = n => (_pushScopeId(scope-id),n=n(),_popScopeId(),n)
const _hoisted_1 = { id: app }
const _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(h1, null, 技术摸鱼, -1 /* HOISTED */))
const _hoisted_3 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(p, null, 今天天气真不错, -1 /* HOISTED */))

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock(div, _hoisted_1, [
    _hoisted_2,
    _hoisted_3,
    _createElementVNode(div, null, _toDisplayString(_ctx.name), 1 /* TEXT */)
  ]))
}
```

注意第 3 个`_createElementVNode`的第 4 个参数即`patchFlag`字段类型，字段类型情况如下所示。1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style等。除此之外，发现所有的静态节点，都保存为一个变量进行`静态提升`，可在重新渲染时直接引用，无需重新创建。

```js
export const enum PatchFlags { 
  TEXT = 1, // 动态文本内容
  CLASS = 1 << 1, // 动态类名
  STYLE = 1 << 2, // 动态样式
  PROPS = 1 << 3, // 动态属性，不包含类名和样式
  FULL_PROPS = 1 << 4, // 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较
  HYDRATE_EVENTS = 1 << 5, // 带有监听事件的节点
  STABLE_FRAGMENT = 1 << 6, // 不会改变子节点顺序的 fragment
  KEYED_FRAGMENT = 1 << 7, // 带有 key 属性的 fragment 或部分子节点
  UNKEYED_FRAGMENT = 1 << 8,  // 子节点没有 key 的fragment
  NEED_PATCH = 1 << 9, // 只会进行非 props 的比较
  DYNAMIC_SLOTS = 1 << 10, // 动态的插槽
  HOISTED = -1,  // 静态节点，diff阶段忽略其子节点
  BAIL = -2 // 代表 diff 应该结束
}
```

## 事件缓存

Vue3 的 `cacheHandler`可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。加一个`click`事件。

```html
<div id=app>
  <h1>技术摸鱼</h1>
  <p>今天天气真不错</p>
  <div>{{name}}</div>
  <span onCLick=() => {}><span>
</div>
```

渲染函数如下:

```js
import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from vue

const _withScopeId = n => (_pushScopeId(scope-id),n=n(),_popScopeId(),n)
const _hoisted_1 = { id: app }
const _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(h1, null, 技术摸鱼, -1 /* HOISTED */))
const _hoisted_3 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(p, null, 今天天气真不错, -1 /* HOISTED */))
const _hoisted_4 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(span, { onCLick: () => {} }, [
  /*#__PURE__*/_createElementVNode(span)
], -1 /* HOISTED */))

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock(div, _hoisted_1, [
    _hoisted_2,
    _hoisted_3,
    _createElementVNode(div, null, _toDisplayString(_ctx.name), 1 /* TEXT */),
    _hoisted_4
  ]))
}
```

## Diff 优化

结合上文与源码，patchFlag帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。Vue3 patchChildren 源码:

```js
function patchChildren(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {
  // 获取新老孩子节点
  const c1 = n1 && n1.children
  const c2 = n2.children
  const prevShapeFlag = n1 ? n1.shapeFlag : 0
  const { patchFlag, shapeFlag } = n2
  
  // 处理 patchFlag 大于 0 
  if(patchFlag > 0) {
    if(patchFlag && PatchFlags.KEYED_FRAGMENT) {
      // 存在 key
      patchKeyedChildren()
      return
    } els if(patchFlag && PatchFlags.UNKEYED_FRAGMENT) {
      // 不存在 key
      patchUnkeyedChildren()
      return
    }
  }
  
  // 匹配是文本节点（静态）：移除老节点，设置文本节点
  if(shapeFlag && ShapeFlags.TEXT_CHILDREN) {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      unmountChildren(c1 as VNode[], parentComponent, parentSuspense)
    }
    if (c2 !== c1) {
      hostSetElementText(container, c2 as string)
    }
  } else {
    // 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense,...)
      } else {
        unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)
      }
    } else {
      
      if(prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
        hostSetElementText(container, )
      } 
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        mountChildren(c2 as VNodeArrayChildren, container,anchor,parentComponent,...)
      }
    }
  }
}
```

patchUnkeyedChildren 源码如下：

```js
function patchUnkeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {
  c1 = c1 || EMPTY_ARR
  c2 = c2 || EMPTY_ARR
  const oldLength = c1.length
  const newLength = c2.length
  const commonLength = Math.min(oldLength, newLength)
  let i
  for(i = 0; i < commonLength; i++) {
    // 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点
    const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as Vnode)) : normalizeVnode(c2[i])
    patch()
  }
  if(oldLength > newLength) {
    // 移除多余的节点
    unmountedChildren()
  } else {
    // 创建新的节点
    mountChildren()
  }
}
```

patchKeyedChildren源码如下，有运用最长递增序列的算法思想:

```js
function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {
  let i = 0;
  const e1 = c1.length - 1
  const e2 = c2.length - 1
  const l2 = c2.length
  
  // 从头开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 
  while(i <= e1 && i <= e2) {
    const n1 = c1[i]
    const n2 = c2[i]
    
    if(isSameVnodeType) {
      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)
    } else {
      break
    }
    i++
  }
  
  // 从尾开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 
  while(i <= e1 && i <= e2) {
    const n1 = c1[e1]
    const n2 = c2[e2]
    if(isSameVnodeType) {
      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)
    } else {
      break
    }
    e1--
    e2--
  }
  
  // 仅存在需要新增的节点
  if(i > e1) {    
    if(i <= e2) {
      const nextPos = e2 + 1
      const anchor = nextPos < l2 ? c2[nextPos] : parentAnchor
      while(i <= e2) {
        patch(null, c2[i], container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)
      }
    }
  }
  
  // 仅存在需要删除的节点
  else if(i > e2) {
    while(i <= e1) {
      unmount(c1[i], parentComponent, parentSuspense, true)    
    }
  }
  
  // 新旧节点均未遍历完
  // [i ... e1 + 1]: a b [c d e] f g
  // [i ... e2 + 1]: a b [e d c h] f g
  // i = 2, e1 = 4, e2 = 5
  else {
    const s1 = i
    const s2 = i
    // 缓存新 Vnode 剩余节点 上例即{e: 2, d: 3, c: 4, h: 5}
    const keyToNewIndexMap = new Map()
    for (i = s2; i <= e2; i++) {
      const nextChild = (c2[i] = optimized
          ? cloneIfMounted(c2[i] as VNode)
          : normalizeVNode(c2[i]))
      
      if (nextChild.key != null) {
        if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {
          warn(
            `Duplicate keys found during update:`,
             JSON.stringify(nextChild.key),
            `Make sure keys are unique.`
          )
        }
        keyToNewIndexMap.set(nextChild.key, i)
      }
    }
  }
  
  let j = 0
  // 记录即将 patch 的 新 Vnode 数量
  let patched = 0
  // 新 Vnode 剩余节点长度
  const toBePatched = e2 - s2 + 1
  // 是否移动标识
  let moved = false
  let maxNewindexSoFar = 0
  
  // 初始化 新老节点的对应关系（用于后续最大递增序列算法）
  const newIndexToOldIndexMap = new Array(toBePatched)
  for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0
  
  // 遍历老 Vnode 剩余节点
  for (i = s1; i <= e1; i++) {
    const prevChild = c1[i]
    
    // 代表当前新 Vnode 都已patch，剩余旧 Vnode 移除即可
    if (patched >= toBePatched) {
      unmount(prevChild, parentComponent, parentSuspense, true)
      continue
    }
    
    let newIndex
    // 旧 Vnode 存在 key，则从 keyToNewIndexMap 获取
    if (prevChild.key != null) {
      newIndex = keyToNewIndexMap.get(prevChild.key)
    // 旧 Vnode 不存在 key，则遍历新 Vnode 获取
    } else {
      for (j = s2; j <= e2; j++) {
        if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j] as VNode)){
           newIndex = j
           break
        }
      }           
   }
   
   // 删除、更新节点
   // 新 Vnode 没有 当前节点，移除
   if (newIndex === undefined) {
     unmount(prevChild, parentComponent, parentSuspense, true)
   } else {
     // 旧 Vnode 的下标位置 + 1，存储到对应 新 Vnode 的 Map 中
     // + 1 处理是为了防止数组首位下标是 0 的情况，因为这里的 0 代表需创建新节点
     newIndexToOldIndexMap[newIndex - s2] = i + 1
     
     // 若不是连续递增，则代表需要移动
     if (newIndex >= maxNewIndexSoFar) {
       maxNewIndexSoFar = newIndex
     } else {
       moved = true
     }
     
     patch(prevChild,c2[newIndex],...)
     patched++
   }
  }
  
  // 遍历结束，newIndexToOldIndexMap = {0:5, 1:4, 2:3, 3:0}
  // 新建、移动节点
  const increasingNewIndexSequence = moved
  // 获取最长递增序列
  ? getSequence(newIndexToOldIndexMap)
  : EMPTY_ARR
  
  j = increasingNewIndexSequence.length - 1

  for (i = toBePatched - 1; i >= 0; i--) {
    const nextIndex = s2 + i
    const nextChild = c2[nextIndex] as VNode
    const anchor = extIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor
    // 0 新建 Vnode
    if (newIndexToOldIndexMap[i] === 0) {
      patch(null,nextChild,...)
    } else if (moved) {
      // 移动节点
      if (j < 0 || i !== increasingNewIndexSequence[j]) {
        move(nextChild, container, anchor, MoveType.REORDER)
      } else {
        j--
      }
    }
  }
}
```

## 打包优化

> tree-shaking：模块打包`webpack`、`rollup`等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于`import`和`export`语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。

以`nextTick`为例子，在 Vue2 中，全局 API 暴露在 Vue 实例上，即使未使用，也无法通过`tree-shaking`进行消除。

Vue3 中针对全局 和内部的API进行了重构，并考虑到`tree-shaking`的支持。因此，全局 API 现在只能作为ES模块构建的命名导出进行访问。

```
import { nextTick } from  vue 
nextTick(() => {
  // 一些和DOM有关的东西
})
```

通过这一更改，只要模块绑定器支持`tree-shaking`，则 Vue 应用程序中未使用的api将从最终的捆绑包中消除，获得最佳文件大小。受此更改影响的全局API有如下。

- Vue.nextTick
- Vue.observable （用 Vue.reactive 替换）
- Vue.version
- Vue.compile （仅全构建）
- Vue.set （仅兼容构建）
- Vue.delete （仅兼容构建）

内部 API 也有诸如 transition、v-model等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。

根据 尤大 直播可以知道如今 Vue3 将所有运行功能打包也只有`22.5kb`，比 Vue2 轻量很多。

## 自定义渲染API

Vue3 提供的`createApp`默认是将 template 映射成 html。但若想生成`canvas`时，就需要使用`custom renderer api`自定义render生成函数。

```js
// 自定义runtime-render函数
import { createApp } from  ./runtime-render 
import App from  ./src/App 
 
createApp(App).mount( #app )
```

## TypeScript 支持

Vue3 由TS重写，相对于 Vue2 有更好地`TypeScript`支持。

- Vue2 `Option API`中 option 是个简单对象，而TS是一种类型系统，面向对象的语法，不是特别匹配。
- Vue2 需要`vue-class-component`强化vue原生组件，也需要`vue-property-decorator`增加更多结合Vue特性的装饰器，写法比较繁琐。

# 自执行函数

**一、函数的声明与执行**

函数申明方式

```
    // 声明函数fun0
    function fun0(){
        console.log("fun0");
    }

    //执行函数fun0
    fun0(); // fun0
```

变量赋值方式

```
    // 声明函数fun1 - 变量方式
    var fun1 = function(){
        console.log("fun1");
    }

    // 执行函数fun1
    fun1(); // fun1
```

**二、 函数的一点猜想**

既然函数名加上括号`fun1()`就是执行函数。 **思考：**直接取赋值符号右侧的内容直接加个括号，是否也能执行？ 试验如下，直接加上小括弧：

```javascript
    function(){
        console.log("fun");
    }();
```

以上会报错 line1：`Uncaught SyntaxError: Unexpected token (`。 **分析：** `function` 是声明函数关键字，若非变量赋值方式声明函数，默认其后面需要跟上函数名的。

加上函数名看看：

```javascript
    function fun2(){
        console.log("fun2");
    }();
```

以上会报错 line3：`Uncaught SyntaxError: Unexpected token )`。 **分析：** 声明函数的结构花括弧后面不能有其他符号（比如此处的小括弧）。

不死心的再胡乱试一下，给它加个实参（表达式）：

```javascript
    function fun3(){
        console.log("fun3");
    }(1);
```

不会报错，但不会输出结果`fun3`。 **分析：** 以上代码相当于在声明函数后，又声明了一个毫无关系的表达式。相当于如下代码形式：

```javascript
    function fun3(){
        console.log("fun3");
    }

(1);

// 若此处执行fun3函数，可以输出结果
fun3(); //"fun3"
```

**三、自执行函数表达式**

**1. 正儿八经的自执行函数**

想要解决上面问题，可以采用小括弧将要执行的代码包含住（方式一），如下：

```javascript
// 方式一
    (function fun4(){
        console.log("fun4");
    }()); // "fun4"
```

**分析：**因为在JavaScript语言中，`()`里面不能包含语句（只能是表达式），所以解析器在解析到`function`关键字的时候，会把它们当作function表达式，而不是正常的函数声明。 

除了上面直接整个包含住，也可以只包含住函数体（方式二），如下：

```javascript
// 方式二
    (function fun5(){
        console.log("fun5");
    })();// "fun4"
```

写法上建议采用方式一（这是参考文的建议。但实际上，我个人觉得方式二比较常见）。

**2. “歪瓜裂枣”的自执行函数**

除了上面`()`小括弧可以把`function`关键字作为函数声明的含义转换成函数表达式外，JavaScript的`&&` 与操作、`||`或操作、`,`逗号等操作符也有这个效果。

```javascript
    true && function () { console.log("true &&") } (); // "true &&"
    false || function () { console.log("true ||") } (); // "true ||"
    0, function () { console.log("0,") } (); // "0,"

// 此处要注意： &&, || 的短路效应。即： false && (表达式1)  是不会触发表达式1；
// 同理，true || (表达式2) 不会触发表达式2
```

如果不在意返回值，也不在意代码的可读性，我们甚至还可以使用一元操作符（`!` `~` `-` `+` ），函数同样也会立即执行。

```javascript
    !function () { console.log("!"); } (); //"!"
    ~function () { console.log("~"); } (); //"~"
    -function () { console.log("-"); } (); //"-"
    +function () { console.log("+"); } (); //"+"
```

甚至还可以使用`new`关键字：

```javascript
// 注意：采用new方式，可以不要再解释花括弧 `}` 后面加小括弧 `()` 
new function () { console.log("new"); } //"new"

// 如果需要传递参数
new function (a) { console.log(a); } ("newwwwwwww"); //"newwwwwwww"
```

嗯，最好玩的是赋值符号`=`同样也有此效用（例子中的`i`变量方式）：

```javascript
//此处 要注意区分 i 和 j 不同之处。前者是函数自执行后返回值给 i ；后者是声明一个函数，函数名为 j 。
    var i = function () { console.log("output i:"); return 10; } (); // "output i:"
    var j = function () { console.log("output j:"); return 99;}
    console.log(i); // 10
    console.log(j); // ƒ () { console.log("output j:"); return 99;}
```

上面提及到，要注意区分 `var i`和 `var j` 不同之处（前者是函数自执行后返回值给`i` ；后者是声明一个函数，函数名为`j`）。如果是看代码，我们需要查看代码结尾是否有没有`()`才能区分。一般为了方便开发人员阅读，我们会采用下面这种方式：

```javascript
    var i2 = (function () { console.log("output i2:"); return 10; } ()); // "output i2:"
    var i3 = (function () { console.log("output i3:"); return 10; }) (); // "output i3:"
// 以上两种都可以，但依旧建议采用第一种 i2 的方式。（个人依旧喜欢第二种i3方式）
```

**四、自执行函数的应用**

**1. for循环 + setTimeout 例子**

因为是全局变量，所以输出都是同一个值

```
for( var i=0;i<3;i++){
    setTimeout(function(){
        console.log(i);
    }
    ,300);
}
// 输出结果 3,3,3
```

那怎么样才能输出`1,2,3`呢？ 看看下面的方式（写法一）：把`setTimeout`代码包含在匿名自执行函数里面，就可以实现“锁住”索引`i`，正常输出索引值。

```javascript
for( var i=0;i<3;i++){
    (function(lockedIndex){
        setTimeout(function(){
            console.log(lockedIndex);
        }
        ,300);
    })(i);
}
// 输出 "1,2,3"
```

**分析**：尽管循环执行结束，`i`值已经变成了3。但因遇到了自执行函数，当时的`i`值已经被 `lockedIndex`锁住了。也可以理解为 自执行函数属于for循环一部分，每次遍历`i`，自执行函数也会立即执行。所以尽管有延时器，但依旧会保留住立即执行时的`i`值。 *上面的分析有点模糊和牵强，也可以从* ***闭包\*** *角度出发分析的。*

除了上面的写法，也可以直接在 `setTimeout` 第一个参数做自执行（写法二），如下：

```javascript
for( var i=0;i<3;i++){
    setTimeout((function(lockedInIndex){
        console.log(lockedInIndex);
    })(i)
    ,300);
}
```

```js
// 1. lockedInIndex变量，也可以换成i，因为和外面的i不在一个作用域
for( var i=0;i<3;i++){
    (function(i){
        setTimeout(function(){
            console.log(i); // 1,2,3
        }
        ,300);
    })(i);
}

for( var i=0;i<3;i++){
    setTimeout((function(i){
        console.log(i); // 1,2,3
    })(i)
    ,300);
}

// 2. 自执行函数不带入参数 
for( var i=0;i<3;i++){
    (function(){
        setTimeout(function(){
            console.log(i); // 3,3,3
        }
        ,300);
    })();
}

for( var i=0;i<3;i++){
    setTimeout((function(){
        console.log(i); // 1,2,3
    })()
    ,300);
}

// 3. 自执行函数只有实参没有写形参
for( var i=0;i<3;i++){
    (function(){
        setTimeout(function(){
            console.log(i); // 3,3,3
        }
        ,300);
    })(i);
}

for( var i=0;i<3;i++){
    setTimeout((function(){
        console.log(i); // 1,2,3
    })(i)
    ,300);
}

// 4. 自执行函数只有形参没有写实参，这种情况不行。因为会导致输出 undefined。
for( var i=0;i<3;i++){
    (function(i){
        setTimeout(function(){
            console.log(i); // undefined,undefined,undefined
        }
        ,300);
    })();
}

for( var i=0;i<3;i++){
    setTimeout((function(i){
        console.log(i); // undefined,undefined,undefined
    })()
    ,300);
}
```



# 任职资格

**字节跳动**

1、本科及以上学历，扎实的计算机基础和前端基础；
2、熟练掌握React/Vue等大型前端框架，理解底层原理，能够灵活运用；
3、了解跨客户端/全栈 其中的一种技术体系，理解相关底层原理；
4、熟悉前端工程化相关及原理，具备良好的架构设计和工程设计能力；
5、有全栈实践，熟悉 Node/Python/Go 加分；
6、有跨端开发经验（React Native/Weex/Flutter）加分；
7、有Web游戏开发或引擎开发，音视频相关实践经验加分。

# Z_Typora常用用法

## 低层级目录

一、

1.

(1.)

a.

# 一行代码让网站变成灰色

```
// 将图像转换为灰度图像。值定义转换的比例。percent 值为 100% 则完全转为灰度图像，值为 0% 图像无变化。
filter: grayscale(100%)
```

# 华为术语

版本生命周期策略GA到EOS,一般GA->EOM->EOP->EOFS->EOS过程。

1，GA：发布，通用可获得性；

2，EOM：停止销售即停止接单，End of Marketing；

单板/部件EOM：停止接受单板、部件订单（包括新建订单、扩容和备件订单）；
产品EOM：停止接受该产品的订单（包括新建订单和扩容订单）；
版本EOM：停止接受该软件版本的订单（包括新建订单和扩容订单）；

3，EOP：停止生产，End of Production；

4，EOFS：停止全面支持，End of Full Support,对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复。

单板/部件EOFS: 该点之后对客户提供单板/部件服务标准降低，在EOFS日之后，备件维修服务不为客户提供修复保证，只解决Critical 和 Major 级别的问题；
版本EOFS：对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复；

5，EOS：停止服务和支持，End of Service and Support，不再提供针对该软件版本的服务支持，只能通过升级新版本来解决问题。

单板/部件EOS：指从该日起可不再提供该单板/部件任何服务；
产品EOS：从该日起不再提供该产品任何服务，包括电话支持；
版本EOS：不再提供任何技术服务支持，包含新问题的定位和缺陷修复；

在EOFS、EOS阶段出补丁需要通过例外备案、审批。

# 如何成为一个优秀的人

```
1.要顾全的大局
  不要为了自己的一点私心去做事，大家嘴上不说但都看的到。多了大局去考虑，领导就喜欢这样的人，也愿意提拔爱顾大局的人。

2.做事不古板
  在团队里随时都能发生应急事件，遵守规则制度是应该的。但不可事事太古板，要懂得随机应变，有了处理好应急事件的能力。

3.不逃避责任
  在发生事故的时候，不要逃避责任，更不要给自己找垫背的。优秀的人才都是能够承担责任的，事故不可能总有，也不可能总没有，如果次次都选择逃避，还怎么做优秀
  人物。

4.愿意帮助每个队员
  收拢人心很要，你能力再强，别人又为什么要选你呢，那是因为你身上有闪光点。而对队员来说，你对大家给予的真诚帮助，就能帮你赢得一大片人心。

5.取长补短
  这也是最重要的一条，你拥有了别人不会的技术，又是团队必须具备的技术。你就成了技术骨干了，多去学习别的长处，将自身的短处补齐。
```

# 自动化测试

## 思想先行

**TDD：Test-Driven Development（测试驱动开发）**

> TDD 则要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行

**BDD：Behavior-Driven Development（行为驱动开发）**

> BDD 可以让项目成员（甚至是不懂编程的）使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试

## 为什么要测试？

- 提高代码质量
- 准确定位问题
- 方便迭代/重构
- 最大程度保证产品符合预期
- 减少回归流程
- 提升开发者信心和安全感

## 测试类型有哪些？

- **单元测试（Unit Test）**
- **集成测试（Integration Test）**
- **UI 测试（UI Test）**

**单元测试（Unit Test）**

> 单元测试是最容易实现的：代码中多个组件共用的工具类库、多个组件共用的子组件等。
>
> **通常情况下，在公共函数/组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。**
>
> 能进行单元测试的函数/组件，一定是低耦合的，这也从一定程度上保证了我们的代码质量。

**集成测试（Integration Test）**

> 集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。
>
> 集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。

**UI 测试（UI Test）**

> UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。
>
> UI 测试（UI Test）更贴近于我们的开发流程。在前后端分离的开发模式中，前端开发通常会使用到 Mock 的服务器和数据。因而我们需要在开发基本完成后进行相应的 UI 测试（UI Test）。
>
> UI 测试的自动化程度还不高，大多数还依赖于手工测试。
>
> 在一些自动化测试工具中有创建快照的功能，也能帮助我们在一定程度上实现 UI 测试（UI Test）的自动化。

## 哪些项目适合自动化测试？

大部分的开发都会觉得：需求这么多，这么紧急，保证完成需求都已经非常困难了，已经没精力再编写测试代码了。

现实中，我们经常会针对一些活动开发一些一次性的代码模块，这样的代码模块功能简单，且后续继续迭代的可能性低，这种代码就完全没有必要引入自动化测试工具。

**适合引入自动化测试的场景：**

1. 公共库类的开发维护
2. 中长期项目的迭代/重构
3. 引用了不可控的第三方依赖

这些场景是需要引入自动化测试来对现有代码进行约束的。**尤其是中长期项目，迭代/重构时人力回归困难，自动化测试就显得尤为重要！**

## 测试工具有哪些？

- 单元测试（Unit Test）有 Mocha, Ava, Karma, Jest, Jasmine 等。
- 集成测试（Integration Test）和 UI 测试（UI Test）有 ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils 等。

**Mocha**

> Mocha 是生态最好，使用最广泛的单测框架，但是他需要较多的配置来实现它的高扩展性。

**Ava**

> Ava 是更轻量高效简单的单测框架，但是自身不够稳定，并发运行文件多的时候会撑爆 CPU。

**Jasmine**

> Jasmine 是单测框架的“元老”，开箱即用，但是异步测试支持较弱。

**Jest**

> Jest 基于 Jasmine, 做了大量修改并添加了很多特性，同样开箱即用，但异步测试支持良好。

**Karma**

> Karma 能在真实的浏览器中测试，强大适配器，可配置其他单测框架，一般会配合 Mocha 或 Jasmine 等一起使用。

每个框架都有自己的优缺点，没有最好的框架，只有最适合的框架。

Vue和React 的默认测试框架是 Jest，Augular 的默认测试框架就是 Karma + Jasmine

# 推荐书籍

javascript dom编程艺术

javascript高级程序设计（红宝书） 和javascript权威指南（犀牛书）

Vuejs设计与实现

javascript忍者秘籍

javascript设计模式与开发实践

学习javascript数据结构和算法

前端开发核心知识进阶

javascript迷你正则书

你不知道的javascript （小黄书）

Javascript20周年（历史书）

javascript语言精粹与编程实践

啊哈算法，小灰说算法

# 掘金夜谈-第一期尤雨溪对话Vue

视频地址：[尤大对话](https://live.juejin.cn/4354/vue3)

**尤对吐槽**

尤对吐槽 [React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) hooks 的缺点：心智负担，闭包陷阱，useEffect 的依赖项等等.

其实不然。

> 首先闭包陷阱的由来在于大家对于闭包的理解不够深刻，因此在使用部分 hooks 的时候，对于某些闭包的产生无法感知到。实际上闭包陷阱的逻辑如果成立的话，并不仅仅存在于 React hooks 中，而是存在于 JavaScript 的所有可能出现的场景。特别是匿名函数这种弱感知的场景。
>
> useEffect 的依赖问题其实在我看来不仅不是 hooks 的缺点，反而是 hooks 的优点。useEffect 的依赖项能够帮助我们监听单一数据以驱动多个数据，于是我们就可以借助这个特性完成单数据驱动多数据，再由多数据驱动 UI 的开关思维。能够极大的简化我们的开发，提升开发效率。

**Vue3尖锐问题**

1.vue3 与 ts 的结合

 vue3 与 ts 的结合不够完善的事情。主要是 props 的定义方式与泛型组件的问题。

> 尤大解释：Props 值定义确实是一个兼容性导致的包袱。但是在 <script setup> 下已经支持直接用 defineProps<{...}> 类型声明 props 了（自动编译为对应的值声明）。

2.Vue3不支持跨端

 Vue 团队没有精力去做这些事情，只有公司级别的体量才有能力去做，因为跨端的支持确实很复杂。

**Vue4新变化**

vue 会借鉴 solid 的编译模式。solid 是一个摈弃了虚拟 DOM，走编译型路线的框架，别的不说，他的性能是能吊打目前的 Vue 与 React。

**郭辉：低代码，无代码**

财务公司(金蝶)在低代码做得非常成熟，但是呢，大多数团队都做得不是很好。主要的原因在于许多场景业务逻辑比较复杂，不通用，无法抽象。也就导致了低代码的实现成为了一种愿景。

许多团队在攻克组件渲染这一层的东西，但是实际上这些都是比较简单的，不是项目的核心痛点。也就是说，郭老师觉得他们的方向走错了。

低代码仅仅只适合逻辑抽象比较简单，比较通用的场景。例如发票。业务逻辑抽象比较容易。toB 的业务逻辑是无法解决的。

# args剩余参数与arguments函数形参类数组

**args**

定义：只包含那些没有对应形参的实参。将所有后面剩余的是实参个数包裹成一个数组。

- 展开运算符
- 用于解构赋值
- 类数组对象变成数组

> **var** arr1=['a','b','c']; **var** arr2=['d','e'];arr1.**push**(...arr2)
>
> **let** b=[...new Set([1,2])]

**arguments对象**

1.定义：包含了传给函数的所有实参。在函数代码中，使用特殊对象 `arguments`，开发者无需明确指出参数名，就能访问它们。它是一个类数组，不是数组。

```js
function test(a, b, c) {
  console.log(arguments) // Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ] 
  console.log(test.length) // 3
  console.log(arguments.callee.length) // 3
  console.log(Array.apply(null, arguments))
}

test(1,2,3,4)
其中arguments 代表的是函数实参的个数
其中fn.length 代表函数形参的个数
其中arguments.callee 指向函数本身
```

2.提取参数

```js
var args = Array.prototype.slice.call(arguments);
var args = [].slice.call(arguments);

// ES2015
const args = Array.from(arguments);
const args = [...arguments];
```

> **警告：** 对参数使用 slice 会阻止某些 JavaScript 引擎中的优化 (比如 V8 - [更多信息](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments))。如果你关心性能，尝试通过遍历 arguments 对象来构造一个新的数组。另一种方法是使用被忽视的`Array`构造函数作为一个函数：
>
> ```
> var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));
> ```

3.一般模式和严格模式下arguments

- 一般模式：如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的
- 严格模式：arguments和参数是双向绑定的

(1)一般模式

直接上代码，先来看调用时缺省参数的情况

```
function a1(x) {
    x = 2;
    console.log(x, arguments[0]);
}
a1(); // 2 undefined

function a2(x) {
    arguments[0] = 2;
    console.log(x, arguments[0]);
}
a2(); // undefined 2
```

再来看调用时传入参数的情况

```
function a3(x) {
    x = 2;
    console.log(x, arguments[0]);
}
a3(1); // 2 2

function a4(x) {
    arguments[0] = 2;
    console.log(x, arguments[0]);
}
a4(1); // 2 2
```

可以看到如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的。

(2)严格模式

再来看看严格模式，直接上代码

```
function b1(x) {
    'use strict';
    x = 2;
    console.log(x, arguments[0]);
}
b1(); // 2 undefined

function b2(x) {
    'use strict';
    arguments[0] = 2;
    console.log(x, arguments[0]);
}
b2(); // undefined 2

function b3(x) {
    'use strict';
    x = 2;
    console.log(x, arguments[0]);
}
b3(1); // 2 1

function b4(x) {
    'use strict';
    arguments[0] = 2;
    console.log(x, arguments[0]);
}
b4(1); // 1 2
```

在严格模式下，无论参数是否缺省，arguments和参数都是隔离开的。

# CJS, AMD, UMD 和 ESM是什么

- 由于 `ESM` 具有简单的语法，异步特性和可摇树性，因此它是最好的模块化方案
- `UMD` 随处可见，通常在 `ESM` 不起作用的情况下用作备用
- `CJS` 是同步的，适合后端
- `AMD` 是异步的，适合前端

**1.CJS**

`CJS` 是 `CommonJS` 的缩写。经常我们这么使用：

```javascript
// importing 
const doSomething = require('./doSomething.js'); 

// exporting
module.exports = function doSomething(n) {
  // do something
}
复制代码
```

- 很多人可以从 `Node` 中立刻认出 `CJS` 的语法。这是因为 `Node` 就是使用 [`CJS` 模块](https://link.juejin.cn?target=https%3A%2F%2Fblog.risingstack.com%2Fnode-js-at-scale-module-system-commonjs-require%2F)的
- `CJS` 是同步导入模块
- 你可以从 `node_modules` 中引入一个库或者从本地目录引入一个文件 。如 `const myLocalModule = require('./some/local/file.js')` 或者 `var React = require('react');` ，都可以起作用
- 当 `CJS` 导入时，它会给你一个导入对象的副本
- `CJS` 不能在浏览器中工作。它必须经过转换和打包

**2.AMD**

`AMD` 代表异步模块定义。

```js
define(['dep1', 'dep2'], function (dep1, dep2) {
    //Define the module value by returning a value.
    return function () {};
});
或者
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');
    return function () {};
});
```

- `AMD` 是异步(`asynchronously`)导入模块的(因此得名)
- 一开始被提议的时候，`AMD` 是为前端而做的(而 `CJS` 是后端)
- `AMD` 的语法不如 `CJS` 直观。我认为 `AMD` 和 `CJS` 完全相反

**3.UMD**

`UMD` 代表通用模块定义（`Universal Module Definition`）

- 在前端和后端都适用（“通用”因此得名）
- 兼容 CommonJS 和 AMD 规范
- 当使用 `Rollup/Webpack` 之类的打包器时，`UMD` 通常用作备用模块

**4.ESM**

`ESM` 代表 `ES` 模块。这是 `Javascript` 提出的实现一个标准模块系统的方案.

```js
import {foo, bar} from './myLib';

...

export default function() {
  // your Function
};
export const function1() {...};
export const function2() {...};
```

- 在很多[现代浏览器](https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2Fes6-module)可以使用
- 它兼具两方面的优点：具有 `CJS` 的简单语法和 `AMD` 的异步
- 得益于 `ES6` 的[静态模块结构](https://link.juejin.cn?target=https%3A%2F%2Fexploringjs.com%2Fes6%2Fch_modules.html%23sec_design-goals-es6-modules)，可以进行 [ Tree Shaking](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Foptimizing-javascript%2Ftree-shaking%2F)
- `ESM` 允许像 `Rollup` 这样的打包器，[删除不必要的代码](https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Fbennypowers%2Fyou-should-be-using-esm-kn3)，减少代码包可以获得更快的加载
- 可以在 `HTML` 中调用，只要如下

```javascript
<script type="module">
  import {func1} from 'my-lib';

  func1();
</script>
```



# NPM

初始化项目

```
npm init -y
```