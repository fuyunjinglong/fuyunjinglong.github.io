---
title: 权限认证和权限认证
date: 2022-05-13 06:33:16
categories:
- D_框架和类库
toc: true # 是否启用内容索引
---

# 术语

**认证**

> `认证(Identification)` 是指根据声明者所特有的识别信息，确认声明者的身份。

**授权**

> `授权(Authorization)`： 在信息安全领域是指`资源所有者`委派`执行者`，赋予`执行者`指定范围的资源操作权限，以便对资源的相关操作。

**鉴权**

> `鉴权(Authentication)` 在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。
>
> 若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。

**权限控制**

> `权限控制(Access/Permission Control)` 将可执行的操作定义为权限列表，然后判断操作是否允许/禁止
>
> 对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。

**认证、授权、鉴权和权限控制的关系？**

它们有先后的依赖关系：认证—>授权—>鉴权—>权限控制

# 权限认证

## 鉴权-Session-Cookie

`Session-Cookie` 认证是利用服务端的 **Session（会话**）和 **浏览器（客户端）** 的 Cookie 来实现的前后端通信认证模式。

**Session-Cookie认证流程图**

<img src="/img/image-20230323221549533.png" alt="image-20230323221549533" style="zoom:65%;" />

**认证流程**

> 1. 客户端： 向服务器发送登录信息用户名/密码来请求登录校验；
> 2. 服务器： 验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 session_id(通常称为 sid)，并在响应头 Set-Cookie 中设置这个唯一标识符；
> 3. 客户端： 收到服务器的响应后会解析响应头，并自动将 sid 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；
> 4. 服务器： 接收客户端请求时会去解析请求头 Cookie 中的 sid，然后根据这个 sid 去找服务端保存的该客户端的 sid，然后判断该请求是否合法

**优点**

>- Cookie 简单易用
>- Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理
>- 只需要后端操作即可，前端可以无感等进行操作；

**缺点**

> - 依赖 Cookie，一旦用户在浏览器端禁用 Cookie，那么就 GG 思密达了；
> - 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）；
> - Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；
> - 对移动端的支持性不友好；

## 鉴权-Token

 为了解决Session 的维护和存储问题，才有了Token。

`Token` 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。

**一般 Token 的组成**

> **uid** (用户唯一的身份标识) + **time** (当前时间的时间戳) + **sign** (签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串)

**Token 的认证流程图**截图https://mybj123.com/17234.html

**认证流程**

> - 客户端： 输入用户名和密码请求登录校验；
> - 服务器： 收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端；
> - 客户端： 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中；
> - 客户端发送请求： 向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端；
> - 服务器： 收到请求，然后从客户端请求取出Token包含的用户信息，查库验证

**优点**

> - **服务端无状态化、可扩展性好：** Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态
> - **支持 APP 移动端设备；**
> - **安全性好：** 有效避免 CSRF 攻击（因为不需要 Cookie）
> - **支持跨程序调用：** 因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题

**缺点**

> - **配合：** 需要前后端配合处理；
> - **占带宽：** 正常情况下比 `sid` 更大，消耗更多流量，挤占更多宽带
> - **性能问题：** 需要访问数据库或远程服务进行权限校验，对 Token 加解密等操作，会更耗性能；
> - **有效期短：** 为了避免 Token 被盗用，一般 Token 的有效期会设置的较短，所以就有了 `Refresh Token`；

**Refresh Token**

业务接口用来鉴权的 Token，我们称之为 `Access Token`。但过短的有效期会造成 `Access Token` 经常过期，过期后怎么办呢？

方案有2种：

> - `刷新 Access Token`，让用户重新登录获取新 Token
> - 再来一个 Token，一个专门生成 Access Token 的 Token，我们称为 `Refresh Token`

定义

> - **Access Token：** 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活；
> - **Refresh Token：** 用来获取 Access Token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 Session 一样处理；

**Refresh Token 的认证流程图**截图https://mybj123.com/17234.html

认证流程：

> 1. **客户端：** 输入用户名和密码请求登录校验；
> 2. **服务端：** 收到请求，验证用户名与密码；验证成功后，服务端会签发一个 `Access Token` 和 `Refresh Token` 并返回给客户端；
> 3. **客户端：** 把 `Access Token` 和 `Refresh Token` 存储在本地；
> 4. **客户端发送请求：** 请求数据时，携带 `Access Token` 传输给服务端；
> 5. 服务端：
>    - 验证 Access Token 有效：正常返回数据
>    - 验证 Access Token 过期：拒绝请求
> 6. **客户端** ( Access Token 已过期) **：** 则重新传输 Refresh Token 给服务端；
> 7. **服务端** ( Access Token 已过期) **：** 验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端；
> 8. **客户端：** 重新携带新的 Access Token 请求接口；

**Token 和 Session-Cookie 的区别**

`Token` 更像是 `Session-Cookie` 的升级改良版

> - **存储地不同：** Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；
> - **安全性不同：** Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击；
> - **支持性不同：** Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。

## 鉴权-JWT

Token每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；所以有了JWT。

`JWT` 是 `Auth0` 提出的通过 `对 JSON 进行加密签名`来实现授权验证的方案；

**JWT 的组成**

三部分组成：Header 头部`、 `Payload 负载` 和 `Signature 签名

Header 头部

> - typ：代表 Token 的类型，这里使用的是 JWT 类型；
> - alg：使用的 Hash 算法，例如 HMAC SHA256 或 RSA.

Payload 负载

它包含一些声明 Claim (实体的描述，通常是一个 User 信息，还包括一些其他的元数据) ，用来存放实际需要传递的数据

> - iss (issuer)：签发人
> - exp (expiration time)：过期时间
> - sub (subject)：主题
> - aud (audience)：受众
> - nbf (Not Before)：生效时间
> - iat (Issued At)：签发时间
> - jti (JWT ID)：编号

Signature 签名

Signature 部分是对前两部分的签名，防止数据篡改。

指定一个密钥（secret）,然后使用 Header 里面指定的签名算法（默认是 HMAC SHA256）产生签名。

**JWT 的认证流程图**截图https://mybj123.com/17234.html

**优点**

> - 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况；
> - JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数

**缺点**

> - **加密问题：** JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
> - **到期问题：** 由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

**前端常用的JWT库**

> - 使用 express：[express-jwt](https://mybj123.com/gohref.php?url=https://github.com/auth0/express-jwt)
> - 使用 koa：[koa-jwt](https://mybj123.com/gohref.php?url=https://github.com/koajs/jwt)

## 鉴权-SSO单点登录

前面解决了在同域下的客户端/服务端认证系统中，通过客户端携带凭证，可以维持一段时间内的登录状态。但一个大型系统里可能包含 n 多子系统，用户在操作不同的系统时，需要多次登录，很麻烦，单点登录（SSO)解决了这个问题。

### 同域下的 SSO（主域名相同）

当网站存在两个相同主域名下的贴吧子系统 `media.mybj123.com` 和网盘子系统 `pan.mybj123.com` 时，以下为他们实现 SSO 的步骤：

>1. **客户端：** 用户访问某个子系统时（例如 `media.mybj123.com`），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；
>2. **服务端：** 登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 `Set-Cookie` 字段中，设置 Cookie 的 Domain 为 `.baidu.com` ；
>3. 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；

以上流程本质是鉴权-Session-Cookie

### 跨域下的 SSO（主域名不同）

比如天猫 和 淘宝的互相登录访问，采用了CAS（Central Authentication Service）中央授权服务。

**单点登录下的 CAS 认证流程图**截图https://mybj123.com/17234.html

认证流程：

> 1. **客户端：** 开始访问系统 A；
> 2. **系统 A：** 发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（[sso.com/login?redir…](https://mybj123.com/gohref.php?url=https://sso.com/login?redirectURL=https://www.taobao.com）；)
> 3. **CAS 认证服务：** 发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 `未登录` 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。
> 4. **客户端：** 输入用户名密码进行 CAS 系统认证；
> 5. **CAS 认证服务：** 校验用户信息，并且 `生成 TGC` 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 `sso. com` 的域下 ；同时生成一个 `授权令牌 ST (Service Ticket)` ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：[www.taobao.com?token=ST-345678）](https://mybj123.com/gohref.php?url=https://www.taobao.com?token=ST-345678)
> 6. **系统 A：** 拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；
> 7. **客户端：** 开始访问系统 B；
> 8. **系统 B：** 发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；
> 9. **CAS 认证服务：** CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ;
> 10. **系统 B：** 拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~

注意点：

> - 如图中流程所示，我们发现 `CAS 认证服务` 在签发的 `授权令牌 ST` 后，直接重定向，这样其实是比较容易容易被窃取，那么我们需要在系统 A 或者系统 B 在向 CAS 验证成功 (如图中的第 14 步和第 11 步) 后，再生成另一个新的验证 Token 返回给客户端保存；
> - CAS 一般提供四个接口：
>   - `/login`：登录接口，用于登录到中央授权服务
>   - `/logout`：登出接口，用于从中央授权服务中登出
>   - `/validate`：用于验证用户是否登录中央授权服务
>   - `/serviceValidate`：用于让各个 Service 验证用户是否登录中央授权服务
> - CAS 生成的票据：
>   - **TGT（Ticket Grangting Ticket）** ：TGT 是 CAS 为用户签发的 `登录票据`，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。
>   - **TGC：Ticket Granting Cookie：** CAS Server 生成TGT放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionId），以 Cookie 形式放到浏览器端，是 CAS Server 用来明确用户身份的凭证。
>   - **ST（Service Ticket）** ：ST 是 CAS 为用户签发的访问某个 Service 的票据。

## 鉴权-OAuth 2.0

通过第三方的 QQ 或者 微信登录，这就用到了 **OAuth** 。

**OAuth** 是一个开放标准，允许用户授权第三方网站 (CSDN、思否等) 访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站；

常见的提供 OAuth 认证服务的厂商： `支付宝、QQ、微信、微博`

> **简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（Token），用来代替密码，供第三方应用使用。**

OAuth 2.0 颁发令牌一共分成**四种授权**模式 **（Authorization Grant）**

无论哪个模式都拥有三个必要角色：`客户端`、`授权服务器`、`资源服务器`，有的还有`用户（资源拥有者）`

**1.授权码模式**

`授权码（Authorization Code Grant)` 方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。

这种方式是最常用的流程，安全性也最高，它适用于那些**有后端服务**的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。

一句话概括：`客户端换取授权码，客户端使用授权码换token，客户端使用token访问资源`

**2.隐藏式模式（Implicit Grant）**

有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。**OAuth2.0 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。**

一句话概括：`客户端让用户登录授权服务器换token，客户端使用token访问资源`。

**3.用户名密码式模式（Password Credentials Grant）**

如果你高度信任某个应用，OAuth 2.0 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。

**一句话概括：用户在客户端提交账号密码换token，客户端使用token访问资源。**

**4.客户端模式（Client Credentials Grant）**

客户端模式指客户端以自己的名义，而不是以用户的名义，向`授权服务器` 进行认证。

主要适用于没有前端的命令行应用。

一句话概括：`客户端使用自己的标识换token，客户端使用token访问资源`。

## 鉴权-唯一登录

我想要实现用户只能在一个设备上登录，禁止用户重复登录。

**唯一登录流程图**截图https://mybj123.com/17234.html

认证流程：

> **用户在客户端 A 操作：**
>
> 1. 输入账号请求登录接口；
> 2. 后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态；
> 3. 客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token；
>
> **用户在客户端 B 操作：**
>
> 突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的；
>
> 只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token；

## 鉴权-QR Code扫码登录

二维码为 QR Code，QR 全称 Quick Response。扫码登录需要三端 (`PC端`、`手机端`、`服务端`) 来进行配合才能达到登录。

**扫码登录的认证流程图**截图https://mybj123.com/17234.html

认证流程：

> 待扫码阶段：
>
> 1. **PC端：**打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求；
> 2. **服务端：**服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 `PC 端的设备信息` 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。
> 3. **PC 端：**收到二维码 ID 之后，将二维码 ID 以 `二维码的形式` 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。如果移动端未扫描，那么一段时间后二维码会自动失效。
>
> 已扫码待确认阶段：
>
> 1. **手机端：**打开手机端对应**已登录**的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。
> 2. **服务端：**收到手机端发来的请求后，会将 `Token 与二维码 ID` 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。
>
> 已确认阶段：
>
> 1. **手机端：**收到确认信息后，点击确认按钮，移动端携带上一步中获取的 `临时 Token` 发送给服务端校验；
> 2. **服务端：**服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 `正式的 Token`，后续 PC 端就是持有这个 Token 访问服务端。
> 3. **PC端：**轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。

## 小结

> - `Session-Cookie` 适用于一般中大型的网站（移动端 APP 除外）；
> - `Token` 和 `JWT` 都适用于市面上大部分的企业型网站，JWT 效能会优于 Token；
> - `单点登录` 适用于子系统较多的大型企业网站；
> - `OAuth 2.0`适用于需要快速注册用户型的网站；
> - `扫码登录` 适用于已完成部署了三端的企业；

## 参考

[前端与后端鉴权方案有哪些？看这篇就够了](https://mybj123.com/17234.html)

# 权限控制

## 接口权限

使用axios请求拦截器实现

## 按钮权限

使用自定义指令实现

## 页面菜单权限

我们没有去某个页面的导航菜单，实际上就是没有去那个页面的权限了，所以说页面权限的实际就是菜单权限。

获取菜单权限列表，动态递归生成菜单

## 路由权限

- 使用Router.beforeEach来判断
- 获取路由权限列表，借助route.add() 动态生成路由表

**参考**

[面试官：Vue要做权限管理该怎么做](https://github.com/febobo/web-interview/issues/29)

[如何用 Vue实现前端权限控制](https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw)

[前端面试必备——权限控制](https://segmentfault.com/a/1190000020887109)

[vue权限路由实现方式总结](https://juejin.cn/post/6844903648057622536#heading-6)