---
title: 0基础
date: 2021-11-06 06:33:16
categories:
- H_工程热点
toc: true # 是否启用内容索引
---

# 前端工程化

**工程化本质**

DevOps即Development和Operations的组合词，是一组**过程、方法与系统**的统称。

从DevOps软件开发角度出发，设计-》开发-》联调-》测试-》发布。

**工程化解决的问题效率&质量**

项目立项-》需求分析-》产品原型-》开发实施-》测试部署-》上线运行

通过各种工具和技术，提高开发效率和质量。

- 安全内容安全策略=》如ie的activeX策略、
- 代码管理代码实践=》如前后端分离,项目结构、代码结构、代码检查、CI/CD配置，编译器、版本控制、项目配置、系统环境
- 性能问题=》压缩、打包、线上线下优化措施
- 代码复用=》组件化、模块化、服务化
- 多设备兼容=》pollyfill,shim,auto-prefixer,响应式，如android,ios,手表电视，IOT设备的兼容性、分辨率
- 跨平台=》React Native、Weex、Flutter、Hybrid、Electron、uniapp,如android,ios,手表电视，IOT设备的兼容性、分辨率
- 跨端=》web,Node.js,IOT,如移动端，IOT设备等
- 跨场景=》WebXR，WebRTC，WebSocket，如直播场景j跨语言WebAssembly

**重要节点的技术**

uglifyjs,jQuery的前后端分离年代-》V8、nodejs的创世纪-》grunt、gulp本地执行的任务流管理器，产生大量包-》npm和Bower-》css的sass和less优化-》webpack、rollup.js编译打包-》eslint和ts规范-》跨段的方案React Native、Weex、Flutter-》微信小程序、支付宝小程序、百度小程序-》WebAssembly-》PWA-》vite-》deno-》docker4.react的优雅UI=fn(state),一个输入对应一个输出，可以事先知道

**前端在发力的事情**

淘宝直播(webRTC)，webXR(ARVR)、Electron、Flutter,SSR优化、ServiceWorker、 GraphQL 、WebAssembly、Serverless

**按照项目的生命周期来分配：**

- 需求评审：技术选型
- 开发前：统一规范
- 开发中：模块化、组件化
- 开发完：测试
- 编译：构建工具
- 部署：自动化部署
- 上线后：性能监控
- 发现问题：性能优化
- 项目迭代：重构
- 项目巨型化：微服务
- 无服务架构升级：Serverless 

**工程化内容：**

脚手架工具:专用工具(vue-cli,create-react-app,angular-cli,vite),通用工具(Yeoman+generator,Plop)

自动化构建:npm script&script hooks,Grunt，Gulp,FIS

模块化打包：webpack,Rollup,Parcel

标准化规范：Eslint,StyleLint,Prettier

自动化测试：Mocha,Jest,Enzyme,Cypress,Nightmare,Puppeteer

自动化部署：Git Hook，Lint-staged,CI/CD

## 技术选型

- 可控性
- 稳定性
- 适用性
- 易用性

**可控性**

可控，就是指如果这门技术因为 BUG 对项目造成了影响，团队中有人能够解决它，而不是等待官方修复。作为技术团队的负责人，一定要是能够兜底的那个人。如果团队解决不了，你必须能够解决。比如魔改vue,react

**稳定性**

稳定性，表示一门技术更新迭代比较稳定，不会有特别大的修改，比较靠谱。即使有，也很容易做到向后兼容（迁移简单、成本小）。

有两个很典型的反例，那就是 Angular 和 python。例如 python2 升级到 python3，除了语法、API 不兼容之外，python3 的各个版本之间也有差异，直到现在才逐渐稳定下来。

稳定性判断：

> 1. 社区是否活跃、配套插件是否丰富。
> 2. 是否经常维护，可以通过 git commit 查看。
> 3. 官方文档是否齐全。
> 4. 更新是稳定、小步的迭代，而不是非常激进的更新。

**适用性**

适用性，是指需要根据业务场景和团队成员来选择技术。

适用性判断：

> 1. 业务的生命周期：短期js，长期推荐ts
> 2. 业务的兼容性：ios,android，iot,不能有死机、白屏、卡顿
> 3. 团队成员：选择约束性比较强的技术是一个更好的选择，如ts(不会就去学)。要用长远的眼光来为团队考虑，太过自由的技术，往往会造成灾难。

**易用性**

学习曲线相对平缓，而不是陡峭的

## 统一规范

- 代码规范
- git规范
- 项目规范
- UI规范

**代码规范**

- 代码格式
- 命名规范
- 文档注释

出名的js规范：

> - [airbnb (101k star 英文版)](https://github.com/airbnb/javascript)，[airbnb-中文版](https://github.com/lin-123/javascript)
> - [standard (24.5k star) 中文版](https://github.com/standard/standard/blob/master/docs/README-zhcn.md)
> - [百度前端编码规范 3.9k star](https://github.com/ecomfe/spec)

出名的css规范：

> - [styleguide 2.3k star](https://github.com/fex-team/styleguide/blob/master/css.md)
> - [spec 3.9k star](https://github.com/ecomfe/spec/blob/master/css-style-guide.md)

**git规范**

- 分支管理规范
- git commit规范

**项目规范**

- npm管理
- pnpm管理

**UI规范**

- 统一命名
- 统一样式

## 模块化、组件化

- 高内聚 低耦合
- 模块化、组件化
- Web Components

**高内聚 低耦合**

高内聚：一个函数尽量只做一件事，如注册模块，只处理注册逻辑

低耦合：两个模块之间的关联程度低，如注册模块调用其他模块，直接引用其他模块即可，不要直接在注册模块中写其他功能

**模块化、组件化**

模块化：拆分html,css,js，按照功能拆分模块

组件化：按照功能拆分为各个组件

**Web Components**

目前三大框架在构建工具下可很好实现组件化，但如果自己实现呢？

组件化是前端未来的发展方向，[Web Components ](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)就是浏览器原生支持的组件化标准。使用 Web Components API，浏览器可以在不引入第三方代码的情况下实现组件化。

## 测试

原则：程序简单，不用测试代码；功能越复杂，越需要测试代码(如果修改一个复杂项目，你要对所有功能都点击一遍，但有了测试代码，一条命令执行就行)

- 单元测试Unit
- 集成测试Integration
- 端到端测试E2E

## 构建工具

- webpack
- rollup
- vite

## 自动化部署

- Gitea + Jenkins
- Github Actions

## 性能监控

- 事前预警
- 事后分析

**数据上报**

- [sendBeacon](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon)
- [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)
- image

## 性能优化

- 加载时优化
- 运行时优化

**加载时优化**

- 白屏时间
- 首屏时间

**运行时优化**

## 重构

**定义**

《重构2》定义：

> 所谓重构（refactoring）是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。

重构和性能优化都在不改变程序功能的情况下修改代码

- 重构：为了让代码变得更加容易理解、易于修改
- 性能优化：为了让程序运行得更快

**重构的原则**

1. 事不过三，三则重构。即不能重复写同样的代码，在这种情况下要去重构。
2. 如果一段代码让人很难看懂，那就该考虑重构了。
3. 如果已经理解了代码，但是非常繁琐或者不够好，也可以重构。
4. 过长的函数，需要重构。
5. 一个函数最好对应一个功能，如果一个函数被塞入多个功能，那就要对它进行重构了。（4 和 5 不冲突）
6. 重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。

**重构手法**

在[《重构2》](https://book.douban.com/subject/30468597/)这本书中介绍了上百种方法，其中8种比较常用：

1. 提取重复代码，封装成函数
2. 拆分功能太多的函数
3. 变量/函数改名
4. 替换算法
5. 以函数调用取代内联代码
6. 移动语句
7. 折分嵌套条件表达式
8. 将查询函数和修改函数分离



## 微服务

- 小应用，建议还是单独建一个项目开发
- 大应用，使用微前端可以减少开发维护成本

## Serverless 

**定义**

无服务架构。是指由第三方云计算供应商以服务的方式为开发者提供所需功能，例如数据库、消息，以及身份验证等。它的核心思想是让开发者专注构建和运行应用，而无需管理服务器。

优点：

> - 自动扩展伸缩、无需自己管理

缺点：

> - 云上访问速度变得比较慢

**分类**

- Faas(Function as a Service) 函数即服务
- Baas(Backend as a Service) 后端即服务

Faas 其实是一个云计算平台，用户可以将自己写的函数托管到平台上运行。而 Baas 则是提供一系列的服务给用户运用，用户通过 API 调用。

**Faas**

定义

> 一个函数通常用于处理某种业务逻辑，例如一个 `abs()` 函数，它将返回所传参数的绝对值。我们可以把这个函数托管到 Faas 平台，由平台提供容器并运行这个函数。当执行函数时，只需要提供函数所需的参数，就可以在不部署应用的情况下得到函数的执行结果。

**Baas**

定义

> 假设你是一个前端，现在要开发一个网站。前端部分你可以自己完成，但后端部分怎么办呢？这个时候就可以使用 Baas 了。也就是说，你只需编写和维护前端页面。其他的一切，例如数据库、身份验证、对象存储等等都由云服务商提供。你只需要在前端通过 API 调用它们就可以使用所需的服务。

**参考**

[带你入门前端工程化](https://woai3c.github.io/introduction-to-front-end-engineering/12.html#faas)

# 微前端和低代码

**1.微前端**
 **(1)微前端是什么？**
 (1.1)定义
 微前端只是管理这种复杂性的一种方法，通过将产品拆分为更小、更简单的应用程序，这些应用程序可以由独立的自治团队一直交付到生产环境。
 微前端是一种整合项目框架和组织结构的架构思维和方法，不是一种技术。
 缺点：
 前端模块包使用npm构建发布使用。
 开发和维护成本比较高;
 团队协作之间不规范；
 特点：
 独立部署、增量迁移、团队自治、松耦合代码。
 **(1.2)解决的问题**
 大型项目，复杂项目的更新维护。
 解决场景：
 拆分巨型应用，使应用变得更加可维护;
 兼容历史应用，实现增量开发;
 **(1.3)微前端架构方案**
 主要有3种：
 自由组织模式，不借助任何框架，自己开发解决第三方依赖问题;
 基座模式，需要容器作为基座，基于Single-spa的乾坤;
 去中心模式，webpack5新出的模块联邦特性,实现跨技术栈调用，相同技术栈之间实现更加深度的定制;
 1)Systemjs模块化解决方案
 此类解决方案使用的不多。使用起来很不友好。
 关键配置：
 //指定构建所需要的库
 out:{
 libraryTarget:'system'
 },
 //排除打包react,因为要system
 externals:['react']
2)Single-spa微前端框架实战
 (1.1)Single-spa最重要三种类型的微前端应用
 single-spa-application:微前端架构中的微应用，可以使用vue,react等。
 single-spa root config:创建微前端容器应用。
 utility modules：公共模块应用，非渲染组件，用于跨应用共享业务逻辑
 (1.3)Single-spa的2.3版本
 执行create-single-spa命令。
 1)初始化相关的两个函数，registerApplication和start
 主入口引入基座，基座引入子应用。
 //注册子应用
 registerApplication({
 name:"@study/navbar",//这里是@团队/应用名称
 app:()=>System.import("@study/navbar"),//应用原地址
 activeWhen:["/"]//应用路径
 })
 //子应用另一个写法，精准匹配
 registerApplication(
 "@single-spa/welcome",
 ()=>System.import("https://unpkg.com/single-spa-welcome/dist/single-spa-welcome.js),
 location=>location.pathname==='/'
 )
 //设置基座
 start({
 uurlRerouteOnly:true
 })
 3)基于Module Federation的微前端架构
 模块联邦的应用，比较少。

**2.低代码Low Code**
 **(1)简介**
 (1.1)定义
 一个创建应用软件的开发环境，更好维护和易用的可视化IDE。
 (1.2)特点
 全栈可视化编程-what you see is what you get.
 低代码扩展能力：组件、主题、模板、逻辑。
 全生命周期管理：开发、构建、测试、部署、运维、运营。
 (1.3)难点
 参考阿里技术专家汪凤震跨端经验(PC、H5、Hybird、小程序、RN 类)《探索低代码的未来》
 一是自身是不是适合可视化
 搞清核心诉求，不要什么功能都要。
 如果是研发这类工具，如没有相关研发资源的重投(5人以上，周期1年以上)，不建议开发
 二是可视化引入的难点
 低代码一般是全生命周期，本身就是个挑战;
 开发周期长;
 除了依赖技术底蕴，更要过硬的产品思维
 **(2)可视化搭建技术**
 三部曲
 IDE的鼠标拖拽=》生成JSON文件=》渲染页面
 (1.1)设计原则
 组件可嵌套
 所见即所得
 低侵入性(比如组件包括渲染和编辑，应该是组件只负责渲染，组件编辑留给系统做，而不是组件内部做，组件不关心编辑属性，否则陷入强耦合逻辑。)
 组件渲染(深度优先遍历，逐层向上渲染。具体：组件名称->加载->注册->属性拼装->创建实例)
 (3)高级低代码平台搭建
 阿里的Sula

# SPA和MPA

**1.单页应用SPA**

第一次进入页面的时候会请求一个`html`文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的`html`文件请求，页面内容也变化了。

**为什么页面切换快？** 页面每次切换跳转时，并不需要做`html`文件的请求，这样就节约了很多`http`发送时延，我们在切换页面的时候速度很快。

**缺点：首屏时间慢，SEO差**

单页应用的首屏时间慢，首屏时需要请求一次`html`，同时还要发送一次`js`请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识`html`里的内容，不认识`js`的内容，而单页应用的内容都是靠`js`渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。

**2.多页面应用MPA**

每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。

**为什么多页应用的首屏时间快？** 首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度非常快。

**为什么搜索引擎优化效果好（SEO）？** 搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在Html中，所以这种多页应用，seo排名效果好。

|   比较   |          单页SPA          |                  多页MPA                  |
| :------: | :-----------------------: | :---------------------------------------: |
|   定义   |     页面跳转->JS渲染      |            页面跳转->HTML渲染             |
|   构成   |  一个html和多个html片段   |                 多个html                  |
|   优点   |        页面切换慢         |             首屏时间快，SEO好             |
|   缺点   |     首屏时间慢，SEO差     |                页面切换慢                 |
| 数据通信 | `借助vuex`或`storage`之类 | 依赖`URL`、`cookie`或者`localstorage`麻烦 |



# Iaas,Paas,Saas

sass,paas,laas这都是云服务的一种，是一种租赁的关系，而不是买卖的关系。我只关注使用，不需要维护。一次性收费变为按批次周期性服务。云服务本质就是把大家通用的一些服务，放到云端操作。

aas即as a Service以什么东西作为服务，

xass即anything as a Service一切即服务

SaaS即Software as  a Service软件即服务，如：salesforce的CRM客户关系管理、google docs。

PaaS即Platform as a Service平台即服务，如：Google的App Engine、微软的windows Server on Azure、AWS Elastic Beanstalk。IaaS读依亚S即Infrastructure as a Service基础设施即服务，如：Amazon S3、微软Azure、Google的Compute Engine

三者合称为SPI模式。

还有其他的服务，DaaS数据即服务，DBaaS数据库即服务，DWaaS数据仓库即服务，FaaS功能即服务，AI PaaS人工智能平台即服务，BaaS后端即服务，NaaS网络即服务。

# MVC、MVP、MVVM的演进过程

这三个框架模式表示了web领域的发展进程，从最早的前后端.net,jsp到分离的ajax,再到完全的前后端分离，再到响应式。

这三者共同的目标都是为了职责划分，代码分层，解决维护问题，目标是为了解决Mode和View的耦合问题。

**1.MVC**

![image-20211225211541701](/img/image-20211225211541701.png)

MVC最早出现在服务端，如springmvc，在前端早期也有应用，如Backbone.js,优点是分层清晰，缺点是数据流混乱，灵活性带来了维护问题。缺点所有通信都是单向的，用户主要通过**控制view或controller**发送指令。

- 视图（View）：用户界面。
- 控制器（Controller）：业务逻辑
- 模型（Model）：数据保存

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

**2.MVP**

MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。解决MV的耦合性问题，但P层过于臃肿。

View 与 Model 不发生联系，View 非常薄，不部署任何业务逻辑。

![image-20211225211824003](/img/image-20211225211824003.png)

**3.MVVM**

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。

唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel

MVVM广泛应用于前端领域，不仅解决MV耦合问题，还解决了两者映射关系复杂和DOM操作代码，提高开发效率、代码可读性。

# Polyfill黑话

`Polyfill`或者`Polyfiller`，是英国Web开发者 [Remy Sharp](https://remysharp.com/) 在咖啡店蹲坑的时候拍脑袋造出来的。当时他想用一个词来形容"用JavaScript来**实现一些浏览器不支持的原生API**"。

`Polyfill`的准确意思为：**用于实现浏览器并不支持的原生API的代码。**

`querySelectorAll`是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持。假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用`document.querySelectorAll`，使用方法跟现代浏览器原生API无异。那么这个库就可以称为`Polyfill`或者`Polyfiller`。

# Web应用服务端主动推送数据？

HTTP协议遵循经典的客户端-服务器模型，客户端发送一个请求，然后等待服务器端的响应，服务器端只能在接收到客户端的请求之后进行响应，不能主动的发送数据到客户端。

客户端想要在不刷新页面的情况下实时获取到服务器端最新的数据，可以通过以下途径:

1. 轮询
2. 长轮询
3. HTTP流
4. SSE
5. Web Sockets

## **轮询**

轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的有用数据可能只是一个很小的值，这样会占用很多的带宽。

客户端（浏览器）定时向服务器端发送请求，获取最新的数据。可以通过在一个定时器中触发ajax请求来实现：

```js
function showUnreadNews()  {  
    $(document).ready(function() {  
        $.ajax({  
            type: "POST",  
            url: "unread_list.js",  
            dataType: "json",  
            success: function(data) {  
                alert(data);  
            }  
        });  
    });  
}  
setInterval('showUnreadNews()',5000);  //轮询执行，5000ms一次  
```

**优点：**

实现简单，JS端进行一些更改即可，无需后端服务任何改动

**缺点：**

轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担

## **长轮询**

长轮询方法实现原理如下：

1. 客户端发起一个请求到服务器端(http request)
2. 服务器端一直保持连接打开，直到有数据数据可发送给客户端，再返回这个请求(http response)
3. 客户端收到服务器端返回的数据后，处理数据，并立马发起一个新的请求

```js
//客户端示例js
function showUnreadNews()  {  
    $.ajax({  
        type: "POST",  
        url: "unread_list.js",  
        dataType: "json",  
        success: function(data) {         
            //处理返回数据
            alert(data);
            //再次请求
            showUnreadNews();
        },
        complete:function(XMLHttpRequest,textStatus){  
            if(textStatus=='timeout'){//判断是否超时
                showUnreadNews();//超时，重新请求
            }  
        }
    });   
}
//server端示例(nodejs)
var aTargets = [];
app.get('/notification', function(req, res) {
    aTargets.push(res);
  //res.end();  这里不调用res.end(),让http request连接一直存活着
})//此方法会在有新的数据时调用
onNewNotification : function (data) {
  aTargets.forEach(function(res){
    res.send(data);//当有新的数据时，再调用res.send(data)返回最新的数据,结束一次http请求
  })
}
```

**优点：**

- 可以及时获取到最新的数据
- 相较于轮询策略，减少了请求数量

**缺点：**

服务器端要一直保持连接，不能释放，由于一个服务器能够处理的连接数有限，当达到服务器处理的上限的时候，服务器将无法响应新的请求

## **HTTP流**

HTTP流区别于轮询和长轮询方法，它在客户端网页的生命周期内，只需要使用一个HTTP连接，也就是只会向服务器发送一个请求，对于这个请求，服务器会保持HTTP连接（不返回response），然后周期性的向浏览器发送数据。

```js
//server端示例(nodejs)
let express = require("express");
let app = express();app.use(express.static("resources"));
app.get("/httpstream",function(req, res){
    var x = 0;
    res.setHeader('Connection', 'Transfer-Encoding');
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.setHeader('Transfer-Encoding', 'chunked');//声明数据传输编码为chunked，让浏览器及时处理
    setInterval(function(){
        res.write(x+++"|"); //每隔2s向客户端发送一次数据
    },2000);
});app.listen(3000);
```

服务器端接收到请求后，每隔两秒向客户端输出一点文字，但是不会使用`res.end()`或者`res.send()`结束当前http请求。

```js
//客户端示例js
var xhr = new XMLHttpRequest();
var received = 0;
var result = "";
xhr.open("get","/httpstream",true);
xhr.onreadystatechange = function () {
  if (xhr.readyState == 3) { //readystate 3 表示正在解析数据
    result = xhr.responseText.substring(received);//截取最新的数据
    received += result.length;
    console.log(result);
  }
}
xhr.send();
```

随着不断从服务器端接收到数据，客户端的`readyState`会周期性的变成`3`，`responseText`包含所有的数据源。通过`received`来记录之前已经处理过的数据长度，然后在`responseText`中截取最新的数据。

**优点：**

页面的整个生命周期内，只需要建立一个http连接

**缺点：**

- 如果接入的客户端过多，服务器端会因为http连接有限而无法为新的客户端提供服务
- 客户端接收到的数据流会越来越大，最终可能会引发页面的性能问题

## **SSE**

SSE(Server-Sent Events)是基于HTTP实现的一套服务器向客户端发送数据的API。他是针对上面说到的三种方法（轮询，长轮询，HTTP流）的一个标准API实现。

使用SSE API可以创建到服务器端的但相连接，服务器可以通过这个连接发送任意数据。它有以下特点：

- 断开自动连接
- 服务器响应的MIME类型必须是`text/event-stream`
- 需要浏览器API支持(参考[浏览器兼容性](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FServer-sent_events%2FEventSource%23%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7))

**使用方法如下：**

```js
//客户端js
var source = new EventSource(url);
//建立连接时触发
source.onopen = function () {
  //do something here
};
//从服务器端接收到新的事件时触发
source.onmessage = function (event) {
  var data = event.data; //服务器返回的数据存放在event.data中
};
//连接异常时触发
source.onerror = function () {
  //do something here
};
```

客户端创建一个EventSource对象，绑定到对应的url，然后监听该对象的onmessage事件就可以获取到最新的数据。

```js
//server端示例(nodejs)
let express = require("express");
let app = express();app.use(express.static("resources"));
app.get("/httpstream",function(req, res){
    var x = 0;
  res.writeHead(200, {
      "Content-Type":"text/event-stream",
      "Cache-Control":"no-cache",
      "Connection":"keep-alive"
    });
  //每个1s往客户端发送一条数据
  setInterval(function(){
      res.write("data: " + x++ + "\n\n");//发送的数据格式必须是"data: <内容>/n/n"
  },1000);
});app.listen(3000);
```

## **Web Sockets**

不同于SSE，Web Sockets 采用了一套全新的协议（`ws/wss`）来建立客户端到服务器端的全双工、双向通信连接。

**WebSocket的定义：**

WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询

**为什么需要WebSocket？**

- HTTP 协议是一种无状态的、无连接的、单向的应用层协议；
- 它采用了请求/响应模型；
- 通信请求只能由客户端发起，服务端对请求做出应答处理；
- 这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息；
- 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦；
- 大多数 Web 应用程序将通过频繁的异步JavaScript和XML（AJAX）请求实现长轮询；
- 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开），因此WebSocket应运而生，需要一种可以保持连接、进行全双工通信的协议；
- WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端；
- WebSocket 只需要建立一次连接，就可以一直保持连接状态，这相比于轮询方式的不停建立连接显然效率要大大提高。

**WebSocket的应用场景：**

实时性要求高的场景：社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。

WebSocket表示当前状态的readyState属性，属性值如下：

```js
WebSocket.OPENING(0)：正在连接
WebSocket.OPEN(1):已经建立连接
WebSocket.CLOSING(2):正在关闭连接
WebSocket.CLOSE(3)：已经关闭连接
```

WebSocket发送数据：send(任意字符串)，复杂数据需要将数据系列化，如下面所示：

```js
var message ={
   time:new Date(),
   text:'hi'
}
socket.send(JSON.stringify(message));
```

WebSocket接收数据：服务器向客户端发送信息，触发message()事件，把数据存在event.data中

```js
socket.onmessage=function(event){
    var data = event.data;
}
var ws;
function WebSocketTest(){
   if ("WebSocket" in window){
      alert("您的浏览器支持 WebSocket!");
      // 打开一个 web socket
      ws = new WebSocket("ws://localhost:9998/echo");
      ws.onopen = function(){
         // Web Socket 已连接上，使用 send() 方法发送数据
         ws.send("发送数据");
         alert("数据发送中...");
      };
      ws.onmessage = function (evt) { 
         var received_msg = evt.data;
         alert("数据已接收..." + received_msg);
      };
      ws.onerror = function (evt) {
          //出错
          alert(JSON.stringify(evt));
      }
      ws.onclose = function(){ 
         // 关闭 websocket
         alert("连接已关闭..."); 
      };
   }
   else{
      // 浏览器不支持 WebSocket
      alert("您的浏览器不支持 WebSocket!");
   }
}
ws.close();//关闭连接
```

**WebSocket其他事件：**
open():在成功建立连接时触发
error():在发生错误时触发，连接不能持续
close():在连接关闭时触发

**优点：**

- 双向通信，实时连接
- 相较于HTTP请求更加高效(不需要握手，连接始终存在；无需携带头部信息)

**缺点：**

- 稳定性和成熟度问题

# 从PWA到Service Worker

## PWA

PWA全称Progressive Web Apps（渐进式WebApp），是通过现代API来构建和增强的，这些API提供了与原生App相似的能力、可靠性、可安装性，而且具备一套代码即可触达任何人、任何地方、任何设备

三大特性：

- 功能性（capable）
- 可靠性（reliable）
- 可安装性（installable）

PWA同时具备这三大特性，这也让PWA的应用体验更接近原生。

**功能性**

Web App当今时代已经具备了丰富的功能，你可以基于 `WebRTC` 开发一个视频聊天工具，可以使用 `Geolocation API` 开发一个地图软件，也可以使用 `Notification API` 来给你的APP推送消息，让用户可以在APP之外接收到通知。你也可以使用 `WebGL` 和 `WebVR` 来虚拟化这些场景。通过 `Web Assembly`，你可以步入其他生态，比如：C和C++等，给Web生态带来更多能力。

**可靠性**

可靠的App需要对网络无依赖。用户会期望在弱网或者无网络的情况下打开App。他们期望看到上次他们加载的内容，就像是音频或者视频播放到某个特定时间点，即使网络连接困难，还是要保持可靠和可用。如果请求失败了，比起默默地失败或者崩溃，给用户合理的提示才是最佳。

**可安装性**

安装好的PWA应用可以在一个独立的窗口启动，而不用在浏览器中。它们也可以从主页、docks或者任务栏启动。

**小结**

PWA的核心还是WebApp，通过渐进式增强，新的功能被现代浏览器实现。通过使用 `service worker` 和 `app manifest`，可以让你的WebApp具备可靠性和可安装性。如果浏览器不支持这些功能，你的网站的核心功能也不受影响。

如果说一个30M的原生App换成PWA，可能只有3M不到。另外，PWA的应用的可触达性是继承了WebApp的，可以通过搜索引擎让触达更多用户，或者通过分享的方式。最后，PWA的应用可随时更新，无需用户下载安装。

**简单总结：PWA是Web应用的自然进化，Service Worker是PWA的关键。**

## Service Worker

### 什么是Service Worker

Service Worker是一项比较新的Web技术，是Chromium团队在吸收了ChromePackaged App的Event Page机制，同时吸取了HTML5 AppCache标准失败的教训之后，提出一套新的W3C规范，旨在提高WebApp的离线缓存能力，缩小WebApp与NativeApp之间差距。

Service Worker从英文翻译过来就是一个服务工人，服务于前端页面的后台线程，基于Web Worker实现。有着独立的js运行环境，分担、协助前端页面完成前端开发者分配的需要在后台悄悄执行的任务。基于它可以实现拦截和处理网络请求、消息推送、静默更新、事件同步等服务。

### 优势及应用场景

- 后台数据的同步
- 从其他域获取资源请求
- 接受计算密集型数据的更新，多页面共享该数据
- 客户端编译与依赖管理
- 后端服务的hook机制
- 根据URL模式，自定义模板
- 性能优化
- 消息推送
- 定时默认更新
- 地理围栏

1、离线缓存：可以将H5应用中不变化的资源或者很少变化的资源长久的存储在用户端，提升加载速度、降低流量消耗、降低服务器压力。如中重度的H5游戏、框架数据独立的web资讯客户端、web邮件客户端等

2、消息推送：激活沉睡的用户，推送即时消息、公告通知，激发更新等。如web资讯客户端、web即时通讯工具、h5游戏等运营产品。

3、事件同步：确保web端产生的任务即使在用户关闭了web页面也可以顺利完成。如web邮件客户端、web即时通讯工具等。

4、定时同步：周期性的触发Service Worker脚本中的定时同步事件，可借助它提前刷新缓存内容。如web资讯客户端。

### 注意点

1、Service Worker线程运行的是js，有着独立的js环境，不能直接操作DOM树，但可以通过postMessage与其服务的前端页面通信。

2、Service Worker服务的不是单个页面，它服务的是当前网络path下所有的页面，只要当前path 的Service Worker被安装，用户访问当前path下的任意页面均会启动该Service Worker。当一段时间没有事件过来，浏览器会自动停止Service Worker来节约资源，所以Service Worker线程中不能保存需要持久化的信息。

3、Service Worker安装是在后台悄悄执行，更新也是如此。每次新唤起Service Worker线程，它都会去检查Service Worker脚本是否有更新，如有一个字节的变化，它都会新起一个Service Worker线程类似于安装一样去安装新的Service Worker脚本，当旧的Service Worker所服务的页面都关闭后，新的Service Worker便会生效。

简单使用

**a.** 首先在页面注册一个service worker

```
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./index.js').then((reg) => {
    console.log('register a service worker: ', reg)
  }).catch((err) => {
    console.log('err: ', err);
  });
}
```

**b.** 接着就可以在Service worker中尽情畅想

以页面的离线应用为出发点，说明sw如实做到离线应用的。

```
const cacheUrl = [
  '/base.css',
  '/france.html'
];
const cacheName = 'my-site-cache';

// install阶段
self.addEventListener('install', (event) => {
  console.log('sw event: install');
  event.waitUntil(
    caches.open(cacheName).then((cache) => {
      console.log('open cache');
      return cache.addAll(cacheUrl);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(caches.match(event.request).then(res => {
    if (res) {
      console.log('match');
      return res;
    }
    return fetch(event.request);
  }));
});
```



### 一个简单例子

[Service Worker离线案例](https://x5.tencent.com/product/service-worker.html)

使用Service Worker只需要三大步：

切入到https；由于Service Worker可以劫持连接，伪造和过滤响应，所以保证其在传输过程中不被篡改非常重要。

2、在页面加载的恰当时机注册Service Worker；示例中在index页面的body onload事件中注册了同path下的serviceworker.js作为index页面的服务线程。

3、编写serviceworker脚本逻辑；serviceworker是事件驱动型服务线程，所以serviceworker脚本逻辑中基本都是以事件监听作为逻辑入口，示例中在serviceworker脚本被安装的install事件中缓存index页面主资源及子资源，在fetch事件中，拦截前端页面发起的资源请求并到之前缓存的cache中匹配。

该示例部署到服务器上之后，用户第一次打开index页面，仍然会从服务器上拉取，之后便去安装Service Worker，执行Service Worker中的install事件，浏览器会再次拉取需要缓存的资源，这一次的缓存是否从网络拉取取决于资源设置的过期时间。当install事件中的资源均拉取成功，Service Worker算是安装成功。如果有一个资源拉取失败，此次Service Worker安装失败，若用户下次再打开该页面，浏览器仍然会重复之前的安装流程尝试安装。

如果index页面的Service Worker安装成功，用户再次打开index页面发起的资源请求便会先经过Service Woker脚本的fetch事件，在该事件中前端开发可以通过编写逻辑控制请求从网络拉取还是从cache中读取或者自己构造一个response丢给前端。

### 参考

[Service Worker 官方案例](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)

[Service Worker生命周期](

# SEO排名

**定义**

SEO（Search Engine Optimization），中文翻译为“**搜索引擎优化**”，从本质上来说，其实就是如何迎合搜索引擎的规则，使得网站在搜索结果中能有更好的排名。比如一个PDA行业网站，当用户输入“PDA数据采集器”，在没有进行SEO优化的情况下，也许这个网站排在第2页或者第3页之后，通过用户行为分析，我们得知，用户在搜索的时候，基本80%左右的用户在浏览完第一页之后就会放弃继续浏览，这样对一个公司来说，如何让你的网站排在尽可能靠前的位置，获得更多流量，就意味着能有更多展示公司产品和品牌的机会。简单一句话，SEO就是让网站，在搜索引擎自然排序中能尽量排在靠前的位置。

**参考**

[SEO禅专注SEO优化](https://www.seozen.top/seo-course-first-step.html)

[台湾加强网站SEO](https://blog.yyisyou.tw/5ac95a76/)