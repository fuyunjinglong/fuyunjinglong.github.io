---
title: TCP的网络拆包粘包
date: 2022-05-17 07:33:16
categories:
- F_计算机网络
toc: true # 是否启用内容索引
---

# 什么是粘包、拆包

由于`TCP`传输协议是面向字节流的传输协议，没有消息保护边界，所以发送方发送的多个数据包，接收方应用层不知如何区分，可能会被当成一个包来处理，这就是粘包；或者，发送方将一个打包分成多个小包发送，而接收方将它们当成多个包进行处理，这就是拆包。

`TCP`传输的四种情况：

1. 客户端向服务器发送了两个包，两个数据包之间互不影响，这是正常的，我们不需要管；
2. 客户端向服务器发送了两个包，但是两个包被并在了一起，当作一个包发送，这就是发生了粘包现象，服务器可能会将它们当成一个数据包处理；
3. 客户端向服务器发送了两个包`D1`和`D2`，但是`D2`的一部分与`D1`合并在了一起，发生了粘包，而`D2`另一部分被单独发送，也就是说`D2`被拆分成了两个小包，发生了拆包现象；
4. 第四种情况和第三种类似，只是顺序反了一下，`D1`发生了拆包，而`D1`的后半部分与`D2`发生了粘包；

以下几种情况：

- 正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；
- 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；
- 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；
- 拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。

# 粘包发生的原因

**（1）套接字缓冲区**

  应用层需要发送数据时，假设是基于`TCP`发送，则会将数据交给`TCP`套接字。数据被放入套接字发送缓存中，由于各种原因，往往不会立即发送，比如数据来的太快，还来不及发送。这就导致在发送缓存中，可能存在多个不同的数据包的字节并排在一起。当`TCP`需要发送数据时，会从发送缓存中读取一段字节，封装成`TCP`报文段发送出去，而读取的这些字节，可能属于多个数据包。

  在接收端，`TCP`接收到的数据也会被放入套接字的接收缓冲区中，再由应用层进行读取。但是，应用层可能并不会立即读取缓冲区中的数据，或者来不及读取，此时就会造成多个数据包同时在缓冲区中。因为没有划定边界，所以应用层也无法将它们拆分开来，而是一同读取，这就会造成粘包。

 **（2）Nagle算法**

  `TCP`的发送方每次发送报文段，都希望能包含尽量多的字节，这样可以最大限度的利用网络带宽。假设发送方需要要向接收方发送一个字节的数据，经过运输层和网络层的封装后，将会为这一个字节加上`40`个字节的首部，这是一种非常浪费的情况，而`Nagle`算法正是为了减少这种情况。

  `Nagle`算法是基本原则就是：**在任意时刻，只能有一个未被确认的小段报文**。未被确认就是已经发送，但是还没有接收到`ACK`的报文段，而小段报文指的是没有达到网络最大传输单元的报文段。使用`Nagle`算法时，会尽量地将一些小段凑成一个大段进行发送，而这就导致了粘包现象的发生。

# 拆包发生的原因

**（1）最大报文段长度MSS、最大传输单元MTU**

  `MSS`表示一个`TCP`报文段能够承载数据的最大字节数，而`MTU`则是网络传输种能够接受的报文的最大长度。这两个概念说明网络传输中，每个报文能够承载的数据是有限的。`TCP`为了能将数据发送出去，且每个报文中的数据不超过`MSS`，会将一个大的数据包分为多个小段，为每个段加上首部后逐一发送，而这就造成了拆包。比如说，对于一张图片，一般都需要拆分成多个段进行发送。

 **（2）TCP滑动窗口**

  `TCP`采用了流水线的传输机制，而流水线传输中通过维护一个窗口来限制数据的发送，也可以叫做一个区间。只有序号落在窗口中的那些字节，才允许被发送。而窗口是动态变化的，它受到网络拥塞情况以及接收方缓冲区剩余空间的限制。如果当前要发送的数据包的长度，大于窗口中的剩余空间，那这个数据包就会被拆分，先发送一部分，这样也就造成了拆包。

# 如何解决拆包粘包

解决拆包/粘包的唯一方法：**定义应用层的通信协议**

`TCP`可以保证完整，并且按序地接收字节，但是并不会帮忙拆分多个包的字节，真正做这个工作的是应用层的协议，应用层负责解决粘包和拆包。

## 消息长度固定

每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。

```
+----+------+------+---+----+

| AB | CDEF | GHIJ | K | LM |

+----+------+------+---+----+
```

假设我们的固定长度为 4 字节，那么如上所示的 5 条数据一共需要发送 4 个报文：

```
+------+------+------+------+

| ABCD | EFGH | IJKL | M000 |

+------+------+------+------+
```

消息定长法使用非常简单，但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用。

## 特定分隔符

既然接收方无法区分消息的边界，那么我们可以在每次发送报文的尾部加上**特定分隔符**，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符 \n 按行解析，即可得到 AB、CDEF、GHIJ、K、LM 五条原始报文。

```
+-------------------------+

| AB\nCDEF\nGHIJ\nK\nLM\n |

+-------------------------+
```

由于在发送报文时尾部需要添加特定分隔符，所以对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。否则可能出现错误的消息拆分。比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。特定分隔符法在消息协议足够简单的场景下比较高效，例如大名鼎鼎的 Redis 在通信过程中采用的就是换行分隔符。

## 消息长度 + 消息内容

```
消息头     消息体

+--------+----------+

| Length |  Content |

+--------+----------+
```

**消息长度 + 消息内容**是项目开发中最常用的一种协议，如上展示了该协议的基本格式。消息头中存放消息的总长度，例如使用 4 字节的 int 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 Len，然后紧接着读取长度为 Len 的字节数据，该数据即判定为一个完整的数据报文。依然以上述提到的原始字节数据为例，使用该协议进行编码后的结果如下所示：

```
+-----+-------+-------+----+-----+

| 2AB | 4CDEF | 4GHIJ | 1K | 2LM |

+-----+-------+-------+----+-----+
```

消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。

# 为什么UDP没有粘包？

粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

# Netty对粘包和拆包问题的处理

Netty对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如：

- LineBasedFrameDecoder：以行为单位进行数据包的解码；
- DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；
- FixedLengthFrameDecoder：以固定长度进行数据包的解码；
- LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）；

# 参考

[计算机网络——浅析TCP粘包，拆包发生的原因以及解决方式](

