---
title: 正则表达式
date: 2022-04-17 07:33:16
categories:
- B_JS
toc: true # 是否启用内容索引
---

# 正则Regular Expression即RE

- [JS正则表达式入门，看这篇就够了](https://segmentfault.com/a/1190000009324194)
- [JS正则表达式完整教程（略长）](https://juejin.cn/post/6844903487155732494)	

功能：利用它来校验数据的有效性，比如用户输入的手机号是不是符合规则；也可以从文本中提取想要的内容，比如从网页中抽取数据；还可以用来做文本内容替换，从而得到我们想要的内容。

## 1.元字符的概念

正则常见的三种功能：

- 校验数据的有效性
- 查找符合要求的文本
- 对文本进行切割和替换等

正则元字符分类：

- 特殊字符
- 空白符
- 范围
- 量词
- 断言

### 特殊字符

- 英文的点（`.`）表示换行以外的任意单个字符
- `\d` 表示任意单个数字
- `\w` 表示任意单个数字或字母或下划线
- `\s` 表示任意单个空白符。
- 另外，还有与之对应的三个 `\D`、`\W` 和 `\S`，分别表示着和原来相反的意思。

测试一下：https://regex101.com/r/PnzZ4k/1

### 空白符

- `\r`：回车符
- `\n`：换行符
- `\f`：换页符
- `\t`：制表符
- `\v`：垂直制表符
- `\s`：任意空白符

### 量词

- `*`：0 到多次
- `+`：1 到多次
- `？`：0 到 1 次，如 `colou?r`
- `{m}`：出现 m 次
- `{m,}`：出现至少 m 次
- `{m,n}`：m 到 n 次

### 范围

- `|` ：或，比如： `ab|bc` 代表 ab 或 bc
- `[...]`：多选一，括号中任意单个元素
- `[a-z]`：匹配 a 到 z 之间任意单个元素（按 ASCII 表，包含 a，z）
- `[^...]`：取反，不能是括号中的任意单个元素

## 2.量词与贪婪

### 贪婪模式与非贪婪模式

主要针对量词而言

- 贪婪模式， 即**最长匹配**，量词默认是贪婪模式即尽可能多的去匹配。
- 非贪婪模式，即 **最短匹配**，**用法：量词后加?**，就变成非贪婪模式即找出**最短长度且符合要求**的。

```
测试文本："123" is io "45"
贪婪模式：".*"，匹配到第一个引号到最后一个引号
非贪婪模式：".*?",匹配到"123"和"45"
```

### 独占模式Possessive

**用法：量词后加+**，就变成了独占模式。

不管是贪婪模式，还是非贪婪模式，**都需要发生回溯才能完成相应的功能**。

独占模式，它类似贪婪匹配，但匹配过程不会发生回溯。

独占模式和贪婪模式很像，**独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯**，这样的话就比较节省时间。

```
text = “xyyz”
独占模式：regex = “xy{1,3}+yz”，匹配失败
贪婪模式：regex = “xy{1,3}yz”，匹配成功，因为有回溯。
```

### 正则回溯引发的血案

Lazada 卖家中心店 **铺名检验规则** 比较复杂，名称中可以出现下面这些组合：

- 英文字母大小写；
- 数字；
- 越南文；
- 一些特殊字符，如 `&`，`-`，`_` 等。

开发的小伙伴在开发过程中使用了正则来实现店铺名称校验，如下所示：

```
^([A-Za-z0-9._()&'\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$

^([符合要求的组成1]|[符合要求的组成2])+$ 
```

**正则中有个加号（`+`）**，**表示前面的内容出现一到多次，进行贪婪匹配**，这样会导致大量回溯，占用大量 CPU 资源，引发线上问题，我们只需要将贪婪模式改成独占模式就可以解决这个问题。

在这个例子中，**匹配不上时证明店铺名不合法，不需要进行回溯**

## 3.分组与引用

匹配15位或18位数字

- 示例一：

  `\d{15}\d{3}?` 由于 `\d{3}` 表示三次，加问号非贪婪还是 3 次

- 示例二：

  `\d{15}(\d{3})?` 在 `\d{3}` 整体后加问号，表示后面三位有或无

```
测试文本：
123456789012345
123456789012345678

\d{15}\d{3}?只能匹配到18位数字
\d{15}(\d{3})?匹配到15和18位数字
```

**用法：括号在正则中的功能就是用于分组**。简单来理解就是，由多个元字符组成某个部分，应该被看成一个整体的时候，可以用括号括起来表示一个整体，这是括号的一个重要功能。其实用括号括起来还有另外一个作用，那就是 **复用**

### **分组和编号**

括号在正则中可以 **用于分组**，被括号括起来的部分 「子表达式」会被保存成一个 **子组**。每一个分组表示一个编号。

比如2020-05-10 20:23:05，**(**\d{4}-\d{2}-\d{2})**(**\d{2}:\d{2}:\d{2})这就是2组编号。共有两个分组，日期是第 1 个，时间是第 2 个

### **不保存子组**

默认情况下，**在括号里面的会保存成子组**，后续继续使用。我们可以理解成，**括号只用于归组，把某个部分当成「单个元素」，不分配编号，后面不会再进行这部分的引用**。

**用法：在括号里面使用 `?:`** ，则表示不保存子组，后续不再使用。

**优点：**

- 不保存子组可以提高正则的性能
- 子组计数时也更不容易出错

```
测试文本：
123456789012345
123456789012345678
\d{15}(\d{3})?匹配到123456789012345，123456789012345，678
\d{15}(?:\d{3})?匹配到123456789012345，123456789012345
```

### 括号嵌套

在阿里云简单日志系统中，我们可以使用正则来匹配一行日志的行首。假设时间格式是 2020-05-10 20:23:05 。

**((**\d{4})-**(**\d{2})-**(**\d{2})**((**\d{2}):**(**\d{2}):**(**\d{2})

```
通过识别左括号即可区分分组编号，日期分组编号是 1，时间分组编号是 5，年月日对应的分组编号分别是 2，3，4，时分秒的分组编号分别是 6，7，8。
```

### 命名分组

分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还 **可能导致编号发生变化**，因此一些编程语言提供了 **命名分组（named grouping）**，这样和数字相比更容易辨识，不容易出错。命名分组的格式为 `(?P<分组名>正则)`。

不是所有语言都支持的，在使用时，你需要查阅所用语言正则说明文档。

### 分组引用

大部分情况下，使用 `反斜扛 + 编号`，即 `\number` 的方式来进行引用，而 JavaScript 中是通过 `$编号` 来引用，如 `$1`。

分组查找和替换的引用方式：

|  变成语言  |  查找时引用方式   |  替换时引用方式   |
| :--------: | :---------------: | :---------------: |
|   Python   | `\number` 如 `\1` | `\number` 如 `\1` |
|     Go     |    官方不支持     |    官方不支持     |
|    Java    | `\number` 如 `\1` | `$number` 如 `$1` |
| JavaScript | `$number` 如 `$1` | `$number` 如 `$1` |
|    PHP     | `\number` 如 `\1` | `\number` 如 `\1` |
|    Ruby    | `\number` 如 `\1` | `\number` 如 `\1` |

### 分组引用在查找中使用

`\w+` 来表示一个单词，语法\1表示可以对相同字母或者数字进行筛选，用来匹配重复分组。

```
测试文本：the litter cat cat is hat hat
(\w+) \1匹配cat cat重复和hat hat重复
```

### 分组引用在替换中使用

和查找类似，我们可以使用 **反向引用**，在得到的结果中，去拼出来我们想要的结果。还是使用刚刚日期时间的例子，我们可以很方便地将它替换成， 2020 年 05 月 10 日这样的格式。

https://regex101.com/r/2RVPTJ/2

```
测试文本：2020-05-10 20:23:05
2020-05-10 20:23:05
((\d{4})-(\d{2})-(\d{2})) ((\d{2}):(\d{2}):(\d{2}))
日期\1 时间\5   \2年\3月\4日 \6时\7分\8秒
```

## 4.匹配模式

匹配模式，指的是正则中一些 **改变元字符匹配行为** 的方式,常见有4种:

- 不区分大小写模式
- 点号通配模式
- 多行模式
- 注释模式

### 不区分大小写模式（Case-Insensitive）

比如要查找单词 cat，不区分大小写，可以写成:

```
测试文本：cat Cat CAT
[Cc][Aa][Tt]
```

那么有没有更好的办法来实现这个需求呢？这时候不区分大小写模式就派上用场了。

把 **模式修饰符** 放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 **(? 模式标识)** 的方式来表示的。

```
(?i)cat
```

不区分大小写模式的要点：

1. 不区分大小写模式的指定方式，使用模式修饰符 `(?i)`；
2. 修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则；
3. 使用编程语言时可以使用预定义好的常量来指定匹配模式。

### 点号通配模式（Dot All）

当我们需要匹配真正的「任意」符号的时候，可以使用 `[\s\S]` 或 `[\d\D]` 或 `[\w\W]` 等.

但是这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（`.`）可以匹配上包括换行的任何字符。

```
测试文本：
the cat is
CAT
Cat

(?s).
```

需要注意的是，JavasScript 不支持此模式，那么我们就可以使用前面说的 `[\s\S]` 等方式替代

###  多行匹配模式（Multiline）

通常情况下，`^` 匹配整个字符串的开头，`$` 匹配整个字符串的结尾。**多行匹配模式改变的就是 `^` 和 `$` 匹配行为**。

```
测试文本：
the little cat
is blue

^the|blue$其中^匹配整个文本的开头，$匹配整个文本的结束
```

多行模式的作用在于，使 `^` 和 `$` 能匹配上 **每行** 的开头或结尾，我们可以使用模式修饰符号 `(?m)` 来指定这个模式。

```
(?m)^the|blue$其中^匹配每行文本的开头，$匹配每行文本的结束
```

### 注释模式（Comment）

我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。正则中注释模式是使用 `(?#comment)` 来表示。

```
(\w+)(?#word) \1(?#word repeat again)
```

小结：

1. 不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。
2. 点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。
3. 多行匹配说的是 `^` 和 `$` 的匹配行为，让其可以匹配上每行的开头或结尾。
4. 注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。

**思考**：比如我们要提取网页中的 head 标签中的内容，用正则如何实现呢？

```
测试文本：
<!DOCTYPE html>
<head>
 <title> 学习正则 </title>
</head>
<body>
</body>
</html>

# (?si) 是模式开关：s 单行匹配模式  i 是不区分大小写
(?si)<head>(.*)<\/head>
```

## 5.断言

简单来说，**断言是指对匹配到的文本位置有要求**。

比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。**正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言**。

常见3种断言：

- 单词边界
- 行的开始和结束
- 环视

### 单词边界（Word Boundary）

```
测试文本：tom asked me if I would go fishing with him tomorrow.

tom匹配到tom和tomorrow
```

这种结果不是我们想要的，正则中使用 `\b` 来表示单词的边界。 `\b` 中的 b 可以理解为是 **边界（Boundary）**。

```
tom表示包含tom
\btom表示以tom开头
tom\b表示以tom结尾
\btom\b表示只有tom的
```

### 行的开始或结束

如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 `^` 和 `$` 来进行位置界定。常用于**输入校验**。

### 环视（ Look Around）

**环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则**，有些地方也称环视为 **零宽断言**。

```
测试文本：
邮政编码的规则是第一位是 1-9，一共有 6 位数字组成。
012300  不满足第一位是 1-9
130400  满足要求
465441  满足要求
4654000 长度过长
138001380002 长度过长

[1-9]\d{5}对于4654000和138001380002也会误匹配到。

```

|   正则   |               名称               |    含义    |                      示例                      |
| :------: | :------------------------------: | :--------: | :--------------------------------------------: |
| `(?<=Y)` |  肯定逆序环境 postive-lookahead  |  左边是 Y  |   `(?<=\d)th` 左边是数字的 th，能匹配 `9th`    |
| `(?<!Y)` | 否定逆序环境 negative-lookahead  | 左边不是 Y | `(?<!\d)th` 左边不是数字的 th，能匹配 `health` |
| `(?=Y)`  | 肯定顺序环境 postive-lookbehind  |  右边是 Y  |  `six(?=\d)` 右边是数字的 six，能匹配 `six6`   |
| `(?!Y)`  | 否定顺序环境 negative-lookbehind | 右边不是 Y | `hi(?!\d)` 右边是不是数字的 hi，能匹配 `high`  |

口诀：**左尖括号代表看左边，没有尖括号是看右边，感叹号是非**

```
(?<!\d)[1-9]\d{5}(?!\d)。这样就能够符合要求了。
```

### 环视与子组

**环视中虽然也有括号，但不会保存成子组**。

### 环视拓展例子

如下的正则表达式，含义是：必须出现 大小写字母、数字、特殊字符， 6-16 个字符

```
(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\d)(?=.*?[#@*&.])[\w!@#$%^&*._]{6,16}
拆解后：
(?=.*?[a-z])
(?=.*?[A-Z])
(?=.*?\d)
(?=.*?[#@*&.])
[\w!@#$%^&*._]{6,16}
```

**前 4 组限定右侧的 6-16 个字符中必须要出现的字符有哪些**，

- ``.*` ：任意字符出现 0 次或多次

- `?`：给这个量词 `*` 限定为非贪婪匹配模式

  与不加该问号，即贪婪匹配模式的区别，在这里应该仅仅只是少匹配几次，增加了匹配性能

- `[a-z]` ：那么唯一看不太懂的就是这个后面的可选字符了