<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>0基础 | Hexo</title>
  <meta name="description" content="JavaScript三大山-堆栈内存及闭包作用域  JS的8种数据类型 基本类型：Number,String,Boolean,Null,undefined,symbol 引用类型：Object,Array,function  Undefined、Null的区别  Undefined 类型表示未定义，它的类型只有一个值，就是 undefined，判空：if(a&#x3D;&#x3D;&#x3D;undefined)  Null表">
<meta property="og:type" content="article">
<meta property="og:title" content="0基础">
<meta property="og:url" content="http://anandasuper.top/2022/05/29/B_JS_0%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JavaScript三大山-堆栈内存及闭包作用域  JS的8种数据类型 基本类型：Number,String,Boolean,Null,undefined,symbol 引用类型：Object,Array,function  Undefined、Null的区别  Undefined 类型表示未定义，它的类型只有一个值，就是 undefined，判空：if(a&#x3D;&#x3D;&#x3D;undefined)  Null表">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/fuyunjinglong/AppData/Roaming/Typora/typora-user-images/image-20220912183546292.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220114072242443.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211024222114449.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220123200002149.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220222215742735.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220504095928130.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220222220554956.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220313115045079.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220313115410595.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220313120537563.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220320214519742.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220320221047255.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211207073137249.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211207073246002.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211207235441427.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211208000338908.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211208001049548.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209072317064.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209072730664.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209072755682.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209072828890.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209073441948.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211209074403859.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/746158/201511/746158-20151124155220468-1074861494.png">
<meta property="article:published_time" content="2022-05-28T23:33:16.000Z">
<meta property="article:modified_time" content="2023-02-19T09:34:33.860Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/fuyunjinglong/AppData/Roaming/Typora/typora-user-images/image-20220912183546292.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://anandasuper.top/2022/05/29/B_JS_0%E5%9F%BA%E7%A1%80/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">昵称</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AA-%E9%9D%A2%E8%AF%95/">AA_面试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/G-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">G_性能优化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/" class="title">插件</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-11T23:33:16.000Z" itemprop="datePublished">2023-01-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/12/11/%E6%A8%A1%E6%9D%BF2/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-11T04:20:22.712Z" itemprop="datePublished">2022-12-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" class="title">E_左神</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-12T23:33:16.000Z" itemprop="datePublished">2022-11-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/10/22/Test/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-22T08:05:41.618Z" itemprop="datePublished">2022-10-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/12/Z_%E4%B9%A6%E5%8D%95/" class="title">书单</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-12T00:33:16.000Z" itemprop="datePublished">2022-09-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E5%8F%8A%E9%97%AD%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">三大山-堆栈内存及闭包作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%848%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">JS的8种数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">JS堆栈内存运行机制-深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E6%9C%BA%E5%88%B6"><span class="toc-text">变量提升机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%A4%E5%A4%A7%E4%BD%9C%E7%94%A8%EF%BC%9A%E4%BF%9D%E5%AD%98%E3%80%81%E4%BF%9D%E6%8A%A4"><span class="toc-text">闭包的两大作用：保存、保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%BC%96%E8%AF%91%E6%9C%BA%E5%88%B6%EF%BC%9AVO-AO-GO"><span class="toc-text">JS编译机制：VO&#x2F;AO&#x2F;GO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E9%AB%98%E9%98%B6%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">JS高阶编程技巧：惰性函数&#x2F;柯里化&#x2F;高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3"><span class="toc-text">模块化思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8Cthis%E5%A4%84%E7%90%86"><span class="toc-text">三大山-面向对象和this处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">constructor构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-text">类和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%BD%A2%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原形和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">new运算符的实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84this%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E6%A2%B3%E7%90%86"><span class="toc-text">JS的this五种情况的梳理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%96%B9%E6%A1%88"><span class="toc-text">JS的四大数据类型检查方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88"><span class="toc-text">JS的四大继承方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-DOM%E5%92%8CBOM%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">三大山-DOM和BOM及事件处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-BOM%E7%9A%84%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-text">DOM&#x2F;BOM的核心操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">DOM2级事件的核心运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="toc-text">节流和防抖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E5%8E%9F%E7%90%86"><span class="toc-text">Ajax原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存溢出和内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E5%BC%95%E6%93%8E"><span class="toc-text">V8引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E9%A1%B5%E9%9D%A2%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">HTML页面乱码问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice-splice-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">slice(),splice()两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-text">typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">JS创建私有变量的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">手写发布订阅</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E5%92%8Cmap"><span class="toc-text">set和map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E5%8E%9F%E7%90%86"><span class="toc-text">Promise原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E3%80%81Generator%E3%80%81Async%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Promise、Generator、Async三者的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reduce-every-some"><span class="toc-text">reduce,every,some</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakset-%E5%92%8C-weakmap"><span class="toc-text">weakset 和 weakmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in%E3%80%81for-of%E3%80%81forEach%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">for in、for of、forEach的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jquery"><span class="toc-text">Jquery</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unbind-%E5%92%8Coff%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">unbind 和off的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">JavaScript对象的两类属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E8%B0%88JavaScript%E3%80%81ES5%E3%80%81ES6"><span class="toc-text">浅谈JavaScript、ES5、ES6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#requestAnimationFrame-%E4%B8%8E-requestIdleCallback"><span class="toc-text">requestAnimationFrame 与 requestIdleCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-text">requestAnimationFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requestIdleCallback"><span class="toc-text">requestIdleCallback</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set%E3%80%81Map%E3%80%81WeakSet-%E5%92%8C-WeakMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Set、Map、WeakSet 和 WeakMap 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E6%96%B9%E6%B3%95"><span class="toc-text">常用技巧方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#split-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8F%82%E6%95%B0"><span class="toc-text">split 方法获取地址栏参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%9010%E4%BB%A5%E4%B8%8B%E6%AD%A3%E6%95%B0"><span class="toc-text">随机生成10以下正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%B7%AE%E9%9B%86%EF%BC%8C%E5%B9%B6%E9%9B%86%EF%BC%8C%E8%A1%A5%E9%9B%86"><span class="toc-text">数组的交集，差集，并集，补集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E5%B0%8F%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%AD%98%E5%9C%A8%E5%B0%8F%E6%95%B0%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">JS中小数相加存在小数位的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E5%90%8E%E9%9D%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">截取最后一个特定字符后面的字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E6%93%8D%E4%BD%9Cdom"><span class="toc-text">JS操作dom</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#querySelector%E5%92%8CgetElementById"><span class="toc-text">querySelector和getElementById</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-text">创建节点添加节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E6%88%96%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-text">获取屏幕或容器的宽高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">绑定解除事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%B8%B2%E5%8F%A3%E5%8F%98%E5%8C%96"><span class="toc-text">监听串口变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%87%E8%91%A9%E7%9A%84JavaScript%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">奇葩的JavaScript闭包面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E5%87%BD%E6%95%B0"><span class="toc-text">JS中有几种函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建函数的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AAfun%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">三个fun函数的关系是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">函数作用域链的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">到底在调用哪个函数？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#devDependencies-%E5%92%8C-dependencies-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">devDependencies 和 dependencies 的区别</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-B_JS_0基础" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      0基础
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/05/29/B_JS_0%E5%9F%BA%E7%A1%80/" class="article-date">
	  <time datetime="2022-05-28T23:33:16.000Z" itemprop="datePublished">2022-05-29</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/B-JS/">B_JS</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/05/29/B_JS_0%E5%9F%BA%E7%A1%80/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="三大山-堆栈内存及闭包作用域"><a href="#三大山-堆栈内存及闭包作用域" class="headerlink" title="三大山-堆栈内存及闭包作用域"></a>三大山-堆栈内存及闭包作用域</h2><img src="C:\Users\fuyunjinglong\AppData\Roaming\Typora\typora-user-images\image-20220912183546292.png" alt="image-20220912183546292" style="zoom:80%;" />

<h3 id="JS的8种数据类型"><a href="#JS的8种数据类型" class="headerlink" title="JS的8种数据类型"></a>JS的8种数据类型</h3><ul>
<li>基本类型：Number,String,Boolean,Null,undefined,symbol</li>
<li>引用类型：Object,Array,function</li>
</ul>
<p><strong>Undefined、Null的区别</strong></p>
<ul>
<li><p>Undefined 类型表示未定义，它的类型只有一个值，就是 undefined，判空：if(a===undefined)</p>
</li>
<li><p>Null表示的是：“定义了但是为空”,判空：if(a)</p>
</li>
</ul>
<h3 id="JS堆栈内存运行机制-深浅拷贝"><a href="#JS堆栈内存运行机制-深浅拷贝" class="headerlink" title="JS堆栈内存运行机制-深浅拷贝"></a>JS堆栈内存运行机制-深浅拷贝</h3><p>var obj={}</p>
<p>obj存放在栈内存中，{}实例存在在堆中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//example 1</span><br><span class="line">let a=&#123;&#125;, b=&#x27;0&#x27;, c=0;</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;培训&#x27;, 对象的key数字和字符串等效</span><br><span class="line"></span><br><span class="line">// ---------------------</span><br><span class="line">//example 2</span><br><span class="line">let a=&#123;&#125;, b=Symbol(&#x27;1&#x27;), c=Symbol(&#x27;1&#x27;);</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;珠峰&#x27;, Symbol的特点，都是唯一的</span><br><span class="line"></span><br><span class="line">// ---------------------</span><br><span class="line">//example 3</span><br><span class="line">let a=&#123;&#125;, b=&#123;n:&#x27;1&#x27;&#125;, c=&#123;m:&#x27;2&#x27;&#125;;</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;培训&#x27;, key会转化成字符串[Obejct object]</span><br></pre></td></tr></table></figure>

<p><strong>赋值、浅拷贝、深拷贝</strong></p>
<p>赋值：把一个对象赋给一个新变量，赋的其实是该对象在栈中的地址，所有值都会相互影响</p>
<p>浅拷贝：重新在堆中创建内存，拷贝后的基本数据类型不影响，但是引用类型属性是相互影响共用</p>
<p>深拷贝：重新在堆中创建内存，所有值都不相互影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值，全部影响</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">play</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =person;</span><br><span class="line">person2.<span class="property">name</span>=<span class="string">&#x27;lucy&#x27;</span>;</span><br><span class="line">person2.<span class="property">play</span>[<span class="number">0</span>]=<span class="string">&#x27;爵士&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝，基本类型不影响，引用类型数据共用</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">play</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">qian</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> target=&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">        target[key]= obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =<span class="title function_">qian</span>(person);</span><br><span class="line">person2.<span class="property">name</span>=<span class="string">&#x27;lucy&#x27;</span>;</span><br><span class="line">person2.<span class="property">play</span>[<span class="number">0</span>]=<span class="string">&#x27;爵士&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝，所有数据不影响</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">play</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>],</span><br><span class="line">    <span class="attr">date</span>:<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\w+&#x27;</span>),</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deep</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> target=&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);<span class="comment">// a instanceof b一句话表示:b的prototypey在a的原型链上</span></span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)<span class="keyword">return</span> obj;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">        target[key]= <span class="title function_">deep</span>(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =<span class="title function_">deep</span>(person);</span><br><span class="line">person2.<span class="property">name</span>=<span class="string">&#x27;lucy&#x27;</span>;</span><br><span class="line">person2.<span class="property">play</span>[<span class="number">0</span>]=<span class="string">&#x27;爵士&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2);</span><br></pre></td></tr></table></figure>

<p>JSON.parse()对于正则和函数无法拷贝</p>
<p><strong>浅拷贝的实现方式</strong></p>
<p>Object.assign()</p>
<p>…扩展运算符</p>
<p>lodash clone</p>
<p><strong>深拷贝的实现</strong></p>
<p>$.extend</p>
<p>lodash deepClone</p>
<h3 id="变量提升机制"><a href="#变量提升机制" class="headerlink" title="变量提升机制"></a>变量提升机制</h3><p>var上升为全局，let是块级作用域，作用于当前。</p>
<ul>
<li>var：声明提升，没有局部作用域，声明覆盖</li>
<li>let:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(var i =0;i&lt;5;i++)&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;var的事件循环机制:&#x27;,i);// 输出55555</span><br><span class="line">    &#125;,500)</span><br><span class="line">&#125;</span><br><span class="line">for(let j =0;j&lt;5;j++)&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;let的块级作用域：&#x27;,j);// 输出01234</span><br><span class="line">    &#125;,500)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><h3 id="闭包的两大作用：保存、保护"><a href="#闭包的两大作用：保存、保护" class="headerlink" title="闭包的两大作用：保存、保护"></a>闭包的两大作用：保存、保护</h3><p>1.先要说到作用域和作用域链，即AO和GO</p>
<p>js代码在预编译阶段，会有一个AO函数作用域和GO全局作用域。</p>
<p>AO是指函数作用域，GO是指全局作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> aa=<span class="number">111</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> bb=<span class="number">22</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(aa)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t=<span class="title function_">a</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  A = <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(a + b++);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">alert</span>(a++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">A</span>(<span class="number">2</span>); <span class="comment">// ‘1’，‘4’</span></span><br></pre></td></tr></table></figure>

<p>a的作用域scope：scope[0]=AO{aa,function b},scope[1]=GO{function a}</p>
<p>b的作用域scope:scope[0]=AO{bb},scope[1]=AO{aa,function b},scope[2]=GO{function a}</p>
<p>通俗理解：<strong>闭包函数(被包裹的函数)中必须要使用到外部函数中的变量</strong></p>
<p>优点：1.读取函数内部变量；2.让这些变量的值始终保持在内存中，不会在f1调用后被自动清除；</p>
<p>缺点：滥用闭包导致内存泄漏，能不用尽量不用，即时释放内存。（闭包会加深作用域链，加长变量查找时间）</p>
<p>场景：setTimeout的函数携带参数；回调；变量封装</p>
<h3 id="JS编译机制：VO-AO-GO"><a href="#JS编译机制：VO-AO-GO" class="headerlink" title="JS编译机制：VO/AO/GO"></a>JS编译机制：VO/AO/GO</h3><p>JS有两个特性，一个是单线程，一个是解释性语言。</p>
<p>JS运行步骤：1.语法分析2.预编译3.解释执行</p>
<p>函数执行四部曲：</p>
<p>1.创建AO对象，供js引擎自己去访问</p>
<p>activation object （活跃对象/执行期上下文）</p>
<p>2.找变量和形参的声明，作为AO对象的属性名，值是undefined</p>
<p>3.实参和形参相统一，实参赋值给形参</p>
<p>4.找函数声明(注意不是函数表达式)，会覆盖变量的声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,c</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//function a()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//function c()&#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> d= <span class="number">678</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//function ()&#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//function c()&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="literal">undefined</span>,<span class="number">1</span>,<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="attr">c</span>:<span class="literal">undefined</span>,<span class="number">2</span>,<span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="attr">d</span>:<span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS高阶编程技巧：惰性函数-柯里化-高阶函数"><a href="#JS高阶编程技巧：惰性函数-柯里化-高阶函数" class="headerlink" title="JS高阶编程技巧：惰性函数/柯里化/高阶函数"></a>JS高阶编程技巧：惰性函数/柯里化/高阶函数</h3><p><strong>JS函数式编程思想</strong></p>
<p><strong>1.概述</strong></p>
<p>中心思想是指：<strong>一个函数的返回值，仅仅依赖于参数的值，而不会因为其他外部的状态而不同。</strong></p>
<p>我们很难将所有函数都构建成符合函数式编程思维的范式，但如果应用函数式编程，则它的好处主要体现于：</p>
<ul>
<li>引用透明（Referential Transparency）</li>
<li>无副作用（No Side Effect）</li>
<li>无竞争态 (No Race Condition)</li>
<li>惰性求值 (Lazy Evaluation)</li>
</ul>
<p><strong>(1)无副作用（no side effects）</strong></p>
<p>任意一个函数，只要输入是确定的，输出就是确定的，这种<strong>纯函数</strong>称之为没有副作用的。</p>
<p> 函数在表现方式上，我们可以将其区分为 <code>纯函数</code> 和 <code>非纯函数</code>。他们有以下区分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">纯函数：返回值仅依赖于参数，输入相同的值，便会得到相同的值的函数。</span><br><span class="line">let seed = 0; // 定义一个外部变量</span><br><span class="line">// 一个用于求和的函数</span><br><span class="line">const sum = (x, y) =&gt; x + y;</span><br><span class="line"></span><br><span class="line">非纯函数：在参数一致的情况下，返回值可能不一致的函数。</span><br><span class="line">let seed = 0; // 定义一个外部变量</span><br><span class="line">// 另一个用于求和的函数</span><br><span class="line">const sum = (x, y) =&gt; x + y + (++seed);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">纯函数` 和 `非纯函数` 最大的两个不同的表现在于：`副作用性` 和 `引用透明性</span><br></pre></td></tr></table></figure>

<p><code>副作用性</code> 是指，该函数的调用过程中，是否对主函数（调用者）产生了附加影响，例如修改了函数外的变量或参数，我们就认为该函数是 <code>有副作用</code> 的函数。</p>
<p><strong>副作用主要表现于：</strong></p>
<ul>
<li><strong>I/O 操作</strong>：其结果本身就是无法预估的，因此无法判断给定了的参数，是否能给予我们预期的返回结果；比如接收输入、或者将结果输出。</li>
<li><strong>改变全局变量原有值</strong>，或者<strong>改变参数对象值及其属性</strong>：其执行结果也是带有副作用的。</li>
<li><strong>抛出异常或以错误中止</strong>：函数除了返回一个值之外，还可能发生不太确定的执行结果。</li>
</ul>
<p><strong>(2)引用透明</strong></p>
<p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p>
<p>非纯函数造成的最大的问题，就是其 <code>不可预知性</code> 。如果代码比较复杂时，会为我们梳理程序运行逻辑造成一定的困难。因此，在函数式编程思维中，我们应尽可能的确保我们编写的函数是 <code>纯函数</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript内置对象中的 非纯函数有：</span><br><span class="line">Math.random()</span><br><span class="line">console.log()</span><br><span class="line">element.addEventListener()</span><br><span class="line">Date.now()</span><br><span class="line">Array.prototype.sort()</span><br><span class="line">ajax操作等</span><br></pre></td></tr></table></figure>

<p>在一段程序中，我们无法保证所有的函数都是纯函数。但纯函数的覆盖面越大，对于调试、缓存数据及线程安全都会提供越多的便利。有一种说法是，保证80%的函数是纯函数即可。</p>
<p><strong>(3)数据不可变</strong></p>
<p>在React中，强调一个组件不能去修改传入的prop值，这遵循了Immutable的原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = a + 1;</span><br><span class="line">=&gt; a = 1  b = 2;</span><br></pre></td></tr></table></figure>

<p>变量b出现，虽然使用了变量a的值，但是没有修改a的值。</p>
<p>再看我们熟悉的react中的代码，假如初始化了this.state = { count: 1 }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    const newState = &#123; ...state, count: 2 &#125;; // &#123; count: 2 &#125;</span><br><span class="line">    this.setState(newState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们使用了this.state，但是没有修改this.state的引用地址和直接修改count的值，对待this.props也一样。</p>
<p>React官网中给出三点好处：</p>
<ul>
<li>简化复杂的功能</li>
</ul>
<p>不可变性使得复杂的特性更容易实现。</p>
<ul>
<li>跟踪数据的改变</li>
</ul>
<p>如果直接修改数据，那么就很难跟踪到数据的改变。跟踪数据的改变需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次。</p>
<p>跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了。</p>
<ul>
<li>确定在 React 中何时重新渲染</li>
</ul>
<p>不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染。</p>
<ul>
<li>纯函数</li>
<li>柯里化</li>
<li>高阶函数</li>
</ul>
<p><strong>1.尾调用</strong></p>
<p><strong>PS:ES6尾调用优化只能在严格模式下使用，详见<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化 阮一峰</a></strong></p>
<p><strong>定义：</strong>某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;//尾调用</span><br><span class="line">// 情况一 非尾调用</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line">// 情况二 非尾调用</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line">//尾调用不一定出现在函数尾部，只要是最后一步操作即可。</span><br><span class="line">    function f(x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    return m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  return n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1)尾调用优化（Tail call optimization）</p>
<p>如图所示，函数调用会在内存形成<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">调用栈（call stack）</a>，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>
<p><strong>优点：</strong>减小调用栈，节省内存使用。</p>
<p><img src="/img/image-20220114072242443.png" alt="image-20220114072242443"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  let m = 1;</span><br><span class="line">  let n = 2;</span><br><span class="line">  return g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line">// 等同于</span><br><span class="line">function f() &#123;</span><br><span class="line">  return g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure>

<p>(2)尾递归</p>
<p><strong>定义：</strong>尾调用自身。<br> “尾调用优化”对递归操作意义重大。ES6中第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归（在严格模式下），就不会发生栈溢出，相对节省内存</p>
<p><strong>2.柯里化</strong></p>
<p><strong>柯里化是把多参数的函数转换成少参数的函数的过程。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(a) &#123;</span><br><span class="line">  return function (b) &#123;</span><br><span class="line">    return function(c) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 调用</span><br><span class="line">let sum1 = sum(1);</span><br><span class="line">let sum2 = sum1(2);</span><br><span class="line">sum2(3); // 6</span><br></pre></td></tr></table></figure>

<p>高阶柯里化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function curry(func) &#123;</span><br><span class="line">  return function curried(...args) &#123;</span><br><span class="line">    if (args.length &gt;= func.length) &#123;</span><br><span class="line">      return func.apply(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return function(...args2) &#123;</span><br><span class="line">        return curried.apply(this, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sum(a, b, c) &#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let curriedSum = curry(sum);</span><br><span class="line">let cu1 = curriedSum(1)</span><br><span class="line">alert( curriedSum( 1,2, 3) );// 6 任意柯里化</span><br><span class="line">alert( cu1( 2, 3) );// 6 任意柯里化</span><br></pre></td></tr></table></figure>

<p>当我们运行它时，这里有两个 <code>if</code> 执行分支：</p>
<ol>
<li>现在调用：如果传入的 <code>args</code> 长度与原始函数所定义的（<code>func.length</code>）相同或者更长，那么只需要将调用传递给它即可。</li>
<li>获取一个偏函数：否则，<code>func</code> 还没有被调用。取而代之的是，返回另一个包装器 <code>pass</code>，它将重新应用 <code>curried</code>，将之前传入的参数与新的参数一起传入。然后，在一个新的调用中，再次，我们将获得一个新的偏函数（如果参数不足的话），或者最终的结果。</li>
</ol>
<p>例如，让我们看看 <code>sum(a, b, c)</code> 这个例子。它有三个参数，所以 <code>sum.length = 3</code>。</p>
<p>对于调用 <code>curried(1)(2)(3)</code>：</p>
<ol>
<li>第一个调用 <code>curried(1)</code> 将 <code>1</code> 保存在词法环境中，然后返回一个包装器 <code>pass</code>。</li>
<li>包装器 <code>pass</code> 被调用，参数为 <code>(2)</code>：它会获取之前的参数 <code>(1)</code>，将它与得到的 <code>(2)</code> 连在一起，并一起调用 <code>curried(1, 2)</code>。由于参数数量仍小于 3，<code>curry</code> 函数依然会返回 <code>pass</code>。</li>
<li>包装器 <code>pass</code> 再次被调用，参数为 <code>(3)</code>，在接下来的调用中，<code>pass(3)</code> 会获取之前的参数 (<code>1</code>, <code>2</code>) 并将 <code>3</code> 与之合并，执行调用 <code>curried(1, 2, 3)</code> — 最终有 <code>3</code> 个参数，它们被传入最原始的函数中</li>
</ol>
<h3 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h3><blockquote>
<p><strong>(1)CommonJS规范—cjs</strong></p>
</blockquote>
<p>CJS是<strong>同步</strong>的，适用于<strong>后端</strong>环境，Nodejs中使用的是这个规范。</p>
<p>CommonJS的核心是通过 module.exports 暴露模块接口，通过 require 引入模块。</p>
<p>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</p>
<blockquote>
<p><strong>(2)AMD(Asynchronous Module Definition ，异步模块定义)/CMD</strong>(Common Module Definition，通用模块定义)</p>
</blockquote>
<p>AMD是<strong>异步</strong>的，适用于<strong>前端</strong>环境。AMD推崇的是<strong>依赖前置</strong>.</p>
<p>CMD是<strong>同步</strong>的，适用于<strong>前端</strong>环境<strong>。</strong>CMD推崇<strong>就近依赖</strong>。</p>
<p>AMD是RequireJS在推广过程中对模块定义的规范化产出。CMD是SeaJS在推广过程中对模块定义的规范化产出。</p>
<p>有的人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</p>
<p>requireJS主要解决两个问题：</p>
<ul>
<li>1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li>
<li>2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMD与CMD区别</span><br><span class="line">模块定义时对依赖的处理不同：</span><br><span class="line">1.AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</span><br><span class="line">2.CMD推崇就近依赖，只有在用到某个模块的时候再去require</span><br><span class="line">同为异步加载模块的区别：</span><br><span class="line">1.AMD在加载模块完成后就会执行该模块</span><br><span class="line">2.CMD加载完某个依赖模块后并不执行，只是下载而已,这样模块的执行顺序和书写顺序是完全一致的。性能较好，只有用户需要时才执行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(3)ES6—ESM</p>
</blockquote>
<p>ECMAScript 6 的一个目标是解决作用域的问题，也为了使 JS 应用程序显得有序，于是引进了模块。目前部分主流浏览器已原生支持 ES Module，使用 type = module 指定为模块引入即可<br>注意：使用该方式执行 JS 时自动应用 defer 属性。</p>
<p>ESM由于具有简单的语法，<strong>同步异步</strong>加载的特性，适用于前后端，以及<strong>Tree-shakeable</strong>的特性.具有Tree-shakeable的特性，这是由于<strong>ES6的静态模块</strong>结构。</p>
<blockquote>
<p>(4)UMD(Universal Module Definition，万能模块定义)</p>
</blockquote>
<p>UMD可以在任何环境下使用，并且在ESM不能使用的情况下回选择UMD。兼容 CommonJS 和 AMD 规范，兼容ESM。</p>
<blockquote>
<p>UMD 实现原理：</p>
<p>先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；<br>再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；<br>前两个都不存在，则将模块公开到全局（window 或 global）<br>UMD 使得你可以直接使用<code>&lt;script&gt;</code>标签引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CommonJS和es6区别</span><br><span class="line">- 因为CommonJS的`require`语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ；</span><br><span class="line">- CommonJS 模块输出的是一个值的拷贝，而ES6 模块输出的是值的引用；</span><br><span class="line">- CommonJS 模块是动态引入，执行时引入，而ES6 模块是静态引入，编译时引入；</span><br><span class="line">- 因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用`import`加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</span><br><span class="line">- 关于模块顶层的`this`指向问题，在CommonJS顶层，`this`指向当前模块；而在ES6模块中，`this`指向`undefined`；</span><br></pre></td></tr></table></figure>

<h2 id="三大山-面向对象和this处理"><a href="#三大山-面向对象和this处理" class="headerlink" title="三大山-面向对象和this处理"></a>三大山-面向对象和this处理</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h3 id="constructor构造函数模式"><a href="#constructor构造函数模式" class="headerlink" title="constructor构造函数模式"></a>constructor构造函数模式</h3><h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><h3 id="原形和原型链"><a href="#原形和原型链" class="headerlink" title="原形和原型链"></a>原形和原型链</h3><p><strong>1.从属关系</strong></p>
<p>proto是对象object的原形属性</p>
<p>prototype是函数fn的原形属性</p>
<p>对象的proto保存着对象的构造函数的prototype</p>
<p><strong>2.构造函数的原形属性也是一个对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span>=<span class="number">222</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span>=<span class="number">333</span>;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">__proto__</span>===<span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>===<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">// 顶层null</span></span><br></pre></td></tr></table></figure>

<p><strong>3.原型链</strong></p>
<p>以对象为基准，以proto为连接点，一直到Object.prototype为止的一条链条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">111</span>,</span><br><span class="line">    <span class="attr">__proto__</span>:<span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>=&#123;</span><br><span class="line">        <span class="attr">b</span>:<span class="number">222</span>,</span><br><span class="line">        <span class="attr">__proto__</span>:<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>=&#123;</span><br><span class="line">            <span class="attr">c</span>:<span class="number">333</span>,</span><br><span class="line">            <span class="attr">__proto__</span>:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象的proto保存着对象的构造函数的prototype属性，从而实现原形继承。自己的属性没有会去构造函数汇总找属性，一层一层找，直到Object.prototype。</p>
<p><strong>4.Function和Object特殊性</strong></p>
<p>他们既是函数又是对象，因为Test=new Function()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Test</span> = <span class="keyword">new</span> <span class="title class_">Function</span>();<span class="comment">//Test是函数，那么也应该是函数构造来的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true,1,js规定的，可以理解为Function既是函数又是对象，那么它的proto也等于prototype</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true,2,Object既是函数又是对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1,2最终得到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property">__proto__</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>5.是否存在属性</strong></p>
<p>test.hasOwnProperty(‘a’)//判断自己对象内部是否存在属性</p>
<p>‘b’  in test //判断原型链中是否存在属性</p>
<p>6.constructor是构造函数，可以更改</p>
<p>console.log(test.constructor===Test);//true</p>
<p>//构造函数可以被修改</p>
<p>function Test2(){</p>
<p>  this.a=000;</p>
<p>}</p>
<p>test.constructor = Test2</p>
<h3 id="new运算符的实现机制"><a href="#new运算符的实现机制" class="headerlink" title="new运算符的实现机制"></a>new运算符的实现机制</h3><ul>
<li>1：检查类是否已经被加载，运行时常量池中查找该引用所指向的类有没有被加载；</li>
<li>2：为对象分配内存空间，通过类元信息来确定类型和后面需要申请的内存大小；</li>
<li>3：为分配的内存空间初始化零值（为对象字段设置零值）；</li>
<li>4：对对象进行其他设置（设置对象头），类的元数据信息，对象的hashcode，GC分代年龄等；</li>
<li>5：执行构造方法</li>
</ul>
<p><strong>js中的new()做了什么？</strong></p>
<p>专业解释：</p>
<blockquote>
<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>2、属性和方法被加入到 this 引用的对象中。</p>
<p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
</blockquote>
<p>经历以下 4个步骤：<br>(1) 创建一个新对象；<br>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；<br>(3) 执行构造函数中的代码（为这个新对象添加属性） ；<br>(4) 返回新对象。</p>
<p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br></pre></td></tr></table></figure>

<p>本质干了三件事：</p>
<blockquote>
<p>var obj = {}</p>
<p>obj.<strong>proto</strong> = Base.prototype</p>
<p>Base.call(obj)</p>
</blockquote>
<p>第一行，我们创建了一个空对象obj<br>第二行，我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象<br>第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是”base”，关于call函数的用法。</p>
<p><code>new</code> 的实现很简单，就是一步一步把它要做的操作给实现出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">Con, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新的空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将这个空对象的__proto__指向构造函数的原型</span></span><br><span class="line">  <span class="comment">// obj.__proto__ = Con.prototype;</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将this指向空对象</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="comment">// 对构造函数返回值做判断，然后返回对应的值</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS的this五种情况的梳理"><a href="#JS的this五种情况的梳理" class="headerlink" title="JS的this五种情况的梳理"></a>JS的this五种情况的梳理</h3><ul>
<li>事件绑定</li>
<li>普通函数执行</li>
<li>构造函数执行</li>
<li>箭头函数</li>
<li><code>call、apply、bind</code></li>
</ul>
<p><strong>情况一：事件绑定</strong></p>
<p><code>this</code>：给元素的某个事件行为绑定方法，事件触发，方法执行，此时方法中的 <em><code>this</code>一般都是当前元素本身</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">// 方法一</span><br><span class="line"> btn.onclick=function anonymous()&#123;</span><br><span class="line">console.log(this);   </span><br><span class="line"> &#125;</span><br><span class="line"> // 方法二</span><br><span class="line">  btn.addEventListener(&#x27;click&#x27;,function anonymous()&#123;</span><br><span class="line">	console.log(this); </span><br><span class="line"> &#125;,false)</span><br><span class="line"> // 方法三，兼容iE 6/7/8 DOM2事件绑定</span><br><span class="line"> btn.attachEvent(&#x27;onclick&#x27;,function anonymous()&#123;</span><br><span class="line">  console.log(this);//this指向window</span><br><span class="line"> &#125;)</span><br><span class="line"> // 方法四</span><br><span class="line"> function fn()&#123;</span><br><span class="line">     console.log(this);</span><br><span class="line"> &#125;</span><br><span class="line"> btn.onclick=fn.bind(window)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>情况二：普通函数执行</strong></p>
<p><strong>‘点’前面是谁this就是谁</strong> 普通函数执行，它里面的<code>this</code>是谁，取决于方法执行前面是否有<code>&quot;点&quot;</code> 有的话，<code>“点”前面</code>是谁<code>this</code>就是谁，没有<code>this</code>指向<code>window</code>（严格模式下是<code>undefined</code>）。</p>
<p>默认情况下，指向window对象，只有当有对象时，才指向对象。关键看调用的时候是fn()还是obj.fn()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span> (p)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">get</span>(<span class="string">&#x27;黄山&#x27;</span>);</span><br><span class="line">等效于get.<span class="title function_">call</span>(<span class="variable language_">window</span>,<span class="string">&#x27;大理&#x27;</span>)---<span class="variable language_">this</span>指向<span class="variable language_">window</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;凤凰&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我在<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;a&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">fn</span>(<span class="string">&#x27;划水&#x27;</span>);</span><br><span class="line">person.<span class="property">fn</span>.<span class="title function_">call</span>(person,<span class="string">&#x27;划水&#x27;</span>);---<span class="variable language_">this</span>指向person</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name =<span class="number">222</span>;</span><br><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="number">111</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun=a.<span class="property">say</span>;</span><br><span class="line"><span class="title function_">fun</span>(); <span class="comment">//window 222</span></span><br><span class="line">a.<span class="title function_">say</span>();<span class="comment">// a 111</span></span><br><span class="line"><span class="keyword">var</span> b=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="number">333</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.<span class="title function_">say</span>(a.<span class="property">say</span>);<span class="comment">//window 222</span></span><br><span class="line">b.<span class="property">say</span>=a.<span class="property">say</span>;</span><br><span class="line">b.<span class="title function_">say</span>();<span class="comment">//b 333</span></span><br></pre></td></tr></table></figure>

<p><strong>情况三：构造函数执行(new xxx)</strong></p>
<p>函数中的this是当前类的实列。</p>
<script>
    function Fn(){
        console.log(this);
          //this.xxx=xxx是给当前实列设置私有属性
      }
      let f= new Fn;
</script>


<p><strong>情况四：箭头函数</strong></p>
<p>箭头函数中this在定义函数的时候就绑定了，而不是在执行函数时候绑定。</p>
<p>箭头函数中，this指向的固定化，并不是因为箭头函数有绑定this机制。是因为箭头函数中根本没有自己的this.它所用的this，是共用父继承下来的this。所以也不能作构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">22</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 同级是obj内部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">say</span>();<span class="comment">//指向obj，但this指向父级，同级是obj，父级是window,11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">birth</span>:<span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> birth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">fn</span> = (<span class="params"></span>)=&gt;<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>()-b<span class="comment">//同级是getAge内部</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getAge</span>());<span class="comment">//指向obj，但遇到箭头函数this指向父级obj</span></span><br></pre></td></tr></table></figure>

<p><strong>情况五：、call、apply、bind</strong></p>
<p><code>call</code> <code>apply</code> <code>bind</code>都可以改变函数调用的<code>this</code>指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有只猫叫小黑，小黑会吃鱼</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小黑&#x27;</span>,</span><br><span class="line">    <span class="title function_">eatFish</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;吃鱼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有只狗叫大毛，大毛会吃骨头</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大毛&#x27;</span>,</span><br><span class="line">    <span class="title function_">eatBone</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;吃骨头&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;=================== call =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃</span></span><br><span class="line">cat.<span class="property">eatFish</span>.<span class="title function_">call</span>(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="comment">// 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span></span><br><span class="line">dog.<span class="property">eatBone</span>.<span class="title function_">call</span>(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;=================== apply =========================&#x27;</span>);</span><br><span class="line">cat.<span class="property">eatFish</span>.<span class="title function_">apply</span>(dog, [<span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line">dog.<span class="property">eatBone</span>.<span class="title function_">apply</span>(cat, [<span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;=================== bind =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃</span></span><br><span class="line"><span class="keyword">const</span> test1 = cat.<span class="property">eatFish</span>.<span class="title function_">bind</span>(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = dog.<span class="property">eatBone</span>.<span class="title function_">bind</span>(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="title function_">test1</span>()</span><br><span class="line"><span class="title function_">test2</span>()</span><br></pre></td></tr></table></figure>

<p><strong><code>call</code>语法</strong></p>
<ul>
<li><code>fun.call(thisArg, arg1, arg2, ...)</code></li>
<li><code>thisArg</code>: 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>
<li><code>arg1, arg2, ...</code> 指定的参数列表</li>
</ul>
<p><strong><code>apply</code>语法</strong></p>
<ul>
<li><code>fun.apply(thisArg, [argsArray])</code></li>
<li><code>thisArg</code> 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li><code>argsArray</code> 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<p><strong><code>bind</code>语法</strong></p>
<ul>
<li><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></li>
<li><code>thisArg</code> 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li><code>arg1, arg2, ...</code> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<p><strong>小结：</strong></p>
<blockquote>
<ol>
<li>当我们使用一个函数需要改变<code>this</code>指向的时候才会用到<code>call``apply``bind</code></li>
<li>如果你要传递的参数不多，则可以使用<code>fn.call(thisObj, arg1, arg2 ...)</code></li>
<li>如果你要传递的参数很多，则可以用数组将参数整理好调用<code>fn.apply(thisObj, [arg1, arg2 ...])</code></li>
<li>如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用<code>const newFn = fn.bind(thisObj); newFn(arg1, arg2...)</code></li>
</ol>
</blockquote>
<h3 id="JS的四大数据类型检查方案"><a href="#JS的四大数据类型检查方案" class="headerlink" title="JS的四大数据类型检查方案"></a>JS的四大数据类型检查方案</h3><h3 id="JS的四大继承方案"><a href="#JS的四大继承方案" class="headerlink" title="JS的四大继承方案"></a>JS的四大继承方案</h3><ul>
<li>原型链继承</li>
<li>构造函数继承</li>
<li>组合式继承</li>
<li>寄生组合式继承</li>
</ul>
<p><strong>原型链继承</strong></p>
<p>定义：让子类的原型指向父类的实列。</p>
<ul>
<li>弊端：父类的某个实例的修改，会影响到所有子类的实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;李连杰&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 子类的原形指向父类的实例</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);<span class="comment">//李连杰</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>());<span class="comment">//李连杰</span></span><br><span class="line"><span class="comment">// 弊端：父类的某个实例的修改，会影响到所有子类的实例</span></span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">child2.<span class="property">name</span> = <span class="string">&#x27;成龙&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>);<span class="comment">//成龙</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);<span class="comment">//成龙</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数继承</strong></p>
<p>定义：在子类构造函数中，执行父类的构造函数，并为其绑定子类的this(改变this指向)</p>
<ul>
<li>弊端：子类无法继承父类的属性和方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    // 构造函数继承</span><br><span class="line">function Animals(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animals.prototype.age=3</span><br><span class="line">Animals.prototype.getName=function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">function Dog()&#123;</span><br><span class="line">    Animals.call(this,&#x27;柴犬&#x27;)// call的应用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog()</span><br><span class="line">const dog1 = new Dog()</span><br><span class="line">dog.name = &#x27;金毛&#x27;</span><br><span class="line">console.log(dog.name);//金毛</span><br><span class="line">console.log(dog1.name);//柴犬</span><br><span class="line">// 弊端:子类无法继承父类的属性和方法</span><br><span class="line">dog.age</span><br><span class="line">dog.getName()</span><br></pre></td></tr></table></figure>

<p><strong>组合式继承</strong></p>
<p>定义：结合了原型链继承和构造函数继承</p>
<ul>
<li>优点：子类继承父类的属性和方法，且不影响其他子类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // 组合式继承：结合了原型链继承和构造函数继承</span><br><span class="line">function Car(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.getName=function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">// 结合了构造函数继承</span><br><span class="line">function Bmw(name)&#123;</span><br><span class="line">    Car.call(this,name)// call的应用</span><br><span class="line">&#125;</span><br><span class="line">// 结合了原型链继承</span><br><span class="line">Bmw.prototype = new Car()</span><br><span class="line">const bmw1 = new Bmw(&#x27;宝马3系&#x27;)</span><br><span class="line">const bmw2 = new Bmw(&#x27;宝马7系&#x27;)</span><br><span class="line">bmw1.name = &#x27;宝马5系&#x27;</span><br><span class="line">console.log(bmw1.name);//宝马5系</span><br><span class="line">console.log(bmw2.name);//宝马7系</span><br></pre></td></tr></table></figure>

<p><strong>寄生组合式继承</strong></p>
<p>定义：父类原形赋值给子类原形</p>
<ul>
<li><p>弊端：如果没有Object.create浅拷贝，这里父类的实例可以调用子类的方法</p>
<p>car.getCar()</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 寄生式组合：父类原形赋值给子类原形</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结合了构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bmw</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="title class_">Car</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name)<span class="comment">// call的应用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bmw</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getCar</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是子类的getCar()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式组合的关键，利用Object.create浅拷贝，父类原形赋值给子类原形</span></span><br><span class="line"><span class="title class_">Bmw</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// 原型链的一个规则</span></span><br><span class="line"><span class="title class_">Bmw</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Bmw</span></span><br><span class="line"><span class="keyword">const</span> bmw1 = <span class="keyword">new</span> <span class="title class_">Bmw</span>(<span class="string">&#x27;宝马3系&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bmw2 = <span class="keyword">new</span> <span class="title class_">Bmw</span>(<span class="string">&#x27;宝马7系&#x27;</span>)</span><br><span class="line">bmw1.<span class="property">name</span> = <span class="string">&#x27;宝马5系&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bmw1.<span class="property">name</span>);<span class="comment">//宝马5系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bmw2.<span class="property">name</span>);<span class="comment">//宝马7系</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"><span class="comment">// 弊端：如果没有Object.create浅拷贝，这里父类的实例可以调用子类的方法</span></span><br><span class="line">car.<span class="title function_">getCar</span>()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="三大山-DOM和BOM及事件处理机制"><a href="#三大山-DOM和BOM及事件处理机制" class="headerlink" title="三大山-DOM和BOM及事件处理机制"></a>三大山-DOM和BOM及事件处理机制</h2><h3 id="DOM-BOM的核心操作"><a href="#DOM-BOM的核心操作" class="headerlink" title="DOM/BOM的核心操作"></a>DOM/BOM的核心操作</h3><h3 id="DOM2级事件的核心运行机制"><a href="#DOM2级事件的核心运行机制" class="headerlink" title="DOM2级事件的核心运行机制"></a>DOM2级事件的核心运行机制</h3><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>定义：当事件触发时，把要做的事委托给父元素来处理。</p>
<p>事件传播分成三个阶段：</p>
<ul>
<li>捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；</li>
<li>目标阶段：在目标节点上触发，称为“目标阶段”</li>
<li>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> target = event.<span class="property">target</span>;</span><br><span class="line">      <span class="keyword">switch</span> (target.<span class="property">id</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>:</span><br><span class="line">          <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;事件委托&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>:</span><br><span class="line">          location.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>: <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>1.JavaScript是单线程，非阻塞的</strong></p>
<p>单线程：JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的会有很多复杂的问题要处理.</p>
<p>非租塞：多线程和异步是通过通过 event loop 实现。</p>
<p><strong>2.任务类型</strong></p>
<p><strong>同步任务</strong>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p><strong>异步任务</strong>指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>异步任务<strong>按照优先级</strong>，又分为微任务和宏任务。</p>
<p><strong>宏任务</strong>:每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主代码块</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"><span class="built_in">setInterval</span></span><br><span class="line">postMessage</span><br><span class="line"><span class="title class_">MessageChannel</span></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">Node</span>.<span class="property">js</span> 环境)</span><br><span class="line"><span class="title function_">script</span>(可以理解为外层同步代码)</span><br><span class="line">I/O（<span class="title class_">Node</span>.<span class="property">js</span>）</span><br><span class="line"><span class="variable constant_">UI</span>交互事件</span><br></pre></td></tr></table></figure>

<p><strong>微任务</strong>：当前宏任务执行结束后立即执行的任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">then</span></span><br><span class="line"><span class="title class_">MutationObserver</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">observe</span>（已废弃；<span class="title class_">Proxy</span> 对象替代）</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="title class_">Node</span>.<span class="property">js</span> 环境)</span><br></pre></td></tr></table></figure>

<p><strong>3.Event Loop执行流程</strong></p>
<p>定义：”<strong>Event Loop是一个程序结构，用于等待和发送消息和事件。</strong></p>
<p>主要涉及<strong>调用栈</strong>(call stack是一个存储函数调用的<strong>栈结构</strong>，遵循<strong>先进后出</strong>的原则)、<strong>宏任务队列</strong>(macrotaskqueue)、<strong>微任务队列</strong>(microtask quene).</p>
<p><strong>特别强调</strong>：根据规范，<strong>宏任务</strong>的队列可以有多个，而<strong>微任务</strong>队列只能有一个。这个过程中，如果产生新的微任务，是可以加入到微任务队列，但如果产生宏任务，则需要添加到下一个宏任务队列。<strong>与先微任务后宏任务流程一致</strong></p>
<p>在一次Tick循环中，执行流程：<strong>当前执行栈即也属于宏任务-当前微任务</strong>-声明的(下一个)宏任务-声明的(下一个)宏任务。。。无限循环</p>
<ul>
<li>执行<strong>一个宏任务</strong>（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到<strong>微任务的任务队列</strong>中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始<strong>下一个宏任务(主线程中当前执行栈的宏任务就是下一个宏任务，所以当前执行栈总是先执行执行栈，然后微任务，再(下一个)宏任务)<strong>（从事件队列中获取，也就是 callbacke queue）</strong>与先微任务后宏任务流程一致</strong></li>
</ul>
<p><img src="/img/image-20211024222114449.png" alt="image-20211024222114449"></p>
<p><img src="/img/image-20220123200002149.png" alt="image-20220123200002149"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">加强版练习</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">async function async1() &#123;</span><br><span class="line">  await async2()</span><br><span class="line">  console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#x27;async2 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Promise&#x27;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br></pre></td></tr></table></figure>

<p>async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">	console.log(&#x27;async1 start&#x27;);</span><br><span class="line">	await async2();</span><br><span class="line">	console.log(&#x27;async1 end&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line">async function async1() &#123;</span><br><span class="line">	console.log(&#x27;async1 start&#x27;);</span><br><span class="line">	Promise.resolve(async2()).then(() =&gt; &#123;</span><br><span class="line">                console.log(&#x27;async1 end&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>微任务队列优先于宏任务队列执行；</li>
<li>微任务队列上创建的宏任务会被后添加到当前宏任务队列的尾端；</li>
<li>微任务队列中创建的微任务会被添加到微任务队列的尾端；</li>
<li>只要微任务队列中还有任务，宏任务队列就只会等待微任务队列执行完毕后再执行；</li>
<li>只有运行完 <code>await</code> 语句，才把 <code>await</code> 语句后面的全部代码加入到微任务行列；</li>
</ul>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><p><strong>本质上是优化高频率执行代码的一种手段</strong></p>
<ul>
<li><p>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p>
</li>
<li><p>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p>
<p>一个经典的比喻:</p>
<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>
<p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p>
<p>电梯第一个人进来后，15秒后准时运送一次，这是<strong>节流</strong></p>
<p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是<strong>防抖</strong></p>
<p><strong>节流</strong></p>
<p>完成节流可以使用<strong>时间戳与定时器</strong>的写法</p>
<p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> remaining = delay - (curTime - starttime)  <span class="comment">// 从上一次到现在，还剩下多少多余时间</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(fn, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>防抖</strong></p>
<p>  简单版本</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">  timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">  &#125;, wait);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// timeout 不为null</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">          <span class="keyword">let</span> callNow = !timeout; <span class="comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span></span><br><span class="line">          timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              timeout = <span class="literal">null</span>;</span><br><span class="line">          &#125;, wait)</span><br><span class="line">          <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">              func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>区别</strong></p>
<p>  相同点：</p>
<ul>
<li>都可以通过使用 <code>setTimeout</code> 实现</li>
<li>目的都是，降低回调执行频率。节省计算资源</li>
</ul>
<p>  不同点：</p>
<ul>
<li><p>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout </code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</p>
</li>
<li><p>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</p>
<p><strong>应用场景</strong></p>
</li>
</ul>
<p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求</p>
<ul>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
</li>
</ul>
<h2 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h2><p><code>AJAX</code>全称(Async Javascript and XML)即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1)创建对象</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">(2)打开请求</span><br><span class="line"></span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;example.txt&#x27;, true);</span><br><span class="line"></span><br><span class="line">(3)发送请求</span><br><span class="line"></span><br><span class="line">xhr.send(); 发送请求到服务器</span><br><span class="line"></span><br><span class="line">(4)接收响应</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange =function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">(1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。</span><br><span class="line"></span><br><span class="line">(2)当readystate==4时，表示已经接收到全部响应数据。</span><br><span class="line"></span><br><span class="line">(3)当status ==200时，表示服务器成功返回页面和数据。</span><br><span class="line"></span><br><span class="line">(4)如果(2)和(3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。</span><br></pre></td></tr></table></figure>

<p><strong>服务器响应处理</strong></p>
<p>同步处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  </span><br><span class="line">2. xhr.send();  </span><br><span class="line">3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</span><br></pre></td></tr></table></figure>

<p>异步处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. xhr.onreadystatechange=function()  &#123; </span><br><span class="line">2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; </span><br><span class="line">3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  </span><br><span class="line">4.      &#125;</span><br><span class="line">5.    &#125; </span><br></pre></td></tr></table></figure>

<p>什么是<strong>readyState</strong>？</p>
<p>readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。 readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义。</p>
<p>0：未初始化 – 尚未调用.open()方法；</p>
<p>1：启动 – 已经调用.open()方法，但尚未调用.send()方法；</p>
<p>2：发送 – 已经调用.send()方法，但尚未接收到响应；</p>
<p>3：接收 – 已经接收到部分响应数据；</p>
<p>4：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了；</p>
<p><strong>什么是status？</strong></p>
<p>1：服务器收到请求</p>
<p>2：成功</p>
<p>3：重定向</p>
<p>4：客户端错误</p>
<p>5：服务端错误</p>
<p>setTimeout模拟setInterval</p>
<p>背景：</p>
<p>某些间隔会被跳过（丢帧现象）<br>定时器之间的间隔会比预期小</p>
<p>核心思想：递归调用+闭包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function mySetInterval(func,millisecond)&#123;</span><br><span class="line">//使用闭包，如果没有闭包，则没办法递归调用下去</span><br><span class="line">    function inside()&#123;</span><br><span class="line">    	func();</span><br><span class="line">		setTimeout(inside,millisecond);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果是inside();则没有人任务队列的概念，第一次就会立即执行</span><br><span class="line">    setTimeout(inside,millisecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mySetInterval(like,100);</span><br><span class="line">function like()&#123;</span><br><span class="line">console.log(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><p><strong>(1)定义</strong></p>
<p>JavaScript 中自动垃圾回收机制的原理为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找出那些不再使用的变量，然后释放其占用的内存。</span><br><span class="line">垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</span><br></pre></td></tr></table></figure>

<p><strong>(2)内存生命周期</strong></p>
<p>不管什么程序语言，内存生命周期基本是一致的：</p>
<ul>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放归还</li>
</ul>
<p>对于javascript而言，</p>
<ul>
<li>简单类型，内存是保存在栈（stack）空间</li>
<li>复杂数据类型，内存是保存在堆（heap）空间</li>
</ul>
<p><strong>(3)为什么需要垃圾回收机制？</strong></p>
<p>在Chrome中，v8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制？</p>
<ul>
<li>表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景。JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</li>
<li>深层原因是，V8的垃圾回收机制的限制（垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，那么性能和应用直线下降）</li>
</ul>
<p><strong>(4)垃圾收集机制</strong></p>
<p>V8的垃圾回收策略主要是基于<code>分代垃圾回收机制</code>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p>
<p>(1.1)内存模型</p>
<ul>
<li>新生代：生存时间短的对象，支持 1～8M 的容量</li>
<li>老年代：生存时间长的对象，容量较大</li>
</ul>
<p>为了提高回收效率，V8 分别使用两个不同的垃圾回收器，</p>
<ul>
<li>副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。</li>
<li>主垃圾回收器 - Mark-Sweep &amp; Mark-Compact：主要负责老生代的垃圾回收。</li>
</ul>
<p>(1.2)新生代回收</p>
<p>在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。</p>
<p>Scavange算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>。</p>
<p>工作过程如下：</p>
<ul>
<li>标记活动对象和非活动对象</li>
<li>复制 from space 的活动对象到 to space 并对其进行排序</li>
<li>释放 from space 中的非活动对象的内存</li>
<li>将 from space 和 to space 角色互换</li>
</ul>
<img src="/img/image-20220222215742735.png" alt="image-20220222215742735" style="zoom: 80%;" />

<p>新生代又细分为<code>nursery</code>子代和<code>intermediate</code>子代两个区域。一个对象第一次分配内存时会被分配到新生代中的<code>nursery</code>子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 <code>intermediate</code> 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为<strong>晋升</strong>。</p>
<p>对象晋升的条件主要有以下两个：</p>
<ul>
<li>对象是否经历过一次<code>Scavenge</code>算法</li>
<li><code>To</code>空间的内存占比是否已经超过<code>25%</code>(之所以有<code>25%</code>的内存限制是因为<code>To</code>空间在经历过一次<code>Scavenge</code>算法后会和<code>From</code>空间完成角色互换，会变为<code>From</code>空间，后续的内存分配都是在<code>From</code>空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理)</li>
</ul>
<p>(1.3)老年代回收</p>
<p>scavenge算法缺陷：</p>
<ul>
<li>scavenge为复制算法，重复复制活动对象会使得效率低下</li>
<li>scavenge是牺牲空间来换取时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题</li>
</ul>
<p>老年代采用 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。</p>
<p>1.）Mark-Sweep</p>
<p>Mark-Sweep处理时分为两阶段，标记阶段和清理阶段。看起来与Scavenge类似，不同的是，Mark-Sweep在标记了活动对象和非活动对象之后，直接把非活动对象清除。</p>
<ul>
<li>标记阶段：对老生代进行第一次扫描，标记活动对象</li>
<li>清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象</li>
</ul>
<img src="/img/image-20220504095928130.png" alt="11" style="zoom: 80%;" />

<p>但是遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。</p>
<p>2.)Mark-Compact</p>
<p>若不清理这些内存碎片，如果出现需要分配一个大对象的时候，这时所有的碎片空间都完全无法完成分配，就会提前触发垃圾回收,而这次回收其实不是必要的。</p>
<p>Mark-Compact被提出，它是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>
<img src="/img/image-20220222220554956.png" alt="image-20220222220554956" style="zoom: 80%;" />

<p>(1.4)全停顿 Stop-The-World</p>
<p>由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为<code>全停顿</code>（stop-the-world）。</p>
<p>在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。</p>
<p><strong>(5)标记活动对象和非活动对象的策略</strong></p>
<p>通常有两个：<strong>引用计数</strong>和<strong>标记清除</strong></p>
<ul>
<li>引用计数-dom的垃圾回收机制</li>
<li>标记清除-js的垃圾回收机制</li>
</ul>
<p>(1.1)引用计数</p>
<p>定义：每个值被引用的次数。声明一个变量后，当使用引用类型值赋值时，+1，当这个变量又赋值另外一值，计数-1。</p>
<p>这是最初级的垃圾收集算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>缺陷:在循环的情况下，引用计数算法存在很大的局限性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">存在内存泄漏</span><br><span class="line">function problem() &#123;</span><br><span class="line">var objA = new Object();</span><br><span class="line">var objB = new Object();</span><br><span class="line">objA.someOtherObject = objB;</span><br><span class="line">objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br><span class="line">objectA 和objectB 通过各自的属性相互引用，即这两个对象的引用次数都是2，在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和objectB 还说明将继续存在，因为它们的引用次数永远不会是0。</span><br><span class="line"></span><br><span class="line">DOM中也如此</span><br><span class="line">var element=document.getElementById（&#x27;&#x27;）；</span><br><span class="line">var myObj=new Object();</span><br><span class="line">myObj.element=element;</span><br><span class="line">element.someObject=myObj;</span><br></pre></td></tr></table></figure>

<p>(1.2)标记清除</p>
<p>定义：当变量进入环境时，标记“进入环境”。当变量离开环境时，标记“离开环境”。</p>
<p>垃圾回收器创建了一个“roots”列表,“window”对象是一个全局变量，被当作root.</p>
<p>从root开始的所有对象如果是可达的，它就不被当作垃圾。所有未被标记的内存会被当做垃圾，收集器现在可以释放内存。</p>
<p>循环引用的问题迎刃而解，缺点: 算法运行时程序执行被暂停。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下几种情况都可以作为根节点：</span><br><span class="line">全局对象</span><br><span class="line">本地函数的局部变量和参数</span><br><span class="line">当前嵌套调用链上的其他函数的变量和参数</span><br></pre></td></tr></table></figure>



<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p><strong>1.概念</strong></p>
<p>内存溢出：当程序需要的内存超过了剩余内存，就会抛出内存溢出错误。</p>
<p>内存泄漏：<strong>不再用到的内存，没有及时释放，就叫做内存泄漏。</strong>应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。</p>
<p><strong>2.内存溢出的几种场景</strong></p>
<p><strong>1.1前端溢出</strong></p>
<p><strong>(1)溢出原因</strong></p>
<p>由于过多的函数调用，导致调用堆栈无法容纳这些调用的<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://baike.baidu.com/item/%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">返回地址</a>，一般在<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>中产生。堆栈溢出很可能由<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://baike.baidu.com/item/%E6%97%A0%E9%99%90">无限</a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级</p>
<p><strong>(2)如何解决堆栈溢出</strong></p>
<p>解决方案：1，引入闭包； 2，引入计时器； 3，尾调优化</p>
<p>(2.1)引入闭包</p>
<p>错误代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> function isEven(num)&#123;</span><br><span class="line">    if(num == 0)&#123;return true;&#125;</span><br><span class="line">    if(num == 1)&#123;return false;&#125;</span><br><span class="line">    return isEven(Math.abs(num)-2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(isEven(100000))//堆栈溢出</span><br></pre></td></tr></table></figure>

<p>引入闭包代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function isEven(num)&#123;</span><br><span class="line">    function isEvenInner(num)&#123;</span><br><span class="line">        if(num === 0)&#123;return true;&#125;</span><br><span class="line">        if(num === 1)&#123;return false;&#125;</span><br><span class="line">        return function()&#123;</span><br><span class="line">        return isEvenInner(Math.abs(num)-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function simplify(func,num)&#123;</span><br><span class="line">        var value=func(num);</span><br><span class="line">        while(typeof value == &#x27;function&#x27;)&#123;</span><br><span class="line">            value=value();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return simplify.bind(null,isEvenInner)(num)</span><br><span class="line">&#125;</span><br><span class="line">console.log(isEven(100000));//这种方法num太大也不可以</span><br></pre></td></tr></table></figure>

<p>(2.3)使用尾递归(尾调用)</p>
<p>错误代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(tailFactorial(5,1))</span><br></pre></td></tr></table></figure>

<p>尾调优化（新增简化函数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(tailFactorial(5,1))</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  return tailFactorial(n, 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(10000))</span><br></pre></td></tr></table></figure>

<p>尾调优化（柯里化）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn,n)&#123;//柯里化要绑定的参数</span><br><span class="line">    return function(m)&#123;//柯里化的函数，m对应输入的唯一一个参数</span><br><span class="line">        return fn.call(this,m,n)  </span><br><span class="line">&#125;//柯里化</span><br><span class="line">&#125;</span><br><span class="line">var factorial_1=currying(tailFactorial,1);</span><br><span class="line">console.log(factorial_1(5));</span><br></pre></td></tr></table></figure>

<p>尾调优化（ES6）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total = 1) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>

<p><strong>1.2后端溢出</strong></p>
<ol>
<li>堆溢出(OutOfMemoryError:Java heap space)</li>
<li>栈溢出(StackOverflowError)</li>
<li>永久代溢出(OutOfMemoryError: PermGen space)</li>
<li>直接内存溢出</li>
</ol>
<p><strong>(1)堆溢出OOM</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    int i=0;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        list.add(new byte[5*1024*1024]);</span><br><span class="line">        System.out.println(&quot;分配次数：&quot;+(++i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)栈溢出</strong></p>
<p>栈空间不足时，需要分下面两种情况处理：</p>
<ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</li>
<li>虚拟机在扩展栈深度时无法申请到足够的内存空间，将抛出OutOfMemberError</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StackSOFTest &#123;</span><br><span class="line"></span><br><span class="line">    int depth = 0;</span><br><span class="line"></span><br><span class="line">    public void sofMethod()&#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        sofMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackSOFTest test = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            test = new StackSOFTest();</span><br><span class="line">            test.sofMethod();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;递归次数：&quot;+test.depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">递归次数：982</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">    at com.ghs.test.StackSOFTest.sofMethod(StackSOFTest.java:8)</span><br></pre></td></tr></table></figure>

<p><strong>(3)永久代溢出</strong></p>
<p>永久代溢出可以分为两种情况，第一种是常量池溢出，第二种是方法区溢出。</p>
<p><strong>(4)直接内存溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DirectMemoryOOMTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * VM Args:-Xms20m -Xmx20m -XX：MaxDirectMemorySize=10m</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                unsafe.allocateMemory(1024*1024);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;分配次数：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="line">    at sun.misc.Unsafe.allocateMemory(Native Method)</span><br></pre></td></tr></table></figure>

<ul>
<li>栈内存溢出：程序所要求的栈深度过大。</li>
<li>堆内存溢出： 分清内存泄露还是 内存容量不足。泄露则看对象如何被 GC Root 引用，不足则通过调大-Xms，-Xmx参数。</li>
<li>永久代溢出：Class对象未被释放，Class对象占用信息过多，有过多的Class对象。</li>
<li>直接内存溢出：系统哪些地方会使用直接内存。</li>
</ul>
<p><strong>3.内存泄漏的几种原因</strong></p>
<p>(1)意外的全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar = &quot;this is a hidden global variable&quot;;</span><br><span class="line">    this.bar = &quot;potential accidental global&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">真相是：</span><br><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar = &quot;this is an explicit global variable&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实战：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;botton onclick=&quot;grow()&quot;&gt;点击测试内存泄漏&lt;/botton&gt;</span><br><span class="line">&lt;botton onclick=&quot;clearGrow()&quot;&gt;点击释放内存&lt;/botton&gt;</span><br><span class="line">&lt;div id=&quot;nodes&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var largeObj = []</span><br><span class="line">function grow()&#123;</span><br><span class="line">grow3()</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow()&#123;</span><br><span class="line">clearGrow3()</span><br><span class="line">&#125;</span><br><span class="line">function getBigData()&#123;</span><br><span class="line">let res = []</span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">for(let i=0;i&lt;10000;i++)&#123;</span><br><span class="line">  obj[`key-$&#123;i&#125;`] = `js创建一个很大内存的对象？`</span><br><span class="line">&#125;</span><br><span class="line">res.push(obj)</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line">function grow0()&#123;</span><br><span class="line"> largeObj=[...largeObj,getBigData()]</span><br><span class="line">&#125;</span><br><span class="line">var timer</span><br><span class="line">function grow1()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line"> timer = setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource);</span><br><span class="line">        // 定时器也没有清除</span><br><span class="line">    &#125;</span><br><span class="line">    // node、someResource 存储了大量数据 无法回收</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow1()&#123;</span><br><span class="line">window.clearInterval(timer)</span><br><span class="line">&#125;</span><br><span class="line">var childNode = document.createElement(&#x27;p&#x27;);</span><br><span class="line">function grow2()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">childNode.innerHTML = JSON.stringify(someResource);</span><br><span class="line">node.appendChild(childNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow2()&#123;</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">node.remove();</span><br><span class="line">//childNode = null;</span><br><span class="line">&#125;</span><br><span class="line">function grow3()&#123;</span><br><span class="line">var theThing = null</span><br><span class="line">    var replaceThing = function () &#123;</span><br><span class="line">        var originalThing = theThing</span><br><span class="line">        var unused = function () &#123;</span><br><span class="line">            if (originalThing)</span><br><span class="line">                console.log(&quot;hi&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">            someMethod: function someMethod() &#123;</span><br><span class="line">                console.log(&#x27;someMessage&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    setInterval(replaceThing,100)</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow3()&#123;</span><br><span class="line">解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220313115045079.png" alt="image-20220313115045079"></p>
<p>解决方法：</p>
<ul>
<li>避免创建全局变量</li>
<li>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量</li>
</ul>
<p>(2)被遗忘的定时器和回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var timer</span><br><span class="line">function grow1()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line"> timer = setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource);</span><br><span class="line">        // 定时器也没有清除</span><br><span class="line">    &#125;</span><br><span class="line">    // node、someResource 存储了大量数据 无法回收</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow1()&#123;</span><br><span class="line">window.clearInterval(timer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原因:与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。</span><br><span class="line">解决方法： 在定时器完成工作的时候，手动清除定时器和回调函数。</span><br><span class="line">现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220313115410595.png" alt="image-20220313115410595"></p>
<p><img src="/img/image-20220313120537563.png" alt="image-20220313120537563"></p>
<p>(3)分离的dom引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function grow2()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">childNode.innerHTML = JSON.stringify(someResource);</span><br><span class="line">node.appendChild(childNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearGrow2()&#123;</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">node.remove();</span><br><span class="line">//childNode = null;必须主动释放dom引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220320214519742.png" alt="image-20220320214519742"></p>
<p><strong>原因</strong>: 保留了DOM节点的引用,导致GC没有回收</p>
<p><strong>解决办法</strong>：断开引用，childNode=null</p>
<p>(4)闭包</p>
<p>使用闭包只是让内存常驻，滥用闭包才会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function grow3()&#123;</span><br><span class="line">var theThing = null</span><br><span class="line">    var replaceThing = function () &#123;</span><br><span class="line">        var originalThing = theThing</span><br><span class="line">        var unused = function () &#123;</span><br><span class="line">            if (originalThing)</span><br><span class="line">                console.log(&quot;hi&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">            someMethod: function someMethod() &#123;</span><br><span class="line">                console.log(&#x27;someMessage&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    setInterval(replaceThing,100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearGrow3()&#123;</span><br><span class="line">解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们明确一下，unused是一个闭包，因为它引用了自由变量 originalThing，虽然它被没有使用，但v8引擎并不会把它优化掉，因为 JavaScript里存在eval函数，所以v8引擎并不会随便优化掉暂时没有使用的函数。</p>
<p>theThing 引用了someMethod，someMethod这个函数作用域隐式的和unused这个闭包共享一个闭包上下文。所以someMethod也引用了originalThing这个自由变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCHandler -&gt; replaceThing -&gt; theThing -&gt; someMethod -&gt; originalThing -&gt; someMethod(old) -&gt; originalThing(older)-&gt; someMethod(older)</span><br></pre></td></tr></table></figure>

<p>这里面的引用链是：</p>
<p>随着setInterval的不断执行，这条引用链是不会断的，所以内存会不断泄漏，直致程序崩溃。<br>因为是闭包作用域引起的内存泄漏，这时候最好的选择是使用 chrome的heap snapshot的container视图，我们通过container视图能清楚的看到这条不断泄漏内存的引用链</p>
<p><img src="/img/image-20220320221047255.png" alt="image-20220320221047255"></p>
<p>这是一段糟糕的代码,每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了theThing）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。</p>
<p><strong>解决</strong>: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</p>
<p><strong>4.内存泄漏排查手段</strong></p>
<p>垃圾回收会导致主线程停下，产生交互的卡顿。</p>
<p>(1)chrome devtools-memory工具</p>
<p>主要功能分为：Head snapshot堆快照，Allocaiton instrumentastion on timeline(js堆内存在时间线上的回收情况)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;botton @click=&quot;grow()&quot;&gt;&lt;/botton&gt;</span><br><span class="line">function largeObj()&#123;</span><br><span class="line">var largeArr= new Array(1000_10000);</span><br><span class="line">&#125;</span><br><span class="line">var x= [];</span><br><span class="line">fucntion grow()&#123;</span><br><span class="line">var o = new larfeObj();</span><br><span class="line">x.push(new Array(1000_10000));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1)Head snapshot堆快照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.核心参数</span><br><span class="line">Summary：摘要视图</span><br><span class="line">Comparison：对比视图，与其它快照对比，看增、删、Delta数量及内存大小</span><br><span class="line">Containment：俯瞰视图，自顶向下看堆的情况，根节点包括window对象，GC root，原生对象等等列头</span><br><span class="line">Shallow Size   ： 对象本身占用的内存</span><br><span class="line">Retained Size ： 对象本身及其引用总共占用的内存</span><br><span class="line">Distance ：当前对象到根的引用层级距离</span><br><span class="line">Alloc. Size : 新分配的内存</span><br><span class="line">Freed  Size ： 释放的内存</span><br><span class="line">2.其他参数</span><br><span class="line">Detached DOM tree：表示它已经不在DOM树上了，但Javascript仍旧对它有引用</span><br><span class="line">(compiled code) — 未知，估计是程序代码区</span><br><span class="line">(closure) — 闭包(array) — 未知</span><br><span class="line">Object — JS对象类型(system) — 未知</span><br><span class="line">(string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里</span><br><span class="line">Array — JS数组类型cls — 游戏大厅特有的继承类</span><br><span class="line">Window — JS的window对象</span><br><span class="line">Quark.DisplayObjectContainer — Quark引擎的显示容器类</span><br><span class="line">Quark.ImageContainer — Quark引擎的图片类</span><br><span class="line">Quark.Text — Quark引擎的文本类</span><br><span class="line">Quark.ToggleButton — Quark引擎的开关按钮类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>功能：查看两次快照之间的新建对象情况</p>
<p>录制两次可以操作之间的快照，使用object allocation between snashot1 and snapshot选项，比较两次快照间创建的对象，常用这个功能；</p>
<p>使用comparison，比较两次快照的内存增减情况</p>
<p><img src="/img/image-20211207073137249.png" alt="image-20211207073137249"></p>
<p>largeObj的第0个元素，被window全局变量x引用着。</p>
<p>2)Allocaiton instrumentastion on timeline分配栈时间轴</p>
<p>功能：查看内存分配在代码中的位置，查看内存回收的时机和频率，要勾选Record stack</p>
<p>蓝色竖条表示内存未被回收，灰色表示内存回收。</p>
<p><img src="/img/image-20211207073246002.png" alt="image-20211207073246002"></p>
<p>选中蓝色竖条，不仅可以查看Retainer表示的泄漏的对象，还可以通过Allocaiton stack分配栈，定位具体代码位置。</p>
<p><img src="/img/image-20211207235441427.png" alt="image-20211207235441427"></p>
<p>在class filter中输入detached,查看是否存在分离的dom节点，如果能搜索出结果，说明有分离的dom节点</p>
<p><img src="/img/image-20211208000338908.png" alt="image-20211208000338908"></p>
<p>查看Constructor构造器中出现system/Context,说明有函数导致闭包留存，下面的Retainer可以找到是inner函数引起的闭包内存泄漏。</p>
<p><img src="/img/image-20211208001049548.png" alt="image-20211208001049548"></p>
<p>(2)在控制台使用ctrl+shift+p打开command menu，输入performance monitor来监听</p>
<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a><strong>V8引擎</strong></h2><p>1.定义</p>
<p><code>V8</code>是一个由<code>Google</code>开源的采用<code>C++</code>编写的高性能<code>JavaScript</code>和<code>WebAssembly</code>引擎。</p>
<p>主要工作：</p>
<ul>
<li>编译和执行js代码，即将js代码转换为机器代码；</li>
<li>处理调用栈；</li>
<li>内存分配和垃圾回收；</li>
</ul>
<p>2.原理</p>
<p><code>V8</code>的内部有很多模块，其中最重要的4个：</p>
<ul>
<li><strong>Parser</strong>解析器:负责将js源代码解析成AST抽象语法树</li>
<li><strong>Interpreter</strong>解释器:负责将AST解释为bytecode字节码文件，同时也有直接解释执行bytecode能力</li>
<li><strong>complier</strong>编译器:负责编译出运行更加高效的机器代码</li>
<li><strong>Orinoco</strong>: 垃圾回收器，负责进行内存空间回收</li>
</ul>
<p><img src="/img/image-20211209072317064.png" alt="image-20211209072317064"></p>
<p>(1)AST抽象语法树</p>
<p><img src="/img/image-20211209072730664.png" alt="image-20211209072730664"></p>
<p>Parser解析器在转换过程中有两个重要的阶段：<code>词法分析（Lexical Analysis）</code>和<code>语法分析（Syntax Analysis）</code>.</p>
<ul>
<li>词法分析,也称为分词，是将字符串形式的代码转换为标记（token）序列的过程。</li>
<li>语法分析,语法分心是将词法分析产生的<code>token</code>按照某种给定的形式文法转换成<code>AST</code>的过程。也就是把单词组合成句子的过程.</li>
</ul>
<p>(2)byteCode</p>
<p><img src="/img/image-20211209072755682.png" alt="image-20211209072755682"></p>
<p>(3)machine code</p>
<p><img src="/img/image-20211209072828890.png" alt="image-20211209072828890"></p>
<p>3.V8发展史</p>
<p>(1)早期的V8</p>
<p>早期的版本5.8以前，V8没有解释器，只有2个编译器。</p>
<p>所以流程是这样的：</p>
<ul>
<li>解析器对js解析成AST，<strong>Full-codegen</strong>编译器(也叫基准编译器)对AST编译成机器代码(省去了bytecode，执行效率更高)。</li>
<li>在执行的过程，有分析线程对机器代码进行优化，需要解析器对js解析成AST，<strong>Crankshaft</strong>编译器(也称为优化编译器)对代码进行优化。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：省去了bytecode的转化，直接生成更加高效的machine code机器代码.</span><br><span class="line"></span><br><span class="line">缺点：V8团队的官方博客这样说,</span><br><span class="line">a.生成的机器码占用了大量内存</span><br><span class="line">b.缺少中间层的bytecode，很多性能优化策略无法实施</span><br><span class="line">c.js引擎无法很好的支持新的语法</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20211209073441948.png" alt="image-20211209073441948"></p>
<p>(2)2017年4月新的V8架构</p>
<p>V8团队这样评价新架构：<strong>它代表了V8团队通过实际测量Javascript性能，并仔细研究Full-codegen和Crankshaft的缺点后收集到的共同见解的顶峰</strong>。</p>
<p>所以新的流程是这样的：</p>
<ul>
<li>解析器对js解析成AST，<strong>Igniton</strong>基准解释器解释成bytecode字节码，并执行</li>
<li>执行一段时间后，<strong>TruboFan</strong>优化编译对bytecode字节码优化为更加高效的机器码</li>
</ul>
<p>有几个优化点：</p>
<p>1.函数<strong>只声明未被调用</strong>，不会被解析成AST</p>
<p>2.函数<strong>只被调用一次</strong>，bytecode直接被解释执行，TruboFan不会进行优化编译</p>
<p>3.函数<strong>被调用多次</strong>，可能被标记为热点函数，可能被编译成机器代码</p>
<p><img src="/img/image-20211209074403859.png" alt="image-20211209074403859"></p>
<p>(3)新架构的特点</p>
<p>将优化后的bytecode和machine code形成共存的状态。</p>
<p>这里要注意<strong>deoptimization</strong>即回退字节码，即由解释器解释执行。函数类型发生变化时，<strong>Igniton</strong>会检测到变化，会将字节码回退，重新解释为新的字节码。</p>
<p>建议：</p>
<p>1.不要将函数的类型变来变去，尽量保证类型一致，如sum(x,y) x一会是int,一会儿是num</p>
<p>优点：</p>
<p>1.第一次执行，直接使用中间层的字节码，省去了机器码，同时编译器生成字节码的速度远远大于机器码</p>
<p>2.优化线程不需要从源码从新编译，而是从bytecode字节码开始优化就可以了。同时<strong>deoptimization</strong>只需要回退到字节码即可。</p>
<p>优化点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.隐藏类（hidden class）</span><br><span class="line">2.内联缓存（incline caching）</span><br><span class="line">3.优化 Orinoco</span><br><span class="line">3.1增量标记 - Incremental marking</span><br><span class="line">3.2懒性清理 - Lazy sweeping</span><br><span class="line">3.3并发 - Concurrent</span><br><span class="line">3.4并行 - Parallel</span><br></pre></td></tr></table></figure>

<h2 id="HTML页面乱码问题"><a href="#HTML页面乱码问题" class="headerlink" title="HTML页面乱码问题"></a>HTML页面乱码问题</h2><p>HTML中的编码方式有三个：gb2312，gbk，utf-8；现在大部分浏览器默认编码的是utf-8。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>●　http-equiv=”Content-Type”表示描述文档类型</p>
<p>●　content=”text/HTML;文档类型，这里为html,如果JS就是text/javascript，</p>
<p>●　charset=utf-8 页面字符集，编码，eg:gb2312,iso-8859-1,utf-8</p>
<h2 id="slice-splice-两种方法"><a href="#slice-splice-两种方法" class="headerlink" title="slice(),splice()两种方法"></a>slice(),splice()两种方法</h2><p>slice(start,end)有两个参数(start必需,end选填),都是索引,返回值不包括end,<strong>不改变原数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];</span><br><span class="line">console.log(heroes.slice(1,4))//  [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ]开始索引为1 结束索引为4(不包括4)</span><br><span class="line">console.log(heroes)// 不改变原数组  [&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>

<p>splice(index,howmany,item1…itemX)只返回被删除的数据,类型为数组(<strong>改变原数组</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];</span><br><span class="line">console.log(heroes.splice(1,2))//  [ &quot;1&quot;, &quot;2&quot;]开始索引为1 删除2个元素</span><br><span class="line">console.log(heroes)// 不改变原数组  [&quot;0&quot;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h2><p>6种基本数据类型：string,Number,boolean,undefined,null,symbol,其他类型如object,function,Array等</p>
<ul>
<li><code>typeof</code>会返回一个变量的基本类型，typeof ‘1’ // ‘string’</li>
<li><code>instanceof</code> 可以准确地判断复杂引用数据类型，[1] instanceof Array //true</li>
</ul>
<p>其中instance原理参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line">    if(typeof left !== &#x27;object&#x27; || left === null) return false;</span><br><span class="line">    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line">    let proto = Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;                  </span><br><span class="line">        if(proto === null) return false;</span><br><span class="line">        if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line">        proto = Object.getPrototypeof(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终极检查数据类型工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;); </span><br><span class="line">&#125;</span><br><span class="line">getType(&#x27;123&#x27;)  // &quot;string&quot;</span><br></pre></td></tr></table></figure>

<h2 id="JS创建私有变量的方法"><a href="#JS创建私有变量的方法" class="headerlink" title="JS创建私有变量的方法"></a>JS创建私有变量的方法</h2><p><strong>1.使用闭包</strong></p>
<p>使用闭包可以使用私有属性或者方法的封装。利用闭包可以访问外部函数的变量特征</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyProfile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> myTitle = <span class="string">&quot;DevPoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getTitle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> myTitle;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myProfile = <span class="title class_">MyProfile</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myProfile.<span class="title function_">getTitle</span>()); <span class="comment">// DevPoint</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在constructor中用Symbol代替key</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的开发者， 调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">username,password</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">PASSWORD</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">username</span> = username</span><br><span class="line">        <span class="comment">// 使用Symbol 规避了公共访问</span></span><br><span class="line">        <span class="variable language_">this</span>[<span class="variable constant_">PASSWORD</span>] = password;</span><br><span class="line">        <span class="comment">// 1. &#123;&#125; key</span></span><br><span class="line">        <span class="comment">// 2. 怎么存进对象？ key不可访问呢？私有</span></span><br><span class="line">        <span class="comment">// 3. symbol</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">checkPassword</span>(<span class="params">pwd</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable constant_">PASSWORD</span>] == pwd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userA = <span class="keyword">new</span> <span class="title class_">Login</span>(<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="comment">// userA.password = &#x27;123456&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">username</span>)  <span class="comment">//aa</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">password</span>)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>3.用对象以Symbol定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const gender = Symbol(&#x27;gender&#x27;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">    name:&#x27;大胖猫&#x27;,</span><br><span class="line">    age:&#x27;3&#x27;,</span><br><span class="line">    [gender]:&#x27;公&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//obj.name  </span><br><span class="line">obj[gender]  //调用成功 </span><br><span class="line">// 不可枚举</span><br><span class="line">console.log(Object.keys(obj));</span><br><span class="line">console.log(JSON.stringify(obj));</span><br></pre></td></tr></table></figure>

<p><strong>4.使用Class优化面向对象的读写操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;   // 公有属性</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get name()&#123;</span><br><span class="line">        console.log(&#x27;get 方法&#x27;);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(str)&#123;</span><br><span class="line">        console.log(&#x27;设置了name 方法&#x27;);</span><br><span class="line">        this.name = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let coco = new Person(&#x27;coco&#x27;);</span><br><span class="line">console.log(coco.name);</span><br></pre></td></tr></table></figure>

<p><strong>5.使用 ES2020 提案</strong></p>
<p>还处于 ES2020 试验草案中，引入了私有方法或者属性的定义，语法比较奇怪，以 <code>#</code> 作为前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ButtonCreator &#123;</span><br><span class="line">    #width;</span><br><span class="line">    #height;</span><br><span class="line">    constructor(width, height) &#123;</span><br><span class="line">        this.#width = width;</span><br><span class="line">        this.#height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    // 私有方法</span><br><span class="line">    #calculateWidth() &#123;</span><br><span class="line">        return this.#width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWidth = () =&gt; this.#calculateWidth();</span><br><span class="line">    getHeight = () =&gt; this.#height;</span><br><span class="line">    setWidth = (width) =&gt; (this.#width = width);</span><br><span class="line">    setHeight = (height) =&gt; (this.#height = height);</span><br><span class="line">&#125;</span><br><span class="line">const button = new ButtonCreator(600, 360);</span><br><span class="line">console.log(button.width); // undefined</span><br><span class="line">console.log(button.getWidth()); // 600</span><br></pre></td></tr></table></figure>

<p><strong>6.使用 WeakMap</strong></p>
<p>这种方法建立在闭包方法之上，使用作用域变量方法创建一个私有 <code>WeakMap</code>，然后使用该 <code>WeakMap</code> 检索与此相关的私有数据。这比作用域变量方法更快，因为所有实例都可以共享一个 <code>WeakMap</code>，所以不需要每次创建实例时都重新创建方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const ButtonCreator = (function () &#123;</span><br><span class="line">    const privateProps = new WeakMap();</span><br><span class="line">    class ButtonCreator &#123;</span><br><span class="line">        constructor(width, height, name) &#123;</span><br><span class="line">            this.name = name; // 公共属性</span><br><span class="line">            privateProps.set(this, &#123;</span><br><span class="line">                width, // 私有属性</span><br><span class="line">                height, // 私有属性</span><br><span class="line">                calculateWidth: () =&gt; privateProps.get(this).width, // 私有方法</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getWidth = () =&gt; privateProps.get(this).calculateWidth();</span><br><span class="line">        getHeight = () =&gt; privateProps.get(this).height;</span><br><span class="line">    &#125;</span><br><span class="line">    return ButtonCreator;</span><br><span class="line">&#125;)();</span><br><span class="line">const button = new ButtonCreator(600, 360);</span><br><span class="line">console.log(button.width); // undefined</span><br><span class="line">console.log(button.getWidth()); // 600</span><br></pre></td></tr></table></figure>

<p><strong>7.使用 TypeScript</strong></p>
<p>可以将 <code>TypeScript</code> 用作 JavaScript 的一种风格，可以使用 <code>private</code> 关键字从面向对象的语言中真正重新创建功能。</p>
<h2 id="手写发布订阅"><a href="#手写发布订阅" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> shoeObj = &#123;&#125;</span><br><span class="line">shoeObj.<span class="property">list</span> = []</span><br><span class="line"><span class="comment">// 增加订阅者</span></span><br><span class="line">shoeObj.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">list</span>[key])&#123;</span><br><span class="line">        <span class="comment">// 如果不存在key的订阅事件，则置为空</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把函数fn加入回调数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>[key].<span class="title function_">push</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line">shoeObj.<span class="property">trigger</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 取出key</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> fns =<span class="variable language_">this</span>.<span class="property">list</span>[key]</span><br><span class="line">    <span class="comment">// 遍历数组，执行函数fn</span></span><br><span class="line">    <span class="keyword">if</span>(!fns||!fns.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;fns.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        fns[i].<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shoeObj.<span class="title function_">listen</span>(<span class="string">&#x27;red&#x27;</span>,<span class="keyword">function</span>(<span class="params">size</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`小红订阅了<span class="subst">$&#123;size&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">shoeObj.<span class="title function_">listen</span>(<span class="string">&#x27;blue&#x27;</span>,<span class="keyword">function</span>(<span class="params">size</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`小蓝订阅了<span class="subst">$&#123;size&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">shoeObj.<span class="title function_">trigger</span>(<span class="string">&#x27;red&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">shoeObj.<span class="title function_">trigger</span>(<span class="string">&#x27;blue&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h2><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构.</p>
<p>Set是由一堆无序的、相关联的，且不重复的内存结构;</p>
<p>Map是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</p>
<p><strong>Set</strong></p>
<p>set常用方法：add(),delete();has();clear();</p>
<p>遍历方法：keys();values();entires();foreach();</p>
<p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>实现并集、交集、和差集</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br></pre></td></tr></table></figure>

<p>手写set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">class Set &#123;</span><br><span class="line">  //Symbol.iterator 为每个对象定义了默认的迭代器。</span><br><span class="line">  //该迭代器可以被for... of循环使用</span><br><span class="line">  constructor(iterator = []) &#123;</span><br><span class="line">    //传递的对象必须是一个可迭代对象</span><br><span class="line">    //所以需要判断传递的参数是否是可迭代对象</span><br><span class="line">    if (typeof iterator[Symbol.iterator] !== &#x27;function&#x27;) &#123;</span><br><span class="line">      //不是可迭代对象就抛出一个错误</span><br><span class="line">      throw new TypeError(`您所提供的 $&#123;iterator&#125;不是一个可迭代对象`)</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个空数组</span><br><span class="line">    this._datas = []</span><br><span class="line">    //取出数组iterator里面的值，用for of循环</span><br><span class="line">    for (const item of iterator) &#123;</span><br><span class="line">      // 将值添加到空数组中</span><br><span class="line">      this.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //判断两个值是否相等</span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    //1.存在两个都为0的情况</span><br><span class="line">    if (data1 === 0 &amp;&amp; data2 === 0) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    //2.Object.is()方法判断两个值是否为同一个值</span><br><span class="line">    return Object.is(data1, data2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //判断数据是否存在数组中</span><br><span class="line">  has(data) &#123;</span><br><span class="line">    //遍历数组中的值(用for of)</span><br><span class="line">    for (const item of this._datas) &#123;</span><br><span class="line">      //调用isEqual()方法判断 data(输入的数据)跟item(数组中的数据)</span><br><span class="line">      if (this.isEqual(data, item)) &#123;</span><br><span class="line">        //相同返回true</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">      //不相同返回false</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //添加数据的方法</span><br><span class="line">  add(data) &#123;</span><br><span class="line">    //首先判断添加的值是否存在在当前数组中，存在的话就默认返回undefined，</span><br><span class="line">    //不存在就把数据添加到之前定义的空数组中，</span><br><span class="line">    // 此时已经不是空数组，而是存入了item值</span><br><span class="line">    if (!this.has(data)) &#123;</span><br><span class="line">      //不存在就添加到数组中</span><br><span class="line">      this._datas.push(data)</span><br><span class="line">    &#125;</span><br><span class="line">    return this._datas</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除数据，返回结果true/false,删除成功/删除失败</span><br><span class="line">  delete(data) &#123;</span><br><span class="line">    //遍历数组中的数据,i为下标,element为每个数据</span><br><span class="line">    for (let i = 0; i &lt; this._datas.length; i++) &#123;</span><br><span class="line">      const element = this._datas[i]</span><br><span class="line">      //判断data跟element是否相同,相同说明数组中存在数据，可以删除</span><br><span class="line">      if (this.isEqual(data, element)) &#123;</span><br><span class="line">        //删除数据利用splice()方法</span><br><span class="line">        this._datas.splice(i, 1)</span><br><span class="line">        //删除成功</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除失败</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //清除数据</span><br><span class="line">  clear() &#123;</span><br><span class="line">    //数组长度为0</span><br><span class="line">    this._datas.length = 0</span><br><span class="line">    return this._datas</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //获取数组长度</span><br><span class="line">  get size() &#123;</span><br><span class="line">    return this._datas.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //forEach方法(里层用for of)</span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    for (const item of this._datas) &#123;</span><br><span class="line">      callback(item, item, this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  values() &#123;</span><br><span class="line">    return this._datas</span><br><span class="line">  &#125;</span><br><span class="line">  entries() &#123;</span><br><span class="line">    return this._datas.map(item =&gt; [item, item])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //*[Sysbol.iterator]</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    for (const item of this._datas) &#123;</span><br><span class="line">      yield item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const s = new Set([1, 1, &#x27;1&#x27;])</span><br><span class="line">console.log([...s]) // [ 1, &#x27;1&#x27; ]</span><br><span class="line">console.log(s.size) // 2</span><br><span class="line">s.clear() // 清空重新来</span><br><span class="line">console.log(s.size) // 0</span><br><span class="line">s.add(1)</span><br><span class="line">console.log(s.size) // 1</span><br><span class="line">s.add(1) // 检测重复</span><br><span class="line">console.log(s.size) // 1</span><br><span class="line">s.add(&#x27;1&#x27;) // 检测 数字1 与 字符串 &#x27;1&#x27;</span><br><span class="line">console.log(s.size) // 2</span><br><span class="line">console.log(s.values()) // [ 1, &#x27;1&#x27; ]</span><br><span class="line">s.add(2)</span><br><span class="line">console.log(s.size) // 3</span><br><span class="line">console.log(s.values()) //[ 1, &#x27;1&#x27;, 2 ]</span><br><span class="line">console.log(s.entries()) // [ [ 1, 1 ], [ &#x27;1&#x27;, &#x27;1&#x27; ], [ 2, 2 ] ]</span><br><span class="line">console.log([...s]) // [ 1, &#x27;1&#x27;, 2 ]</span><br><span class="line">s.delete(1)</span><br><span class="line">console.log(s.size) // 2</span><br><span class="line">s.clear()</span><br><span class="line">console.log(s.size) // 0</span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<p>size 属性,set();get();has();delete();clear()</p>
<p>遍历：同set</p>
<p>手写map</p>
<p>map函数接收两个参数,迭代器函数fn和迭代器函数的this指向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">class Map &#123;</span><br><span class="line">  //Symbol.iterator 为每个对象定义了默认的迭代器。</span><br><span class="line">  //该迭代器可以被for... of循环使用</span><br><span class="line">  constructor(iterator = []) &#123;</span><br><span class="line">    //传递的对象必须是一个可迭代对象</span><br><span class="line">    //所以需要判断传递的参数是否是可迭代对象</span><br><span class="line">    if (typeof iterator[Symbol.iterator] !== &#x27;function&#x27;) &#123;</span><br><span class="line">      //不是可迭代对象就抛出一个错误</span><br><span class="line">      throw new TypeError(`您所提供的 $&#123;iterator&#125;不是一个可迭代对象`)</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个空数组</span><br><span class="line">    this._datas = []</span><br><span class="line">    //取出数组iterator里面的值，用for of循环</span><br><span class="line">    for (const item of iterator) &#123;</span><br><span class="line">      const [k, v] = item</span><br><span class="line">      // 将值添加到空数组中</span><br><span class="line">      this.set(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //判断两个值是否相等</span><br><span class="line">  isEqual(data1, data2) &#123;</span><br><span class="line">    //1.存在两个都为0的情况</span><br><span class="line">    if (data1 === 0 &amp;&amp; data2 === 0) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    //2.Object.is()方法判断两个值是否为同一个值</span><br><span class="line">    return Object.is(data1, data2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //判断数据是否存在数组中</span><br><span class="line">  has(key) &#123;</span><br><span class="line">    //遍历数组中的值(用for of)</span><br><span class="line">    for (const [k, _] of this._datas) &#123;</span><br><span class="line">      //调用isEqual()方法判断 data(输入的数据)跟item(数组中的数据)</span><br><span class="line">      if (this.isEqual(key, k)) &#123;</span><br><span class="line">        //相同返回true</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">      //不相同返回false</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //添加数据的方法</span><br><span class="line">  set(key, val) &#123;</span><br><span class="line">    //首先判断添加的值是否存在在当前数组中，存在的话就默认返回undefined，</span><br><span class="line">    //不存在就把数据添加到之前定义的空数组中，</span><br><span class="line">    // 此时已经不是空数组，而是存入了item值</span><br><span class="line">    if (!this.has(key)) &#123;</span><br><span class="line">      //不存在就添加到数组中</span><br><span class="line">      this._datas.push([key, val])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const item = this._datas.find(([k, _]) =&gt; k === key)</span><br><span class="line">      item[1] = val</span><br><span class="line">    &#125;</span><br><span class="line">    return this._datas</span><br><span class="line">  &#125;</span><br><span class="line">  //添加数据的方法</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    //首先判断添加的值是否存在在当前数组中，存在的话就默认返回undefined，</span><br><span class="line">    //不存在就把数据添加到之前定义的空数组中，</span><br><span class="line">    // 此时已经不是空数组，而是存入了item值</span><br><span class="line">    if (!this.has(key)) &#123;</span><br><span class="line">      //不存在就添加到数组中</span><br><span class="line">      return undefined</span><br><span class="line">    &#125;</span><br><span class="line">    const item = this._datas.find(([k, _]) =&gt; k === key)</span><br><span class="line">    return item[1]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除数据，返回结果true/false,删除成功/删除失败</span><br><span class="line">  delete(key) &#123;</span><br><span class="line">    if (!this.has(key)) &#123;</span><br><span class="line">      //不存在返回false</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    const idx = this._datas.findIndex(([k, _]) =&gt; k === key)</span><br><span class="line">    //删除数据利用splice()方法</span><br><span class="line">    this._datas.splice(idx, 1)</span><br><span class="line">    //删除成功，返回true</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //清除数据</span><br><span class="line">  clear() &#123;</span><br><span class="line">    //数组长度为0</span><br><span class="line">    this._datas.length = 0</span><br><span class="line">    return this._datas</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //获取数组长度</span><br><span class="line">  get size() &#123;</span><br><span class="line">    return this._datas.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //forEach方法(里层用for of)</span><br><span class="line">  forEach(callback) &#123;</span><br><span class="line">    for (const [k, v] of this._datas) &#123;</span><br><span class="line">      callback(v, k, this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  keys() &#123;</span><br><span class="line">    return this._datas.reduce((acc, cur) =&gt; &#123;</span><br><span class="line">      acc.push(cur[0])</span><br><span class="line">      return acc</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line">  values() &#123;</span><br><span class="line">    return this._datas.reduce((acc, cur) =&gt; &#123;</span><br><span class="line">      acc.push(cur[1])</span><br><span class="line">      return acc</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line">  entries() &#123;</span><br><span class="line">    return this._datas.reduce((acc, cur) =&gt; &#123;</span><br><span class="line">      acc.push([cur[0], cur[1]])</span><br><span class="line">      return acc</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //*[Sysbol.iterator]</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    for (const item of this._datas) &#123;</span><br><span class="line">      yield item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const m = new Map([[1], [2, 3]])</span><br><span class="line">console.log([...m]) // [ [ 1, undefined ], [ 2, 3 ] ]</span><br><span class="line">console.log(m.keys()) // [ 1, 2 ]</span><br><span class="line">console.log(m.values()) // [ undefined, 3 ]</span><br><span class="line">console.log(m.entries()) // [ [ 1, undefined ], [ 2, 3 ] ]</span><br><span class="line">console.log(m.size) // [ [ 1, undefined ], [ 2, 3 ] ]</span><br><span class="line">m.clear()</span><br><span class="line">m.set(1, 2)</span><br><span class="line">console.log(m.entries()) // [ [ 1, 2 ] ]</span><br><span class="line">m.set(1, 3)</span><br><span class="line">console.log(m.entries()) // [ [ 1, 3 ] ]</span><br><span class="line">m.delete(1)</span><br><span class="line">console.log(m.entries()) // []</span><br></pre></td></tr></table></figure>

<p>1 迭代器函数 ，该函数有三个参数<br>数组项的值<br>数组项下标<br>数组对象本身<br>2 迭代器函数的this指向<br>（注：当传了该值，迭代器函数不能为箭头函数了。原因是箭头函数没有this隐式指向。箭头函数在定义时候就已经绑定了上层上下文中非箭头函数this）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyMap = function (fn, toThis) &#123;</span><br><span class="line">let arr = this;</span><br><span class="line">const result = [];</span><br><span class="line">const redirectThis = toThis || Object.create(null);</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">const item = fn.call(redirectThis, arr[i], i, arr);</span><br><span class="line">result.push(item);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h2><p>1.promise解决的问题</p>
<p>它是一个异步解决方案，比如：以前嵌套调用即回调地域，处理多个异步请求并发。现在可以消灭嵌套调用和合并多个任务请求。</p>
<p>以前异步方案有四种：</p>
<ul>
<li>calllback回调函数；</li>
<li>generator+co库；</li>
<li>promise;</li>
<li>aysnc+await;</li>
</ul>
<p>2.promise/A+规范</p>
<ul>
<li><strong>解决（fulfill）</strong>：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 <code>fulfill</code> 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li>
<li><strong>拒绝（reject）</strong>：指一个 promise 失败时进行的一系列操作。</li>
<li><strong>终值（eventual value）</strong>：所谓终值，指的是 promise 被<strong>解决</strong>时传递给解决回调的值，由于 promise 有<strong>一次性</strong>的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li><strong>据因（reason）</strong>：也就是拒绝原因，指在 promise 被<strong>拒绝</strong>时传递给拒绝回调的值。</li>
</ul>
<p>promise状态有三种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。</p>
<p>promise提供一个 then 方法以访问其当前值、终值和据因。入参分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected</p>
<p>3.原理</p>
<p>new promise时， 需要传递一个executor()执行器，入参是resolve和reject函数。结合settimeout异步+回调数组实现then异步，then的new promise实现链式调用</p>
<p>4.手写promise</p>
<p>4.1基础版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> executor !==<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;executor 不是一个函数&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">resolve</span> =(<span class="params">value</span>)=&gt;&#123;</span><br><span class="line">            <span class="comment">//接收终值，成功时回调</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收终值&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">reject</span>=(<span class="params">res</span>)=&gt;&#123;</span><br><span class="line">            <span class="comment">//接收据因，失败时回调</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收据因&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">executor</span>(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= <span class="title class_">Promise</span></span><br><span class="line"></span><br><span class="line">index.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">Promise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./promise.js&#x27;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始了&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>代码优化版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> executor !==<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;executor 不是一个函数&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initValue</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initBind</span>();</span><br><span class="line">        <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>,<span class="variable language_">this</span>.<span class="property">reject</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;<span class="comment">//终值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span>=<span class="literal">null</span>;<span class="comment">//据因</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;pending&#x27;</span>;<span class="comment">//状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initBind</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 初始化改变this指向</span></span><br><span class="line">        <span class="comment">//如果是箭头函数，就不要改变this指向，因为箭头函数自动继承父的this即当前实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">//接收终值，成功时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收终值&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="comment">//接收据因，失败时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收据因&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= <span class="title class_">Promise</span></span><br></pre></td></tr></table></figure>

<p>4.2then异步实现</p>
<p>先上同步代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> executor !==<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;executor 不是一个函数&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initValue</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initBind</span>();</span><br><span class="line">        <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>,<span class="variable language_">this</span>.<span class="property">reject</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;<span class="comment">//终值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span>=<span class="literal">null</span>;<span class="comment">//据因</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>;<span class="comment">//状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initBind</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 初始化改变this指向</span></span><br><span class="line">        <span class="comment">//如果是箭头函数，就不要改变this指向，因为箭头函数自动继承父的this即当前实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">//接收终值，成功时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收终值&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">FULFILLED</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="comment">//接收据因，失败时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收据因&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">REJECTED</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled,onRejected</span>)&#123;</span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !==<span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            <span class="comment">//不是函数则返回一个函数</span></span><br><span class="line">            onFulfilled = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !==<span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            <span class="comment">//不是函数则返回一个函数</span></span><br><span class="line">            onRejected = <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span> ===<span class="title class_">Promise</span>.<span class="property">FULFILLED</span>)&#123;</span><br><span class="line">            <span class="comment">//有结果后，直接回调</span></span><br><span class="line">            <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span> ===<span class="title class_">Promise</span>.<span class="property">REJECTED</span>)&#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也称为魔法数字</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= <span class="title class_">Promise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">Promise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./promise.js&#x27;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;我要执行&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>,value);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason:&#x27;</span>,reason); </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">打印</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>； <span class="number">4</span>不执行了，这是不对的</span><br></pre></td></tr></table></figure>

<p>上异步代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">class Promise&#123;</span><br><span class="line">    constructor(executor)&#123;</span><br><span class="line">        if(typeof executor !==&#x27;function&#x27;)</span><br><span class="line">        throw new TypeError(&#x27;executor 不是一个函数&#x27;);</span><br><span class="line"></span><br><span class="line">        this.initValue();</span><br><span class="line">        this.initBind();</span><br><span class="line">        executor(this.resolve,this.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    initValue()&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        this.value = null;//终值</span><br><span class="line">        this.reason=null;//据因</span><br><span class="line">        this.state=Promise.PENDING;//状态</span><br><span class="line">        this.onFulfilledCallbacks=[];//成功回调数组</span><br><span class="line">        this.onRejectedCallbacks=[];//失败回调数组</span><br><span class="line">    &#125;</span><br><span class="line">    initBind()&#123;</span><br><span class="line">        // 初始化改变this指向</span><br><span class="line">        //如果是箭头函数，就不要改变this指向，因为箭头函数自动继承父的this即当前实例</span><br><span class="line">        this.resolve = this.resolve.bind(this);</span><br><span class="line">        this.reject = this.reject.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        //接收终值，成功时回调</span><br><span class="line">        console.log(&#x27;接收终值&#x27;);</span><br><span class="line">        if(this.state=Promise.PENDING)&#123;</span><br><span class="line">            this.state=Promise.FULFILLED;</span><br><span class="line">            this.value = value;</span><br><span class="line">            // 成功后，执行成功的回调数组</span><br><span class="line">            this.onFulfilledCallbacks.forEach(fn=&gt;fn(this.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        //接收据因，失败时回调</span><br><span class="line">        console.log(&#x27;接收据因&#x27;);</span><br><span class="line">        if(this.state=Promise.PENDING)&#123;</span><br><span class="line">            this.state=Promise.REJECTED;</span><br><span class="line">            this.reason = reason;</span><br><span class="line">            this.onRejectedCallbacks.forEach(fn=&gt;fn(this.reason));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled,onRejected)&#123;</span><br><span class="line">        //参数校验</span><br><span class="line">        if(typeof onFulfilled !==&#x27;function&#x27; )&#123;</span><br><span class="line">            //不是函数则返回一个函数</span><br><span class="line">            onFulfilled = function(value)&#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof onRejected !==&#x27;function&#x27; )&#123;</span><br><span class="line">            //不是函数则返回一个函数</span><br><span class="line">            onRejected = function(reason)&#123;</span><br><span class="line">                return reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.state ===Promise.FULFILLED)&#123;</span><br><span class="line">            //有结果后，直接回调</span><br><span class="line">            onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.state ===Promise.REJECTED)&#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(this.state ===Promise.PENDING)&#123;</span><br><span class="line">            //还在执行中，将异步回调函数加入到数组中存放起来</span><br><span class="line">            this.onFulfilledCallbacks.push(value=&gt;&#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    onFulfilled(value);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            this.onRejectedCallbacks.push(reason=&gt;&#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    onRejected(reason);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//也称为魔法数字</span><br><span class="line">Promise.PENDING = &#x27;pending&#x27;;</span><br><span class="line">Promise.FULFILLED = &#x27;fulfilled&#x27;;</span><br><span class="line">Promise.REJECTED = &#x27;rejected&#x27;;</span><br><span class="line">module.exports= Promise</span><br></pre></td></tr></table></figure>

<p>4.3链式调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">promise.js文件</span><br><span class="line">class Promise&#123;</span><br><span class="line">    constructor(executor)&#123;</span><br><span class="line">        if(typeof executor !==&#x27;function&#x27;)</span><br><span class="line">        throw new TypeError(&#x27;executor 不是一个函数&#x27;);</span><br><span class="line"></span><br><span class="line">        this.initValue();</span><br><span class="line">        this.initBind();</span><br><span class="line">        executor(this.resolve,this.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    initValue()&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        this.value = null;//终值</span><br><span class="line">        this.reason=null;//据因</span><br><span class="line">        this.state=Promise.PENDING;//状态</span><br><span class="line">        this.onFulfilledCallbacks=[];//成功回调数组</span><br><span class="line">        this.onRejectedCallbacks=[];//失败回调数组</span><br><span class="line">    &#125;</span><br><span class="line">    initBind()&#123;</span><br><span class="line">        // 初始化改变this指向</span><br><span class="line">        //如果是箭头函数，就不要改变this指向，因为箭头函数自动继承父的this即当前实例</span><br><span class="line">        this.resolve = this.resolve.bind(this);</span><br><span class="line">        this.reject = this.reject.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        //接收终值，成功时回调</span><br><span class="line">        console.log(&#x27;接收终值&#x27;);</span><br><span class="line">        if(this.state=Promise.PENDING)&#123;</span><br><span class="line">            this.state=Promise.FULFILLED;</span><br><span class="line">            this.value = value;</span><br><span class="line">            // 成功后，执行成功的回调数组</span><br><span class="line">            this.onFulfilledCallbacks.forEach(fn=&gt;fn(this.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        //接收据因，失败时回调</span><br><span class="line">        console.log(&#x27;接收据因&#x27;);</span><br><span class="line">        if(this.state=Promise.PENDING)&#123;</span><br><span class="line">            this.state=Promise.REJECTED;</span><br><span class="line">            this.reason = reason;</span><br><span class="line">            this.onRejectedCallbacks.forEach(fn=&gt;fn(this.reason));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled,onRejected)&#123;</span><br><span class="line">        //参数校验</span><br><span class="line">        if(typeof onFulfilled !==&#x27;function&#x27; )&#123;</span><br><span class="line">            //不是函数则返回一个函数</span><br><span class="line">            onFulfilled = function(value)&#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof onRejected !==&#x27;function&#x27; )&#123;</span><br><span class="line">            //不是函数则返回一个函数</span><br><span class="line">            onRejected = function(reason)&#123;</span><br><span class="line">                return reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //链式调用，需要返回一个新实例</span><br><span class="line">        let promise2=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            if(this.state ===Promise.FULFILLED)&#123;</span><br><span class="line">                //有结果后，直接回调</span><br><span class="line">              try &#123;</span><br><span class="line">                const x=  onFulfilled(this.value);</span><br><span class="line">                resolve(x);</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                  reject(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.state ===Promise.REJECTED)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    const x= onRejected(this.reason);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            if(this.state ===Promise.PENDING)&#123;</span><br><span class="line">                //还在执行中，将异步回调函数加入到数组中存放起来</span><br><span class="line">                this.onFulfilledCallbacks.push(value=&gt;&#123;</span><br><span class="line">                    setTimeout(()=&gt;&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            const x = onFulfilled(value);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                this.onRejectedCallbacks.push(reason=&gt;&#123;</span><br><span class="line">                    setTimeout(()=&gt;&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            const x=  onRejected(reason);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return promise2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//也称为魔法数字</span><br><span class="line">Promise.PENDING = &#x27;pending&#x27;;</span><br><span class="line">Promise.FULFILLED = &#x27;fulfilled&#x27;;</span><br><span class="line">Promise.REJECTED = &#x27;rejected&#x27;;</span><br><span class="line">module.exports= Promise</span><br><span class="line"></span><br><span class="line">index.js文件</span><br><span class="line">console.log(1);</span><br><span class="line">const  Promise = require(&#x27;./promise.js&#x27;) </span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        resolve(&#x27;我要执行&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(value=&gt;&#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">    console.log(&#x27;value:&#x27;,value);</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line">    console.log(&#x27;reason:&#x27;,reason); </span><br><span class="line">&#125;).then(value=&gt;&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">    console.log(&#x27;value:&#x27;,value);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>

<p>4.4终极解决方案</p>
<p>解决promise的then返回一个promise和循环递归调用自己</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">js</span>文件</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> executor !==<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;executor 不是一个函数&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initValue</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initBind</span>();</span><br><span class="line">        <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>,<span class="variable language_">this</span>.<span class="property">reject</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;<span class="comment">//终值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span>=<span class="literal">null</span>;<span class="comment">//据因</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>;<span class="comment">//状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>=[];<span class="comment">//成功回调数组</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>=[];<span class="comment">//失败回调数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">initBind</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 初始化改变this指向</span></span><br><span class="line">        <span class="comment">//如果是箭头函数，就不要改变this指向，因为箭头函数自动继承父的this即当前实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">//接收终值，成功时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收终值&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">FULFILLED</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">            <span class="comment">// 成功后，执行成功的回调数组</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="comment">//接收据因，失败时回调</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收据因&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">PENDING</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span>=<span class="title class_">Promise</span>.<span class="property">REJECTED</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">reason</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled,onRejected</span>)&#123;</span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !==<span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            <span class="comment">//不是函数则返回一个函数</span></span><br><span class="line">            onFulfilled = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !==<span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            <span class="comment">//不是函数则返回一个函数</span></span><br><span class="line">            onRejected = <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式调用，需要返回一个新实例</span></span><br><span class="line">        <span class="keyword">let</span> promise2=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span> ===<span class="title class_">Promise</span>.<span class="property">FULFILLED</span>)&#123;</span><br><span class="line">                <span class="comment">//有结果后，直接回调</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x=  <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">                <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                  <span class="title function_">reject</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span> ===<span class="title class_">Promise</span>.<span class="property">REJECTED</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x= <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">                    <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                    <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span> ===<span class="title class_">Promise</span>.<span class="property">PENDING</span>)&#123;</span><br><span class="line">                <span class="comment">//还在执行中，将异步回调函数加入到数组中存放起来</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(value);</span><br><span class="line">                        <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                        <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            <span class="title function_">reject</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> x=  <span class="title function_">onRejected</span>(reason);</span><br><span class="line">                        <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                        <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            <span class="title function_">reject</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也称为魔法数字</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 循环调用</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolvePromise</span>=<span class="keyword">function</span>(<span class="params">promise2,x,resolve,reject</span>)&#123;</span><br><span class="line"><span class="comment">// x与promise相等，说明自己在调用自己</span></span><br><span class="line"><span class="keyword">let</span> called; <span class="comment">//是否调用过，防止无限循环调用</span></span><br><span class="line"><span class="keyword">if</span>(promise2===x)&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line"><span class="comment">//判断x是promise</span></span><br><span class="line">x.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果返回的是promise,则要继续调用</span></span><br><span class="line">    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2,value,resolve,reject);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line"><span class="title function_">reject</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x !==<span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x ===<span class="string">&#x27;object&#x27;</span>||<span class="keyword">typeof</span> x ===<span class="string">&#x27;function&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// x为对象或函数</span></span><br><span class="line"><span class="keyword">let</span> then = x.<span class="property">then</span>;<span class="comment">//官方推荐这么写，不明原因</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">then.<span class="title function_">call</span>(x,<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果返回的是promise,则要继续调用</span></span><br><span class="line">    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolvePromise</span>(promise2,value,resolve,reject);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= <span class="title class_">Promise</span></span><br><span class="line"></span><br><span class="line">index.<span class="property">js</span>文件</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">Promise</span> = <span class="built_in">require</span>(<span class="string">&#x27;./promise.js&#x27;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;我要执行&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>,value);</span><br><span class="line">    <span class="comment">// then返回一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason:&#x27;</span>,reason); </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>,value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环调用</span></span><br><span class="line"><span class="comment">// let p1=new Promise(resolve=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;p1&#x27;);</span></span><br><span class="line"><span class="comment">//     resolve(1);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// let p2=p1.then(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;p2&#x27;);</span></span><br><span class="line"><span class="comment">//     return p2</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简约版手写Promise</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 初始状态为等待</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span> <span class="comment">// 成功的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span> <span class="comment">// 失败的原因</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [] <span class="comment">// 成功的回调函数数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [] <span class="comment">// 失败的回调函数数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>()) <span class="comment">// 调用成功的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>()) <span class="comment">// 调用失败的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 将成功的回调函数放入成功数组</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 将失败的回调函数放入失败数组</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">p1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">p2</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ret) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4.5自动化测试Promise代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      dfd.resolve = resolve;</span><br><span class="line">      dfd.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  return dfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装测试脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g promises-aplus-tests</span><br></pre></td></tr></table></figure>

<p>执行自动化脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure>

<p>4.6promise.all原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Promise.all = function(values) &#123;</span><br><span class="line">  if (!Array.isArray(values)) &#123;</span><br><span class="line">    const type = typeof values;</span><br><span class="line">    return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let resultArr = [];</span><br><span class="line">    let orderIndex = 0;</span><br><span class="line">    const processResultByKey = (value, index) =&gt; &#123;</span><br><span class="line">      resultArr[index] = value;</span><br><span class="line">      if (++orderIndex === values.length) &#123;</span><br><span class="line">          resolve(resultArr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">      let value = values[i];</span><br><span class="line">      if (value &amp;&amp; typeof value.then === &#x27;function&#x27;) &#123;</span><br><span class="line">        value.then((value) =&gt; &#123;</span><br><span class="line">          processResultByKey(value, i);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        processResultByKey(value, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.7如何中断promise</p>
<p>注意这里是中断而不是终止，因为 Promise 无法终止，这个中断的意思是：在合适的时候，把 pending 状态的 promise 给 reject 掉。例如一个常见的应用场景就是希望给网络请求设置超时时间，一旦超时就就中断，我们这里用定时器模拟一个网络请求，随机 3 秒之内返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeoutWrapper</span>(<span class="params">p, timeout = <span class="number">2000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wait = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&#x27;请求超时&#x27;</span>)</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([p, wait])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise、Generator、Async三者的区别"><a href="#Promise、Generator、Async三者的区别" class="headerlink" title="Promise、Generator、Async三者的区别"></a>Promise、Generator、Async三者的区别</h2><p><strong>Promise</strong></p>
<p>Promise有三种状态：pending(进行中)、resolved(成功)、rejected(失败)。</p>
<p>缺点：</p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
<li>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。</li>
</ul>
<p><strong>Generator</strong></p>
<p>Generator 是ES6引入的新语法，Generator是一个可以暂停和继续执行的函数。</p>
<p>简单的用法，可以当做一个Iterator来用，进行一些遍历操作。复杂一些的用法，他可以在内部保存一些状态，成为一个状态机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Generator 基本语法包含两部分：函数名前要加一个星号；函数内部用 yield 关键字返回值。</span><br><span class="line">yield，表达式本身没有返回值，或者说总是返回undefined。</span><br><span class="line">next，方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * foo(x) &#123;</span><br><span class="line">    var y = 2 * (yield (x + 1));</span><br><span class="line">    var z = yield (y / 3);</span><br><span class="line">    return (x + y + z);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(5); </span><br><span class="line">b.next() // &#123; value:6, done:false &#125;</span><br><span class="line">b.next(12) // &#123; value:8, done:false &#125; </span><br><span class="line">b.next(13) // &#123; value:42, done:true &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Async(推荐使用～～)</strong></p>
<p>async await 本身就是 promise+generator 的语法糖</p>
<p>Async 是 Generator 的一个语法糖。</p>
<p>async 对应的是 * 。</p>
<p>await 对应的是 yield 。</p>
<p>async/await 自动进行了 Generator 的流程控制。</p>
<p><strong>为什么Async/Await更好？</strong></p>
<ol>
<li>使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</li>
<li>错误处理：Async/Await 让 try/catch 可以同时处理同步和异步错误。</li>
</ol>
<h2 id="reduce-every-some"><a href="#reduce-every-some" class="headerlink" title="reduce,every,some"></a>reduce,every,some</h2><p>reduce累加器</p>
<p>var total = [ 0, 1, 2, 3 ].reduce(( acc, cur ) =&gt; {    return acc + cur }, 0);</p>
<p>every一假即假</p>
<p>const flag=[ 0, 1, 2, 3 ].every(ele=&gt; {    return ele&gt;3 });</p>
<p>some一真即真</p>
<p>const flag=[ 0, 1, 2, 3 ].some(ele=&gt; {    return ele&gt;3 });</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6引入了一种新的原始数据类型Symbol，表示<strong>独一无二的值</strong>。</p>
<p>基本数据类型有6种：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数的情况</span><br><span class="line">var s1 = Symbol();</span><br><span class="line">var s2 = Symbol();</span><br><span class="line">s1 === s2 // false</span><br><span class="line"></span><br><span class="line">// 有参数的情况</span><br><span class="line">var s1 = Symbol(&quot;foo&quot;);</span><br><span class="line">var s2 = Symbol(&quot;foo&quot;);</span><br><span class="line">s1 === s2 // false</span><br></pre></td></tr></table></figure>

<p><strong>1)应用场景1：使用Symbol来作为对象属性名(key)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const PROP_NAME = Symbol()</span><br><span class="line">const PROP_AGE = Symbol()</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [PROP_NAME]: &quot;一斤代码&quot;</span><br><span class="line">&#125;</span><br><span class="line">obj[PROP_AGE] = 18</span><br><span class="line">obj[PROP_NAME] // &#x27;一斤代码&#x27;</span><br><span class="line">obj[PROP_AGE] // 18</span><br></pre></td></tr></table></figure>

<p>Symbol类型的key是不能通过<code>Object.keys()</code>或者<code>for...in</code>来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   [Symbol(&#x27;name&#x27;)]: &#x27;一斤代码&#x27;,</span><br><span class="line">   age: 18,</span><br><span class="line">   title: &#x27;Engineer&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br><span class="line"></span><br><span class="line">for (let p in obj) &#123;</span><br><span class="line">   console.log(p)   // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br><span class="line">JSON.stringify(obj)  // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>还是会有一些专门针对Symbol的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用Object的API</span><br><span class="line">Object.getOwnPropertySymbols(obj) // [Symbol(name)]</span><br><span class="line"></span><br><span class="line">// 使用新增的反射API</span><br><span class="line">Reflect.ownKeys(obj) // [Symbol(name), &#x27;age&#x27;, &#x27;title&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>2)应用场景2：使用Symbol来替代常量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const TYPE_AUDIO = Symbol()</span><br><span class="line">const TYPE_VIDEO = Symbol()</span><br><span class="line">const TYPE_IMAGE = Symbol()</span><br><span class="line"></span><br><span class="line">function handleFileResource(resource) &#123;</span><br><span class="line">  switch(resource.type) &#123;</span><br><span class="line">    case TYPE_AUDIO:</span><br><span class="line">      playAudio(resource)</span><br><span class="line">      break</span><br><span class="line">    case TYPE_VIDEO:</span><br><span class="line">      playVideo(resource)</span><br><span class="line">      break</span><br><span class="line">    case TYPE_IMAGE:</span><br><span class="line">      previewImage(resource)</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(&#x27;Unknown type of resource&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3)应用场景3：使用Symbol定义类的私有属性/方法</strong></p>
<p>在JavaScript中，是没有如Java等面向对象语言的访问控制关键字<code>private</code>的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p>
<p>而有了<code>Symbol</code>以及<code>模块化机制</code>，类的私有属性和方法才变成可能。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a.js</span><br><span class="line">const PASSWORD = Symbol()</span><br><span class="line"></span><br><span class="line">class Login &#123;</span><br><span class="line">  constructor(username, password) &#123;</span><br><span class="line">    this.username = username</span><br><span class="line">    this[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(pwd) &#123;</span><br><span class="line">      return this[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Login</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b.js</span><br><span class="line">import Login from &#x27;./a&#x27;</span><br><span class="line"></span><br><span class="line">const login = new Login(&#x27;admin&#x27;, &#x27;123456&#x27;)</span><br><span class="line"></span><br><span class="line">login.checkPassword(&#x27;admin&#x27;)  // true</span><br><span class="line"></span><br><span class="line">login.PASSWORD  // oh!no!</span><br><span class="line">login[PASSWORD] // oh!no!</span><br><span class="line">login[&quot;PASSWORD&quot;] // oh!no!</span><br></pre></td></tr></table></figure>

<p><strong>4)Symbol.for()，Symbol.keyFor()</strong></p>
<p><strong>Symbol.for</strong>机制有点类似于单例模式，首先在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。和直接的Symbol就点不同了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(&#x27;foo&#x27;);</span><br><span class="line">var s2 = Symbol.for(&#x27;foo&#x27;);</span><br><span class="line"></span><br><span class="line">s1 === s2 // true</span><br></pre></td></tr></table></figure>

<p><strong>Symbol.keyFor</strong>方法返回一个已登记的Symbol类型值的key。实质就是检测该Symbol是否已创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s1) // &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">var s2 = Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure>



<h2 id="weakset-和-weakmap"><a href="#weakset-和-weakmap" class="headerlink" title="weakset 和 weakmap"></a>weakset 和 weakmap</h2><p>ES6 考虑到防止内存泄漏，推出了两种新的数据结构： weakset 和 weakmap 。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const wm = new WeakMap()const element = document.getElementById(&#x27;example&#x27;) vm.set(element, &#x27;something&#x27;) vm.get(element)</span><br></pre></td></tr></table></figure>

<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>注册监听事件的 listener 对象很适合用 WeakMap 来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 代码1</span><br><span class="line">ele.addEventListener(&#x27;click&#x27;, handler, false)// </span><br><span class="line">代码2</span><br><span class="line">const listener = new WeakMap() </span><br><span class="line">listener.set(ele, handler) </span><br><span class="line">ele.addEventListener(&#x27;click&#x27;, listener.get(ele), false)</span><br></pre></td></tr></table></figure>

<p>代码 2 比起代码 1 的好处是：由于监听函数是放在 WeakMap 里面，一旦 dom 对象 ele 消失，与它绑定的监听函数 handler 也会自动消失。</p>
<h2 id="for-in、for-of、forEach的区别"><a href="#for-in、for-of、forEach的区别" class="headerlink" title="for in、for of、forEach的区别"></a>for in、for of、forEach的区别</h2><p><strong>for…of与for…in的区别</strong></p>
<ul>
<li>for…in循环会遍历（当前对象及其原型上的）每一个<strong>属性名称</strong>。</li>
<li>for…of只能应用于<strong>可迭代对象</strong>，循环遍历（当前对象上的）每一个属性值.</li>
</ul>
<p><strong>forEach</strong></p>
<p>是数组的一个方法，用于遍历数组的每一项，没有返回值，返回值总是undefined。</p>
<p><strong>for…of</strong></p>
<p>ES6提出的语句，在<strong>可迭代对象</strong>（Array，Map，Set，String，TypedArray，arguments）上创建一个迭代循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//遍历数组</span><br><span class="line">let array = [10,20];</span><br><span class="line">for(let val of array)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line">// 10</span><br><span class="line">// 20</span><br><span class="line"></span><br><span class="line">//遍历字符串</span><br><span class="line">let str = &quot;bo&quot;;</span><br><span class="line">for(let val of str)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;b&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line"></span><br><span class="line">//遍历map</span><br><span class="line">let map = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);</span><br><span class="line">for(let entry of map)&#123;</span><br><span class="line">    console.log(entry);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;a&quot;, 1]</span><br><span class="line">// [&quot;b&quot;, 2]</span><br><span class="line">// [&quot;c&quot;, 3]</span><br><span class="line"></span><br><span class="line">for(let [key,value] of map)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">//遍历set</span><br><span class="line">let set = new Set([1,1,2,2,3,3]);</span><br><span class="line">for(let value of set)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">//遍历DOM</span><br><span class="line">let divs = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">for(let div of divs)&#123;</span><br><span class="line">    div.className = &quot;red&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历生成器</span><br><span class="line">function* fibonacci()&#123;</span><br><span class="line">    let [prev,curr] = [0,1];</span><br><span class="line">    for(;;)&#123;</span><br><span class="line">        [prev,curr] = [curr,curr+prev];</span><br><span class="line">        yield curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let n of fibonacci())&#123;</span><br><span class="line">    if(n&gt;1000) break;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for…in</strong></p>
<p>for…in 语句以任意顺序遍历<strong>一个对象的可枚举属性的属性名</strong>。所有可枚举属性和从它原型继承而来的可枚举属性，因此如果想要仅迭代对象本身的属性，要结合hasOwnProperty（）来使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a:1, b:2, c:3&#125;;</span><br><span class="line">for(var prop in obj)&#123;</span><br><span class="line">    console.log(prop);</span><br><span class="line">&#125;</span><br><span class="line">//a</span><br><span class="line">//b</span><br><span class="line">//c</span><br><span class="line"></span><br><span class="line">var obj= &#123;</span><br><span class="line">a:1,</span><br><span class="line">[Symbol(&#x27;level&#x27;)]:2</span><br><span class="line">&#125;</span><br><span class="line">Reflect.ownKeys(obj) // 遍历所有属性，包括Symbol</span><br></pre></td></tr></table></figure>



<h1 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h1><h2 id="unbind-和off的区别"><a href="#unbind-和off的区别" class="headerlink" title="unbind 和off的区别"></a>unbind 和off的区别</h2><p>off() 方法移除用.on()绑定的事件处理程序。</p>
<p>unbind() 方法移除用.bind()绑定的事件处理程序。</p>
<p>对比发现off 和unbind的 差别不大， 但是off多一个[selector] 可以过滤指定元素。</p>
<p>查看jQuery源码可知，.unbind()是通过.off()来实现的。</p>
<p>从 jQuery 1.7开始， .on() 和 .off()方法是最好的元素上附加和移除事件处理程序的方法</p>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><strong>1.概念</strong></p>
<p>1)定义<br> JavaScript的超集，支持es6标准，可以编译成普通js，可以在任何浏览器和操作系统上运行。<br> 2)历史<br> 2012年公开0.8第一个版本。<br> 3)背景<br> JS设计最初是用于脚本语言，缺少大型项目的基础特性，如静态类型、类、模块等。最初ts是微软内部项目，致力于提升大型JS项目可靠性和维护性.<br> 4)特征<br> 静态类型批注和编译时类型检查，类、接口等</p>
<h1 id="JavaScript对象的两类属性"><a href="#JavaScript对象的两类属性" class="headerlink" title="JavaScript对象的两类属性"></a>JavaScript对象的两类属性</h1><p>第一类属性，数据属性具有四个特征</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定for in能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>第二类属性是访问器（getter/setter）属性，它也有四个特征。</p>
<ul>
<li>getter：函数或undefined，在取属性值时被调用。</li>
<li>setter：函数或undefined，在设置属性值时被调用。</li>
<li>enumerable：决定for in能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<h1 id="浅谈JavaScript、ES5、ES6"><a href="#浅谈JavaScript、ES5、ES6" class="headerlink" title="浅谈JavaScript、ES5、ES6"></a>浅谈JavaScript、ES5、ES6</h1><p><strong>什么是JavaScript</strong></p>
<p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能</p>
<p>JavaScript由三部分组成：</p>
<ul>
<li>ECMAScript（核心）</li>
<li>DOM（文档对象模型）</li>
<li>BOM （浏览器对象模型）</li>
</ul>
<blockquote>
<p>1.ECMAScript（核心）</p>
</blockquote>
<p>作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象</p>
<blockquote>
<p>2.DOM（文档对象模型）</p>
</blockquote>
<p>DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。</p>
<p>PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。</p>
<blockquote>
<p>3.BOM （浏览器对象模型）</p>
</blockquote>
<p>支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。</p>
<p>PS：BOM未形成规范</p>
<p><strong>什么是ES5</strong></p>
<p>作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下：</p>
<blockquote>
<p>1.strict模式</p>
</blockquote>
<p>严格模式，限制一些用法，’use strict’;</p>
<blockquote>
<p>2.Array增加方法</p>
</blockquote>
<p>增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法</p>
<p>PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now</p>
<blockquote>
<p>3.Object方法</p>
</blockquote>
<p>Object.getPrototypeOf</p>
<p>Object.create</p>
<p>Object.getOwnPropertyNames</p>
<p>Object.defineProperty</p>
<p>Object.getOwnPropertyDescriptor</p>
<p>Object.defineProperties</p>
<p>Object.keys</p>
<p>Object.preventExtensions / Object.isExtensible</p>
<p>Object.seal / Object.isSealed</p>
<p>Object.freeze / Object.isFrozen</p>
<p>PS：只讲有什么，不讲是什么。</p>
<p><strong>什么是ES6</strong></p>
<p>ECMAScript6在保证向下兼容的前提下，提供大量新特性：</p>
<blockquote>
<p>1.块级作用域 关键字let, 常量const</p>
</blockquote>
<blockquote>
<p>2.对象字面量的属性赋值简写（property value shorthand）</p>
</blockquote>
<blockquote>
<p>3.赋值解构</p>
</blockquote>
<blockquote>
<p>4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread）</p>
</blockquote>
<blockquote>
<p>5.箭头函数 Arrow functions</p>
</blockquote>
<p>(1).简化了代码形式，默认return表达式结果。</p>
<p>(2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。</p>
<blockquote>
<p>6.字符串模板 Template strings</p>
</blockquote>
<blockquote>
<p>7.Iterators（迭代器）+ for..of</p>
</blockquote>
<p>迭代器有个next方法，调用会返回：</p>
<p>(1).返回迭代对象的一个元素：{ done: false, value: elem }</p>
<p>(2).如果已到迭代对象的末端：{ done: true, value: retVal }</p>
<blockquote>
<p>8.生成器 （Generators）</p>
</blockquote>
<blockquote>
<p>9.Class,有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）</p>
</blockquote>
<blockquote>
<p>10.Modules</p>
</blockquote>
<p>ES6的内置模块功能借鉴了CommonJS和AMD各自的优点：</p>
<p>(1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。</p>
<p>(2).类似AMD，支持异步加载和可配置的模块加载。</p>
<blockquote>
<p>11.Map + Set + WeakMap + WeakSet</p>
</blockquote>
<p>四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。</p>
<blockquote>
<p>12.Math + Number + String + Array + Object APIs</p>
</blockquote>
<blockquote>
<p>13.Proxy,使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。</p>
</blockquote>
<p>可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。</p>
<blockquote>
<p>14.Symbols</p>
</blockquote>
<p>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。</p>
<blockquote>
<p>15.Promises,Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。</p>
</blockquote>
<h1 id="requestAnimationFrame-与-requestIdleCallback"><a href="#requestAnimationFrame-与-requestIdleCallback" class="headerlink" title="requestAnimationFrame 与 requestIdleCallback"></a>requestAnimationFrame 与 requestIdleCallback</h1><p><strong>1.视觉暂留</strong></p>
<p>眼睛的另一个重要特是视觉惰，即光象一旦在视网膜上形成，视觉将会对这个光象的感觉维持一个有限的时间，这种生理现象叫做**<code>视觉暂留</code>**。对于中等亮度的光刺激，视觉暂留时间约为<code>50ms</code>至<code>200ms</code>。当我们看屏幕的时候，虽然你什么也没做，但是屏幕还是以特定的频率在不停刷新，只是这个刷新过程我们肉眼识别到他的细微变化，这就是我们接下来要说的 <strong><code>屏幕刷新频率</code></strong></p>
<p><strong>2.屏幕刷新频率</strong></p>
<p>我们日常的显示器，一般频率在<code>60Hz</code>左右，意味着我们的屏幕每<code>1</code>秒需要刷新<code>60</code>次，也就是说每<code>1000ms</code>需要更新<code>60</code>次的屏幕图像，那么我们由此可以得出，屏幕图像更新一次所需要的时间间隔也就是<code>16.7ms(1000/60≈16.7)</code>。<br>由于人的眼睛具有**<code>视觉暂留效应</code><strong>，且暂留时间为<code>50ms</code>至<code>200ms</code>，也就是说人在看屏幕的时候，还没等到你的大脑印象消失，电脑屏幕就已经更新了，所以这个间隔让你感觉不到变化。<br>那么屏幕刷新频率是不是越大越好？我们可以大胆假设一下，假如我有三个显示器，刷新频率分别为<code>1Hz</code>、<code>60Hz</code>、<code>200Hz</code>、那么对应的更新周期时间分别为<code>1000ms</code>、<code>16.7ms</code>、<code>5ms</code>。</strong>也就是频率越大，图像更新的间隔就越短，我们看到的画面就会越稳定，**当达到一秒更新一次的时候，这个时候我们就能够感觉到明显的屏幕闪烁，带来视觉疲劳。</p>
<p>与<code>setTimeout</code>相比，<code>requestAnimationFrame</code>*<strong>最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调。*</strong></p>
<p>具体一点讲，如果屏幕刷新频率是60Hz，那么回调函数每16.7ms被执行一次，如果屏幕刷新频率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，自然不会导致动画的卡顿。</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong>requestAnimationFrame</strong></h2><p>requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。</p>
<p>设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。</p>
<p>requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。</p>
<p>不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。</p>
<p>requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimationFrame(callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数：</strong> 其中<code>callback</code>接受一个参数<code>DOMHighResTimeStamp</code>参数，表示该<code>callback</code>执行的时间。</li>
<li><strong>返回值：</strong> 返回值requestID：是一个long integer 类型的值。 可以使用<code>window.cancelAnimationFrame(requestID)</code>来取消这个回调。</li>
</ul>
<p><em><strong>requestAnimationFrame 比起 setTimeout、setInterval 的比较</strong></em></p>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就实现，并且重绘或回流的工夫距离紧紧追随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。</li>
<li>在暗藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。</li>
</ul>
</blockquote>
<h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a><strong>requestIdleCallback</strong></h2><blockquote>
<p>MDN上的解释：<code>requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var requestID = window.requestIdleCallback(callback[, options])</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>options：</strong> 是一个对象，现在只有一个属性被定义：<code>timeout</code> 表示该回调超过这个时间扔未执行，就会强制执行，不必等空闲时间，这个请看<strong>下面代码示例</strong>。</p>
</li>
<li><p><strong>callback参数：</strong> 是IdleDeadline对象，包含两个属性： 1：<code>didTimeout</code>是一个只读布尔值，表示是否超时。</p>
<p>2： <code>timeRemaining()</code>，是一个方法，返回当前帧还剩多少空余时间。如果没有时间就返回0。</p>
</li>
<li><p><strong>返回值：</strong> 返回值requestID可以使用<code>window.cancelIdleCallback(requestID)</code>来取消这个回调。</p>
</li>
</ul>
<p><em><strong>requestIdleCallback 的比较</strong></em></p>
<blockquote>
<p>优点：常用来切割长任务，利用空闲时间执行，避免主线程长时间阻塞</p>
<p>缺点：这个办法实践上可行，但为什么 React 团队又 polyfill 这个办法呢？</p>
<ol>
<li>浏览器兼容不好的问题</li>
<li>requestIdleCallback 的 FPS 只有 20，也就是 50ms 刷新一次，远远低于页面晦涩度的要求，所以 React 团队须要本人实现。</li>
</ol>
</blockquote>
<blockquote>
<p>留神：timeRemaining 最大为 50ms，是有依据钻研得出的，即是说人对用户输出的 100 毫秒以内的响应通常被认为是刹时的，不会被人察觉到。将闲暇工夫限度在 50ms 内意味着即便在闲置工作开始后立刻产生用户操作，用户代理依然有残余的 50ms 能够在其中响应用户输出而不会产生用户可察觉的滞后。</p>
</blockquote>
<p><strong>为什么须要 requestIdleCallback</strong></p>
<blockquote>
<p>在网页运行中，有很多耗时但又不是那么重要的工作。这些工作和重要的工作如对用户的输出作出及时响应的之类的工作，它们共享事件队列。如果两者发生冲突，用户体验会很蹩脚。</p>
<p>requestIdleCallback 就解决了这个痛点，requestIdleCallback 会在每一帧完结时并且有闲暇工夫执行回调。</p>
<p>假如须要大量波及到 DOM 的操作的计算，在运算时，浏览器可能就会呈现显著的卡顿行为，甚至不能进行任何操作，因为是 JS 单线程，就算用在输出解决，给定帧渲染和合成之后，用户的主线程就会变得闲暇，直到下一帧的开始。</p>
<p>而这些闲暇工夫能够拿来解决低优先级的工作，React16 的调度策略异步可中断，其中要害就靠的这个（polyfill）办法性能；React 把工作细分（工夫切片），在浏览器闲暇的工夫去执行，从而尽可能地进步渲染性能。</p>
<p>工夫切片的实质是模仿实现 requestIdleCallback</p>
<p>讲到这里，从 React15 到 React16 Fiber，对整体性能来说是大优化了；但要晓得的是，React16 绝对 15 做出的优化，并不是大大减少了任务量，你写的代码的工作总量并没有变动，只是把闲暇工夫利用起来了，不停的干活，就能更快的把活干完；这只是其中一个角度，React 还做了辨别优先级执行等等。</p>
<p><code>requestAnimationFrame</code>会在每次屏幕刷新的时候被调用，而<code>requestIdleCallback</code>则会在每次屏幕刷新时，判断当前帧是否还有多余的时间，如果有，则会调用<code>requestAnimationFrame</code>的回调函数</p>
<p>图片中是两个连续的执行帧，大致可以理解为两个帧的持续时间大概为16.67，图中黄色部分就是空闲时间。所以，<code>requestIdleCallback</code>中的回调函数仅会在每次屏幕刷新并且有空闲时间时才会被调用.</p>
<p>利用这个特性，我们可以在动画执行的期间，利用每帧的空闲时间来进行数据发送的操作，或者一些优先级比较低的操作，此时不会使影响到动画的性能，或者和requestAnimationFrame搭配，可以实现一些页面性能方面的的优化，</p>
</blockquote>
<blockquote>
<p>react 的 <code>fiber</code> 架构也是基于 <code>requestIdleCallback</code> 实现的, 并且在不支持的浏览器中提供了 polyfill</p>
</blockquote>
<p><code>requestIdleCallback()</code>常用来切割长任务，利用空闲时间执行，避免主线程长时间阻塞。</p>
<p><strong>两者应用场景比较</strong></p>
<p><code>requestAnimationFrame</code>：操作DOM，动画，回调会在每一帧确定执行，属于高优先级工作</p>
<p><code>requestIdleCallback</code>: 回调则不肯定，有闲暇工夫才执行，属于低优先级工作；因为它发生在一帧的最后，此时页面布局已经完成，所以不建议在 requestIdleCallback 里再操作 DOM，这样会导致页面再次重绘。</p>
<h1 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h1><p><strong>Set</strong></p>
<p>几个关键点：</p>
<ul>
<li>集合中的元素无序且唯一</li>
<li>集合中的元素可以是任何类型，无论是原始值还是对象引用</li>
</ul>
<p><strong>WeakSet</strong></p>
<p>与 Set 的区别</p>
<ul>
<li>WeakSet 中的元素只能是对象，不能是其他类型的值</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果该对象不在被其他变量引用，那么垃圾回收机制就会自动回收该对象所占用内存，所以只要 WeakSet 成员对象在外部消失，它们在 WeakSet 里面的引用就会自动消失。</li>
<li>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</li>
</ul>
<p><strong>WeakMap</strong></p>
<p>WeakMap 和 Map 区别</p>
<ul>
<li>WeakMap 只接受对象作为键名（不包括null）</li>
<li>WeakMap 键名所指向的对象，不计入垃圾回收机制（同 WeakSet）</li>
</ul>
<p><strong>小结：</strong></p>
<p>Set、Map、WeakSet、WeakMap、都是一种集合的数据结构</p>
<p>Set 和 WeakSet 是一种值-值的集合，且元素唯一不重复</p>
<p>Map 和 WeakMap 是一种键-值对的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型。</p>
<p>Set 和 Map可遍历，WeakSet 和 WeakMap不可遍历</p>
<p>WeakSet 和 WeakMap 键名所指向的对象，不计入垃圾回收机制</p>
<h1 id="常用技巧方法"><a href="#常用技巧方法" class="headerlink" title="常用技巧方法"></a>常用技巧方法</h1><h2 id="split-方法获取地址栏参数"><a href="#split-方法获取地址栏参数" class="headerlink" title="split 方法获取地址栏参数"></a>split 方法获取地址栏参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getParams</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="title function_">includes</span>(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> str = url.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> key = item.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">const</span> val = item.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">      res[key] = <span class="built_in">decodeURIComponent</span>(val) <span class="comment">// 解码</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">getParams</span>(<span class="string">&#x27;http://www.baidu.com?user=%E9%98%BF%E9%A3%9E&amp;age=16&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user) <span class="comment">// &#123; user: &#x27;阿飞&#x27;, age: &#x27;16&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="随机生成10以下正数"><a href="#随机生成10以下正数" class="headerlink" title="随机生成10以下正数"></a>随机生成10以下正数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random()*10)</span><br></pre></td></tr></table></figure>

<h2 id="数组的交集，差集，并集，补集"><a href="#数组的交集，差集，并集，补集" class="headerlink" title="数组的交集，差集，并集，补集"></a>数组的交集，差集，并集，补集</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> b.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">var</span> d = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> b.<span class="title function_">indexOf</span>(v) == -<span class="number">1</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//补集</span></span><br><span class="line"><span class="keyword">var</span> e = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(b.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>) &#125;)</span><br><span class="line">        .<span class="title function_">concat</span>(b.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(a.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>)&#125;))</span><br><span class="line"> </span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">var</span> f = a.<span class="title function_">concat</span>(b.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(a.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>)&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数组a：&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数组b：&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的交集：&quot;</span>, c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的差集：&quot;</span>, d);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的补集：&quot;</span>, e);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的并集：&quot;</span>, f);</span><br></pre></td></tr></table></figure>

<h2 id="JS中小数相加存在小数位的问题"><a href="#JS中小数相加存在小数位的问题" class="headerlink" title="JS中小数相加存在小数位的问题"></a>JS中小数相加存在小数位的问题</h2><p>0.1+0.2=0.300000001，注意要处理</p>
<h2 id="截取最后一个特定字符后面的字符串"><a href="#截取最后一个特定字符后面的字符串" class="headerlink" title="截取最后一个特定字符后面的字符串"></a>截取最后一个特定字符后面的字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name=s.substring(s.lastIndexOf(&quot;/&quot;)+1);</span><br></pre></td></tr></table></figure>

<h1 id="JS操作dom"><a href="#JS操作dom" class="headerlink" title="JS操作dom"></a>JS操作dom</h1><h2 id="querySelector和getElementById"><a href="#querySelector和getElementById" class="headerlink" title="querySelector和getElementById"></a>querySelector和getElementById</h2><p>querySelector() 方法选择指定 CSS 选择器的第一个元素；</p>
<p>querySelectorAll() 方法选择指定的所有元素</p>
<p>比较：</p>
<ul>
<li>query 选择符选出来的元素是静态的，而 getElement 这种方法选出的元素的动态的</li>
<li>Chrome 浏览器下 getElementBy 方法的执行速度基本都高于 querySelector</li>
</ul>
<p><strong>querySelector和getElementById的api相同</strong></p>
<ul>
<li><p>添加class:el.classList.add(“mystyle”, “anotherClass”)</p>
</li>
<li><p>移除class:el.classList.remove(“mystyle”, “anotherClass”)</p>
</li>
<li><p>设置style:el.setAttribute(“class”,classVal )</p>
</li>
<li><p>设置style:el.style.top=’100px’ </p>
</li>
<li><p>el.style[“border-width”]=”10px”</p>
</li>
</ul>
<h2 id="创建节点添加节点"><a href="#创建节点添加节点" class="headerlink" title="创建节点添加节点"></a><strong>创建节点添加节点</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    childNode.<span class="property">innerHTML</span> = <span class="string">&#x27;这里是提示信息〜〜&#x27;</span>;</span><br><span class="line">    <span class="comment">//childNode.setAttribute(&#x27;class&#x27;, &#x27;alerts&#x27;);</span></span><br><span class="line">    <span class="comment">//childNode.setAttribute(&#x27;onclick&#x27;, &#x27;this.style.display = &quot;none&quot;&#x27;);</span></span><br><span class="line">    childNode.<span class="property">className</span> = <span class="string">&#x27;alerts&#x27;</span>;</span><br><span class="line">    childNode.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(childNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取屏幕或容器的宽高"><a href="#获取屏幕或容器的宽高" class="headerlink" title="获取屏幕或容器的宽高"></a>获取屏幕或容器的宽高</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取宽高</span><br><span class="line">元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight</span><br><span class="line">元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth</span><br><span class="line">元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft</span><br><span class="line">元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop</span><br><span class="line"></span><br><span class="line">设置宽高</span><br><span class="line">document.getElementById(&quot;div&quot;).style.width = &quot;120px&quot;;//可行</span><br><span class="line">document.getElementById(&quot;div&quot;).style.offsetWidth = &quot;120px&quot;;//不可行</span><br></pre></td></tr></table></figure>

<h2 id="绑定解除事件"><a href="#绑定解除事件" class="headerlink" title="绑定解除事件"></a>绑定解除事件</h2><p>事件有三要素 : <code>事件源</code>、<code>事件</code>、<code>监听器</code> 。</p>
<p><strong>事件源</strong>：在哪个元素上发生的。比如: p标签、a标签、div标签、form表单 等等</p>
<p> <strong>事件</strong>：到底发生了什么事件。click(点击事件)、mouseover(鼠标事件)、focus(焦点事件) 等</p>
<p><strong>监听器</strong>：事件源触发事件后，如何回应发生的事件，通常以函数(funtion)的形式来出现。</p>
<p>常见有3种绑定方式：</p>
<ul>
<li><p>1、直接在html元素上进行绑定事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btn&quot; type=&quot;button&quot; onclick=&quot;test();&quot; /&gt; &lt;!--点击按钮 触发事件--&gt;</span><br><span class="line">缺点：HTML与js代码紧密耦合。如果要更换 事件，就要改动两个地方:HTML代码和JS代码，这就不利于后期代码的维护。</span><br></pre></td></tr></table></figure></li>
<li><p>2、用 on 绑定事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> var div=document.getElementById(&#x27;id&#x27;);</span><br><span class="line">    div.onclick=function()&#123;</span><br><span class="line">        console.log(&#x27;甲需要红背景&#x27;);</span><br><span class="line">        div.setAttribute(&#x27;style&#x27;, &#x27;background: #ff0000&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">优点：它最大的优点是就是兼容性很好，所有浏览器都支持</span><br><span class="line">缺点：同一个 dom 元素上，on 只能绑定一个同类型事件，后者会覆盖前者，不同类型的事件可以绑定多个。有一个问题，无法允许团队不同人员对同一元素监听同一事件但做出不用的响应</span><br></pre></td></tr></table></figure></li>
<li><p>3、用 addEventListener、attachEvent 绑定事件。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var oBox = document.getElementById(&quot;container&quot;);</span><br><span class="line">//绑定事件</span><br><span class="line">oBox.addEventListener(&quot;click&quot;,fn(),false);</span><br><span class="line">//解绑事件</span><br><span class="line">oBox.removeEventListener(&quot;click&quot;,fn(),false);</span><br><span class="line"></span><br><span class="line">var oBox = document.getElementById(&quot;container&quot;);</span><br><span class="line">//绑定</span><br><span class="line">oBox.attach(&quot;click&quot;,fn());</span><br><span class="line">//解绑</span><br><span class="line">oBox.detach(&quot;click&quot;,fn());</span><br><span class="line">优点：它们可以支持绑定多个同类型事件</span><br><span class="line">缺点：兼容性并不好,它们只兼容相对应的浏览器才有用。</span><br></pre></td></tr></table></figure>

<h2 id="监听串口变化"><a href="#监听串口变化" class="headerlink" title="监听串口变化"></a>监听串口变化</h2><p><strong>Resize事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123;</span><br><span class="line">       this.helpHeight = window.innerHeight - 90</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>ResizeObserverAPI监听元素容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const resizeObserver = new ResizeObserver(entries =&gt; &#123;</span><br><span class="line">  //回调</span><br><span class="line">  this.$chart.resize();</span><br><span class="line">&#125;);</span><br><span class="line">resizeObserver.observe(this.$refs.chart);</span><br><span class="line">// 取消某个元素监听</span><br><span class="line">//resizeObserver.unobserve(this.$refs.chart)</span><br><span class="line">// 取消全部元素监听</span><br><span class="line">//resizeObserver.disconnect()</span><br><span class="line">缺点：但是坏处是，兼容性不高</span><br><span class="line">解决：</span><br><span class="line">github上，已经提供了能够兼容至IE9的 resizeObserver polyfill</span><br><span class="line">yarn add @juggle/resize-observer</span><br><span class="line">import ResizeObserver from &#x27;@juggle/resize-observer&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="奇葩的JavaScript闭包面试题"><a href="#奇葩的JavaScript闭包面试题" class="headerlink" title="奇葩的JavaScript闭包面试题"></a>奇葩的JavaScript闭包面试题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      return fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?</span><br><span class="line">var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?</span><br><span class="line">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?</span><br></pre></td></tr></table></figure>

<p> 这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。 可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//答案：</span><br><span class="line">//a: undefined,0,0,0</span><br><span class="line">//b: undefined,0,1,2</span><br><span class="line">//c: undefined,0,1,1</span><br></pre></td></tr></table></figure>

<h2 id="JS中有几种函数"><a href="#JS中有几种函数" class="headerlink" title="JS中有几种函数"></a>JS中有几种函数</h2><p>首先，在此之前需要了解的是，在JS中函数可以分为两种，<strong>具名函数（命名函数）</strong>和<strong>匿名函数</strong>。 区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<blockquote>
<p>注意：在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试</p>
</blockquote>
<p>或是采用兼容IE的获取函数name方法来获取函数名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 获取指定函数的函数名称（用于兼容IE）</span><br><span class="line">    * @param &#123;Function&#125; fun 任意函数</span><br><span class="line">    */</span><br><span class="line">function getFunctionName(fun) &#123;</span><br><span class="line">    if (fun.name !== undefined)</span><br><span class="line">        return fun.name;</span><br><span class="line">    var ret = fun.toString();</span><br><span class="line">    ret = ret.substr(&#x27;function &#x27;.length);</span><br><span class="line">    ret = ret.substr(0, ret.indexOf(&#x27;(&#x27;));</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遂用上述函数测试是否为匿名函数： <a target="_blank" rel="noopener" href="http://images2015.cnblogs.com/blog/746158/201511/746158-20151124155219640-2082081917.png"><img src="http://images2015.cnblogs.com/blog/746158/201511/746158-20151124155220468-1074861494.png" alt="image"></a> 可以得知变量fn1是具名函数，fn2是匿名函数</p>
<h2 id="创建函数的几种方式"><a href="#创建函数的几种方式" class="headerlink" title="创建函数的几种方式"></a>创建函数的几种方式</h2><p>说完函数的类型，还需要了解JS中创建函数都有几种创建方法。</p>
<p> <strong>1、声明函数</strong> 最普通最标准的声明函数方法，包括函数名及函数体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>2、创建匿名函数表达式</strong> 创建一个变量，这个变量的内容为一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function ()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意采用这种方法创建的函数为<strong>匿名函数</strong>，即没有函数name</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function ()&#123;&#125;;</span><br><span class="line">getFunctionName(fn1).length;//0</span><br></pre></td></tr></table></figure>

<p> <strong>3、创建具名函数表达式</strong> 创建一个变量，内容为一个带有名称的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function xxcanghai()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：具名函数表达式的函数名只能在创建函数内部使用</p>
</blockquote>
<p>即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用 测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function xxcanghai()&#123;</span><br><span class="line">    console.log(&quot;in:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(&quot;out:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">fn1();</span><br><span class="line">//out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt;</span><br><span class="line">//in:fn1&lt; function &gt;xxcanghai:&lt; function &gt;</span><br></pre></td></tr></table></figure>

<p>可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。</p>
<blockquote>
<p>注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
</blockquote>
<p> <strong>4、Function构造函数</strong> 可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是<strong>匿名函数</strong>。 </p>
<p> <strong>5、自执行函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;alert(1);&#125;)();</span><br><span class="line">(function fn1()&#123;alert(1);&#125;)();</span><br></pre></td></tr></table></figure>

<p>自执行函数属于上述的“函数表达式”，规则相同  </p>
<p><strong>6、其他创建函数的方法</strong> 当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 eval ， setTimeout ， setInterval 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开  </p>
<h2 id="三个fun函数的关系是什么？"><a href="#三个fun函数的关系是什么？" class="headerlink" title="三个fun函数的关系是什么？"></a>三个fun函数的关系是什么？</h2><p>说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。 这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 先看第一个fun函数，属于标准具名函数声明，是<strong>新创建</strong>的函数，他的返回值是一个对象字面量表达式，属于一个新的object。 这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个<strong>新创建</strong>匿名函数表达式。</p>
<blockquote>
<p>注意：所有<strong>声明的匿名函数都是一个新函数。</strong></p>
</blockquote>
<p>所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。  </p>
<h2 id="函数作用域链的问题"><a href="#函数作用域链的问题" class="headerlink" title="函数作用域链的问题"></a>函数作用域链的问题</h2><p>再说第三个fun函数之前需要先说下，在<em>函数表达式</em>内部能不能访问存放当前函数的变量。  <strong>测试1，对象内部的函数表达式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">  fn:function ()&#123;</span><br><span class="line">    console.log(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.fn();//ERROR报错</span><br></pre></td></tr></table></figure>

<p><strong>测试2，非对象内部的函数表达式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fn=function ()&#123;</span><br><span class="line">  console.log(fn);</span><br><span class="line">&#125;;</span><br><span class="line">fn();//function ()&#123;console.log(fn);&#125;;正确</span><br></pre></td></tr></table></figure>

<p>结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。 原因也非常简单，因为<strong>函数作用域链</strong>的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。  所以综上所述，可以得知，<strong>最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数</strong>。 所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。  </p>
<h2 id="到底在调用哪个函数？"><a href="#到底在调用哪个函数？" class="headerlink" title="到底在调用哪个函数？"></a>到底在调用哪个函数？</h2><p>再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      return fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?</span><br><span class="line">var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?</span><br><span class="line">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?</span><br><span class="line">//问:三行a,b,c的输出分别是什么？</span><br></pre></td></tr></table></figure>

<p> <strong>1、第一行a</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以得知，第一个fun(0)是在调用<strong>第一层fun函数</strong>。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以： 第后面几个fun(1),fun(2),fun(3),函数都是在调用<strong>第二层fun函数</strong>。 遂： 在第一次调用fun(0)时，o为undefined； 第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0； 第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0 第四次同理； 即：最终答案为undefined,0,0,0  </p>
</blockquote>
<p><strong>2、第二行b</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。 遂： 在第一次调用第一层fun(0)时，o为undefined； 第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0； 第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是<strong>第二次执行的返回对象</strong>。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1； 第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2； 即最终答案：undefined,0,1,2  </p>
</blockquote>
<p><strong>3、第三行c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据前面两个例子，可以得知： fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的<strong>也</strong>是fun(1)返回的第二层fun函数。 遂： 在第一次调用第一层fun(0)时，o为undefined； 第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0； 第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1； 第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1 即最终答案：undefined,0,1,1  </p>
</blockquote>
<h1 id="devDependencies-和-dependencies-的区别"><a href="#devDependencies-和-dependencies-的区别" class="headerlink" title="devDependencies 和 dependencies 的区别"></a>devDependencies 和 dependencies 的区别</h1><p><code>devDependencies</code> 和 <code>dependencies</code>的区别核心体现在 <strong>npm包</strong> 中。</p>
<p>只要开发的项目是<strong>发npm包</strong>提供给外部、其他业务项目使用的，需要非常注意依赖的安装地方，因为搞不好很容易在业务使用中会出现bug。dependencies的依赖包会被打入到npm包中，慎用。</p>
<p>而如果只是自己项目用，<strong>不需要发npm包</strong>的话，把依赖安装到 <code>devDependencies</code> 或者 <code>dependencies</code> 中，实质上是没有任何区别的。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://anandasuper.top/2022/05/29/B_JS_0%E5%9F%BA%E7%A1%80/" title="0基础" target="_blank" rel="external">http://anandasuper.top/2022/05/29/B_JS_0基础/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">昵称</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/05/29/B_JS_Promise%E5%8E%9F%E7%90%86/" title="Promise原理"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/05/29/B_JS_%E7%BB%A7%E6%89%BF%E5%8E%9F%E5%BD%A2%E9%97%AD%E5%8C%85%E4%B8%93%E9%A2%98/" title="继承原形闭包专题"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>