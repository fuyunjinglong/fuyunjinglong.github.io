<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>E_左神 | Hexo</title>
  <meta name="description" content="前言基础班视频 代码仓库 基础班和进阶班：绝对的技术干活。 体系学习班和大厂刷题班：比前者多一些新题型而已。 书 大话数据结构，算法图解 视频 数据结构-浙江大学(opens new window)清华大学-邓俊辉MOOC数据结构与算法全套 数据结构与算法本质数据结构就是2种结构：  连续结构：连续空间(数组)，寻址容易，增删难 跳转结构：不连续，指针跳转，增删容易，寻址难  算法第一句话：分析算">
<meta property="og:type" content="article">
<meta property="og:title" content="E_左神">
<meta property="og:url" content="https://fuyunjinglong.github.io/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言基础班视频 代码仓库 基础班和进阶班：绝对的技术干活。 体系学习班和大厂刷题班：比前者多一些新题型而已。 书 大话数据结构，算法图解 视频 数据结构-浙江大学(opens new window)清华大学-邓俊辉MOOC数据结构与算法全套 数据结构与算法本质数据结构就是2种结构：  连续结构：连续空间(数组)，寻址容易，增删难 跳转结构：不连续，指针跳转，增删容易，寻址难  算法第一句话：分析算">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-12T23:33:16.000Z">
<meta property="article:modified_time" content="2023-01-30T14:44:51.974Z">
<meta property="article:author" content="Elven">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://fuyunjinglong.github.io/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://fuyunjinglong.github.io/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Elven</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AA-%E9%9D%A2%E8%AF%95/">AA_面试</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/">H_工程热点</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/11/">十一月 2099</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/09/">九月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/06/">六月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/05/">五月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/03/">三月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/">H_工程热点</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/06/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_0%E5%9F%BA%E7%A1%80/" class="title">0基础_工程热点</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-05T22:33:16.000Z" itemprop="datePublished">2099-11-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/05/I_%E7%A7%BB%E5%8A%A8%E7%AB%AF_0%E5%9F%BA%E7%A1%80/" class="title">0基础_移动端</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-04T22:33:16.000Z" itemprop="datePublished">2099-11-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/04/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0%E5%9F%BA%E7%A1%80/" class="title">0基础_计算机网络</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-03T22:33:16.000Z" itemprop="datePublished">2099-11-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/01/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_0%E5%9F%BA%E7%A1%80/" class="title">0基础_数据结构</a>
              </p>
              <p class="item-date">
                <time datetime="2099-10-31T22:33:16.000Z" itemprop="datePublished">2099-11-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/01/J_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%9F%BA%E7%A1%80/" class="title">0基础_设计模式</a>
              </p>
              <p class="item-date">
                <time datetime="2099-10-31T22:33:16.000Z" itemprop="datePublished">2099-11-01</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%9C%AC%E8%B4%A8"><span class="toc-text">数据结构与算法本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">什么是常数操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">什么是时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%87%E6%A0%87"><span class="toc-text">评估算法优劣的核心指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E6%B5%81%E7%A8%8B%E5%86%B3%E5%AE%9A"><span class="toc-text">时间复杂度(流程决定)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E6%B5%81%E7%A8%8B%E5%86%B3%E5%AE%9A"><span class="toc-text">额外空间复杂度(流程决定)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E9%A1%B9%E6%97%B6%E9%97%B4-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%86%B3%E5%AE%9A"><span class="toc-text">常数项时间(实现细节决定)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#N%E7%9A%84%E9%98%B6%E5%B1%82%E5%92%8C"><span class="toc-text">N的阶层和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E5%99%A8"><span class="toc-text">对数器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-text">异或运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">排序算法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-text">工具函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E5%A0%86"><span class="toc-text">比较器与堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%BB%93%E6%9E%84"><span class="toc-text">堆结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">比较器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-text">数组范围和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%9A%BE%E5%80%92%E8%8B%B1%E9%9B%84%E6%B1%89"><span class="toc-text">随机数难倒英雄汉</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%97%8B%E8%BD%AC%E8%AF%8D"><span class="toc-text">判断旋转词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91T2%E6%98%AF%E5%90%A6%E4%B8%BAT1%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">判断二叉树T2是否为T1的子树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-text">单链表反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-text">双链表反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">用单链表结构实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text">用单链表结构实现栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-text">用双链表结构实现双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84k%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%84%E5%86%85%E9%80%86%E5%BA%8F%E8%B0%83%E6%95%B4"><span class="toc-text">单链表的k个节点的组内逆序调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0"><span class="toc-text">两个链表相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%A5%97%E8%B7%AF"><span class="toc-text">链表套路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87"><span class="toc-text">链表是否回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">链表的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-text">两链表是否相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%BB%99%E5%A4%B4%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">不给头结点删除节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树宽度优先遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">二叉树的最大宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树任意节点的后继节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-text">折纸问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E5%A5%97%E8%B7%AF"><span class="toc-text">二叉树递归套路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">套路实践-判断平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E5%88%A4%E6%96%AD%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">套路实践-判断满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">套路实践-判断完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="toc-text">套路实践-二叉树的最大距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-text">套路实践-二叉搜索子树头结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E5%91%98%E5%B7%A5%E5%BF%AB%E4%B9%90%E5%80%BC"><span class="toc-text">套路实践-员工快乐值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%AE%9E%E8%B7%B5-%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="toc-text">套路实践-最低公共祖先节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFPRT%E7%AE%97%E6%B3%95"><span class="toc-text">BFPRT算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Morris%E7%AE%97%E6%B3%95%E9%81%8D%E5%8E%86"><span class="toc-text">Morris算法遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Morris%E5%BA%8F"><span class="toc-text">Morris序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Morris%E9%81%8D%E5%8E%86%E5%92%8C%E4%BC%A0%E7%BB%9F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">Morris遍历和传统二叉树遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST"><span class="toc-text">判断是否为二叉搜索树BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6"><span class="toc-text">求二叉树的最小高度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E7%BB%93%E6%9E%84%E8%A1%A8%E8%BE%BE"><span class="toc-text">图的结构表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A6%82%E4%BD%95%E6%90%9E%E5%AE%9A"><span class="toc-text">图的面试题如何搞定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6-%E5%B9%BF%E5%BA%A6-%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS"><span class="toc-text">图的宽度(广度)优先遍历BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS"><span class="toc-text">图的深度优先遍历DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">图的拓扑排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BKruskal%E5%8D%B3K%E7%AE%97%E6%B3%95"><span class="toc-text">最小生成树之Kruskal即K算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BPrim%E5%8D%B3P%E7%AE%97%E6%B3%95"><span class="toc-text">最小生成树之Prim即P算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E4%B9%8BDijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">最短路径算法之Dijkstra算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSP%E9%97%AE%E9%A2%98"><span class="toc-text">TSP问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-text">单词接龙</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-text">核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-text">暴力递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-text">尝试模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E7%9A%84%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96"><span class="toc-text">从左往右的尝试模型1-字符串转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E7%9A%84%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B2-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">从左往右的尝试模型2-背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E4%B8%8A%E7%9A%84%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B-%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F"><span class="toc-text">范围上的尝试模型-纸牌游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B-N%E7%9A%87%E5%90%8E"><span class="toc-text">业务限制类的尝试模型-N皇后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8C%89%E7%85%A7%E5%88%92%E5%88%86%E5%80%BC%E5%88%86%E7%BB%84"><span class="toc-text">单链表按照划分值分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">暴力递归到动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%88%AC%E6%A5%BC"><span class="toc-text">阿里面试题爬楼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A7%E5%B8%81%E9%9D%A2%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">货币面值问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F"><span class="toc-text">贪心-最小字典序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">经典面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E7%A7%8D%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9C%80%E9%AB%98%E6%8A%A5%E9%85%AC"><span class="toc-text">每种能力的最高报酬</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">简单背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-text">最长公共子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E9%A2%91%E6%9C%80%E5%A4%A7%E5%89%8DK%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">词频最大前K个字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E9%A2%91%E6%9C%80%E5%A4%A7%E7%9A%84K%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">词频最大的K个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E6%B1%82%E5%90%8E%E5%BA%8F"><span class="toc-text">已知树的先序和中序，求后序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81"><span class="toc-text">俄罗斯套娃信封</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C"><span class="toc-text">最大累加和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树转为双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#str1%E7%BC%96%E8%BE%91%E6%88%90str2%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7"><span class="toc-text">str1编辑成str2的最小代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">求完全二叉树节点的个数</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-E_数据结构_左神" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      E_左神
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" class="article-date">
	  <time datetime="2022-11-12T23:33:16.000Z" itemprop="datePublished">2022-11-13</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zr4y1W7ww?p=37&spm_id_from=pageDriver&vd_source=bd4c7d99d71adf64d6e88c65370e0247">基础班视频</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/fuyunjinglong/algorith-systematiclearning">代码仓库</a></p>
<p>基础班和进阶班：绝对的技术干活。</p>
<p>体系学习班和大厂刷题班：比前者多一些新题型而已。</p>
<p><strong>书</strong></p>
<p>大话数据结构，算法图解</p>
<p><strong>视频</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av18586085?from=search&seid=15275956372728133584">数据结构-浙江大学(opens new window)</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av49361421?from=search&seid=2756779141930403558">清华大学-邓俊辉MOOC数据结构与算法全套</a></p>
<h1 id="数据结构与算法本质"><a href="#数据结构与算法本质" class="headerlink" title="数据结构与算法本质"></a>数据结构与算法本质</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>就是2种结构：</p>
<ul>
<li>连续结构：连续空间(数组)，寻址容易，增删难</li>
<li>跳转结构：不连续，指针跳转，增删容易，寻址难</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>第一句话：分析算法复杂度，必须对算法流程足够清楚才能大致推算出来</strong></p>
<p><strong>算法不挑语言，因为算法很少用到语言的特性，只要会伪代码就行。其次，你在JS中也能找到Java对应的数据结构，增加实际codeing能力。</strong></p>
<p>生活的意思不是一出生就会，是吃过苦会有的。算法也是，练过了，思维自然就有了。</p>
<ul>
<li>有具体的问题-问题</li>
<li>有设计解决这个问题的具体流程-程序</li>
<li>有评价处理流程的可量化指标-复杂度</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>明确知道怎么算的流程，如加减乘除</li>
<li>明确知道怎么尝试的流程，如质数。所以图灵是计算机算法的祖师爷。图灵在二战利用无数分支尝试破解德军密码。</li>
</ul>
<h2 id="什么是常数操作"><a href="#什么是常数操作" class="headerlink" title="什么是常数操作"></a>什么是常数操作</h2><p>算法的执行时间与样本量无关，是一个固定值,表示为O(1)</p>
<h2 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h2><p>比如冒泡排序的时间复杂度：n平方。只取最高阶，去掉系数，去掉低阶。时间复杂度一定是<strong>最差的情况</strong>。</p>
<p>二分法的复杂度是O(logN)</p>
<p>常见时间复杂度排序：O(1)&lt;O(logN)&lt;O(N)&lt;O(N*logN)&lt;O(N2)&lt;O(2N)&lt;O(3N)&lt;…</p>
<h2 id="评估算法优劣的核心指标"><a href="#评估算法优劣的核心指标" class="headerlink" title="评估算法优劣的核心指标"></a>评估算法优劣的核心指标</h2><ul>
<li>时间复杂度(流程决定)</li>
<li>额外空间复杂度(流程决定)</li>
<li>常数项时间(实现细节决定)</li>
</ul>
<h3 id="时间复杂度-流程决定"><a href="#时间复杂度-流程决定" class="headerlink" title="时间复杂度(流程决定)"></a>时间复杂度(流程决定)</h3><p><strong>常数时间的操作</strong></p>
<p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定值，这样的操作为常数时间操作。</p>
<p>比如：</p>
<ul>
<li>常见的算术运算(+-*/)</li>
<li>常见的位运算(&gt;&gt;,&lt;&lt;,|,&amp;,^)</li>
<li>赋值、比较、自增、自减</li>
<li>数组寻址操作</li>
</ul>
<p><strong>算法的总操作流程与样本数量的关系确定</strong></p>
<ol>
<li>想象算法流程所处理的数据状况，按照最差情况来。比如时间复杂度，通常说的就是最差时间复杂度</li>
<li>把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作</li>
<li>如果数据量为N,看看基本动作的数量和N是什么关系</li>
</ol>
<p><strong>如何确定算法流程的时间复杂度</strong></p>
<p>当完成表达式建立后，只保留最高阶项，低阶项去掉，高阶项系数也去掉，记为O(忽略掉系数的高阶项)</p>
<p><strong>问题的最优解</strong></p>
<p>一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低指标后，使用最少空间复杂度，叫这个问题的最优解。最优解可以忽略常数项因素。</p>
<p><strong>常见时间复杂度从好到差</strong></p>
<ul>
<li>O(1)</li>
<li>O(logN)</li>
<li>O(N)</li>
<li>O(N*logN)</li>
<li>O(N^2) O(N^3)…O(N^K)</li>
<li>O(2^N) O(3^N)…O(K^N)</li>
<li>O(N!)</li>
</ul>
<p><strong>算法学习脉络</strong></p>
<ul>
<li>知道算法的严格流程</li>
<li>知道算法的尝试流程(递归)</li>
</ul>
<h3 id="额外空间复杂度-流程决定"><a href="#额外空间复杂度-流程决定" class="headerlink" title="额外空间复杂度(流程决定)"></a>额外空间复杂度(流程决定)</h3><p>在实现算法流程中，你需要开辟一些空间来支持你的算法流程。这部分空间就是额外空间。</p>
<p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)</p>
<h3 id="常数项时间-实现细节决定"><a href="#常数项时间-实现细节决定" class="headerlink" title="常数项时间(实现细节决定)"></a>常数项时间(实现细节决定)</h3><p>放弃理论分析，利用随机样本实际测试常数项时间差异性。</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p><strong>题目：打印int类型数据的32位信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">code_print</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">// 打印int类型数据的32位信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">         <span class="comment">// 1左移31位，即1000000...0可以取出第31位信息</span></span><br><span class="line">         <span class="comment">// &lt;&lt;带符号左移，&lt;&lt;&lt;不带符号左移</span></span><br><span class="line">            System.out.print((num&amp;(<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原码，反码，补码</strong></p>
<ul>
<li><p>原码：是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。</p>
</li>
<li><p>反码：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。</p>
</li>
<li><p>补码：正数的补码等于它的原码；负数的补码等于反码+1</p>
</li>
</ul>
<p><strong>int类型的无符号和有符号数的数</strong></p>
<ul>
<li>无符号：0—2的32次方即共有2的32次方个数</li>
<li>有符号：-2的31次方—2的31次方-1即共有2的32次方个数，相当于把无符号中的一半分给了负数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值，10000000000000000000000000000000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">// 最大值，01111111111111111111111111111111</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//一个数的相反数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -a或 ~a+<span class="number">1</span>即取反加<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>对于有符号的二进制转十进制</strong></p>
<ul>
<li>非负数：最高位为0，不看最高位，其他位正常转十进制</li>
<li>负数：最高位为，不看最高位，其他位取反+1，再转十进制</li>
</ul>
<p>多一句：为什么这么设计？方便底层对+2,-2统一做一套加减乘除的底层运算逻辑，提高计算机的运算性能。</p>
<h2 id="N的阶层和"><a href="#N的阶层和" class="headerlink" title="N的阶层和"></a>N的阶层和</h2><p>题目：给定一个参数N,返回1!+2!+3!…N!的结果</p>
<ul>
<li>解法二明显优于解法一。</li>
</ul>
<ul>
<li>解法一：先计算当前阶层值，然后求和</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两层for循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">code_f1</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">         ans+=code_factorial(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">code_factorial</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        ans*=i; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>解法二：每一个阶层值可以看成前一个阶层*当前N</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一层for循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">code_f2</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//求和</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span><span class="number">1</span>;<span class="comment">//cur记录前一个阶层值</span></span><br><span class="line">     <span class="comment">// 一边计算阶层，一边同时求值</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">         cur*=i;</span><br><span class="line">         ans+=cur;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>找到一个实现算法流程的最简单的算法，与最终的算法，进行比较。</p>
<ol>
<li>有一个你想要测的方法a；</li>
<li>实现一个绝对正确但是复杂度不好的方法b；</li>
<li>实现一个随机样本产生器；</li>
<li>实现对比算法a和b的方法；</li>
<li>把方法a和方法b比对多次来验证方法a是否正确；</li>
<li>如果有一个样本使得比对出错，打印样本分析是哪个方法出错；</li>
<li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</li>
</ol>
<p>定义：用于生成随机样本给自己做比对的机器。</p>
<p>利用随机性，生成任意数组，即对数器便于调试验证.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* package codechef; // don&#x27;t place package name! */</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">/* Name of the class has to be &quot;Main&quot; only if the class is public. */</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">    // 利用随机数特性，可以生成一个任意长度任意值的样本数组，便于验证。</span><br><span class="line">    // 和后续的对数器一起使用，方便调试排查问题</span><br><span class="line">    int testTimes = 10000000;</span><br><span class="line">  for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">   int[] arr = lengthRadomValueRadom(10,19);</span><br><span class="line">            code_InsertSort1(arr);</span><br><span class="line">         if(!isSortAsc(arr))&#123;</span><br><span class="line">             System.out.println(&quot;插入排序算法不正确&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br><span class="line">       </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int[] lengthRadomValueRadom(int maxLength,int maxvalue)&#123;</span><br><span class="line">     // 随机生成最大长度，最大值的随机数组</span><br><span class="line">     int N = (int)(Math.random()*maxLength);</span><br><span class="line">     int [] arr = new int[N];</span><br><span class="line">     for(int i =0;i&lt;N;i++)&#123;</span><br><span class="line">         arr[i] = (int)(Math.random()*maxvalue);</span><br><span class="line">     &#125;</span><br><span class="line">     return arr;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static boolean isSortAsc(int[] arr)&#123;</span><br><span class="line">     // 判断数组是否为升序，本质是对数器</span><br><span class="line">     int N = arr.length;</span><br><span class="line">     if(N&lt;2)&#123;</span><br><span class="line">         // 注意边界条件</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     int maxV = arr[0];</span><br><span class="line">     for(int i = 1;i&lt;N;i++)&#123;</span><br><span class="line">         if(maxV &gt;arr[i])&#123;</span><br><span class="line">           return false;  </span><br><span class="line">         &#125;</span><br><span class="line">         maxV = arr[i];</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static void code_InsertSort1(int[] arr)&#123;</span><br><span class="line"> // 插入排序</span><br><span class="line">     if(arr == null||arr.length&lt;2)&#123;</span><br><span class="line">         //所有算法优先考虑边界问题</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        for(int end=1;end&lt;N;end++)&#123;</span><br><span class="line">            // 1.遍历0-1，0-2...</span><br><span class="line">            // 2.索引值不越界且左边小于后边相邻的，才停止。否则，一直交换下去，保证左边小右边大</span><br><span class="line">            for(int pre = end;pre-1&gt;=0&amp;&amp;arr[pre-1]&gt;arr[pre];pre--)&#123;</span><br><span class="line">                swap(arr,pre-1,pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static void swap(int[]arr,int i,int j)&#123;</span><br><span class="line">     // 常规交换</span><br><span class="line">     int tem = arr[i];</span><br><span class="line">     arr[i] = arr[j];</span><br><span class="line">     arr[j] = tem;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p>经常看到在有序数组上，开展二分搜索。但有序是所有问题使用二分的必要条件吗？不是，只要能正确构建左右两侧的淘汰逻辑，就可以用二分。</p>
<ul>
<li>题目1:在一个有序数组中，找某个数是否存在</li>
<li>题目2:在一个有序数组中，找&gt;=某个数最左侧的位置</li>
<li>题目3:在一个有序数组中，找&lt;=某个数最右侧的位置</li>
<li>题目4:局部最小值问题，无序数组，任意两个相邻的数不相等，返回一个局部最小值。注意：这个局部最小值可能有多个，只要找到一个就可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// 题目1:在一个有序数组中，找某个数是否存在</span><br><span class="line">public static boolean exist(int[] sortedArr, int num) &#123;</span><br><span class="line"> // 默认sortedArr是升序的</span><br><span class="line"> if (sortedArr == null || sortedArr.length == 0) &#123;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"> int L = 0;</span><br><span class="line"> int R = sortedArr.length - 1;</span><br><span class="line"> int mid = 0;</span><br><span class="line"> // L..R</span><br><span class="line"> while (L &lt; R) &#123; // L..R 至少两个数的时候</span><br><span class="line">  mid = L + ((R - L) &gt;&gt; 1);</span><br><span class="line">  if (sortedArr[mid] == num) &#123;</span><br><span class="line">   return true;</span><br><span class="line">  &#125; else if (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">   // 因为数组是升序的，中间&gt;num,去左半边查询</span><br><span class="line">   R = mid - 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   // 去右半边查询</span><br><span class="line">   L = mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return sortedArr[L] == num;</span><br><span class="line">&#125;</span><br><span class="line">// 题目2:在一个有序数组中，找&gt;=某个数最左侧的位置</span><br><span class="line">public static int nearestIndex(int[] arr, int value) &#123;</span><br><span class="line"> int L = 0;</span><br><span class="line"> int R = arr.length - 1;</span><br><span class="line"> int index = -1; // 记录最左的对号</span><br><span class="line"> // 相当于，在大于等于value区域，一直往左收缩，直到index左边没有数为止</span><br><span class="line"> while (L &lt;= R) &#123; // 至少一个数的时候</span><br><span class="line">  int mid = L + ((R - L) &gt;&gt; 1);</span><br><span class="line">  if (arr[mid] &gt;= value) &#123;</span><br><span class="line">   // 记录mid,往左收缩</span><br><span class="line">   index = mid;</span><br><span class="line">   R = mid - 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   // 往右收缩</span><br><span class="line">   L = mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return index;</span><br><span class="line">&#125;</span><br><span class="line">// 题目3:在一个有序数组中，找&lt;=某个数最右侧的位置</span><br><span class="line">public static int nearestIndex(int[] arr, int value) &#123;</span><br><span class="line"> int L = 0;</span><br><span class="line"> int R = arr.length - 1;</span><br><span class="line"> int index = -1; // 记录最右的对号</span><br><span class="line"> // 相当于，在小于等于value区域，一直往右收缩，直到index右边没有数为止</span><br><span class="line"> while (L &lt;= R) &#123;</span><br><span class="line">  int mid = L + ((R - L) &gt;&gt; 1);</span><br><span class="line">  if (arr[mid] &lt;= value) &#123;</span><br><span class="line">   // 记录mid,往右收缩</span><br><span class="line">   index = mid;</span><br><span class="line">   L = mid + 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   // 往左收缩</span><br><span class="line">   R = mid - 1;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return index;</span><br><span class="line">&#125;</span><br><span class="line">// 题目4:局部最小值问题</span><br><span class="line">public static int getLessIndex(int[] arr) &#123;</span><br><span class="line"> if (arr == null || arr.length == 0) &#123;</span><br><span class="line">  return -1;</span><br><span class="line"> &#125;</span><br><span class="line"> // 情况1：如果一个数组(0~1)(0 1)是升序排列，则局部最小值是 0 位置</span><br><span class="line"> if (arr.length == 1 || arr[0] &lt; arr[1]) &#123;</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> // 情况2：如果一个数组(n-2, n-1)(n−2,n−1)是降序排列，则局部最小值是 n - 1n−1 位置</span><br><span class="line"> if (arr[arr.length - 1] &lt; arr[arr.length - 2]) &#123;</span><br><span class="line">  return arr.length - 1;</span><br><span class="line"> &#125;</span><br><span class="line"> int left = 1;</span><br><span class="line"> int right = arr.length - 2;</span><br><span class="line"> int mid = 0;</span><br><span class="line"> // 情况3：数组开头向下，结尾向上，那这个局部最小位置一定在中间</span><br><span class="line"> while (left &lt; right) &#123;</span><br><span class="line">  mid = (left + right) / 2;</span><br><span class="line">  if (arr[mid] &gt; arr[mid - 1]) &#123;</span><br><span class="line">   right = mid - 1;</span><br><span class="line">  &#125; else if (arr[mid] &gt; arr[mid + 1]) &#123;</span><br><span class="line">   left = mid + 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   return mid;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h1><p>异或运算：相同为0，不同为1</p>
<p>同或运算：相同为1，不同为0</p>
<p>能长时间记住的概率为0%，所以记住异或运算是<strong>无进位相加</strong>即可。</p>
<p><strong>异或运算的性质</strong></p>
<ul>
<li>0^N=N  N^N=0</li>
<li>异或运算满足交换律和结合律</li>
</ul>
<p><strong>如何不用额外变量交换两个数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">利用交换律和结合律：注意a,b的内存地址一定要不同，值相同是可以的。之所以能这么来回倒，是因为有2个空间操作，如果变成一个空间，就挂了。</span><br><span class="line">int a=甲;int b=乙;</span><br><span class="line">a = a^b;</span><br><span class="line">b = a^b;//a^b^b a^0 a</span><br><span class="line">a = a^b;//a^b^a 0^b b</span><br></pre></td></tr></table></figure>

<p><strong>怎么把一个int类型的数N，提取出最右侧的1来</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int rightOne = N &amp; ((~N) + 1)</span><br><span class="line">其中(~N) + 1也等于-N</span><br></pre></td></tr></table></figure>

<p><strong>经典题目</strong></p>
<ul>
<li>题目1：一个数组中，只有一种数出现了奇数次，其余数出现了偶数次，怎么找到该数？</li>
<li>题目2：一个数组中，有两种数出现了奇数次，其余数出现了偶数次，怎么找到这两个数？</li>
<li>题目3：提取出一个int类型数N的出现1的次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 题目1：一个数组中，只有一种数出现了奇数次，其余数出现了偶数次，怎么找到该数？</span><br><span class="line">public static void printOddTimesNum1(int[] arr) &#123;</span><br><span class="line">   /*</span><br><span class="line">    * 因为偶数的数异或结果为0,0^N=N,这就提取出来了</span><br><span class="line">    */</span><br><span class="line"> int eor = 0;</span><br><span class="line"> for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  eor ^= arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(eor);</span><br><span class="line">&#125;</span><br><span class="line">// 题目2：一个数组中，有两种数出现了奇数次，其余数出现了偶数次，怎么找到这两个数？</span><br><span class="line">public static void printOddTimesNum2(int[] arr) &#123;</span><br><span class="line"> int eor = 0;</span><br><span class="line"> for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  eor ^= arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> // eor=a^b, a 和 b是两种数</span><br><span class="line"> // eor != 0</span><br><span class="line"> // eor最右侧的1，提取出来</span><br><span class="line"> // eor :     00110010110111000</span><br><span class="line"> // rightOne :00000000000001000</span><br><span class="line"> int rightOne = eor &amp; (-eor); // 提取出最右的1</span><br><span class="line"> int onlyOne = 0; // eor&#x27;只异或最右为1的数，提取出a</span><br><span class="line"> for (int i = 0 ; i &lt; arr.length;i++) &#123;</span><br><span class="line">  //  arr[1] =  111100011110000</span><br><span class="line">  // rightOne=  000000000010000</span><br><span class="line">  if ((arr[i] &amp; rightOne) != 0) &#123;</span><br><span class="line">   onlyOne ^= arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   // b=a^b^a</span><br><span class="line"> System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br><span class="line">// 题目3：提取出一个int类型数N的出现1的次数</span><br><span class="line">public static int bit1counts(int N) &#123;</span><br><span class="line"> int count = 0;</span><br><span class="line"> //   011011010000</span><br><span class="line"> //   000000010000     1</span><br><span class="line"> //   011011000000</span><br><span class="line"> while(N != 0) &#123;</span><br><span class="line">  int rightOne = N &amp; ((~N) + 1);</span><br><span class="line">  count++;</span><br><span class="line">  N ^= rightOne;</span><br><span class="line">  // N -= rightOne</span><br><span class="line"> &#125;</span><br><span class="line"> return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a><strong>排序算法总结</strong></h2><p><strong>术语说明</strong></p>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选择排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(N*logN)</td>
<td align="center">O(N)</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">随机快排</td>
<td align="center">O(N*logN)</td>
<td align="center">O(logN)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(N*logN)</td>
<td align="center">O(1)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">界限</td>
<td align="center">界限</td>
<td align="center">界限</td>
<td align="center">界限</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(N)</td>
<td align="center">O(M)</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(N)</td>
<td align="center">O(N)</td>
<td align="center">有</td>
</tr>
</tbody></table>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序算法验证函数for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;<span class="comment">//测试次数</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//最大测试容量</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//最大测试数据</span></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">  <span class="type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line">  <span class="type">int</span>[] arr2 = copyArray(arr1);<span class="comment">//这两个数组除了数值相同内存地址完全没关系，请看copyArray()方法实现</span></span><br><span class="line">  selectionSort(arr1);<span class="comment">//用自己的算法排序</span></span><br><span class="line">  comparator(arr2);<span class="comment">//用java.util.Arrays包的排序算法排序</span></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">   succeed = <span class="literal">false</span>;</span><br><span class="line">   printArray(arr1);</span><br><span class="line">   printArray(arr2);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(succeed ? <span class="string">&quot;Nice!&quot;</span> : <span class="string">&quot;Fucking fucked!&quot;</span>);</span><br><span class="line"> <span class="type">int</span>[] arr = generateRandomArray(maxSize, maxValue);</span><br><span class="line"> printArray(arr);<span class="comment">// 排序前，打印数组</span></span><br><span class="line"> selectionSort(arr);<span class="comment">// 排序</span></span><br><span class="line"> printArray(arr);<span class="comment">// 排序后，打印数组</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 交换arr的i和j位置上的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"> arr[i] = arr[j];</span><br><span class="line"> arr[j] = tmp;</span><br><span class="line">       <span class="comment">// 更骚的交换，但i和j是一个位置的话，会出错</span></span><br><span class="line"> <span class="comment">/*arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment"> arr[j] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment"> arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序对数器for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">comparator</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"> Arrays.sort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回随机长度，随机值的数组for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> maxSize, <span class="type">int</span> maxValue) &#123;</span><br><span class="line"> <span class="comment">// Math.random() -&gt; [0,1) 所有的小数，等概率返回一个</span></span><br><span class="line"> <span class="comment">// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个</span></span><br><span class="line"> <span class="comment">// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个</span></span><br><span class="line"> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())]; <span class="comment">// 长度随机</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i] = (<span class="type">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="type">int</span>) (maxValue * Math.random());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组深拷贝for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"> <span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  res[i] = arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组值比较for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> ((arr1 == <span class="literal">null</span> &amp;&amp; arr2 != <span class="literal">null</span>) || (arr1 != <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (arr1 == <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组值打印for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>过程：</p>
<p>arr[0 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到0位置</p>
<p>arr[1 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到1位置</p>
<p>arr[2 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到2位置</p>
<p>…</p>
<p>arr[N-1 ~ N-1]范围上，找到最小值所在位置，然后把最小值交换到N-1位置</p>
<p>估算：</p>
<p>明显，如果arr长度为N,每一步都是常数操作的数量，如等差数列一般。所以总的常数操作数量=a(N^2)+bN+c,其中abc都是常数。所以是O(N^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void selectionSort(int[] arr) &#123;</span><br><span class="line">  if (arr == null || arr.length &lt; 2) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 0 ~ N-1  找到最小值，在哪，放到0位置上</span><br><span class="line">  // 1 ~ n-1  找到最小值，在哪，放到1 位置上</span><br><span class="line">  // 2 ~ n-1  找到最小值，在哪，放到2 位置上</span><br><span class="line">  for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">   int minIndex = i;</span><br><span class="line">   for (int j = i + 1; j &lt; arr.length; j++) &#123; // i ~ N-1 上找最小值的下标 </span><br><span class="line">    minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">   &#125;</span><br><span class="line">   swap(arr, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>过程：</p>
<p>在arr[0 ~ N-1]范围上，</p>
<p>arr[0]和arr[1],谁大谁来到1位置；arr[1]和arr[2],谁大谁来到2位置…arr[N-2]和arr[N-1],谁大谁来到N-1位置</p>
<p>在arr[0 ~ N-1]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2],谁大谁来到N-2位置</p>
<p>在arr[0 ~ N-1]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3],谁大谁来到N-3位置</p>
<p>…</p>
<p>最后在arr[0 ~ 1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1],谁大谁来到1位置</p>
<p>估算：</p>
<p>很明显，如果arr长度为N,每一步都是常数操作的数量，如等差数列一般。所以总的常数操作数量=a(N^2)+bN+c,其中abc都是常数。所以是O(N^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">  if (arr == null || arr.length &lt; 2) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 0 ~ N-1</span><br><span class="line">  // 0 ~ N-2</span><br><span class="line">  // 0 ~ N-3</span><br><span class="line">  for (int e = arr.length - 1; e &gt; 0; e--) &#123; // 0 ~ e</span><br><span class="line">   for (int i = 0; i &lt; e; i++) &#123;</span><br><span class="line">    if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class="line">     swap(arr, i, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>过程：</p>
<p>想让arr[0~0]上有序，这个范围只有一个数，当然有序</p>
<p>想让arr[0~1]上有序，所以从arr[1]往前看，如果arr[1]&lt;arr[0],就交换。否则什么都不做</p>
<p>…</p>
<p>想让arr[0~i]上有序，所以从arr[i]往前看，arr[i]这个数不停向左移动，一直移动到左边数字&gt;=自己，停止移动。</p>
<p>估算时发现，复杂度明显会因数据状况不同而不同。最好情况是只看不交换O(N),最差情况就是O(N^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void insertionSort(int[] arr) &#123;</span><br><span class="line">  if (arr == null || arr.length &lt; 2) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 不只1个数</span><br><span class="line">  for (int i = 1; i &lt; arr.length; i++) &#123; // 0 ~ i 做到有序</span><br><span class="line">   for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class="line">    swap(arr, j, j + 1);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="比较器与堆"><a href="#比较器与堆" class="headerlink" title="比较器与堆"></a>比较器与堆</h1><p><strong>堆结构是比堆排序重要得多的知识。</strong></p>
<h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><ol>
<li>堆结构就是用数组实现的完全二叉树。(完全二叉树，上面的层是满的，即使不满，那么一定是从左到右逐渐变满)</li>
<li>完全二叉树如果每棵子树的最大值都在顶部就是大根堆</li>
<li>完全二叉树如果每棵子树的最小值都在顶部就是小根堆</li>
<li>堆结构关键就是heapInsert和heapify操作</li>
<li>堆结构的增大和减少</li>
<li>优先级队列结构，就是堆结构</li>
</ol>
<p>heap堆结构[0,1,2,3,4,5]，对应到我们想象的堆结构是：</p>
<blockquote>
<pre><code> 0

 1   2

 3  4  5

 这里有一个关系heap的数组索引为i。假设当前节点为i,且节点索引从0开始使用。那么它的

 - 左节点：2i+1
 - 右节点：2i+2
 - 父节点：(i-1)/2

 当然某些题目可能节点索引从1开始。为什么这么奸？因为可以用位运算。那么它的，

 - 左节点：2i
 - 右节点：2i+1
 - 父节点：(i)/2
</code></pre>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class Code02_Heap &#123;</span><br><span class="line">    public static class MyMaxHeap &#123;</span><br><span class="line">        // O(longN)的大根堆数组</span><br><span class="line">        private int[] heap;</span><br><span class="line">        // 限制堆的大小</span><br><span class="line">        private final int limit;</span><br><span class="line">        // 当前堆的实时大小</span><br><span class="line">        private int heapSize;</span><br><span class="line"></span><br><span class="line">        public MyMaxHeap(int limit) &#123;</span><br><span class="line">            heap = new int[limit];</span><br><span class="line">            this.limit = limit;</span><br><span class="line">            heapSize = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return heapSize == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isFull() &#123;</span><br><span class="line">            return heapSize == limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void push(int value) &#123;</span><br><span class="line">            // 大根堆数组尾部添加节点</span><br><span class="line">            if (heapSize == limit) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;heap is full&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 大根堆添加节点，一定是来到最后的位置。原来的最后是heapSize-1索引处</span><br><span class="line">            heap[heapSize] = value;</span><br><span class="line">            // 先将最新的索引作为参数传入，然后heapSize长度+1</span><br><span class="line">            heapInsert(heap, heapSize++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public int pop() &#123;</span><br><span class="line">            // 大根堆数组弹出顶部节点</span><br><span class="line">            /*</span><br><span class="line">             * 用户此时，让你返回最大值，并且在大根堆中，把最大值删掉.剩下的数，依然保持大根堆组织</span><br><span class="line">             * */</span><br><span class="line">            // 先把最大值记录下来</span><br><span class="line">            int ans = heap[0];</span><br><span class="line">            // 然后把最后一个节点和第一个位置交换，然后长度--</span><br><span class="line">            swap(heap, 0, --heapSize);</span><br><span class="line">            // 接下来就是0索引节点值从上往下窜</span><br><span class="line">            heapify(heap, 0, heapSize);</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void heapInsert(int[] arr, int index) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 从下往上窜，添加节点，生成大根堆，可以用于建堆</span><br><span class="line">             * index表示大根堆添加节点的索引，比较当前节点和父节点值，直到要么index到顶，要么父节点比当前节点大.</span><br><span class="line">             * 新加进来的数，现在停在了index位置，请依次往上移动，</span><br><span class="line">             * 移动到0位置，或者干不掉自己的父亲了，停！</span><br><span class="line">             * [index]是当前节点， [index-1]/2是父节点</span><br><span class="line">             * index == 0是顶部，即使到顶部arr[0]&gt;arr[0]也可以跳出循环</span><br><span class="line">             */</span><br><span class="line">            while (arr[index] &gt; arr[(index - 1) / 2]) &#123;</span><br><span class="line">                // 只要当前值大于父节点值，就交换，并且索引更新为父节点索引，一直往上窜</span><br><span class="line">                swap(arr, index, (index - 1) / 2);</span><br><span class="line">                index = (index - 1) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void heapify(int[] arr, int index, int heapSize) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 从上往下窜，将当前节点调整为大根堆，可以用于建堆</span><br><span class="line">             * index表示当前节点的索引，比较当前节点和子节点最大的一个，直到要么index到底，要么父节点比当前节点大</span><br><span class="line">             * 从index位置，往下看，不断的下沉</span><br><span class="line">             * 停：较大的孩子都不再比index位置的数大；已经没孩子了</span><br><span class="line">             * */</span><br><span class="line">            // left表示左子节点</span><br><span class="line">            int left = index * 2 + 1;</span><br><span class="line">            // 如果有左孩子</span><br><span class="line">            while (left &lt; heapSize) &#123; // 如果有左孩子，有没有右孩子，可能有可能没有！</span><br><span class="line">                // 如果有右孩子且右大于左，则右孩子给largest。否则给左孩子。</span><br><span class="line">                int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;</span><br><span class="line">                // 比较当前节点和子节点最大的一个，哪一个大</span><br><span class="line">                largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">                // 如果父节点比当前节点大，直接跳出循环。index就是当前父节点，largest是子节点最大的一个</span><br><span class="line">                if (largest == index) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // index和较大孩子，要互换</span><br><span class="line">                swap(arr, largest, index);</span><br><span class="line">                // 当前节点往下更新索引</span><br><span class="line">                index = largest;</span><br><span class="line">                // 同时更新左子节点</span><br><span class="line">                left = index * 2 + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">            int tmp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RightMaxHeap &#123;</span><br><span class="line">        // O(N)的大根堆数组，巨暴力的一个大根堆</span><br><span class="line">        private int[] arr;</span><br><span class="line">        private final int limit;</span><br><span class="line">        private int size;</span><br><span class="line"></span><br><span class="line">        public RightMaxHeap(int limit) &#123;</span><br><span class="line">            arr = new int[limit];</span><br><span class="line">            this.limit = limit;</span><br><span class="line">            size = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return size == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isFull() &#123;</span><br><span class="line">            return size == limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void push(int value) &#123;</span><br><span class="line">            // 暴力的往后添加节点</span><br><span class="line">            if (size == limit) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;heap is full&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            arr[size++] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int pop() &#123;</span><br><span class="line">            // 每次找到最大值，并弹出</span><br><span class="line">            int maxIndex = 0;</span><br><span class="line">            for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">                if (arr[i] &gt; arr[maxIndex]) &#123;</span><br><span class="line">                    maxIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int ans = arr[maxIndex];</span><br><span class="line">            arr[maxIndex] = arr[--size];</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MyComparator implements Comparator&lt;Integer&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 小根堆</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(new MyComparator());</span><br><span class="line">        heap.add(5);</span><br><span class="line">        heap.add(5);</span><br><span class="line">        heap.add(5);</span><br><span class="line">        heap.add(3);</span><br><span class="line">        // 5 , 3</span><br><span class="line">        System.out.println(heap.peek());</span><br><span class="line">        heap.add(7);</span><br><span class="line">        heap.add(0);</span><br><span class="line">        heap.add(7);</span><br><span class="line">        heap.add(0);</span><br><span class="line">        heap.add(7);</span><br><span class="line">        heap.add(0);</span><br><span class="line">        System.out.println(heap.peek());</span><br><span class="line">        while (!heap.isEmpty()) &#123;</span><br><span class="line">            System.out.println(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int value = 1000;</span><br><span class="line">        int limit = 100;</span><br><span class="line">        int testTimes = 1000000;</span><br><span class="line">        for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">            int curLimit = (int) (Math.random() * limit) + 1;</span><br><span class="line">            MyMaxHeap my = new MyMaxHeap(curLimit);</span><br><span class="line">            // 对数器</span><br><span class="line">            RightMaxHeap test = new RightMaxHeap(curLimit);</span><br><span class="line">            int curOpTimes = (int) (Math.random() * limit);</span><br><span class="line">            for (int j = 0; j &lt; curOpTimes; j++) &#123;</span><br><span class="line">                if (my.isEmpty() != test.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (my.isFull() != test.isFull()) &#123;</span><br><span class="line">                    System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (my.isEmpty()) &#123;</span><br><span class="line">                    int curValue = (int) (Math.random() * value);</span><br><span class="line">                    my.push(curValue);</span><br><span class="line">                    test.push(curValue);</span><br><span class="line">                &#125; else if (my.isFull()) &#123;</span><br><span class="line">                    if (my.pop() != test.pop()) &#123;</span><br><span class="line">                        System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (Math.random() &lt; 0.5) &#123;</span><br><span class="line">                        int curValue = (int) (Math.random() * value);</span><br><span class="line">                        my.push(curValue);</span><br><span class="line">                        test.push(curValue);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (my.pop() != test.pop()) &#123;</span><br><span class="line">                            System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;finish!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol>
<li>第一步：先生成大根堆</li>
<li>第二步：先将最大值交换到最后，循环逻辑：heapify调整当前值在剩下范围内为大根堆，再交换。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">public class Code03_HeapSort &#123;</span><br><span class="line">    // 堆排序额外空间复杂度O(1)</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        // 小根堆排序</span><br><span class="line">        if (arr == null || arr.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 解法1：第一步：先生成大根堆。复杂度：O(N*logN)</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span><br><span class="line">            // 建堆，注意这是每次只给一个节点</span><br><span class="line">            heapInsert(arr, i); // O(logN)</span><br><span class="line">        &#125;</span><br><span class="line">        // 解法2：第一步：先生成大根堆，注意是从右往左的。复杂度：O(N)</span><br><span class="line">//        for (int i = arr.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">//            // 建堆,注意这是一次给所有arr节点</span><br><span class="line">//            heapify(arr, i, arr.length);</span><br><span class="line">//        &#125;</span><br><span class="line">        int heapSize = arr.length;</span><br><span class="line">        // 第二步：先将最大值交换到最后，循环逻辑：heapify调整当前值在剩下范围内为大根堆，再交换。复杂度:O(N*logN)</span><br><span class="line">        // 先size--。将大根堆的最大值交换到最后，即最大值下沉。</span><br><span class="line">        swap(arr, 0, --heapSize);</span><br><span class="line">        // O(N*logN)</span><br><span class="line">        // 在剩下的0到size-1上，heapify调整当前值为大根堆，再交换。下沉第二大的值，size--</span><br><span class="line">        while (heapSize &gt; 0) &#123; // O(N)</span><br><span class="line">            // heapify调整当前值在剩下范围内为大根堆</span><br><span class="line">            heapify(arr, 0, heapSize); // O(logN)</span><br><span class="line">            // 先size--</span><br><span class="line">            // 将当前最大值交换到最后，即最大值下沉</span><br><span class="line">            swap(arr, 0, --heapSize); // O(1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void heapInsert(int[] arr, int index) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 从下往上窜，添加节点，生成大根堆。可以用于建堆，注意这是每次只给一个节点</span><br><span class="line">         * index表示大根堆添加节点的索引，比较当前节点和父节点值，直到要么index到顶，要么父节点比当前节点大.</span><br><span class="line">         * 新加进来的数，现在停在了index位置，请依次往上移动，</span><br><span class="line">         * 移动到0位置，或者干不掉自己的父亲了，停！</span><br><span class="line">         * [index]是当前节点， [index-1]/2是父节点</span><br><span class="line">         * index == 0是顶部，即使到顶部arr[0]&gt;arr[0]也可以跳出循环</span><br><span class="line">         */</span><br><span class="line">        while (arr[index] &gt; arr[(index - 1) / 2]) &#123;</span><br><span class="line">            // 只要当前值大于父节点值，就交换，并且索引更新为父节点索引，一直往上窜</span><br><span class="line">            swap(arr, index, (index - 1) / 2);</span><br><span class="line">            index = (index - 1) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void heapify(int[] arr, int index, int heapSize) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 从上往下窜，将当前节点调整为大根堆。可以用于建堆，注意这是一次给所有arr节点</span><br><span class="line">         * index表示当前节点的索引，比较当前节点和子节点最大的一个，直到要么index到底，要么父节点比当前节点大</span><br><span class="line">         * 从index位置，往下看，不断的下沉</span><br><span class="line">         * 停：较大的孩子都不再比index位置的数大；已经没孩子了</span><br><span class="line">         * */</span><br><span class="line">        // left表示左子节点</span><br><span class="line">        int left = index * 2 + 1;</span><br><span class="line">        // 如果有左孩子</span><br><span class="line">        while (left &lt; heapSize) &#123; // 如果有左孩子，有没有右孩子，可能有可能没有！</span><br><span class="line">            // 如果有右孩子且右大于左，则右孩子给largest。否则给左孩子。</span><br><span class="line">            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;</span><br><span class="line">            // 比较当前节点和子节点最大的一个，哪一个大</span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            // 如果父节点比当前节点大，直接跳出循环。index就是当前父节点，largest是子节点最大的一个</span><br><span class="line">            if (largest == index) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // index和较大孩子，要互换</span><br><span class="line">            swap(arr, largest, index);</span><br><span class="line">            // 当前节点往下更新索引</span><br><span class="line">            index = largest;</span><br><span class="line">            // 同时更新左子节点</span><br><span class="line">            left = index * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void comparator(int[] arr) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static int[] generateRandomArray(int maxSize, int maxValue) &#123;</span><br><span class="line">        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static int[] copyArray(int[] arr) &#123;</span><br><span class="line">        if (arr == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[arr.length];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static boolean isEqual(int[] arr1, int[] arr2) &#123;</span><br><span class="line">        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr1 == null &amp;&amp; arr2 == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr1.length != arr2.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            if (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void printArray(int[] arr) &#123;</span><br><span class="line">        if (arr == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 系统自带的优先级队列，默认小根堆</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();</span><br><span class="line">        heap.add(6);</span><br><span class="line">        heap.add(8);</span><br><span class="line">        heap.add(0);</span><br><span class="line">        heap.add(2);</span><br><span class="line">        heap.add(9);</span><br><span class="line">        heap.add(1);</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">        while (!heap.isEmpty()) &#123;</span><br><span class="line">            System.out.println(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int testTime = 500000;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        int maxValue = 100;</span><br><span class="line">        boolean succeed = true;</span><br><span class="line">        for (int i = 0; i &lt; testTime; i++) &#123;</span><br><span class="line">            int[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line">            int[] arr2 = copyArray(arr1);</span><br><span class="line">            heapSort(arr1);</span><br><span class="line">            comparator(arr2);</span><br><span class="line">            if (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">                succeed = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);</span><br><span class="line"></span><br><span class="line">        int[] arr = generateRandomArray(maxSize, maxValue);</span><br><span class="line">        printArray(arr);</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与堆有关的题目</strong></p>
<p>题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素的移动距离可以不超过k，并且k相对于整个数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。</p>
<ol>
<li>第一步：先建一个小根堆，0…K。这里一定有最小值，因为题目给出排序移动距离不超过k.</li>
<li>第二步：先弹出小根堆的最小值，然后再添加，再弹出</li>
<li>第三步：最后发现没有可以添加的节点了，直接逐个弹出节点。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class Code04_SortArrayDistanceLessK &#123;</span><br><span class="line">    public static void sortedArrDistanceLessK(int[] arr, int k) &#123;</span><br><span class="line">     // 复杂度O(N*logK)</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 默认小根堆</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();</span><br><span class="line">        int index = 0;</span><br><span class="line">        // 第一步：先建一个小根堆，0...K。这里一定有最小值，因为题目给出排序移动距离不超过k.</span><br><span class="line">        // 比如k=3,则下标索引0,1,2,3。</span><br><span class="line">        for (; index &lt;= Math.min(arr.length - 1, k); index++) &#123;</span><br><span class="line">            heap.add(arr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        // 第二步：先弹出小根堆的最小值，然后再添加，再弹出</span><br><span class="line">        for (; index &lt; arr.length; i++, index++) &#123;</span><br><span class="line">            arr[i] = heap.poll();</span><br><span class="line">            heap.add(arr[index]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        // 第三步：最后发现没有可以添加的节点了，直接逐个弹出节点。最后arr就是升序排好序的结果</span><br><span class="line">        while (!heap.isEmpty()) &#123;</span><br><span class="line">            arr[i++] = heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void comparator(int[] arr, int k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static int[] randomArrayNoMoveMoreK(int maxSize, int maxValue, int K) &#123;</span><br><span class="line">        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        // 先排个序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        // 然后开始随意交换，但是保证每个数距离不超过K</span><br><span class="line">        // swap[i] == true, 表示i位置已经参与过交换</span><br><span class="line">        // swap[i] == false, 表示i位置没有参与过交换</span><br><span class="line">        boolean[] isSwap = new boolean[arr.length];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int j = Math.min(i + (int) (Math.random() * (K + 1)), arr.length - 1);</span><br><span class="line">            if (!isSwap[i] &amp;&amp; !isSwap[j]) &#123;</span><br><span class="line">                isSwap[i] = true;</span><br><span class="line">                isSwap[j] = true;</span><br><span class="line">                int tmp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static int[] copyArray(int[] arr) &#123;</span><br><span class="line">        if (arr == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[arr.length];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static boolean isEqual(int[] arr1, int[] arr2) &#123;</span><br><span class="line">        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr1 == null &amp;&amp; arr2 == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr1.length != arr2.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            if (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void printArray(int[] arr) &#123;</span><br><span class="line">        if (arr == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;test begin&quot;);</span><br><span class="line">        int testTime = 500000;</span><br><span class="line">        int maxSize = 100;</span><br><span class="line">        int maxValue = 100;</span><br><span class="line">        boolean succeed = true;</span><br><span class="line">        for (int i = 0; i &lt; testTime; i++) &#123;</span><br><span class="line">            int k = (int) (Math.random() * maxSize) + 1;</span><br><span class="line">            int[] arr = randomArrayNoMoveMoreK(maxSize, maxValue, k);</span><br><span class="line">            int[] arr1 = copyArray(arr);</span><br><span class="line">            int[] arr2 = copyArray(arr);</span><br><span class="line">            sortedArrDistanceLessK(arr1, k);</span><br><span class="line">            comparator(arr2, k);</span><br><span class="line">            if (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">                succeed = false;</span><br><span class="line">                System.out.println(&quot;K : &quot; + k);</span><br><span class="line">                printArray(arr);</span><br><span class="line">                printArray(arr1);</span><br><span class="line">                printArray(arr2);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><ol>
<li>比较器的实质是重载比较运算符</li>
<li>比较器可以很好的应用在特殊标准的排序上</li>
<li>写代码变得异常容易，还用于泛型编程</li>
</ol>
<p><strong>比较器通用规则</strong></p>
<p>a-b的return返回值，如果结果为：</p>
<ul>
<li>负数,表示a排前，b在后，即升序</li>
<li>正数,表示b排前，a在后，即降序</li>
<li>0,表示ab相等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">123</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cmp</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b;&#125;<span class="comment">//比较器</span></span><br><span class="line">arr.<span class="title function_">sort</span>(cmp);<span class="comment">//使用比较器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(arr));<span class="comment">//3,6,11,12,23,43,123</span></span><br></pre></td></tr></table></figure>

<p><strong>利用比较器，自己实现动态小根堆</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class HeapGreater&lt;T&gt; &#123;</span><br><span class="line">    // 利用比较器，自己实现动态的小根堆.即增删改后，始终都是小根堆。因为系统不提供动态的小根堆，只是一个静态的小根堆.关键就是节点索引记录表，知道了i,可以上窜或下窜。</span><br><span class="line">    // 加入小根堆的节点</span><br><span class="line">    private ArrayList&lt;T&gt; heap;</span><br><span class="line">    // 节点索引记录表：加入过小根堆的节点对应的索引值</span><br><span class="line">    private HashMap&lt;T, Integer&gt; indexMap;</span><br><span class="line">    private int heapSize;</span><br><span class="line">    // 比较器规则</span><br><span class="line">    private Comparator&lt;? super T&gt; comp;</span><br><span class="line"></span><br><span class="line">    public HeapGreater(Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        heap = new ArrayList&lt;&gt;();</span><br><span class="line">        indexMap = new HashMap&lt;&gt;();</span><br><span class="line">        heapSize = 0;</span><br><span class="line">        comp = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return heapSize == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return heapSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean contains(T obj) &#123;</span><br><span class="line">        // 判断是否加入过小根堆</span><br><span class="line">        return indexMap.containsKey(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去除小根堆的顶部</span><br><span class="line">    public T peek() &#123;</span><br><span class="line">        return heap.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加节点到小根堆</span><br><span class="line">    public void push(T obj) &#123;</span><br><span class="line">        // 直接先添加</span><br><span class="line">        heap.add(obj);</span><br><span class="line">        // 节点表添加节点索引</span><br><span class="line">        indexMap.put(obj, heapSize);</span><br><span class="line">        // 上窜，并且按照cop比较器规则上窜</span><br><span class="line">        heapInsert(heapSize++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 弹出小根堆顶部节点</span><br><span class="line">    public T pop() &#123;</span><br><span class="line">        // 先取出要返回的节点，然后小根堆化</span><br><span class="line">        T ans = heap.get(0);</span><br><span class="line">        // 交换到最后</span><br><span class="line">        swap(0, heapSize - 1);</span><br><span class="line">        // 两个map同步删除</span><br><span class="line">        indexMap.remove(ans);</span><br><span class="line">        heap.remove(--heapSize);</span><br><span class="line">        // 把顶部节点下窜，并且按照cop比较器规则下窜</span><br><span class="line">        heapify(0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除一个小根堆节点</span><br><span class="line">    public void remove(T obj) &#123;</span><br><span class="line">        T replace = heap.get(heapSize - 1);</span><br><span class="line">        int index = indexMap.get(obj);</span><br><span class="line">        indexMap.remove(obj);</span><br><span class="line">        heap.remove(--heapSize);</span><br><span class="line">        if (obj != replace) &#123;</span><br><span class="line">            heap.set(index, replace);</span><br><span class="line">            indexMap.put(replace, index);</span><br><span class="line">            resign(replace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新了节点值，重置小根堆，使其小根堆化</span><br><span class="line">    public void resign(T obj) &#123;</span><br><span class="line">        // 因为不确定节点是上窜还是下窜，关键就是这个索引值即记录表</span><br><span class="line">        // 要么上窜</span><br><span class="line">        heapInsert(indexMap.get(obj));</span><br><span class="line">        // 要么下窜</span><br><span class="line">        heapify(indexMap.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 请返回堆上的所有元素</span><br><span class="line">    public List&lt;T&gt; getAllElements() &#123;</span><br><span class="line">        List&lt;T&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (T c : heap) &#123;</span><br><span class="line">            ans.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 上窜</span><br><span class="line">    private void heapInsert(int index) &#123;</span><br><span class="line">        // 按照比较器规则上窜，因为是负数，所以整体是升序，对应小根堆</span><br><span class="line">        while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) &lt; 0) &#123;</span><br><span class="line">            swap(index, (index - 1) / 2);</span><br><span class="line">            index = (index - 1) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 下窜</span><br><span class="line">    private void heapify(int index) &#123;</span><br><span class="line">        int left = index * 2 + 1;</span><br><span class="line">        while (left &lt; heapSize) &#123;</span><br><span class="line">            // 按照比较器规则下窜，因为是负数，所以整体是升序，对应小根堆</span><br><span class="line">            int best = left + 1 &lt; heapSize &amp;&amp; comp.compare(heap.get(left + 1), heap.get(left)) &lt; 0 ? (left + 1) : left;</span><br><span class="line">            best = comp.compare(heap.get(best), heap.get(index)) &lt; 0 ? best : index;</span><br><span class="line">            if (best == index) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(best, index);</span><br><span class="line">            index = best;</span><br><span class="line">            left = index * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换</span><br><span class="line">    private void swap(int i, int j) &#123;</span><br><span class="line">        T o1 = heap.get(i);</span><br><span class="line">        T o2 = heap.get(j);</span><br><span class="line">        // heap有变动，indexMap也变动，强同步</span><br><span class="line">        heap.set(i, o2);</span><br><span class="line">        heap.set(j, o1);</span><br><span class="line">        indexMap.put(o2, i);</span><br><span class="line">        indexMap.put(o1, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组范围和"><a href="#数组范围和" class="headerlink" title="数组范围和"></a>数组范围和</h2><p><strong>关键词：利用前缀和，两者相减即为范围和</strong></p>
<p><strong>题目：求arr的2-3的范围和，如3+6=9</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">  int [] a = &#123;2,4,3,6,12,8,5,6,7,2,3,9&#125;;</span><br><span class="line">  int b = rangeNum(a,2,4,getHelp(a));</span><br><span class="line">  System.out.println(b);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int[] getHelp(int[]  arr)&#123;</span><br><span class="line">     // 利用前缀和数组辅助，差值就是范围和</span><br><span class="line">     int N = arr.length;</span><br><span class="line">     int [] help=new int[N];</span><br><span class="line">     help[0]=arr[0];</span><br><span class="line">     for(int i =1;i&lt;N;i++)&#123;</span><br><span class="line">         help[i]=help[i-1]+arr[i];</span><br><span class="line">     &#125;</span><br><span class="line">     return help;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int rangeNum(int[] arr,int L,int R,int[] help)&#123;</span><br><span class="line">     //求数组任意范围的和,如求arr的3-7范围和等于help[7]-help[2]</span><br><span class="line">     // 注意边界0</span><br><span class="line">     return L==0?help[R]:help[R]-help[L-1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机数难倒英雄汉"><a href="#随机数难倒英雄汉" class="headerlink" title="随机数难倒英雄汉"></a>随机数难倒英雄汉</h2><p><strong>Math.random()等概率返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* package codechef; // don&#x27;t place package name! */</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">/* Name of the class has to be &quot;Main&quot; only if the class is public. */</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">    int testTimes = 10000000;</span><br><span class="line">    int k = 6;</span><br><span class="line">  int counts[] = new int[k];</span><br><span class="line">  for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">   counts[f()]++;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">   System.out.println(i + &quot;这个数，出现了 &quot; + counts[i] + &quot; 次&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    // 此函数只能用，不能修改</span><br><span class="line"> // 等概率返回1~5</span><br><span class="line"> public static int f() &#123;</span><br><span class="line">     // (int) (Math.random() * k)表示等概率返回[0,k-1]范围值</span><br><span class="line">  return (int) (Math.random() * 5) + 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目：已知1<del>5随机等概率，求1</del>7随机等概率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* package codechef; // don&#x27;t place package name! */</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">/* Name of the class has to be &quot;Main&quot; only if the class is public. */</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">    int testTimes = 10000000;</span><br><span class="line">    int k = 8;</span><br><span class="line">  int counts[] = new int[k];</span><br><span class="line">  for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">   counts[f06()]++;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">   System.out.println(i + &quot;这个数，出现了 &quot; + counts[i] + &quot; 次&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int f01()&#123;</span><br><span class="line">     // 将1-5等概率转化为01等概率</span><br><span class="line">     int ans = 0;</span><br><span class="line">     // </span><br><span class="line">     do&#123;</span><br><span class="line">         ans = f();</span><br><span class="line">     &#125;while(ans == 3);</span><br><span class="line">     return ans &lt;3?0:1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int f07()&#123;</span><br><span class="line">     // 通过01移位等概率返回0~7，</span><br><span class="line">     return (f01()&lt;&lt;2)+(f01()&lt;&lt;1)+(f01());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static int f06()&#123;</span><br><span class="line">  //1~7等概率</span><br><span class="line">     // 将0~7等概率得到的7强制重新等概率，就变成了0~6等概率</span><br><span class="line">     int ans = 0;</span><br><span class="line">     // </span><br><span class="line">     do&#123;</span><br><span class="line">         ans = f07();</span><br><span class="line">     &#125;while(ans == 7);// 如果遇到7，则继续等概率，使之不要出现7</span><br><span class="line">     return ans+1;//0~6等概率，然后+1，变成1~7等概率</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    // 此函数只能用，不能修改</span><br><span class="line"> // 等概率返回1~5</span><br><span class="line"> public static int f() &#123;</span><br><span class="line">     // (int) (Math.random() * k)表示等概率返回[0,k-1]范围值</span><br><span class="line">  return (int) (Math.random() * 5) + 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目：已知a<del>b随机等概率，求c</del>d随机等概率</strong></p>
<blockquote>
<p>思路：</p>
<p>1.将a~b等概率转化为01等概率发生器，利用do.while均分，剔除一些不要的</p>
<p>2.c<del>d等价于0</del>(k)等概率+c,其中k=d-c</p>
<p>3.求0~k等概率，利用二进制特性左移，求取等概率，其中某些数据不要则利用do.while均分，剔除一些不要的</p>
</blockquote>
<p><strong>题目：已知01随机不等概率，求01随机等概率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！</span><br><span class="line"> public static int x() &#123;</span><br><span class="line">  return Math.random() &lt; 0.84 ? 0 : 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 等概率返回0和1</span><br><span class="line"> // f 0(p%) 1(1-p%)</span><br><span class="line"> // 两两组合，只有01和10是等概率，另外两个推倒重做</span><br><span class="line"> // 00 pp</span><br><span class="line"> // 11 (1-p)(1-p)</span><br><span class="line"> // 01 p(1-p)</span><br><span class="line"> // 10 (1-p)p</span><br><span class="line"> public static int y() &#123;</span><br><span class="line">  int ans = 0;</span><br><span class="line">  do &#123;</span><br><span class="line">   ans = x();</span><br><span class="line">  &#125; while (ans == x());</span><br><span class="line">   // 表示第一次和第二次的值相同，则继续循环即推倒重做</span><br><span class="line">  return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。该算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的，以其名字首字母命名。</p>
<p>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class KMP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getIndexOf(&quot;sssb&quot;,&quot;sb&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getIndexOf(String s, String m) &#123;</span><br><span class="line">        // KMP算法核心：分2步走，s为主串，m为模板串</span><br><span class="line">        // 第一步：求解模板串的最长公共前后缀的长度值</span><br><span class="line">        // 第二步：主串和模板串比较，采用不进行主串回溯的比较方法，高效</span><br><span class="line">        if (s == null || m == null || m.length() &lt; 1 || s.length() &lt; m.length()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //下面就是KMP算法的全部步骤</span><br><span class="line">        char[] str1 = s.toCharArray();</span><br><span class="line">        char[] str2 = m.toCharArray();</span><br><span class="line">        int i1 = 0;</span><br><span class="line">        int i2 = 0;</span><br><span class="line">        // 第一步：求解模板串的最长公共前后缀的长度值</span><br><span class="line">        int[] next = getNextArray(str2);</span><br><span class="line">        // 第二步：主串和模板串比较，采用不进行主串回溯的比较方法，高效</span><br><span class="line">        while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;</span><br><span class="line">            if (str1[i1] == str2[i2]) &#123;</span><br><span class="line">                // 主串和模板串值相同，则继续后移比较</span><br><span class="line">                i1++;</span><br><span class="line">                i2++;</span><br><span class="line">                //-1为起始位置</span><br><span class="line">            &#125; else if (next[i2] == -1) &#123;</span><br><span class="line">                // -1表示模板串的指针到首位了，则主串继续后移</span><br><span class="line">                i1++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 只要模板串的指针不是首位，则该指针继续回溯往前比较</span><br><span class="line">                i2 = next[i2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果i2滑到最后了，那证明找到了，返回匹配的索引开始值；如果到最后都不等于，那返回负一，没找到</span><br><span class="line">        return i2 == str2.length ? i1 - i2 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int[] getNextArray(char[] str2)&#123;</span><br><span class="line">        // 求解最长公共前后缀表</span><br><span class="line">        /*</span><br><span class="line">        首先确定好第i个位置上的匹配长度L</span><br><span class="line">        第i+1位置匹配长度判断时，需要判断第i位置上匹配长度中前半段A的下个字符和第i位置上的字符进行比较</span><br><span class="line">        如果相等则第i+1位置匹配长度为L+1</span><br><span class="line">        如果不相等将前半段A的匹配长度读出，再分出A的前半段B，再返回步骤2，进行判断。</span><br><span class="line">        最后前半段中只包含整个字符串中的第一个字符，此时还不相等则返回0，相等则返回1。</span><br><span class="line">        */</span><br><span class="line">        if(str2.length == 1)&#123;</span><br><span class="line">            return new int[] &#123;-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] next = new int[str2.length];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        next[1] = 0;</span><br><span class="line">        //i代表数组开始的位置</span><br><span class="line">        int i = 2;</span><br><span class="line">        //cn代表匹配的前后缀的最大长度</span><br><span class="line">        int cn = 0;</span><br><span class="line">        while(i&lt;next.length)&#123;</span><br><span class="line">            //如果前一个和最长串的相等，则直接最长串+1就是当前最长串</span><br><span class="line">            if(str2[i-1] == str2[cn])&#123;</span><br><span class="line">             // 条件1</span><br><span class="line">                next[i++] = ++cn;</span><br><span class="line">            &#125;else if(cn&gt;0)&#123;</span><br><span class="line">             // 条件2</span><br><span class="line">                // 最长串有值且当前值不相等，则需要找上一个最长串，刚好是next[cn]，往前递归回溯，一直到满足条件1或3</span><br><span class="line">                cn = next[cn];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">             // 条件3</span><br><span class="line">                // cn=0表示前面没有最长串，同时又不相等，则直接计算为0</span><br><span class="line">                next[i++] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断旋转词"><a href="#判断旋转词" class="headerlink" title="判断旋转词"></a>判断旋转词</h3><p>题目：旋转词是指，左侧部分字符整体搬移到右侧。例如：str=”123456”,str的旋转词有：“234561”，“345612”。。。判断str1=”113332”是不是str的旋转词？</p>
<p>暴力方法：O(N2)，求出str所有旋转词，逐一匹配</p>
<p>最佳解法：str+str得到一个双倍长串，判断str1是否为长串的连续子串。很神奇喔，因为旋转后刚好和str+str长串一致。</p>
<h3 id="判断二叉树T2是否为T1的子树"><a href="#判断二叉树T2是否为T1的子树" class="headerlink" title="判断二叉树T2是否为T1的子树"></a>判断二叉树T2是否为T1的子树</h3><p>题目：子树是指所有节点值相同，且小数的叶子节点也是大树的叶子节点。</p>
<p><strong>解法1：暴力求解法</strong></p>
<p><strong>解法2：利用KMP算法</strong></p>
<p>解法1：暴力求解法，逐一比较所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main (String[] args) throws java.lang.Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 判断二叉树T2是否为T1的子树</span><br><span class="line">        // T1 41235和T2 123</span><br><span class="line">        TreeNode tree1 = new TreeNode(4);</span><br><span class="line">        tree1.left = new TreeNode(1);</span><br><span class="line">        tree1.right = new TreeNode(5);</span><br><span class="line">        tree1.left.left = new TreeNode(2);</span><br><span class="line">        tree1.left.right = new TreeNode(3);</span><br><span class="line">        TreeNode tree2 = new TreeNode(1);</span><br><span class="line">        tree2.left = new TreeNode(2);</span><br><span class="line">        tree2.right = new TreeNode(3);</span><br><span class="line">        System.out.println(containsTree1(tree1,tree2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static class TreeNode &#123;</span><br><span class="line">        public int val;</span><br><span class="line">        public TreeNode left;</span><br><span class="line">        public TreeNode right;</span><br><span class="line">        public TreeNode(int value)&#123;</span><br><span class="line">            val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean containsTree1(TreeNode big,TreeNode small)&#123;</span><br><span class="line">        // 判断小树是否为大树的子树</span><br><span class="line">        if(small == null)&#123;</span><br><span class="line">            // 边界，小树为空</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(big == null)&#123;</span><br><span class="line">            // 边界，大树为空</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isSameValStructure(big,small))&#123;</span><br><span class="line">            // 大树和小树的是否完全一样</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 说明当前节点的数结构与小数不一样，则继续递归左右两边的节点</span><br><span class="line">        return containsTree1(big.left,small) || containsTree1(big.right,small);</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isSameValStructure(TreeNode head1,TreeNode head2)&#123;</span><br><span class="line">        // 判断两棵树是否完全相等</span><br><span class="line">        if(head1 == null &amp;&amp; head2 != null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(head1 != null &amp;&amp; head2 == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(head1 == null &amp;&amp; head2 == null)&#123;</span><br><span class="line">            // 说明完全相等</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(head1.val != head2.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归各个子节点</span><br><span class="line">        return isSameValStructure(head1.left,head2.left)&amp;&amp;isSameValStructure(head1.right,head2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：KMP算法，将T1，T2两棵树先序遍历转为数组，然后判断T2是否为T1的子串数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main (String[] args) throws java.lang.Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 判断二叉树T2是否为T1的子树</span><br><span class="line">        // T1 41235和T2 123</span><br><span class="line">        TreeNode tree1 = new TreeNode(4);</span><br><span class="line">        tree1.left = new TreeNode(1);</span><br><span class="line">        tree1.right = new TreeNode(5);</span><br><span class="line">        tree1.left.left = new TreeNode(2);</span><br><span class="line">        tree1.left.right = new TreeNode(3);</span><br><span class="line">        TreeNode tree2 = new TreeNode(1);</span><br><span class="line">        tree2.left = new TreeNode(2);</span><br><span class="line">        tree2.right = new TreeNode(3);</span><br><span class="line">        System.out.println(containsTree2(tree1,tree2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static class TreeNode &#123;</span><br><span class="line">        public int val;</span><br><span class="line">        public TreeNode left;</span><br><span class="line">        public TreeNode right;</span><br><span class="line">        public TreeNode(int value)&#123;</span><br><span class="line">            val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean containsTree2(TreeNode big,TreeNode small)&#123;</span><br><span class="line">        // 利用KMP子串特性巧妙求解，核心：先把树转为字符串数组，然后利用kmp算法求解</span><br><span class="line">        // 判断小树是否为大树的子树</span><br><span class="line">        if(small == null)&#123;</span><br><span class="line">            // 边界，小树为空</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(big == null)&#123;</span><br><span class="line">            // 边界，大树为空</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList &lt;String&gt; b = preSerial(big);</span><br><span class="line">        ArrayList &lt;String&gt; s = preSerial(small);</span><br><span class="line">        String[] str = new String[b.size()];</span><br><span class="line">        for(int i =0;i&lt;str.length;i++)&#123;</span><br><span class="line">            str[i] = b.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] match = new String[s.size()];</span><br><span class="line">        for(int i =0;i&lt;match.length;i++)&#123;</span><br><span class="line">            match[i] = s.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return getIndexOf(str,match) != -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static ArrayList &lt;String&gt; preSerial(TreeNode head)&#123;</span><br><span class="line">        // 将树结构通过先序遍历转为数组</span><br><span class="line">        ArrayList &lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        pres(head,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void pres(TreeNode head,ArrayList &lt;String&gt; ans)&#123;</span><br><span class="line">        // 先序遍历</span><br><span class="line">        if(head == null)&#123;</span><br><span class="line">            // 树为空则填充空值</span><br><span class="line">            ans.add(null);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans.add(String.valueOf(head.val));</span><br><span class="line">            pres(head.left,ans);</span><br><span class="line">            pres(head.right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getIndexOf(String[] str1,String[] str2)&#123;</span><br><span class="line">        // 判断字符串数组是否存在KMP子串数组</span><br><span class="line">        if(str1 == null||str2 == null || str1.length == 0 ||str1.length &lt; str2.length)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0;</span><br><span class="line">        int y = 0;</span><br><span class="line">        int[] next = getNextArray(str2);</span><br><span class="line">        while(x&lt;str1.length&amp;&amp;y&lt;str2.length)&#123;</span><br><span class="line">            if(isEqual(str1[x],str2[y]))&#123;</span><br><span class="line">              x++;</span><br><span class="line">              y++;</span><br><span class="line">            &#125;else if(next[y] == -1)&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                y = next[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return y == str2.length?x-y:-1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int[] getNextArray(String[] ms)&#123;</span><br><span class="line">        if(ms.length == 1)&#123;</span><br><span class="line">            return new int[]&#123;-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] next = new int[ms.length];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        next[1] = 0;</span><br><span class="line">        int i =2;</span><br><span class="line">        int cn = 0;</span><br><span class="line">        while(i&lt;next.length)&#123;</span><br><span class="line">            if(isEqual(ms[i-1],ms[cn]))&#123;</span><br><span class="line">                next[i++] = ++cn;</span><br><span class="line">            &#125;else if (cn&gt;0)&#123;</span><br><span class="line">                cn = next[cn];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                next[i++] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  next;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isEqual(String a,String b)&#123;</span><br><span class="line">        // 判断两个字符串是否相等</span><br><span class="line">        if(a == null &amp;&amp; b==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(a==null||b==null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return a.equals(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>没有复杂的数据结构，纯记忆多做即可</p>
<h2 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">     // 单链表反转，注意一定要有返回值的头结点，否则容易断链</span><br><span class="line">     Node node0 = new Node(0);</span><br><span class="line">     node0.next = new Node(1);</span><br><span class="line">     node0.next.next = new Node(2);</span><br><span class="line">     node0.next.next.next = new Node(3);</span><br><span class="line">     print(node0);</span><br><span class="line">     System.out.println();</span><br><span class="line">     node0 = reverseLinkedList(node0);</span><br><span class="line">     print(node0);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static Node reverseLinkedList(Node head)&#123;</span><br><span class="line">     // 单链表反转。</span><br><span class="line">     //注意一定要有返回值，让头结点指针指向第一个节点。否则头结点只能指向最后一个节点，导致其他节点丢失</span><br><span class="line">     Node pre = null;</span><br><span class="line">     Node next = null;</span><br><span class="line">     while(head != null)&#123;</span><br><span class="line">      // 先将当前节点的下个节点临时保存下</span><br><span class="line">       next = head.next;</span><br><span class="line">      // 把当前节点的下一个节点往前指</span><br><span class="line">       head.next =  pre;</span><br><span class="line">       // 把前一个节点变成当前，方便下一次继续往前指</span><br><span class="line">       pre = head;</span><br><span class="line">       // 上面就已经完成了反转，但还需要继续遍历下去，所以用到了第一步临时的next</span><br><span class="line">       head = next;</span><br><span class="line">     &#125;</span><br><span class="line">     // 当node为空，停止，并返回反转后的第一个节点pre</span><br><span class="line">     return pre;</span><br><span class="line"> &#125;</span><br><span class="line"> public static class Node&#123;</span><br><span class="line">  // 单链表结构</span><br><span class="line">     public int value;</span><br><span class="line">     public Node next;</span><br><span class="line">     public Node(int val)&#123;</span><br><span class="line">         value = val;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static void print(Node node)&#123;</span><br><span class="line">     while(node !=null)&#123;</span><br><span class="line">         System.out.print(node.value+&quot;-&gt;&quot;);</span><br><span class="line">         node = node.next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表反转"><a href="#双链表反转" class="headerlink" title="双链表反转"></a>双链表反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Node reverseDoubleList(Node head)&#123;</span><br><span class="line">     // 单链表反转。</span><br><span class="line">     //注意一定要有返回值，让头结点指针指向第一个节点。否则头结点只能指向最后一个节点，导致其他节点丢失</span><br><span class="line">     Node pre = null;</span><br><span class="line">     Node next = null;</span><br><span class="line">     while(head != null)&#123;</span><br><span class="line">      // 先将当前节点的下个节点临时保存下</span><br><span class="line">       next = head.next;</span><br><span class="line">      // 把当前节点的下一个节点往前指</span><br><span class="line">       head.next =  pre;</span><br><span class="line">       // 把当前节点的上一个节点往后指</span><br><span class="line">       head.last = next;</span><br><span class="line">       // 把前一个节点变成当前，方便下一次继续往前指</span><br><span class="line">       pre = head;</span><br><span class="line">       // 上面就已经完成了反转，但还需要继续遍历下去，所以用到了第一步临时的next</span><br><span class="line">       head = next;</span><br><span class="line">     &#125;</span><br><span class="line">     // 当node为空，停止，并返回反转后的第一个节点pre</span><br><span class="line">     return pre;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用单链表结构实现队列"><a href="#用单链表结构实现队列" class="headerlink" title="用单链表结构实现队列"></a>用单链表结构实现队列</h2><p>先进先出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">     //基于单链表结构实现的队列</span><br><span class="line">     MyQueue mq = new MyQueue();</span><br><span class="line">     mq.offer(1);</span><br><span class="line">     mq.offer(2);</span><br><span class="line">     mq.offer(3);</span><br><span class="line">     for(int i =0;i&lt;3;i++)&#123;</span><br><span class="line">         System.out.print(mq.poll()+&quot;-&gt;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static class Node&lt;V&gt; &#123;</span><br><span class="line">     // value的类型为泛型，单链表结构</span><br><span class="line">  public V value;</span><br><span class="line">  public Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">  public Node(V v) &#123;</span><br><span class="line">   value = v;</span><br><span class="line">   next = null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static class MyQueue&lt;V&gt; &#123;</span><br><span class="line">     // 基于链表结构的队列，先进先出。只需要记录头尾指针，内部的跳转使用单链表关联起来。</span><br><span class="line">     // 头指针</span><br><span class="line">  private Node&lt;V&gt; head;</span><br><span class="line">  // 尾指针</span><br><span class="line">  private Node&lt;V&gt; tail;</span><br><span class="line">  private int size;</span><br><span class="line"></span><br><span class="line">  public MyQueue() &#123;</span><br><span class="line">   head = null;</span><br><span class="line">   tail = null;</span><br><span class="line">   size = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">   return size == 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int size() &#123;</span><br><span class="line">   return size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void offer(V value) &#123;</span><br><span class="line">      // 队列添加数据</span><br><span class="line">      // cur是单链表结构</span><br><span class="line">   Node&lt;V&gt; cur = new Node&lt;V&gt;(value);</span><br><span class="line">   if (tail == null) &#123;</span><br><span class="line">       // 全空，则头尾指针指向当前节点</span><br><span class="line">    head = cur;</span><br><span class="line">    tail = cur;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       // 尾巴的节点先指向当前节点</span><br><span class="line">    tail.next = cur;</span><br><span class="line">    // 然后尾巴指针指向当前节点</span><br><span class="line">    tail = cur;</span><br><span class="line">   &#125;</span><br><span class="line">   size++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // C/C++的同学需要做节点析构的工作</span><br><span class="line">  public V poll() &#123;</span><br><span class="line">      // 队列弹出数据</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head != null) &#123;</span><br><span class="line">       // 直接取出头指针节点</span><br><span class="line">    ans = head.value;</span><br><span class="line">    // 头指针下移一个</span><br><span class="line">    head = head.next;</span><br><span class="line">    size--;</span><br><span class="line">   &#125;</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">    tail = null;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // C/C++的同学需要做节点析构的工作</span><br><span class="line">  public V peek() &#123;</span><br><span class="line">      // 查询队列的头结点</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head != null) &#123;</span><br><span class="line">    ans = head.value;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用单链表结构实现栈"><a href="#用单链表结构实现栈" class="headerlink" title="用单链表结构实现栈"></a>用单链表结构实现栈</h2><p>先进后出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static class MyStack&lt;V&gt; &#123;</span><br><span class="line">     // 基于链表结构的栈，先进后出。</span><br><span class="line">     // 只需要用到一个头指针</span><br><span class="line">  private Node&lt;V&gt; head;</span><br><span class="line">  private int size;</span><br><span class="line"></span><br><span class="line">  public MyStack() &#123;</span><br><span class="line">   head = null;</span><br><span class="line">   size = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">   return size == 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int size() &#123;</span><br><span class="line">   return size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void push(V value) &#123;</span><br><span class="line">      // 栈添加数据</span><br><span class="line">   Node&lt;V&gt; cur = new Node&lt;&gt;(value);</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">    head = cur;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    // 当前节点的下一个指向老头节点</span><br><span class="line">    cur.next = head;</span><br><span class="line">    // 新头指向当前节点</span><br><span class="line">    head = cur;</span><br><span class="line">   &#125;</span><br><span class="line">   size++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V pop() &#123;</span><br><span class="line">      // 栈弹出数据</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head != null) &#123;</span><br><span class="line">    ans = head.value;</span><br><span class="line">    head = head.next;</span><br><span class="line">    size--;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V peek() &#123;</span><br><span class="line">      // 查看栈顶数据</span><br><span class="line">   return head != null ? head.value : null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用双链表结构实现双端队列"><a href="#用双链表结构实现双端队列" class="headerlink" title="用双链表结构实现双端队列"></a>用双链表结构实现双端队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">     //基于双链表结构实现的双端队列，队列的头部和尾部都可以添加和删除元素</span><br><span class="line">     MyDeque mq = new MyDeque();</span><br><span class="line">     mq.pushHead(1);</span><br><span class="line">     mq.pushHead(2);</span><br><span class="line">     mq.pushHead(3);</span><br><span class="line">     for(int i =0;i&lt;3;i++)&#123;</span><br><span class="line">         System.out.print(mq.pollHead()+&quot;-&gt;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public static class Node&lt;V&gt; &#123;</span><br><span class="line">     // 双链表，不复杂，就是两个指针，一个往前指，一个往后指</span><br><span class="line">  public V value;</span><br><span class="line">  public Node&lt;V&gt; last;</span><br><span class="line">  public Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">  public Node(V v) &#123;</span><br><span class="line">   value = v;</span><br><span class="line">   last = null;</span><br><span class="line">   next = null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static class MyDeque&lt;V&gt; &#123;</span><br><span class="line">     // 基于双链表实现的双端队列，即头部可添加删除元素，尾部也可添加删除元素</span><br><span class="line">     // 依然是头指针和尾指针</span><br><span class="line">  private Node&lt;V&gt; head;</span><br><span class="line">  private Node&lt;V&gt; tail;</span><br><span class="line">  private int size;</span><br><span class="line"></span><br><span class="line">  public MyDeque() &#123;</span><br><span class="line">    </span><br><span class="line">   head = null;</span><br><span class="line">   tail = null;</span><br><span class="line">   size = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">   return size == 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int size() &#123;</span><br><span class="line">   return size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void pushHead(V value) &#123;</span><br><span class="line">      // 头部添加元素</span><br><span class="line">   Node&lt;V&gt; cur = new Node&lt;&gt;(value);</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">       // 先判空，头尾指针都指向当前节点</span><br><span class="line">    head = cur;</span><br><span class="line">    tail = cur;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       // 当前节点的下一个指针指向老头指针</span><br><span class="line">    cur.next = head;</span><br><span class="line">    // 老头指针指向当前节点</span><br><span class="line">    head.last = cur;</span><br><span class="line">    // 头指针变成当前节点</span><br><span class="line">    head = cur;</span><br><span class="line">   &#125;</span><br><span class="line">   // 队列长度+1</span><br><span class="line">   size++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void pushTail(V value) &#123;</span><br><span class="line">      // 尾部添加元素</span><br><span class="line">   Node&lt;V&gt; cur = new Node&lt;&gt;(value);</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">    head = cur;</span><br><span class="line">    tail = cur;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    tail.next = cur;</span><br><span class="line">    cur.last = tail;</span><br><span class="line">    tail = cur;</span><br><span class="line">   &#125;</span><br><span class="line">   size++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V pollHead() &#123;</span><br><span class="line">      // 头部弹出元素</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">   &#125;</span><br><span class="line">   size--;</span><br><span class="line">   ans = head.value;</span><br><span class="line">   if (head == tail) &#123;</span><br><span class="line">    head = null;</span><br><span class="line">    tail = null;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    head.last = null;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V pollTail() &#123;</span><br><span class="line">      // 尾部弹出元素</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">   &#125;</span><br><span class="line">   size--;</span><br><span class="line">   ans = tail.value;</span><br><span class="line">   if (head == tail) &#123;</span><br><span class="line">    head = null;</span><br><span class="line">    tail = null;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    tail = tail.last;</span><br><span class="line">    tail.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V peekHead() &#123;</span><br><span class="line">      // 头部查询元素</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (head != null) &#123;</span><br><span class="line">    ans = head.value;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V peekTail() &#123;</span><br><span class="line">      // 尾部查询元素</span><br><span class="line">   V ans = null;</span><br><span class="line">   if (tail != null) &#123;</span><br><span class="line">    ans = tail.value;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的k个节点的组内逆序调整"><a href="#单链表的k个节点的组内逆序调整" class="headerlink" title="单链表的k个节点的组内逆序调整"></a>单链表的k个节点的组内逆序调整</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">     // 该算法难度为hard,一定要画图，否则玩个6啊</span><br><span class="line">     // 测试链接：https://leetcode.com/problems/reverse-nodes-in-k-group/</span><br><span class="line">     //单链表的k个节点的组内逆序调整，不足k个的不需要逆序。</span><br><span class="line">     // 1-2-3-4-5-6-7-8逆序后3-2-1-6-5-4-7-8</span><br><span class="line">     ListNode node = new ListNode(1);</span><br><span class="line">     node.next = new ListNode(2);</span><br><span class="line">     node.next.next = new ListNode(3);</span><br><span class="line">     node.next.next.next = new ListNode(4);</span><br><span class="line">     node.next.next.next.next = new ListNode(5);</span><br><span class="line">     node.next.next.next.next.next = new ListNode(6);</span><br><span class="line">     node.next.next.next.next.next.next = new ListNode(7);</span><br><span class="line">     node.next.next.next.next.next.next.next = new ListNode(8);</span><br><span class="line">     node = reverseKGroup(node,3);</span><br><span class="line">     for(int i =0;i&lt;8;i++)&#123;</span><br><span class="line">         System.out.print(node.val+&quot;-&gt;&quot;);</span><br><span class="line">         node = node.next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 不要提交这个类</span><br><span class="line"> public static class ListNode&lt;V&gt; &#123;</span><br><span class="line">  public V val;</span><br><span class="line">  public ListNode&lt;V&gt; next;</span><br><span class="line">  public ListNode(V value)&#123;</span><br><span class="line">      val = value;</span><br><span class="line">      next = null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">  ListNode start = head;</span><br><span class="line">  ListNode end = getKGroupEnd(start, k);</span><br><span class="line">  if (end == null) &#123;</span><br><span class="line">      // 不足一组k个的情况，不用反转，直接返回头结点</span><br><span class="line">   return head;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第一组凑齐了！</span><br><span class="line">  head = end;</span><br><span class="line">  // 第一组直接反转</span><br><span class="line">  reverse(start, end);</span><br><span class="line">  // 当前组的最后一个节点是逆序后的原头节点</span><br><span class="line">  ListNode lastEnd = start;</span><br><span class="line">  while (lastEnd.next != null) &#123;</span><br><span class="line">      // 继续组内的头结点到尾节点的反转操作</span><br><span class="line">   start = lastEnd.next;</span><br><span class="line">   end = getKGroupEnd(start, k);</span><br><span class="line">   if (end == null) &#123;</span><br><span class="line">       // 当前组不需要反转，直接返回外层的头结点</span><br><span class="line">    return head;</span><br><span class="line">   &#125;</span><br><span class="line">   reverse(start, end);</span><br><span class="line">   // 逆序后，上一组的尾节点指向当前组的逆序后的头节点</span><br><span class="line">   lastEnd.next = end;</span><br><span class="line">   // 将上一组的尾节点变为当前组的逆序后的尾节点</span><br><span class="line">   lastEnd = start;</span><br><span class="line">  &#125;</span><br><span class="line">  return head;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static ListNode getKGroupEnd(ListNode start, int k) &#123;</span><br><span class="line">     // 已知节点，获取同组第k个节点</span><br><span class="line">  while (--k != 0 &amp;&amp; start != null) &#123;</span><br><span class="line">  // k=0表示k个节点，同时节点不能为空</span><br><span class="line">  // 根据链表特性，依次获取下去</span><br><span class="line">   start = start.next;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回从开始节点算起的第k个节点</span><br><span class="line">  return start;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void reverse(ListNode start, ListNode end) &#123;</span><br><span class="line">     // 将一组内的k个节点，全部反转</span><br><span class="line">     // 先将尾指针指向最后一个的下一个</span><br><span class="line">  end = end.next;</span><br><span class="line">  ListNode pre = null;</span><br><span class="line">  // 将头节点给起当前节点</span><br><span class="line">  ListNode cur = start;</span><br><span class="line">  ListNode next = null;</span><br><span class="line">  // 循环逆序当前这一组</span><br><span class="line">  while (cur != end) &#123;</span><br><span class="line">      // 链表反转的经典常规操作</span><br><span class="line">   next = cur.next;</span><br><span class="line">   cur.next = pre;</span><br><span class="line">   pre = cur;</span><br><span class="line">   cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  // 原来的头结点指向下一组的第一个节点</span><br><span class="line">  start.next = end;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个链表相加"><a href="#两个链表相加" class="headerlink" title="两个链表相加"></a>两个链表相加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">class Codechef</span><br><span class="line">&#123;</span><br><span class="line"> // 测试链接：https://leetcode.com/problems/add-two-numbers/</span><br><span class="line"> public static void main (String[] args) throws java.lang.Exception</span><br><span class="line"> &#123;</span><br><span class="line">     // 两个链表相加，计算进位信息</span><br><span class="line">     // 1-2-3-4和9-4-8-9-9相加得0-7-1-4-0-1</span><br><span class="line">     ListNode node = new ListNode(1);</span><br><span class="line">     node.next = new ListNode(2);</span><br><span class="line">     node.next.next = new ListNode(3);</span><br><span class="line">     node.next.next.next = new ListNode(4);</span><br><span class="line">     ListNode node1 = new ListNode(9);</span><br><span class="line">     node1.next = new ListNode(4);</span><br><span class="line">     node1.next.next = new ListNode(8);</span><br><span class="line">     node1.next.next.next = new ListNode(9);</span><br><span class="line">     node1.next.next.next.next = new ListNode(9);</span><br><span class="line">     node = addTwoNumbers(node,node1);</span><br><span class="line">     while(node != null)&#123;</span><br><span class="line">         System.out.print(node.val+&quot;-&gt;&quot;);</span><br><span class="line">         node = node.next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 不要提交这个类</span><br><span class="line"> public static class ListNode &#123;</span><br><span class="line">  public int val;</span><br><span class="line">  public ListNode next;</span><br><span class="line"></span><br><span class="line">  public ListNode(int val) &#123;</span><br><span class="line">   this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ListNode(int val, ListNode next) &#123;</span><br><span class="line">   this.val = val;</span><br><span class="line">   this.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static ListNode addTwoNumbers(ListNode head1, ListNode head2) &#123;</span><br><span class="line">     // 两个链表相加，从左到右依次为低位到高位，有进位要计算进位</span><br><span class="line">  int len1 = listLength(head1);</span><br><span class="line">  int len2 = listLength(head2);</span><br><span class="line">  // 获取两个链表中的哪一个长，哪一个短一些</span><br><span class="line">  ListNode l = len1 &gt;= len2 ? head1 : head2;</span><br><span class="line">  ListNode s = l == head1 ? head2 : head1;</span><br><span class="line">  /*</span><br><span class="line">   计算分三步走：</span><br><span class="line">   第一步：l节点有值，s节点有值，则直接计算ls包括进位符，该进位进位</span><br><span class="line">   第二步：l有值，s无值，则直接计算l包括进位符，该进位进位</span><br><span class="line">   第三部：l无值，s无值，则看进位符是否有，高位新增一个节点，保存进位值</span><br><span class="line">  */</span><br><span class="line">  ListNode curL = l;</span><br><span class="line">  ListNode curS = s;</span><br><span class="line">  ListNode last = curL;</span><br><span class="line">  // 表示当前进位符</span><br><span class="line">  int carry = 0;</span><br><span class="line">  int curNum = 0;</span><br><span class="line">  while (curS != null) &#123;</span><br><span class="line">      // 第一步，l+s+carry进位符</span><br><span class="line">   curNum = curL.val + curS.val + carry;</span><br><span class="line">   // 取余，最终结果复制到长链表中</span><br><span class="line">   curL.val = (curNum % 10);</span><br><span class="line">   // 更新进位符</span><br><span class="line">   carry = curNum / 10;</span><br><span class="line">   // 时刻跟随最新的节点</span><br><span class="line">   last = curL;</span><br><span class="line">   // 长短链表，依次往下指</span><br><span class="line">   curL = curL.next;</span><br><span class="line">   curS = curS.next;</span><br><span class="line">  &#125;</span><br><span class="line">  while (curL != null) &#123;</span><br><span class="line">       // 第二步</span><br><span class="line">   curNum = curL.val + carry;</span><br><span class="line">   curL.val = (curNum % 10);</span><br><span class="line">   carry = curNum / 10;</span><br><span class="line">   last = curL;</span><br><span class="line">   curL = curL.next;</span><br><span class="line">  &#125;</span><br><span class="line">  if (carry != 0) &#123;</span><br><span class="line">       // 第三步，如果最后一个还有进位，则追加一个链表节点到最后</span><br><span class="line">   last.next = new ListNode(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return l;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 求链表长度</span><br><span class="line"> public static int listLength(ListNode head) &#123;</span><br><span class="line">  int len = 0;</span><br><span class="line">  while (head != null) &#123;</span><br><span class="line">   len++;</span><br><span class="line">   head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return len;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表套路"><a href="#链表套路" class="headerlink" title="链表套路"></a>链表套路</h2><p>套路：</p>
<ul>
<li>对于笔试，不用关注空间复杂度，一切为了时间复杂度。比如：hash表，数组等</li>
<li>对于面试，时间复杂度依然第一，还要找到空间最省的方法。比如：快慢指针</li>
</ul>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义：一般情况下，快指针的移动步长为慢指针的两倍。利用快慢指针，我们把一个链表看成一个跑道，假设<strong>a</strong>的速度是<strong>b</strong>的两倍，那么当<strong>a</strong>跑完全程后，<strong>b</strong>刚好跑一半，以 此来 达到找到中间节点的目的。</p>
<p>题目：</p>
<ol>
<li>输入链表头结点，奇数长度返回中点，偶数长度返回上中点</li>
<li>输入链表头结点，奇数长度返回中点，偶数长度返回下中点</li>
<li>输入链表头结点，奇数长度返回中点前一个，偶数长度返回上中点前一个</li>
<li>输入链表头结点，奇数长度返回中点前一个，偶数长度返回下中点前一个</li>
</ol>
<ul>
<li>解法1：暴力求解，把节点加入到数组中，二分取值—用于笔试</li>
<li>解法2：快慢指针，—用于面试，如果笔试中能写出也可以</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Code01_LinkedListMid &#123;</span><br><span class="line">   public static class Node &#123;</span><br><span class="line">      public int value;</span><br><span class="line">      public Node next;</span><br><span class="line">      public Node(int v) &#123;</span><br><span class="line">         value = v;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 判断链表中是否存在环</span><br><span class="line">   public boolean hasCycle(Node head) &#123;</span><br><span class="line">      if (head == null)</span><br><span class="line">         return false;</span><br><span class="line">      //快慢两个指针，初始时都指向链表的头结点</span><br><span class="line">      Node slow = head;</span><br><span class="line">      Node fast = head;</span><br><span class="line">      while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">         //慢指针每次走一步</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         //快指针每次走两步</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">         //如果相遇，说明有环，直接返回true</span><br><span class="line">         if (slow == fast)</span><br><span class="line">            return true;</span><br><span class="line">      &#125;</span><br><span class="line">      //否则就是没环</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 题目1：解法2：快慢指针，---用于面试，如果笔试中能写出也可以</span><br><span class="line">   public static Node midOrUpMidNode(Node head) &#123;</span><br><span class="line">      // 链表没有节点，有1个节点，2个节点</span><br><span class="line">      if (head == null || head.next == null || head.next.next == null) &#123;</span><br><span class="line">         return head;</span><br><span class="line">      &#125;</span><br><span class="line">      // 链表有3个点或以上</span><br><span class="line">      // 根据题意，确定快慢指针的起始位置，起始值位置不用记忆，直接按照结果尝试奇偶即可</span><br><span class="line">      Node slow = head.next;</span><br><span class="line">      Node fast = head.next.next;</span><br><span class="line">      // 快慢指针的走法都是每次慢指针走一步，快指针走两步</span><br><span class="line">      while (fast.next != null &amp;&amp; fast.next.next != null) &#123;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return slow;</span><br><span class="line">   &#125;</span><br><span class="line">   // 题目2</span><br><span class="line">   public static Node midOrDownMidNode(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null) &#123;</span><br><span class="line">         return head;</span><br><span class="line">      &#125;</span><br><span class="line">      Node slow = head.next;</span><br><span class="line">      Node fast = head.next;</span><br><span class="line">      while (fast.next != null &amp;&amp; fast.next.next != null) &#123;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return slow;</span><br><span class="line">   &#125;</span><br><span class="line">   // 题目3</span><br><span class="line">   public static Node midOrUpMidPreNode(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null || head.next.next == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Node slow = head;</span><br><span class="line">      Node fast = head.next.next;</span><br><span class="line">      while (fast.next != null &amp;&amp; fast.next.next != null) &#123;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return slow;</span><br><span class="line">   &#125;</span><br><span class="line">   // 题目4</span><br><span class="line">   public static Node midOrDownMidPreNode(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (head.next.next == null) &#123;</span><br><span class="line">         return head;</span><br><span class="line">      &#125;</span><br><span class="line">      Node slow = head;</span><br><span class="line">      Node fast = head.next;</span><br><span class="line">      while (fast.next != null &amp;&amp; fast.next.next != null) &#123;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return slow;</span><br><span class="line">   &#125;</span><br><span class="line">   // 题目1：解法1：暴力求解，把节点加入到数组中，二分取值---用于笔试</span><br><span class="line">   public static Node right1(Node head) &#123;</span><br><span class="line">      if (head == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         arr.add(cur);</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.get((arr.size() - 1) / 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Node right2(Node head) &#123;</span><br><span class="line">      if (head == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         arr.add(cur);</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.get(arr.size() / 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Node right3(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null || head.next.next == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         arr.add(cur);</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.get((arr.size() - 3) / 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Node right4(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         arr.add(cur);</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr.get((arr.size() - 2) / 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Node test = null;</span><br><span class="line">      test = new Node(0);</span><br><span class="line">      test.next = new Node(1);</span><br><span class="line">      test.next.next = new Node(2);</span><br><span class="line">      test.next.next.next = new Node(3);</span><br><span class="line">      test.next.next.next.next = new Node(4);</span><br><span class="line">      test.next.next.next.next.next = new Node(5);</span><br><span class="line">      test.next.next.next.next.next.next = new Node(6);</span><br><span class="line">      test.next.next.next.next.next.next.next = new Node(7);</span><br><span class="line">      test.next.next.next.next.next.next.next.next = new Node(8);</span><br><span class="line"></span><br><span class="line">      Node ans1 = null;</span><br><span class="line">      Node ans2 = null;</span><br><span class="line"></span><br><span class="line">      ans1 = midOrUpMidNode(test);</span><br><span class="line">      ans2 = right1(test);</span><br><span class="line">      System.out.println(ans1 != null ? ans1.value : &quot;无&quot;);</span><br><span class="line">      System.out.println(ans2 != null ? ans2.value : &quot;无&quot;);</span><br><span class="line"></span><br><span class="line">      ans1 = midOrDownMidNode(test);</span><br><span class="line">      ans2 = right2(test);</span><br><span class="line">      System.out.println(ans1 != null ? ans1.value : &quot;无&quot;);</span><br><span class="line">      System.out.println(ans2 != null ? ans2.value : &quot;无&quot;);</span><br><span class="line"></span><br><span class="line">      ans1 = midOrUpMidPreNode(test);</span><br><span class="line">      ans2 = right3(test);</span><br><span class="line">      System.out.println(ans1 != null ? ans1.value : &quot;无&quot;);</span><br><span class="line">      System.out.println(ans2 != null ? ans2.value : &quot;无&quot;);</span><br><span class="line"></span><br><span class="line">      ans1 = midOrDownMidPreNode(test);</span><br><span class="line">      ans2 = right4(test);</span><br><span class="line">      System.out.println(ans1 != null ? ans1.value : &quot;无&quot;);</span><br><span class="line">      System.out.println(ans2 != null ? ans2.value : &quot;无&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表是否回文"><a href="#链表是否回文" class="headerlink" title="链表是否回文"></a>链表是否回文</h3><p>题目：给定一个单链表头结点head,请判断该链表是否为回文结构</p>
<ul>
<li>栈方法特别简单—笔试用</li>
<li>改原链表的方法就需要注意边界—面试用</li>
</ul>
<p>解法：</p>
<ul>
<li>解法1：把链表所有节点放进栈中，然后逐一出栈(相当于逆序)和链表逐一比对</li>
<li>解法2：利用快慢指针，找到中点或上中点。中点以后的节点全部入栈，然后逐一出栈(相当于逆序)和链表逐一比对，直到栈空为止。可以想象成纸对折逐一比对。</li>
<li>解法3：不使用额外空间，利用快慢指针，找到中点或上中点。中点以后的节点全部逆序指向，定义左右两个指针，逐一比较。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class Code02_IsPalindromeList &#123;</span><br><span class="line">   public static class Node &#123;</span><br><span class="line">      public int value;</span><br><span class="line">      public Node next;</span><br><span class="line">      public Node(int data) &#123;</span><br><span class="line">         this.value = data;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法1：把链表所有节点放进栈中，然后逐一出栈(相当于逆序)和链表逐一比对</span><br><span class="line">   public static boolean isPalindrome1(Node head) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">      Node cur = head;</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      while (head != null) &#123;</span><br><span class="line">         if (head.value != stack.pop().value) &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法2：利用快慢指针，找到中点或上中点。中点以后的节点全部入栈，然后逐一出栈(相当于逆序)和链表逐一比对，直到栈空为止。可以想象成纸对折逐一比对。</span><br><span class="line">   public static boolean isPalindrome2(Node head) &#123;</span><br><span class="line">      if (head == null || head.next == null) &#123;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      Node right = head.next;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      while (cur.next != null &amp;&amp; cur.next.next != null) &#123;</span><br><span class="line">         right = right.next;</span><br><span class="line">         cur = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">      while (right != null) &#123;</span><br><span class="line">         stack.push(right);</span><br><span class="line">         right = right.next;</span><br><span class="line">      &#125;</span><br><span class="line">      while (!stack.isEmpty()) &#123;</span><br><span class="line">         if (head.value != stack.pop().value) &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法3：不使用额外空间，利用快慢指针，找到中点或上中点。中点以后的节点全部逆序指向，定义左右两个指针，逐一比较。</span><br><span class="line">   public static boolean isPalindrome3(Node head) &#123;</span><br><span class="line">      /*</span><br><span class="line">      * 1-&gt;2-&gt;3-&gt;-&gt;3-&gt;2-&gt;1</span><br><span class="line">      *    null</span><br><span class="line">      *     ^</span><br><span class="line">      *      |</span><br><span class="line">      * 1-&gt;2-3&lt;&lt;-3&lt;-2&lt;-1</span><br><span class="line">      * n2             n1 n3</span><br><span class="line">      * */</span><br><span class="line">      if (head == null || head.next == null) &#123;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      Node n1 = head;// 慢指针</span><br><span class="line">      Node n2 = head;// 快指针</span><br><span class="line">      while (n2.next != null &amp;&amp; n2.next.next != null) &#123; // find mid node</span><br><span class="line">         n1 = n1.next; // n1 -&gt; mid</span><br><span class="line">         n2 = n2.next.next; // n2 -&gt; end</span><br><span class="line">      &#125;</span><br><span class="line">      // n1 中点</span><br><span class="line">      // 把n1以后的节点全部逆序指向</span><br><span class="line">      n2 = n1.next; // n2 -&gt; right part first node</span><br><span class="line">      n1.next = null; // mid.next -&gt; null</span><br><span class="line">      Node n3 = null;</span><br><span class="line">      while (n2 != null) &#123; // right part convert</span><br><span class="line">         n3 = n2.next; // n3 -&gt; save next node</span><br><span class="line">         n2.next = n1; // next of right node convert</span><br><span class="line">         n1 = n2; // n1 move</span><br><span class="line">         n2 = n3; // n2 move</span><br><span class="line">      &#125;</span><br><span class="line">      // 临时记录下右节点</span><br><span class="line">      n3 = n1; // n3 -&gt; save last node</span><br><span class="line">      n2 = head;// n2 -&gt; left first node</span><br><span class="line">      boolean res = true;</span><br><span class="line">      // 比较左右节点是否相等</span><br><span class="line">      while (n1 != null &amp;&amp; n2 != null) &#123; // check palindrome</span><br><span class="line">         if (n1.value != n2.value) &#123;</span><br><span class="line">            res = false;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">         n1 = n1.next; // left to mid</span><br><span class="line">         n2 = n2.next; // right to mid</span><br><span class="line">      &#125;</span><br><span class="line">      // 将n3-...&gt;n1指向逆序还原回来</span><br><span class="line">      n1 = n3.next;</span><br><span class="line">      n3.next = null;</span><br><span class="line">      while (n1 != null) &#123; // recover list</span><br><span class="line">         n2 = n1.next;</span><br><span class="line">         n1.next = n3;</span><br><span class="line">         n3 = n1;</span><br><span class="line">         n1 = n2;</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void printLinkedList(Node node) &#123;</span><br><span class="line">      System.out.print(&quot;Linked List: &quot;);</span><br><span class="line">      while (node != null) &#123;</span><br><span class="line">         System.out.print(node.value + &quot; &quot;);</span><br><span class="line">         node = node.next;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Node head = null;</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      head.next.next = new Node(3);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      head.next.next = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      head.next.next = new Node(3);</span><br><span class="line">      head.next.next.next = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      head.next.next = new Node(2);</span><br><span class="line">      head.next.next.next = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line"></span><br><span class="line">      head = new Node(1);</span><br><span class="line">      head.next = new Node(2);</span><br><span class="line">      head.next.next = new Node(3);</span><br><span class="line">      head.next.next.next = new Node(2);</span><br><span class="line">      head.next.next.next.next = new Node(1);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.print(isPalindrome1(head) + &quot; | &quot;);</span><br><span class="line">      System.out.print(isPalindrome2(head) + &quot; | &quot;);</span><br><span class="line">      System.out.println(isPalindrome3(head) + &quot; | &quot;);</span><br><span class="line">      printLinkedList(head);</span><br><span class="line">      System.out.println(&quot;=========================&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表的复制"><a href="#链表的复制" class="headerlink" title="链表的复制"></a>链表的复制</h3><p>题目：一种特殊的单链表结构，其中有个Node rand随机属性。rand可能指向任意节点，也可能指向null.请设计一个函数完成这个链表的复制，返回复制的链表的头结点。</p>
<ul>
<li>解法1：把所有节点放入hashmap,从头结点开始遍历，依次copy出新链表</li>
<li>解法2：在每个节点后面插入前一个节点的copy节点，然后设置radom，再分离新老节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">// 测试链接 : https://leetcode.com/problems/copy-list-with-random-pointer/</span><br><span class="line">public class Code04_CopyListWithRandom &#123;</span><br><span class="line"> public static class Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node next;</span><br><span class="line">  Node random;</span><br><span class="line"></span><br><span class="line">  public Node(int val) &#123;</span><br><span class="line">   this.val = val;</span><br><span class="line">   this.next = null;</span><br><span class="line">   this.random = null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 解法1：把所有节点放入hashmap,从头结点开始遍历，依次copy出新链表</span><br><span class="line"> public static Node copyRandomList1(Node head) &#123;</span><br><span class="line">  // key 老节点</span><br><span class="line">  // value 新节点</span><br><span class="line">  HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">  Node cur = head;</span><br><span class="line">  // 所有节点放入hashmap</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">   map.put(cur, new Node(cur.val));</span><br><span class="line">   cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = head;</span><br><span class="line">  // 从头结点开始遍历，依次copy</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">   // cur 老节点</span><br><span class="line">   // map.get(cur) 新节点</span><br><span class="line">   // 新.next -&gt;  cur.next克隆节点找到</span><br><span class="line">   map.get(cur).next = map.get(cur.next);</span><br><span class="line">   map.get(cur).random = map.get(cur.random);</span><br><span class="line">   cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return map.get(head);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 解法2：在每个节点后面插入前一个节点的copy节点，然后设置radom，再分离新老节点</span><br><span class="line"> public static Node copyRandomList2(Node head) &#123;</span><br><span class="line">  if (head == null) &#123;</span><br><span class="line">   return null;</span><br><span class="line">  &#125;</span><br><span class="line">  Node cur = head;</span><br><span class="line">  Node next = null;</span><br><span class="line">  // 1 -&gt; 2 -&gt; 3 -&gt; null</span><br><span class="line">  // 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27;</span><br><span class="line">  // 每个节点后面插入前一个节点的copy节点</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">   next = cur.next;</span><br><span class="line">   cur.next = new Node(cur.val);</span><br><span class="line">   cur.next.next = next;</span><br><span class="line">   cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = head;</span><br><span class="line">  Node copy = null;</span><br><span class="line">  // 1 1&#x27; 2 2&#x27; 3 3&#x27;， 其中1‘是1的复制节点</span><br><span class="line">  // 依次设置 1&#x27; 2&#x27; 3&#x27; 的random指针</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">   next = cur.next.next;</span><br><span class="line">   copy = cur.next;</span><br><span class="line">   // 注意cur.random的节点 一定是对应cur.random.next。因为下一个节点是当前节点的复制。</span><br><span class="line">   copy.random = cur.random != null ? cur.random.next : null;</span><br><span class="line">   cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  Node res = head.next;</span><br><span class="line">  cur = head;</span><br><span class="line">  // 老 新 混在一起，next方向上，random正确</span><br><span class="line">  // next方向上，把新老链表分离，一定动手实际画图，想是想不清楚的</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">   next = cur.next.next;</span><br><span class="line">   copy = cur.next;</span><br><span class="line">   cur.next = next;</span><br><span class="line">   copy.next = next != null ? next.next : null;</span><br><span class="line">   cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两链表是否相交"><a href="#两链表是否相交" class="headerlink" title="两链表是否相交"></a>两链表是否相交</h3><p>题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实 现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返 回null。要求时间复杂度O(N),空间复杂度O(1)</p>
<p>思路：这是一个超大题目。涉及知识点：</p>
<ul>
<li>必考知识点：找到链表第一个入环节点，如果无环，返回null</li>
<li>必考知识点：如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</li>
<li>必考知识点：两个有环链表，返回第一个相交节点，如果不想交返回null</li>
</ul>
<p>解法：</p>
<ul>
<li>解法：先求链表的入环节点，然后按照无环和有环分情况讨论</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_FindFirstIntersectNode</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">      <span class="keyword">public</span> Node next;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = data;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">      <span class="comment">// 解法：先求链表的入环节点，然后按照无环和有环分情况讨论</span></span><br><span class="line">      <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">loop1</span> <span class="operator">=</span> getLoopNode(head1);</span><br><span class="line">      <span class="type">Node</span> <span class="variable">loop2</span> <span class="operator">=</span> getLoopNode(head2);</span><br><span class="line">      <span class="comment">// 如果两个链表都是无环链表</span></span><br><span class="line">      <span class="keyword">if</span> (loop1 == <span class="literal">null</span> &amp;&amp; loop2 == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果两个链表都是有环链表</span></span><br><span class="line">      <span class="keyword">if</span> (loop1 != <span class="literal">null</span> &amp;&amp; loop2 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一链表有环，一链表无环，一定不会相交。画画图就知道了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 必考知识点：找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 解法1：用额外空间，遍历链表，每到一个节点就判断是否在Set里，如果突然发现在了。说明是第一个入环节点。</span></span><br><span class="line"><span class="comment">      * 解法2：快慢指针，慢指针一定不会走够两圈以上，在环内相遇时，将快指针放到开头，慢指针原地不动。然后两个开始一次走一步，最后会在入环节点相遇。本文采用解法2.</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// n1 慢指针  n2 快指针，让n1,n2都先走一次，方便下面的while判断</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">      <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">         <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         fast = fast.next.next;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到这里，说明slow fast  相遇了</span></span><br><span class="line">      <span class="comment">// 抖机灵做法：快指针回到头结点，然后快慢指针再次相遇，就是入环节点</span></span><br><span class="line">      fast = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">      <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">         slow = slow.next;</span><br><span class="line">         fast = fast.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> slow;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 必考知识点：如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 先统计head1到end1并且记住长度假设是100，然后统计head2和end2并且记住长度假设是80。如果end1！=end2则没有相交部分。</span></span><br><span class="line"><span class="comment">      * 如果一样，则head1先走20步，然后一起走直到找到相同内存的节点，即相交节点。可以通过n记录链表一和二的长度之差，节约一个变量。</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">         n++;</span><br><span class="line">         cur1 = cur1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">         n--;</span><br><span class="line">         cur2 = cur2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 因为是无环链表，如果最后的节点都不相同，结果一定是不相交，后续不用执行</span></span><br><span class="line">      <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// n 表示链表1长度减去链表2长度的值</span></span><br><span class="line">      cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">      cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">      n = Math.abs(n);</span><br><span class="line">      <span class="comment">// 长链表减去多余的部分，然后一起往下走</span></span><br><span class="line">      <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">         n--;</span><br><span class="line">         cur1 = cur1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果相遇，则是相交点</span></span><br><span class="line">      <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">         cur1 = cur1.next;</span><br><span class="line">         cur2 = cur2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cur1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 必考知识点：两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 情况1：如果有入环节点相同</span></span><br><span class="line"><span class="comment">      * 情况2:如果有入环点不同，可能有两个入环点</span></span><br><span class="line"><span class="comment">      * 情况3：如果有入环点不同，可能不相交</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 情况1：和前面的无环链表判断类似，只不过节点找到入环节点就可以，也没有入环节点的判断</span></span><br><span class="line">      <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">         cur1 = head1;</span><br><span class="line">         cur2 = head2;</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">         &#125;</span><br><span class="line">         cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">         cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">         n = Math.abs(n);</span><br><span class="line">         <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cur1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 情况2</span></span><br><span class="line">         cur1 = loop1.next;</span><br><span class="line">         <span class="comment">// 链表1从自己的入环点开始遍历一圈，找下是否有节点和链表2的入环点相同，相同即返回节点</span></span><br><span class="line">         <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">               <span class="keyword">return</span> loop1;<span class="comment">// 或返回loop2都行，因为有2个入环点，随便一个都可以</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//情况3</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">      head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">      head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">      head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">      head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">      head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">      head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">head2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">      head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">      head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">      head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">      System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">      head1 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">      head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">      head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">      head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">      head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">      head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">      head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">      head1.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">      head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">      head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">      head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">      head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">      System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">      head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">      head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">      head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">      head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">      System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不给头结点删除节点"><a href="#不给头结点删除节点" class="headerlink" title="不给头结点删除节点"></a>不给头结点删除节点</h3><p>题目：能不能不给单链表的头结点，只给想要删除的节点，就能做到在链表上把这个点删除掉？</p>
<p>解法：抖机灵的做法，把删除节点的下一个节点复制到当前节点，删除下一个节点。</p>
<p>弊端：无法删除链表最后一个节点；因为是复制节点，如果节点表示服务器，那就不可能这么操作。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ul>
<li>先序遍历：对于所有子树，先访问头结点-左节点-右节点</li>
<li>中序遍历：对于所有子树，先访问左结点-头节点-右节点</li>
<li>后序遍历：对于所有子树，先访问左结点-右节点-头节点</li>
</ul>
<p>题目：二叉树节点结构 第一层1 第二层2 3 第三层 4 5 6 7。</p>
<p><strong>递归遍历</strong></p>
<p>递归序：1，2，4，4，4，5，5，5，2，1，3，6，6，6，3，7，7，7，3，1 相当于第一次到自己的时候输出一下，然后左子树走完后输出一下，右子树走完后输出一下。这是递归实现，所有的递归都可以用非递归替代。</p>
<p>先序遍历（头左右）：1，2，4，5，3，6，7 相当于递归序里第一次来到的时候打印，第二三次到的时候什么也不做</p>
<p>中序遍历（左头右）：4，2，5，1，6，3，7 相当于递归序里第二次来到的时候打印，第一三次到的时候什么也不做</p>
<p>后序遍历（左右头）：4，2，5，1，6，3，7 相当于递归序里第三次来到的时候打印，第一二次到的时候什么也不做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 传统二叉树递归遍历</span><br><span class="line">public static void pre(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;先序遍历&quot; + head.value);</span><br><span class="line">    pre(head.left);</span><br><span class="line">    System.out.println(&quot;中序遍历&quot; + head.value);</span><br><span class="line">    pre(head.right);</span><br><span class="line">    System.out.println(&quot;后序遍历&quot; + head.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归序遍历</span><br><span class="line">public static void f(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1-第1次到达</span><br><span class="line">    f(head.left);</span><br><span class="line">    // 2-第2次到达</span><br><span class="line">    f(head.right);</span><br><span class="line">    // 3-第2次到达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class Code03_UnRecursiveTraversalBT &#123;</span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public int value;</span><br><span class="line">        public Node left;</span><br><span class="line">        public Node right;</span><br><span class="line">        public Node(int v) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先序遍历</span><br><span class="line">    /*用栈实现：因为栈的特性是先进后出，右比左先压入，所以先打印左然后右</span><br><span class="line">     * 1.栈压入头结点</span><br><span class="line">     * 2.栈弹出节点，打印</span><br><span class="line">     * 3.如果右节点存在，压入右节点</span><br><span class="line">     * 4.如果左节点存在，压入左节点</span><br><span class="line">     * 5.循环2,3,4</span><br><span class="line">     * */</span><br><span class="line">    public static void pre(Node head) &#123;</span><br><span class="line">        System.out.print(&quot;pre-order: &quot;);</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">            stack.add(head);</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + &quot; &quot;);</span><br><span class="line">                if (head.right != null) &#123;</span><br><span class="line">                    stack.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                if (head.left != null) &#123;</span><br><span class="line">                    stack.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    /*用栈实现：因为栈的特性是先进后出，右比左先压入，所以先打印左然后右</span><br><span class="line">     * 1.初始化当前cur为头结点</span><br><span class="line">     * 2.从cur出发，依次压入所有左节点。直到为null.</span><br><span class="line">     * 3.栈弹出节点，打印</span><br><span class="line">     * 4.cur来到cur的右节点</span><br><span class="line">     * 5.循环2,3,4</span><br><span class="line">     * */</span><br><span class="line">    public static void in(Node cur) &#123;</span><br><span class="line">        System.out.print(&quot;in-order: &quot;);</span><br><span class="line">        if (cur != null) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">            while (!stack.isEmpty() || cur != null) &#123;</span><br><span class="line">                if (cur != null) &#123;</span><br><span class="line">                    // 第2步</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 第3,4步</span><br><span class="line">                    cur = stack.pop();</span><br><span class="line">                    System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 后续遍历：解法1</span><br><span class="line">    /*用栈实现：准备2个栈。因为栈的特性是先进后出，初步得到是头-右-左。直接利用栈s2逆序弹出就是左右头。</span><br><span class="line">     * 1.栈压入头结点</span><br><span class="line">     * 2.栈弹出节点，打印</span><br><span class="line">     * 3.如果左节点存在，压入左节点</span><br><span class="line">     * 4.如果右节点存在，压入右节点</span><br><span class="line">     * 5.循环2,3,4</span><br><span class="line">     * */</span><br><span class="line">    public static void pos1(Node head) &#123;</span><br><span class="line">        System.out.print(&quot;pos-order: &quot;);</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();</span><br><span class="line">            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();</span><br><span class="line">            s1.push(head);</span><br><span class="line">            while (!s1.isEmpty()) &#123;</span><br><span class="line">                head = s1.pop(); // 头 右 左</span><br><span class="line">                s2.push(head);</span><br><span class="line">                if (head.left != null) &#123;</span><br><span class="line">                    s1.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (head.right != null) &#123;</span><br><span class="line">                    s1.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 左 右 头</span><br><span class="line">            while (!s2.isEmpty()) &#123;</span><br><span class="line">                System.out.print(s2.pop().value + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 后续遍历：解法2，很难想到这种思路</span><br><span class="line">    /*思路：</span><br><span class="line">     * 先看栈顶元素有无左孩子，有就入栈，这里完成左边界入栈。</span><br><span class="line">     * 然后从栈顶peek，如果该节点没有左右孩子，则pop掉并打印，并且将该元素赋给变量h，再peek栈顶元素，这个节点因为是h的父元素，所以看有没有右孩子，如果有，将右孩子压入栈。</span><br><span class="line">     * 将该节点右孩子处理完后，此节点被pop，以此类推。</span><br><span class="line">     * */</span><br><span class="line">    public static void pos2(Node h) &#123;</span><br><span class="line">        System.out.print(&quot;pos-order: &quot;);</span><br><span class="line">        if (h != null) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">            stack.push(h);</span><br><span class="line">            Node c = null;</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                c = stack.peek();</span><br><span class="line">                if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">                    // 先压入所有左节点</span><br><span class="line">                    stack.push(c.left);</span><br><span class="line">                &#125; else if (c.right != null &amp;&amp; h != c.right) &#123;</span><br><span class="line">                    // 然后压入右节点</span><br><span class="line">                    stack.push(c.right);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 先处理左树，然后处理右树，再处理头节点</span><br><span class="line">                    System.out.print(stack.pop().value + &quot; &quot;);</span><br><span class="line">                    h = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node head = new Node(1);</span><br><span class="line">        head.left = new Node(2);</span><br><span class="line">        head.right = new Node(3);</span><br><span class="line">        head.left.left = new Node(4);</span><br><span class="line">        head.left.right = new Node(5);</span><br><span class="line">        head.right.left = new Node(6);</span><br><span class="line">        head.right.right = new Node(7);</span><br><span class="line">        pre(head);</span><br><span class="line">        System.out.println(&quot;========&quot;);</span><br><span class="line">        in(head);</span><br><span class="line">        System.out.println(&quot;========&quot;);</span><br><span class="line">        pos1(head);</span><br><span class="line">        System.out.println(&quot;========&quot;);</span><br><span class="line">        pos2(head);</span><br><span class="line">        System.out.println(&quot;========&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树宽度优先遍历"><a href="#二叉树宽度优先遍历" class="headerlink" title="二叉树宽度优先遍历"></a>二叉树宽度优先遍历</h2><p>本质就是按照层遍历，用队列实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树宽度优先遍历，利用队列实现</span><br><span class="line">public static void level(Node head) &#123;</span><br><span class="line">   if (head == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">   // 头结点入队列</span><br><span class="line">   queue.add(head);</span><br><span class="line">   while (!queue.isEmpty()) &#123;</span><br><span class="line">      // 节点先出队列</span><br><span class="line">      Node cur = queue.poll();</span><br><span class="line">      System.out.println(cur.value);</span><br><span class="line">      // 如果有左子节点，加入队列</span><br><span class="line">      if (cur.left != null) &#123;</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果有右子节点，加入队列。循环上面操作</span><br><span class="line">      if (cur.right != null) &#123;</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><p>题目：求每一层二叉树中最大宽度的层的宽度</p>
<ul>
<li>解法1，利用map记录node来到的层数，方便遍历完一层后，才开始比较大小</li>
<li>解法2，不使用map,通过设置flag变量的方式，来发现某一层的结束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树的最大宽度：解法1，利用map记录node来到的层数，方便遍历完一层后，才开始比较大小</span><br><span class="line">public static int maxWidthUseMap(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    // key 在 哪一层，value,</span><br><span class="line">    HashMap&lt;Node, Integer&gt; levelMap = new HashMap&lt;&gt;();</span><br><span class="line">    // 头结点在第1层，从第1层开始</span><br><span class="line">    levelMap.put(head, 1);</span><br><span class="line">    int curLevel = 1; // 当前你正在统计哪一层的宽度</span><br><span class="line">    int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少</span><br><span class="line">    // 最大宽度</span><br><span class="line">    int max = 0;</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        int curNodeLevel = levelMap.get(cur);</span><br><span class="line">        // 利用队列进行宽度优先遍历</span><br><span class="line">        if (cur.left != null) &#123;</span><br><span class="line">            // 记录节点层数</span><br><span class="line">            levelMap.put(cur.left, curNodeLevel + 1);</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur.right != null) &#123;</span><br><span class="line">            // 记录节点层数</span><br><span class="line">            levelMap.put(cur.right, curNodeLevel + 1);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curNodeLevel == curLevel) &#123;</span><br><span class="line">            // 当前节点还在当前记录的层数上，宽度+1</span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 当前节点的层数不是当前记录的层数，那么一定是来到了下一层，可以小结比较了</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            // 记录的层数+1，已经来到新的下一层</span><br><span class="line">            curLevel++;</span><br><span class="line">            // 已经来到下新的下一层，宽度记录为1</span><br><span class="line">            curLevelNodes = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后比较全局最大宽度和最后一层的宽度</span><br><span class="line">    max = Math.max(max, curLevelNodes);</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二叉树的最大宽度：解法2，不使用map,通过设置flag变量的方式，来发现某一层的结束</span><br><span class="line">public static int maxWidthNoMap(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    Node curEnd = head; // 当前层，最右节点是谁</span><br><span class="line">    Node nextEnd = null; // 下一层，最右节点是谁</span><br><span class="line">    int max = 0;</span><br><span class="line">    int curLevelNodes = 0; // 当前层的节点数</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        // 常规的宽度优先遍历</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        if (cur.left != null) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            // 在当前层，就已经拿到下一层的最右一个节点</span><br><span class="line">            nextEnd = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur.right != null) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            nextEnd = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前层宽度++</span><br><span class="line">        curLevelNodes++;</span><br><span class="line">        // 当前节点来到当前层的最右节点时</span><br><span class="line">        if (cur == curEnd) &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            // 下一层马上要变成当前层了</span><br><span class="line">            // 初始化下一层的宽度为0</span><br><span class="line">            curLevelNodes = 0;</span><br><span class="line">            // 把当前层的最右节点更新为下一层的最右节点，继续循环</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p>内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树。</p>
<p>思路：先序列化，将一棵树遍历（先序遍历），然后空就用#代替，存储成一个字符串。然后反序列化就是用一个队列将字符串拆成值并一一压入，再递归构建树。不是很难，<strong>用什么逻辑序列化就是相同逻辑反序列化</strong>。</p>
<ul>
<li>按照先序遍历的逻辑，序列化和反序列化</li>
<li>按照宽度优先遍历逻辑，序列化和反序列化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，</span><br><span class="line"> * 以下代码全部实现了。</span><br><span class="line"> * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化</span><br><span class="line"> * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。</span><br><span class="line"> * 比如如下两棵树</span><br><span class="line"> *         __2</span><br><span class="line"> *        /</span><br><span class="line"> *       1</span><br><span class="line"> *       和</span><br><span class="line"> *       1__</span><br><span class="line"> *          \</span><br><span class="line"> *           2</span><br><span class="line"> * 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;</span><br><span class="line"> *</span><br><span class="line"> * */</span><br><span class="line">  // 序列化：先序遍历，在遍历的时候，序列节点</span><br><span class="line">    public static Queue&lt;String&gt; preSerial(Node head) &#123;</span><br><span class="line">        Queue&lt;String&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">        pres(head, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void pres(Node head, Queue&lt;String&gt; ans) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            // 空需要补空，序列化空</span><br><span class="line">            ans.add(null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 先序遍历，先加入到队列中，序列化节点</span><br><span class="line">            ans.add(String.valueOf(head.value));</span><br><span class="line">            pres(head.left, ans);</span><br><span class="line">            pres(head.right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     // 反序列化：按照先序遍历的逻辑，反向操作</span><br><span class="line">    public static Node buildByPreQueue(Queue&lt;String&gt; prelist) &#123;</span><br><span class="line">        if (prelist == null || prelist.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return preb(prelist);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Node preb(Queue&lt;String&gt; prelist) &#123;</span><br><span class="line">        // 和先序遍历的逻辑如出一辙</span><br><span class="line">        String value = prelist.poll();</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            // 空返回空节点，反序列化节点</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 反序列化的节点</span><br><span class="line">        Node head = new Node(Integer.valueOf(value));</span><br><span class="line">        // 反序列化的节点，补齐它的左子节点</span><br><span class="line">        head.left = preb(prelist);</span><br><span class="line">        // 反序列化的节点，补齐它的右子节点</span><br><span class="line">        head.right = preb(prelist);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        // 序列化：按照层遍历即宽度优先遍历，在遍历的时候，序列节点</span><br><span class="line">    public static Queue&lt;String&gt; levelSerial(Node head) &#123;</span><br><span class="line">        Queue&lt;String&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            // 空节点序列化补空</span><br><span class="line">            ans.add(null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 在遍历的时候，序列节点</span><br><span class="line">            ans.add(String.valueOf(head.value));</span><br><span class="line">            Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">            queue.add(head);</span><br><span class="line">            while (!queue.isEmpty()) &#123;</span><br><span class="line">                head = queue.poll(); // head 父   子</span><br><span class="line">                if (head.left != null) &#123;</span><br><span class="line">                    //  添加节点的时候，序列化</span><br><span class="line">                    ans.add(String.valueOf(head.left.value));</span><br><span class="line">                    queue.add(head.left);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 空节点也要序列化</span><br><span class="line">                    ans.add(null);</span><br><span class="line">                &#125;</span><br><span class="line">                if (head.right != null) &#123;</span><br><span class="line">                    ans.add(String.valueOf(head.right.value));</span><br><span class="line">                    queue.add(head.right);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ans.add(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化：按照宽度优先遍历，反向逻辑操作</span><br><span class="line">    public static Node buildByLevelQueue(Queue&lt;String&gt; levelList) &#123;</span><br><span class="line">        // 边界条件</span><br><span class="line">        if (levelList == null || levelList.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 先反序列生成头结点</span><br><span class="line">        Node head = generateNode(levelList.poll());</span><br><span class="line">        // 建立需要while遍历的队列</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            queue.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = null;</span><br><span class="line">        // 借助队列，遍历所有节点</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            // 弹出反序列化的节点</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            // 反序列化的节点的左子节点</span><br><span class="line">            node.left = generateNode(levelList.poll());</span><br><span class="line">            // 反序列化的节点的右子节点</span><br><span class="line">            node.right = generateNode(levelList.poll());</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                // 不为空的节点，要加入到循环队列，方便后面继续宽度优先遍历</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 节点生成函数</span><br><span class="line">    public static Node generateNode(String val) &#123;</span><br><span class="line">        if (val == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Node(Integer.valueOf(val));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树任意节点的后继节点"><a href="#二叉树任意节点的后继节点" class="headerlink" title="二叉树任意节点的后继节点"></a>二叉树任意节点的后继节点</h2><p>题目：给你二叉树中的某个节点，返回该节点的后继节点</p>
<p>后继节点定义：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点。前驱结点：也是相对于中序遍历而言的。一个节点的前一个节点。</p>
<p><strong>中序遍历：对于每个节点，都按照左头右访问。</strong></p>
<ul>
<li>解法1：先中序遍历然后存入一个List,然后再遍历找到当前节点的下一个节点，但是时间复杂度是O(N)</li>
<li>解法2：要求时间复杂度为O(K)，其中K为两个节点的距离</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Code06_SuccessorNode &#123;</span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public int value;</span><br><span class="line">        public Node left;</span><br><span class="line">        public Node right;</span><br><span class="line">        public Node parent;</span><br><span class="line"></span><br><span class="line">        public Node(int data) &#123;</span><br><span class="line">            this.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Node getSuccessorNode(Node node) &#123;</span><br><span class="line">        // 解法2：返回后继节点，利用中序遍历中后继节点的特性</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null) &#123;</span><br><span class="line">            // 如果该节点有右孩子，那么右子树的最左节点就是后继节点。</span><br><span class="line">            return getLeftMost(node.right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果该节点无右孩子，那么它的后继节点一定是往上找父节点，直到节点是其父节点的左孩子，返回。因为左头</span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            // 父节点不能为null,null表示到根节点了。同时只要当前节点是其父节点的右孩子，循环继续。直到节点是其父节点的左孩子，跳出循环。</span><br><span class="line">            while (parent != null &amp;&amp; parent.right == node) &#123; // 当前节点是其父亲节点右孩子</span><br><span class="line">                // 更新当前节点</span><br><span class="line">                node = parent;</span><br><span class="line">                // 取出当前节点的父节点</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回那个节点是其父节点的左孩子的节点，就是后继节点</span><br><span class="line">            return parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回该节点的最左节点</span><br><span class="line">    public static Node getLeftMost(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        // 只要节点的左节点不为空，就循环找，直到该节点的左节点为空。返回该节点</span><br><span class="line">        while (node.left != null) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node head = new Node(6);</span><br><span class="line">        head.parent = null;</span><br><span class="line">        head.left = new Node(3);</span><br><span class="line">        head.left.parent = head;</span><br><span class="line">        head.left.left = new Node(1);</span><br><span class="line">        head.left.left.parent = head.left;</span><br><span class="line">        head.left.left.right = new Node(2);</span><br><span class="line">        head.left.left.right.parent = head.left.left;</span><br><span class="line">        head.left.right = new Node(4);</span><br><span class="line">        head.left.right.parent = head.left;</span><br><span class="line">        head.left.right.right = new Node(5);</span><br><span class="line">        head.left.right.right.parent = head.left.right;</span><br><span class="line">        head.right = new Node(9);</span><br><span class="line">        head.right.parent = head;</span><br><span class="line">        head.right.left = new Node(8);</span><br><span class="line">        head.right.left.parent = head.right;</span><br><span class="line">        head.right.left.left = new Node(7);</span><br><span class="line">        head.right.left.left.parent = head.right.left;</span><br><span class="line">        head.right.right = new Node(10);</span><br><span class="line">        head.right.right.parent = head.right;</span><br><span class="line"></span><br><span class="line">        Node test = head.left.left;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.left.left.right;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.left;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.left.right;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.left.right.right;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.right.left.left;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.right.left;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.right;</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test).value);</span><br><span class="line">        test = head.right.right; // 10&#x27;s next is null</span><br><span class="line">        System.out.println(test.value + &quot; next: &quot; + getSuccessorNode(test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后 展开。<br>此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。<br>如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从 上到下依次是下折痕、下折痕和上折痕。<br>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。<br>请从上到下打印所有折痕的方向。<br>例如:N=1时，打印: down N=2时，打印: down down up<br>思路：试验一下会发现，每次折完之后，会在每个上一次出现的痕迹处上面出现一个凹痕下面出现一个凸痕，其实可以理解为树，这个数根节点是凹痕，然后所有左子树的根节点都是凹痕，所有右子树的根节点都是凸痕。然后通过中序遍历递归去实现打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Code07_PaperFolding &#123;</span><br><span class="line">    public static void printAllFolds(int N) &#123;</span><br><span class="line">        process(1, N, true);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前你来了一个节点，脑海中想象的！</span><br><span class="line">    // 这个节点在第i层，一共有N层，N固定不变的</span><br><span class="line">    // 这个节点如果是凹的话，down = T</span><br><span class="line">    // 这个节点如果是凸的话，down = F</span><br><span class="line">    // 函数的功能：中序打印以你想象的节点为头的整棵树！</span><br><span class="line">    public static void process(int i, int N, boolean down) &#123;</span><br><span class="line">        if (i &gt; N) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        process(i + 1, N, true);</span><br><span class="line">        // 这里打印，本质就是用递归模拟中序遍历</span><br><span class="line">        System.out.print(down ? &quot;凹 &quot; : &quot;凸 &quot;);</span><br><span class="line">        process(i + 1, N, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 4;</span><br><span class="line">        printAllFolds(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树递归套路"><a href="#二叉树递归套路" class="headerlink" title="二叉树递归套路"></a>二叉树递归套路</h2><p>本质利用递归遍历二叉树的便利性。</p>
<ol>
<li>假设以X节点为头，假设可以向X左子树和X右子树获取任何信息</li>
<li>在上一步的假设下，套路以X为头结点的树，得到答案的可能性。(最重要)</li>
<li>列出所有可能性后，确定到底需要向左树和右树获取什么样的信息</li>
<li>把左树信息和右树信息整合，就是任何一棵子树需要返回的信息S</li>
<li>递归函数都返回S,每棵子树都这么要求</li>
<li>写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</li>
</ol>
<h3 id="套路实践-判断平衡二叉树"><a href="#套路实践-判断平衡二叉树" class="headerlink" title="套路实践-判断平衡二叉树"></a><strong>套路实践-判断平衡二叉树</strong></h3><p>题目：给定一棵二叉树的头结点head,返回这棵树是否为平衡二叉树ALV.</p>
<p>ALV平衡二叉树定义：必须是二叉搜索树；每个节点的左子树和右子树的高度差至多为1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isBalanced2(Node head) &#123;</span><br><span class="line">    // 返回根节点的平衡性</span><br><span class="line">    return process(head).isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class Info &#123;</span><br><span class="line">    // 先组织定义任意节点的平衡性信息数据结构</span><br><span class="line">    // 该节点下，是否是平衡二叉树ALV</span><br><span class="line">    public boolean isBalanced;</span><br><span class="line">    // 该节点下，树的高度</span><br><span class="line">    public int height;</span><br><span class="line"></span><br><span class="line">    public Info(boolean i, int h) &#123;</span><br><span class="line">        isBalanced = i;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Info process(Node x) &#123;</span><br><span class="line">    // 返回任意节点的平衡性信息数据结构</span><br><span class="line">    // 叶子节点，一定是平衡二叉树ALV,且高度为0</span><br><span class="line">    if (x == null) &#123;</span><br><span class="line">        return new Info(true, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取左子树的平衡信息---套路步骤1</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    // 获取右子树的平衡信息---套路步骤1</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    // 当前节点的树的高度信息，就是取左右子树最大高度+1自己</span><br><span class="line">    int height = Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">    boolean isBalanced = true;</span><br><span class="line">    // ---套路步骤2</span><br><span class="line">    if (!leftInfo.isBalanced) &#123;</span><br><span class="line">        // 左子树不平衡，不是平衡树</span><br><span class="line">        isBalanced = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // ---套路步骤2</span><br><span class="line">    if (!rightInfo.isBalanced) &#123;</span><br><span class="line">        // 右子树不平衡，不是平衡树</span><br><span class="line">        isBalanced = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // ---套路步骤2</span><br><span class="line">    if (Math.abs(leftInfo.height - rightInfo.height) &gt; 1) &#123;</span><br><span class="line">        // 左右子树的高度差大于1，也不是平衡树</span><br><span class="line">        isBalanced = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-判断满二叉树"><a href="#套路实践-判断满二叉树" class="headerlink" title="套路实践-判断满二叉树"></a>套路实践-判断满二叉树</h3><ul>
<li>解法1：收集整棵树的高度h，和节点数n。满二叉树满足 : 2 ^ h - 1 == n</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 解法1：收集整棵树的高度h，和节点数n。满二叉树满足 : 2 ^ h - 1 == n</span><br><span class="line">public static boolean isFull1(Node head) &#123;</span><br><span class="line"> if (head == null) &#123;</span><br><span class="line">  return true;</span><br><span class="line"> &#125;</span><br><span class="line"> Info1 all = process1(head);</span><br><span class="line">   // 满二叉树：节点数=(2^height) - 1</span><br><span class="line"> return (1 &lt;&lt; all.height) - 1 == all.nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class Info1 &#123;</span><br><span class="line">   // 二叉树高度</span><br><span class="line"> public int height;</span><br><span class="line">   // 二叉树节点个数</span><br><span class="line"> public int nodes;</span><br><span class="line"></span><br><span class="line"> public Info1(int h, int n) &#123;</span><br><span class="line">  height = h;</span><br><span class="line">  nodes = n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Info1 process1(Node head) &#123;</span><br><span class="line"> if (head == null) &#123;</span><br><span class="line">  return new Info1(0, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> Info1 leftInfo = process1(head.left);</span><br><span class="line"> Info1 rightInfo = process1(head.right);</span><br><span class="line">   // 高度，取左右子树中最高的那个+1自己</span><br><span class="line"> int height = Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">   // 节点个数，同理</span><br><span class="line"> int nodes = leftInfo.nodes + rightInfo.nodes + 1;</span><br><span class="line"> return new Info1(height, nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-判断完全二叉树"><a href="#套路实践-判断完全二叉树" class="headerlink" title="套路实践-判断完全二叉树"></a>套路实践-判断完全二叉树</h3><p>完全二叉树：上面的层是满的，即使不满，那么一定是从左到右逐渐变满。</p>
<ul>
<li>解法1：利用宽度优先遍历，排除两种情况后，一定是满二叉树。</li>
<li>解法2：二叉树递归套路，完全二叉树有4种情况。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">// 测试链接 : https://leetcode.com/problems/check-completeness-of-a-binary-tree/</span><br><span class="line">public class Code01_IsCBT &#123;</span><br><span class="line">   // 不要提交这个类</span><br><span class="line">   public static class TreeNode &#123;</span><br><span class="line">      public int val;</span><br><span class="line">      public TreeNode left;</span><br><span class="line">      public TreeNode right;</span><br><span class="line">      public TreeNode(int v) &#123;</span><br><span class="line">         val = v;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  //解法1：利用宽度优先遍历，排除两种情况后，一定是满二叉树。</span><br><span class="line">   public static boolean isCompleteTree1(TreeNode head) &#123;</span><br><span class="line">      /*</span><br><span class="line">      * 情况a：无左孩子，有右孩子</span><br><span class="line">      * 情况b：遇到过节点的左右孩子不全的节点，且节点不是叶子节点。</span><br><span class="line">      * */</span><br><span class="line">      /* 具体分析：</span><br><span class="line">      * 对一个节点而言有四种可能：</span><br><span class="line">         1. 当前节点有两个孩子</span><br><span class="line">         2.当前节点有左孩子 没有右孩子</span><br><span class="line">         3，当前节点 没有左孩子  有 右孩子</span><br><span class="line">         4，当前节点 没有孩子</span><br><span class="line">         我们层次遍历每一个节点，若碰到3的情况 一定不是完全二叉树 ，直接返回，</span><br><span class="line">         当我们 第一次碰到：  2 或者 4 的情况的时候， 这意味着我们之后遍历的节点都必须是叶子，否则不是完全二叉树。</span><br><span class="line">         若程序能执行到结束， 返回 true；</span><br><span class="line">      * */</span><br><span class="line">      if (head == null) &#123;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">      // 是否遇到过左右两个孩子不双全的节点</span><br><span class="line">      boolean leaf = false;</span><br><span class="line">      TreeNode l = null;</span><br><span class="line">      TreeNode r = null;</span><br><span class="line">      queue.add(head);</span><br><span class="line">      // 基于队列的宽度优先遍历</span><br><span class="line">      while (!queue.isEmpty()) &#123;</span><br><span class="line">         head = queue.poll();</span><br><span class="line">         l = head.left;</span><br><span class="line">         r = head.right;</span><br><span class="line">         if (</span><br><span class="line">         // 情况a||情况b</span><br><span class="line">               (l == null &amp;&amp; r != null)||(leaf &amp;&amp; !(l == null || r == null))</span><br><span class="line"></span><br><span class="line">         ) &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         if (l != null) &#123;</span><br><span class="line">            queue.add(l);</span><br><span class="line">         &#125;</span><br><span class="line">         if (r != null) &#123;</span><br><span class="line">            queue.add(r);</span><br><span class="line">         &#125;</span><br><span class="line">         // 遇到了叶子节点，左右都没孩子，不双全，标记true</span><br><span class="line">         if (l == null || r == null) &#123;</span><br><span class="line">            leaf = true;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static boolean isCompleteTree2(TreeNode head) &#123;</span><br><span class="line">      return process(head).isCBT;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static class Info &#123;</span><br><span class="line">      // 节点的子树为满二叉树</span><br><span class="line">      public boolean isFull;</span><br><span class="line">      // 节点的子树为完全二叉树</span><br><span class="line">      public boolean isCBT;</span><br><span class="line">      // 节点的子树高度</span><br><span class="line">      public int height;</span><br><span class="line">      public Info(boolean full, boolean cbt, int h) &#123;</span><br><span class="line">         isFull = full;</span><br><span class="line">         isCBT = cbt;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法2：二叉树递归套路，完全二叉树有4种情况。</span><br><span class="line">   public static Info process(TreeNode x) &#123;</span><br><span class="line">      /*假设树有3层，</span><br><span class="line">          1         1       1          1</span><br><span class="line">         2    3     2  3    2   3     2   3</span><br><span class="line">       4  5  6 7   4       4  5     4  5 6</span><br><span class="line">      * 情况1：最后一层都满了，一定要求：左树是满树&amp;右树是满树&amp;左树高度=右树高度</span><br><span class="line">      * 情况2：最后一层只有1个节点，一定要求：左树是完全树&amp;右树是满树&amp;左树高度=右树高度+1</span><br><span class="line">      * 情况3：最后一层只有2个节点，一定要求：左树是满树&amp;右树是满树&amp;左树高度=右树高度+1</span><br><span class="line">      * 情况4：最后一层只有3个节点，一定要求：左树是满树&amp;右树是完全树&amp;左树高度=右树高度</span><br><span class="line">      * */</span><br><span class="line">      if (x == null) &#123;</span><br><span class="line">         return new Info(true, true, 0);</span><br><span class="line">      &#125;</span><br><span class="line">      Info leftInfo = process(x.left);</span><br><span class="line">      Info rightInfo = process(x.right);</span><br><span class="line">      int height = Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">      boolean isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;</span><br><span class="line">      boolean isCBT = false;</span><br><span class="line">      if (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height) &#123;</span><br><span class="line">         // 情况1</span><br><span class="line">         isCBT = true;</span><br><span class="line">      &#125; else if (leftInfo.isCBT &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + 1) &#123;</span><br><span class="line">         // 情况2</span><br><span class="line">         isCBT = true;</span><br><span class="line">      &#125; else if (leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height + 1) &#123;</span><br><span class="line">         // 情况3</span><br><span class="line">         isCBT = true;</span><br><span class="line">      &#125; else if (leftInfo.isFull &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;</span><br><span class="line">         // 情况4</span><br><span class="line">         isCBT = true;</span><br><span class="line">      &#125;</span><br><span class="line">      return new Info(isFull, isCBT, height);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // for test</span><br><span class="line">   public static TreeNode generateRandomBST(int maxLevel, int maxValue) &#123;</span><br><span class="line">      return generate(1, maxLevel, maxValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // for test</span><br><span class="line">   public static TreeNode generate(int level, int maxLevel, int maxValue) &#123;</span><br><span class="line">      if (level &gt; maxLevel || Math.random() &lt; 0.5) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode head = new TreeNode((int) (Math.random() * maxValue));</span><br><span class="line">      head.left = generate(level + 1, maxLevel, maxValue);</span><br><span class="line">      head.right = generate(level + 1, maxLevel, maxValue);</span><br><span class="line">      return head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int maxLevel = 5;</span><br><span class="line">      int maxValue = 100;</span><br><span class="line">      int testTimes = 1000000;</span><br><span class="line">      for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">         TreeNode head = generateRandomBST(maxLevel, maxValue);</span><br><span class="line">         if (isCompleteTree1(head) != isCompleteTree2(head)) &#123;</span><br><span class="line">            System.out.println(&quot;Oops!&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;finish!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-二叉树的最大距离"><a href="#套路实践-二叉树的最大距离" class="headerlink" title="套路实践-二叉树的最大距离"></a><strong>套路实践-二叉树的最大距离</strong></h3><p>题目：给定一棵二叉树的头结点head,任何两个节点之间都存在距离。返回整颗二叉树的最大距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static class Info &#123;</span><br><span class="line">    // 先组织节点的最远距离的信息数据结构</span><br><span class="line">    // 该节点作为树根节点的最大距离</span><br><span class="line">    public int maxDistance;</span><br><span class="line">    // 该节点作为树根节点的高度</span><br><span class="line">    public int height;</span><br><span class="line"></span><br><span class="line">    public Info(int m, int h) &#123;</span><br><span class="line">        maxDistance = m;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Info process(Node x) &#123;</span><br><span class="line">    // 如果空节点，则00</span><br><span class="line">    if (x == null) &#123;</span><br><span class="line">        return new Info(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // 左子树信息---套路步骤1</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    // 右子树信息---套路步骤1</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    // 节点的树高度</span><br><span class="line">    int height = Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">    // 节点下的最大距离</span><br><span class="line">    // 情况1：最大距离不经过x节点：左子树的最大距离 ---套路步骤2</span><br><span class="line">    int p1 = leftInfo.maxDistance;</span><br><span class="line">    // 情况2：最大距离不经过x节点：右子树的最大距离 ---套路步骤2</span><br><span class="line">    int p2 = rightInfo.maxDistance;</span><br><span class="line">    // 情况3：最大距离经过x节点：左子树+左子树的高度+1自己 ---套路步骤2</span><br><span class="line">    int p3 = leftInfo.height + rightInfo.height + 1;</span><br><span class="line">    // 节点的最大距离一定是情况123中的最大值，好好想想</span><br><span class="line">    int maxDistance = Math.max(Math.max(p1, p2), p3);</span><br><span class="line">    return new Info(maxDistance, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-二叉搜索子树头结点"><a href="#套路实践-二叉搜索子树头结点" class="headerlink" title="套路实践-二叉搜索子树头结点"></a>套路实践-二叉搜索子树头结点</h3><p>题目：给定一棵二叉树的头结点head,返回这颗二叉树中最大的二叉搜索子树的头结点。</p>
<p>思路：</p>
<blockquote>
<p>(1)最大二叉搜索树不经过X节点</p>
<p>a)最大二叉搜索树要么是左子树</p>
<p>b)最大二叉搜索树要么是右子树</p>
<p>(2)最大二叉搜索树经过X节点</p>
<p>c)左子树是BST且右子树是BST且左子树的最大值&lt;x&lt;右子树的最小值</p>
<p>最终结果取a,b,c中的一种</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubBSTHead2(Node head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 解法1：初始化就是传入头结点，并返回最大二叉搜索树的头结点</span><br><span class="line">        return process(head).maxSubBSTSize;</span><br><span class="line">        // 解法2：提前处理好null节点</span><br><span class="line">       //  return dfs(head).ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先定义每一棵子树,二叉搜索树的信息数据结构</span><br><span class="line">    public static class Info &#123;</span><br><span class="line">        // 最大二叉搜索子树的头节点，如果存在则有值。不存在，则是null</span><br><span class="line">        public Node maxSubBSTHead;</span><br><span class="line">        // 最大二叉搜索子树的大小，就是最大二叉搜索子树的所有节点个数</span><br><span class="line">        public int maxSubBSTSize;</span><br><span class="line">        // 最大二叉搜索子树的最小值</span><br><span class="line">        public int min;</span><br><span class="line">        // 最大二叉搜索子树的最大值</span><br><span class="line">        public int max;</span><br><span class="line"></span><br><span class="line">        public Info(Node h, int size, int mi, int ma) &#123;</span><br><span class="line">            maxSubBSTHead = h;</span><br><span class="line">            maxSubBSTSize = size;</span><br><span class="line">            min = mi;</span><br><span class="line">            max = ma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Info process(Node X) &#123;</span><br><span class="line">        // 判空的时候，不知道返回什么，就返回空，后续自己处理</span><br><span class="line">        if (X == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // ---套路步骤1,假设拿到左树信息</span><br><span class="line">        Info leftInfo = process(X.left);</span><br><span class="line">        // ---套路步骤1,假设拿到右树信息</span><br><span class="line">        Info rightInfo = process(X.right);</span><br><span class="line">        /*</span><br><span class="line">         *---套路步骤2</span><br><span class="line">         * (1)最大二叉搜索树不经过X节点</span><br><span class="line">         * a)最大二叉搜索树要么是左子树</span><br><span class="line">         * b)最大二叉搜索树要么是右子树</span><br><span class="line">         * (2)最大二叉搜索树经过X节点</span><br><span class="line">         * c)左子树是BST且右子树是BST且左子树的最大值&lt;x&lt;右子树的最小值</span><br><span class="line">         * 最终结果取a,b,c中的一种</span><br><span class="line">         * */</span><br><span class="line">        // 先假设最大最小为当前值</span><br><span class="line">        int min = X.value;</span><br><span class="line">        int max = X.value;</span><br><span class="line">        // 先假设最大二叉搜索子树为空</span><br><span class="line">        Node maxSubBSTHead = null;</span><br><span class="line">        // 先假设最大二叉搜索子树的大小为0</span><br><span class="line">        int maxSubBSTSize = 0;</span><br><span class="line">        // 情况1：套路步骤2中的a</span><br><span class="line">        if (leftInfo != null) &#123;</span><br><span class="line">            // 比较全局最小和当前子树最小值，取最小的值</span><br><span class="line">            min = Math.min(min, leftInfo.min);</span><br><span class="line">            max = Math.max(max, leftInfo.max);</span><br><span class="line">            maxSubBSTHead = leftInfo.maxSubBSTHead;</span><br><span class="line">            maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">        &#125;</span><br><span class="line">        // 情况2：套路步骤2中的b</span><br><span class="line">        if (rightInfo != null) &#123;</span><br><span class="line">            min = Math.min(min, rightInfo.min);</span><br><span class="line">            max = Math.max(max, rightInfo.max);</span><br><span class="line">            // 这里要看一眼右节点比之前的值是不是更大，更大才更新</span><br><span class="line">            if (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;</span><br><span class="line">                maxSubBSTHead = rightInfo.maxSubBSTHead;</span><br><span class="line">                maxSubBSTSize = rightInfo.maxSubBSTSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 情况3：套路步骤2中的c</span><br><span class="line">        /*</span><br><span class="line">         * 如果leftInfo == null，表示左子树为空，没有节点。那么也属于BST，直接给true</span><br><span class="line">         * 如果leftInfo != null，leftInfo.maxSubBSTHead == X.left表示X的左子节点是X左子树的最大搜索二叉树的节点即左子树是BST，</span><br><span class="line">         * leftInfo.max &lt; X.value表示左子树的最大值&lt;x，这种才满足c的一部分条件。右子树也是同样判断</span><br><span class="line">         * */</span><br><span class="line">        if ((leftInfo == null ? true : (leftInfo.maxSubBSTHead == X.left &amp;&amp; leftInfo.max &lt; X.value))</span><br><span class="line">                &amp;&amp; (rightInfo == null ? true : (rightInfo.maxSubBSTHead == X.right &amp;&amp; rightInfo.min &gt; X.value))) &#123;</span><br><span class="line">            // 满足以上条件的，X节点才是X为头结点的最大二叉搜索树的头节点</span><br><span class="line">            maxSubBSTHead = X;</span><br><span class="line">            // 二叉搜索树的大小就是左+有+1自己节点</span><br><span class="line">            maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize)</span><br><span class="line">                    + (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // ---套路步骤5,终极目的就是递归这四个值</span><br><span class="line">        return new Info(maxSubBSTHead, maxSubBSTSize, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SuperNode &#123;</span><br><span class="line">        int ans;</span><br><span class="line">        int small, large;</span><br><span class="line">        boolean isBST;</span><br><span class="line"></span><br><span class="line">        public SuperNode() &#123;</span><br><span class="line">            ans = 0;</span><br><span class="line">            isBST = true;</span><br><span class="line">            small = Integer.MAX_VALUE;</span><br><span class="line">            large = -Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SuperNode dfs(Node node) &#123;</span><br><span class="line">        // 解法2：提前处理好null节点</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return new SuperNode();</span><br><span class="line">        &#125;</span><br><span class="line">        SuperNode now = new SuperNode();</span><br><span class="line">        SuperNode left = dfs(node.left);</span><br><span class="line">        SuperNode right = dfs(node.right);</span><br><span class="line">        now.small = Math.max(left.small, node.value);</span><br><span class="line">        now.large = Math.max(right.large, node.value);</span><br><span class="line">        if (left.isBST &amp;&amp; right.isBST &amp;&amp; left.large &lt;= node.value &amp;&amp; right.small &gt;= node.value) &#123;</span><br><span class="line">         // 最大二叉搜索树经过X节点</span><br><span class="line">            now.ans = left.ans + right.ans + 1;</span><br><span class="line">            now.isBST = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         // 如果最大二叉搜索树不经过X节点，则最大值一定在左右中最大的一个</span><br><span class="line">            now.ans = Math.max(left.ans, right.ans);</span><br><span class="line">            // 标记为非BST</span><br><span class="line">            now.isBST = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return now;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-员工快乐值"><a href="#套路实践-员工快乐值" class="headerlink" title="套路实践-员工快乐值"></a>套路实践-员工快乐值</h3><p>题目：定义员工Employee信息，每个员工可能有多个直接下级，但只有一个上级。基层员工没有下级。现在公司办party,要决定哪些人来或不来。规则如下：</p>
<p>1.如果某个员工来了，那么这个员工的所有<strong>直接下级</strong>都不能来<br>2.派对的整体快乐值是所有到场员工快乐值的累加<br>3.你的目标是让派对的整体快乐值尽量大<br>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</p>
<p>思路：员工X,假设有a,b,c三个下属</p>
<p>(1)X来时,yes快乐值=a不来的快乐值+b不来的快乐值+c不来的快乐值</p>
<p>(2)X不来时，no快乐值=max(a来的快乐值,a不来的快乐值)+max(b来的快乐值,b不来的快乐值)+max(c来的快乐值,c不来的快乐值)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class Code04_MaxHappy &#123;</span><br><span class="line">    public static class Employee &#123;</span><br><span class="line">        // 员工可以带来的快乐值</span><br><span class="line">        public int happy;</span><br><span class="line">        // 该员工的直接下属员工</span><br><span class="line">        public List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">        public Employee(int h) &#123;</span><br><span class="line">            happy = h;</span><br><span class="line">            nexts = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int maxHappy2(Employee head) &#123;</span><br><span class="line">        Info allInfo = process(head);</span><br><span class="line">        return Math.max(allInfo.no, allInfo.yes);</span><br><span class="line">    &#125;</span><br><span class="line">    // 先定义员工节点的快乐值，因为是树结构，要考虑其下属来不来</span><br><span class="line">    public static class Info &#123;</span><br><span class="line">        // 员工不来的情况下，他的快乐值</span><br><span class="line">        public int no;</span><br><span class="line">        // 员工来的情况下，他的快乐值</span><br><span class="line">        public int yes;</span><br><span class="line"></span><br><span class="line">        public Info(int n, int y) &#123;</span><br><span class="line">            no = n;</span><br><span class="line">            yes = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Info process(Employee x) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 思路：X,假设有a,b,c三个下属</span><br><span class="line">         * (1)X来时,yes快乐值=a不来的快乐值+b不来的快乐值+c不来的快乐值</span><br><span class="line">         * (2)X不来时，no快乐值=max(a来的快乐值,a不来的快乐值)+max(b来的快乐值,b不来的快乐值)+max(c来的快乐值,c不来的快乐值)</span><br><span class="line">         * */</span><br><span class="line">        // base case 没有员工了</span><br><span class="line">        if (x == null) &#123;</span><br><span class="line">            return new Info(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 员工不来的初始快乐值为0</span><br><span class="line">        int no = 0;</span><br><span class="line">        // 员工来的初始快乐值为自己的happy</span><br><span class="line">        int yes = x.happy;</span><br><span class="line">        // 遍历所有下属</span><br><span class="line">        for (Employee next : x.nexts) &#123;</span><br><span class="line">            // 假设能获取下属的信息</span><br><span class="line">            Info nextInfo = process(next);</span><br><span class="line">            // X不来时，快乐值就是如下</span><br><span class="line">            no += Math.max(nextInfo.no, nextInfo.yes);</span><br><span class="line">            // X来时，快乐值就是如下</span><br><span class="line">            yes += nextInfo.no;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Info(no, yes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套路实践-最低公共祖先节点"><a href="#套路实践-最低公共祖先节点" class="headerlink" title="套路实践-最低公共祖先节点"></a>套路实践-最低公共祖先节点</h3><p>题目：给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点。</p>
<ul>
<li>解法1：利用一个map构件节点向上找父节点的效果，利用set查找两者第一个相同的向上找到的父节点</li>
<li>解法2：二叉树递归套路。构建基本信息，递归分情况讨论</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public static class Node &#123;</span><br><span class="line"> public int value;</span><br><span class="line"> public Node left;</span><br><span class="line"> public Node right;</span><br><span class="line"> public Node(int data) &#123;</span><br><span class="line">  this.value = data;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解法1：利用一个map构件节点向上找父节点的效果，利用set查找两者第一个相同的向上找到的父节点</span><br><span class="line">public static Node lowestAncestor1(Node head, Node o1, Node o2) &#123;</span><br><span class="line"> if (head == null) &#123;</span><br><span class="line">  return null;</span><br><span class="line"> &#125;</span><br><span class="line"> // key的父节点是value</span><br><span class="line"> HashMap&lt;Node, Node&gt; parentMap = new HashMap&lt;&gt;();</span><br><span class="line"> parentMap.put(head, null);</span><br><span class="line"> // 构建所有节点的父节点表</span><br><span class="line"> fillParentMap(head, parentMap);</span><br><span class="line"> HashSet&lt;Node&gt; o1Set = new HashSet&lt;&gt;();</span><br><span class="line"> Node cur = o1;</span><br><span class="line"> o1Set.add(cur);</span><br><span class="line"> // 递归取出o1节点的所有父节点，加入o1Set</span><br><span class="line"> while (parentMap.get(cur) != null) &#123;</span><br><span class="line">  cur = parentMap.get(cur);</span><br><span class="line">  o1Set.add(cur);</span><br><span class="line"> &#125;</span><br><span class="line"> cur = o2;</span><br><span class="line"> // 递归取出o2节点的所有父节点，判断是否存在o1Set中，存在了就是最近的公共祖先。</span><br><span class="line"> while (!o1Set.contains(cur)) &#123;</span><br><span class="line">  cur = parentMap.get(cur);</span><br><span class="line"> &#125;</span><br><span class="line"> return cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用，填写map,含义key:当前节点,value：当前节点的父节点</span><br><span class="line">public static void fillParentMap(Node head, HashMap&lt;Node, Node&gt; parentMap) &#123;</span><br><span class="line"> if (head.left != null) &#123;</span><br><span class="line">  // 存在左节点，加入map</span><br><span class="line">  parentMap.put(head.left, head);</span><br><span class="line">  // 继续递归左节点</span><br><span class="line">  fillParentMap(head.left, parentMap);</span><br><span class="line"> &#125;</span><br><span class="line"> if (head.right != null) &#123;</span><br><span class="line">  parentMap.put(head.right, head);</span><br><span class="line">  fillParentMap(head.right, parentMap);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解法2：二叉树递归套路。构建基本信息，递归分情况讨论</span><br><span class="line">public static Node lowestAncestor2(Node head, Node a, Node b) &#123;</span><br><span class="line"> return process(head, a, b).ans;</span><br><span class="line">&#125;</span><br><span class="line">// 任何节点作为头结点的子树信息</span><br><span class="line">public static class Info &#123;</span><br><span class="line"> // 子树上是否存在a节点</span><br><span class="line"> public boolean findA;</span><br><span class="line"> // 子树上是否存在b节点</span><br><span class="line"> public boolean findB;</span><br><span class="line"> // 子树上的a,b的最初交汇点即最近的公共祖先，可能存在，也可能不存在为null</span><br><span class="line"> public Node ans;</span><br><span class="line"> public Info(boolean fA, boolean fB, Node an) &#123;</span><br><span class="line">  findA = fA;</span><br><span class="line">  findB = fB;</span><br><span class="line">  ans = an;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static Info process(Node x, Node a, Node b) &#123;</span><br><span class="line"> // base case</span><br><span class="line"> if (x == null) &#123;</span><br><span class="line">  return new Info(false, false, null);</span><br><span class="line"> &#125;</span><br><span class="line"> // 二叉树递归套路，先要来左右子树的信息</span><br><span class="line"> Info leftInfo = process(x.left, a, b);</span><br><span class="line"> Info rightInfo = process(x.right, a, b);</span><br><span class="line"> // 判断子树上是否存在a节点.要么当前节点就是a,要么a在左子树上，要么a在右子树上</span><br><span class="line"> boolean findA = (x == a) || leftInfo.findA || rightInfo.findA;</span><br><span class="line"> boolean findB = (x == b) || leftInfo.findB || rightInfo.findB;</span><br><span class="line"> // 接下来就是对于当前子树，它对于a,b的交汇点在哪</span><br><span class="line"> Node ans = null;</span><br><span class="line"> /*</span><br><span class="line"> * 最低公共祖先一定在以下三种情况：</span><br><span class="line"> * 情况1：如果左子树的交汇点不为空，那么交汇点就是它</span><br><span class="line"> * 情况2：如果右子树的交汇点不为空，那么交汇点就是它</span><br><span class="line"> * 情况3：如果都不在，但是又有最低祖先，那么一定在当前节点上</span><br><span class="line"> * */</span><br><span class="line"> if (leftInfo.ans != null) &#123;</span><br><span class="line">  // 情况1</span><br><span class="line">  ans = leftInfo.ans;</span><br><span class="line"> &#125; else if (rightInfo.ans != null) &#123;</span><br><span class="line">  // 情况2</span><br><span class="line">  ans = rightInfo.ans;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  // 情况3</span><br><span class="line">  if (findA &amp;&amp; findB) &#123;</span><br><span class="line">   ans = x;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> // 不满足情况123的就表示没有最低公共祖先</span><br><span class="line"> return new Info(findA, findB, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h1><p>简称：五个好朋友算法，是5个人共同提出的算法。开创了算法的优化一个新局面。</p>
<p>bfprt算法最牛逼划时代的意义是，在你还没有完全求解出来时，你就已经知道算法收敛于O(n),也叫五个好朋友算法。</p>
<p>题目：无序数组中，求第K小的数</p>
<ul>
<li><p>解法1：常规解法，利用快排分组，利用荷兰国旗问题，获取值，笔试常用。平均复杂度nlog(n)，最差n2</p>
</li>
<li><p>解法2：bfprt算法也叫<strong>五个好朋友算法</strong>也叫<strong>中位数的中位数算法</strong>，只有第一步的选值特别讲究，后续都和1一样，面试装逼.平均复杂度n</p>
</li>
</ul>
<p>解法1：利用快排，只不过没有快排的两边排序，只排序一边即可。流程：a随机选一个数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class FindMinK &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1,  3,  5, 7,  9, 11&#125;;</span><br><span class="line">        int k = 2;</span><br><span class="line">        System.out.println(select(arr, 0, arr.length - 1, k - 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在arr[L..R]范围上，求如果排序的话，i位置的数是谁，返回</span><br><span class="line">    //i一定且必须出现在L~R范围上</span><br><span class="line">    public static int select(int[] arr, int L, int R, int i) &#123;</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        // 解法1：常规解法，a随机选一个数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归</span><br><span class="line">        int pivot = arr[L+(int)(Math.random()*(R-L+1))];</span><br><span class="line">        // partition过程 根据pivot做划分值  &lt;p ==p &lt;p 返回等于区域的左边界和右边界</span><br><span class="line">        // range[0] 等于区域的左边界的索引值</span><br><span class="line">        // range[1] 等于区域的右边界的索引值</span><br><span class="line">        int[] range = partition(arr, L, R, pivot);</span><br><span class="line">        // 注意range存放的是边界的索引值，不是数组值</span><br><span class="line">        // 左右分组后，range左边的索引值数都是小于range值索引值数，右边都是大于值。比如range[6-10],说明左边有5个小数，右边是大数。</span><br><span class="line">        if (i &gt;= range[0] &amp;&amp; i &lt;= range[1]) &#123;</span><br><span class="line">            return arr[i];</span><br><span class="line">        &#125; else if (i &lt; range[0]) &#123;</span><br><span class="line">            return select(arr, L, range[0] - 1, i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return select(arr, range[1] + 1, R, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int[] partition(int[] arr, int L, int R, int pivotValue) &#123;</span><br><span class="line">        // 常规荷兰国旗问题分组</span><br><span class="line">        int small = L - 1;</span><br><span class="line">        int cur = L;</span><br><span class="line">        int big = R + 1;</span><br><span class="line">        while (cur != big) &#123;</span><br><span class="line">            if (arr[cur] &lt; pivotValue) &#123;</span><br><span class="line">                swap(arr, ++small, cur++);</span><br><span class="line">            &#125; else if (arr[cur] &gt; pivotValue) &#123;</span><br><span class="line">                swap(arr, cur, --big);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] range = new int[2];</span><br><span class="line">        range[0] = small + 1;</span><br><span class="line">        range[1] = big - 1;</span><br><span class="line">        return range;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int index1, int index2) &#123;</span><br><span class="line">        int tmp = arr[index1];</span><br><span class="line">        arr[index1] = arr[index2];</span><br><span class="line">        arr[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：利用bfprt算法，流程：a非常非常讲究的选一个数即中位数的中位数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public class FindMinK &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;;</span><br><span class="line">        int k = 2;</span><br><span class="line">        System.out.println(bfprt(arr, 0, arr.length - 1, k - 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在arr[L..R]范围上，求如果排序的话，i位置的数是谁，返回。</span><br><span class="line">    //i一定且必须出现在L~R范围上</span><br><span class="line">    public static int bfprt(int[] arr, int L, int R, int i) &#123;</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        // 解法2: bfprt算法，a非常非常讲究的选一个数即中位数的中位数；b划分区域值&lt;p=p&gt;p;c如果命中index,则返回。否则左侧或右侧递归</span><br><span class="line">        int pivot = medianOfMedians(arr, L, R);</span><br><span class="line">        // partition过程 根据pivot做划分值  &lt;p ==p &lt;p 返回等于区域的左边界和右边界</span><br><span class="line">        // range[0] 等于区域的左边界的索引值</span><br><span class="line">        // range[1] 等于区域的右边界的索引值</span><br><span class="line">        int[] range = partition(arr, L, R, pivot);</span><br><span class="line">        // 注意range存放的是边界的索引值，不是数组值</span><br><span class="line">        // 左右分组后，range左边的索引值数都是小于range值索引值数，右边都是大于值。比如range[6-10],说明左边有5个小数，右边是大数。</span><br><span class="line">        if (i &gt;= range[0] &amp;&amp; i &lt;= range[1]) &#123;</span><br><span class="line">            return arr[i];</span><br><span class="line">        &#125; else if (i &lt; range[0]) &#123;</span><br><span class="line">            return bfprt(arr, L, range[0] - 1, i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return bfprt(arr, range[1] + 1, R, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int medianOfMedians(int[] arr, int begin, int end) &#123;</span><br><span class="line">        /* 求解中位数</span><br><span class="line">        1.每5个数分为一组</span><br><span class="line">        2.内部排序，每组的中位数组成新数组marr</span><br><span class="line">        3.继续调用中位数算法bfprt(marr,marr的中位数即长度一半)</span><br><span class="line">         */</span><br><span class="line">        // 数组总长度</span><br><span class="line">        int num = end - begin + 1;</span><br><span class="line">        // 每五个一组，查看是否有多余的数，有的话则单独成一位</span><br><span class="line">        int offset = num % 5 == 0 ? 0 : 1;</span><br><span class="line">        // 创建存储每五个数据排序后中位数的数组</span><br><span class="line">        int[] mArr = new int[num / 5 + offset];</span><br><span class="line">        // 遍历此数组</span><br><span class="line">        for (int i = 0; i &lt; mArr.length; i++) &#123;</span><br><span class="line">            // 当前mArr来源自原来数组中的起始位置</span><br><span class="line">            int beginI = begin + i * 5;</span><br><span class="line">            // 当前mArr来源自原来数组中的终止位置</span><br><span class="line">            int endI = beginI + 4;</span><br><span class="line">            // 计算出当前i位置5个数排序后的中位数</span><br><span class="line">            mArr[i] = getMedian(arr, beginI, Math.min(end, endI));</span><br><span class="line">        &#125;</span><br><span class="line">        // 在这些中位数的点中，挑选出排好序之后的中位数返回，即继续调用bfprt功能前一半小的数也就是中位数</span><br><span class="line">        return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getMedian(int[] arr, int begin, int end) &#123;</span><br><span class="line">        // 对数组排序，获取中位数或中间的偏左位置。因为可能刚好4个数，取第2个</span><br><span class="line">        insertionSort(arr, begin, end);</span><br><span class="line">        int sum = end + begin;</span><br><span class="line">        int mid = (sum / 2) + (sum % 2);</span><br><span class="line">        return arr[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void insertionSort(int[] arr, int begin, int end) &#123;</span><br><span class="line">    // 插入排序</span><br><span class="line">        for (int i = begin + 1; i != end + 1; i++) &#123;</span><br><span class="line">            for (int j = i; j != begin; j--) &#123;</span><br><span class="line">                if (arr[j - 1] &gt; arr[j]) &#123;</span><br><span class="line">                    swap(arr, j - 1, j);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] partition(int[] arr, int L, int R, int pivotValue) &#123;</span><br><span class="line">        int small = L - 1;</span><br><span class="line">        int cur = L;</span><br><span class="line">        int big = R + 1;</span><br><span class="line">        while (cur != big) &#123;</span><br><span class="line">            if (arr[cur] &lt; pivotValue) &#123;</span><br><span class="line">                swap(arr, ++small, cur++);</span><br><span class="line">            &#125; else if (arr[cur] &gt; pivotValue) &#123;</span><br><span class="line">                swap(arr, cur, --big);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] range = new int[2];</span><br><span class="line">        range[0] = small + 1;</span><br><span class="line">        range[1] = big - 1;</span><br><span class="line">        return range;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int index1, int index2) &#123;</span><br><span class="line">        int tmp = arr[index1];</span><br><span class="line">        arr[index1] = arr[index2];</span><br><span class="line">        arr[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Morris算法遍历"><a href="#Morris算法遍历" class="headerlink" title="Morris算法遍历"></a>Morris算法遍历</h1><h2 id="Morris序"><a href="#Morris序" class="headerlink" title="Morris序"></a>Morris序</h2><p>比如二叉树：第一层：1，第二层：2,3；第三层，4,5,6,7。Morris序是：1242513637</p>
<p>算法流程：</p>
<blockquote>
<p>首先cur表示当前节点，cur指向树的头结点。直到最终cur指向null停止。</p>
<ol>
<li><p>如果cur无左树，cur=cur.right</p>
</li>
<li><p>如果cur有左树，找到左树的最右节点mostRight,即左树的右右右…不为空的节点。</p>
<p>1)如果mostRight的右指针指向null,则mostRight.right =cur,cur=cur.left</p>
<p>2)如果mostRight的右指针指向cur,则mostRight.right =null,cur=cur.right</p>
</li>
</ol>
</blockquote>
<p><strong>时间复杂度</strong>：O(N),因为每个节点的左树右边界最多趟过2次，即2N是N规模的复杂度。</p>
<p><strong>空间复杂度</strong>：O(1)即不需要额外空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static class Node &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">        this.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void morris(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从头结点开始</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = null;</span><br><span class="line">    // cur指向null停止，跳出while循环。</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // cur只要不为null,就一直跑下去</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        if (mostRight != null) &#123;</span><br><span class="line">            // 2.如果cur有左孩子</span><br><span class="line">            while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mostRight.right == null) &#123;</span><br><span class="line">             // 第一次到达cur</span><br><span class="line">             // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             // 第二次到达cur</span><br><span class="line">                // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                mostRight.right = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 1.如果cur没有左孩子</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Morris遍历和传统二叉树遍历"><a href="#Morris遍历和传统二叉树遍历" class="headerlink" title="Morris遍历和传统二叉树遍历"></a>Morris遍历和传统二叉树遍历</h2><p>Morris遍历是向传统遍历致敬，做到了优化的前序和中序遍历，后续遍历需要额外代码。</p>
<p>传统二叉树遍历代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void process(Node head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 先序遍历</span><br><span class="line">        System.out.println(“先序遍历：头左右”);</span><br><span class="line">        process(head.left);</span><br><span class="line">        // 中序遍历</span><br><span class="line">        System.out.println(“中序遍历：左头右”);</span><br><span class="line">        process(head.right);</span><br><span class="line">        // 后序遍历</span><br><span class="line">        System.out.println(“后序遍历：左右头”);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>先序遍历</strong></p>
<p>只打印没有左节点或第一次进入的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void morrisPre(Node head) &#123;</span><br><span class="line">        // 中序遍历</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从头结点开始</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = null;</span><br><span class="line">        // cur指向null停止，跳出while循环。</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // cur只要不为null,就一直跑下去</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            if (mostRight != null) &#123;</span><br><span class="line">                // 2.如果cur有左孩子</span><br><span class="line">                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                if (mostRight.right == null) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    // 只打印第一次进入的节点</span><br><span class="line">                    System.out.println(&quot;先序遍历&quot;+cur.value);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                    mostRight.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 只打印没有左节点</span><br><span class="line">                System.out.println(&quot;先序遍历&quot;+cur.value);</span><br><span class="line">            &#125;</span><br><span class="line">            // 1.如果cur没有左孩子</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<p>只打印没有左节点或第二次进入的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void morrisIn(Node head) &#123;</span><br><span class="line">        // 中序遍历</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从头结点开始</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = null;</span><br><span class="line">        // cur指向null停止，跳出while循环。</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // cur只要不为null,就一直跑下去</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            if (mostRight != null) &#123;</span><br><span class="line">                // 2.如果cur有左孩子</span><br><span class="line">                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                if (mostRight.right == null) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                    mostRight.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 一行代码，只打印没有左节点或第二次进入的节点</span><br><span class="line">            System.out.println(&quot;中序遍历&quot;+cur.value);</span><br><span class="line">            // 1.如果cur没有左孩子</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<ul>
<li>打印第二次进入节点的左树的右边界的逆序，其中Morris序是：1242513637。</li>
</ul>
<p>第二个2的左树右边界只有4，第二个1的左树右边界逆序是52，第二个3的左树右边界逆序是6</p>
<ul>
<li>打印整棵树的右边界逆序，731</li>
</ul>
<p>最终结果为4526731</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public static void morrisPos(Node head) &#123;</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从头结点开始</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = null;</span><br><span class="line">        // cur指向null停止，跳出while循环。</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // cur只要不为null,就一直跑下去</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            if (mostRight != null) &#123;</span><br><span class="line">                // 2.如果cur有左孩子</span><br><span class="line">                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                if (mostRight.right == null) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                    mostRight.right = null;</span><br><span class="line">                    // 打印第二次进入节点的左树的右边界的逆序</span><br><span class="line">                    printEdge(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 打印整棵树的右边界逆序</span><br><span class="line">            printEdge(head);</span><br><span class="line">            // 1.如果cur没有左孩子</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void printEdge(Node head) &#123;</span><br><span class="line">        // 打印整棵树的右树逆序</span><br><span class="line">        // 1.先逆序所有的右节点</span><br><span class="line">        Node tail = reverseEdge(head);</span><br><span class="line">        Node cur = tail;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // 2.打印所有右节点</span><br><span class="line">            System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.再还原回来，因为是在原树上处理，没有额外空间</span><br><span class="line">        reverseEdge(tail);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Node reverseEdge(Node from) &#123;</span><br><span class="line">        // 逆序所有的右节点，和链表逆序原理一致</span><br><span class="line">        Node pre = null;</span><br><span class="line">        Node next = null;</span><br><span class="line">        while (from != null) &#123;</span><br><span class="line">            next = from.right;</span><br><span class="line">            from.right = pre;</span><br><span class="line">            pre = from;</span><br><span class="line">            from = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否为二叉搜索树BST"><a href="#判断是否为二叉搜索树BST" class="headerlink" title="判断是否为二叉搜索树BST"></a>判断是否为二叉搜索树BST</h2><p>利用Morris序判断是否为二叉搜索树BST,BST定义：左节点小于根，根小于右节点。即中序遍历是依次递增的就是BST.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isBST(Node head) &#123;</span><br><span class="line">        // 利用Morris序判断是否为二叉搜索树BST,BST定义：左节点小于根，根小于右节点。即中序遍历是依次递增的就是BST.</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            // 空，则是BST</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从头结点开始</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = null;</span><br><span class="line">        Integer pre = null;</span><br><span class="line">        // cur指向null停止，跳出while循环。</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // cur只要不为null,就一直跑下去</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            if (mostRight != null) &#123;</span><br><span class="line">                // 2.如果cur有左孩子</span><br><span class="line">                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                if (mostRight.right == null) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                    mostRight.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 中序遍历的所有值，判断前一个大于等于后一个，一定不是BST</span><br><span class="line">            if (pre != null &amp;&amp; pre &gt;= cur.value) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 指针下移，继续判断下一个</span><br><span class="line">            pre = cur.value;</span><br><span class="line">            // 1.如果cur没有左孩子</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 跑完了，不报错就是BST</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="求二叉树的最小高度"><a href="#求二叉树的最小高度" class="headerlink" title="求二叉树的最小高度"></a>求二叉树的最小高度</h2><p>叶节点才有最小高度.</p>
<p>解法1：利用无脑递归</p>
<p>解法2：利用Morris序，有点复杂</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">public class MorrisMinHeight &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node node1 = new Node(1);</span><br><span class="line">        Node node2 = new Node(2);</span><br><span class="line">        node1.right = node2;</span><br><span class="line">        Node node3 = new Node(3);</span><br><span class="line">        node2.left = node3;</span><br><span class="line">        Node node4 = new Node(4);</span><br><span class="line">        Node node5 = new Node(5);</span><br><span class="line">        node3.left = node4;</span><br><span class="line">        node3.right = node5;</span><br><span class="line">        System.out.println(minDepth2(node1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public int value;</span><br><span class="line">        public Node left;</span><br><span class="line">        public Node right;</span><br><span class="line"></span><br><span class="line">        public Node(int data) &#123;</span><br><span class="line">            this.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int minDepth1(Node head) &#123;</span><br><span class="line">        // 二叉树最小高度，常规递归遍历</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return p(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int minDepth2(Node head) &#123;</span><br><span class="line">        // 利用morris遍历改写获取二叉树最小高度</span><br><span class="line">        /*</span><br><span class="line">        1.需要知道当前节点的高度，即curLevel值</span><br><span class="line">        2.每次比较相近的叶节点的高度，判定最小值，最终就是最小高度。</span><br><span class="line">          1)比较左侧的所有叶节点高度</span><br><span class="line">          2)在上面的基础上，比较最右叶节点高度，去最小值即可</span><br><span class="line">        */</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从头结点开始</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = null;</span><br><span class="line">        // 当前节点的高度</span><br><span class="line">        int curLevel = 0;</span><br><span class="line">        // 最终返回的最小高度</span><br><span class="line">        int minHeight = Integer.MAX_VALUE;</span><br><span class="line">        // cur指向null停止，跳出while循环。</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            // cur只要不为null,就一直跑下去</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            if (mostRight != null) &#123;</span><br><span class="line">                // 定义cur左子树上，右边界的节点个数</span><br><span class="line">                int leftTreeRightSize = 1;</span><br><span class="line">                // 2.如果cur有左孩子</span><br><span class="line">                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    // 找到cur左子树最右节点，要么节点的右指针为空，要么节点的右指针指向当前节点(因为人工改变了指向)</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                    // 只要有右节点则高度加1</span><br><span class="line">                    leftTreeRightSize++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mostRight.right == null) &#123;</span><br><span class="line">                    // 第一次到达cur</span><br><span class="line">                    // 说明往左节点去了，高度加1</span><br><span class="line">                    curLevel++;</span><br><span class="line">                    // 1)mostRight的右孩子指向空，让其指向cur，cur向左移动</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 第二次到达cur</span><br><span class="line">                    if (mostRight.left == null) &#123;</span><br><span class="line">                        // 左节点为空了，说明已经到达叶子节点，判定最小值</span><br><span class="line">                        minHeight = Math.min(minHeight, curLevel);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 因为是第二次到cur，所以是当前节点-当前树的右边界节点个数</span><br><span class="line">                    curLevel -= leftTreeRightSize;</span><br><span class="line">                    // 2)mostRight的右孩子指向cur，让其指向空，cur向右移动</span><br><span class="line">                    mostRight.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 无左节点，直接往右，高度加1</span><br><span class="line">                curLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1.如果cur没有左孩子</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为morris序上面的过程是没有计算整树的右边界的最右节点，所以人工把最右节点计算下</span><br><span class="line">        int finalRight = 1;</span><br><span class="line">        cur = head;</span><br><span class="line">        while (cur.right != null) &#123;</span><br><span class="line">            // 不断寻找右节点</span><br><span class="line">            finalRight++;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后不要忘了单独看看整棵树的最右节点是不是叶节点</span><br><span class="line">        if (cur.left == null &amp;&amp; cur.right == null) &#123;</span><br><span class="line">            // 到了最右的叶子节点，取最小值</span><br><span class="line">            minHeight = Math.min(minHeight, finalRight);</span><br><span class="line">        &#125;</span><br><span class="line">        return minHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int p(Node head) &#123;</span><br><span class="line">        // 左右节点都为空直接返回1</span><br><span class="line">        if (head.left == null &amp;&amp; head.right == null) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftH = Integer.MAX_VALUE;</span><br><span class="line">        if (head.left != null) &#123;</span><br><span class="line">            // 如果左节点为空，则继续遍历左子树</span><br><span class="line">            leftH = p(head.left);</span><br><span class="line">        &#125;</span><br><span class="line">        int rightH = Integer.MAX_VALUE;</span><br><span class="line">        if (head.right != null) &#123;</span><br><span class="line">            // 如果右节点为空，则继续遍历右子树</span><br><span class="line">            rightH = p(head.right);</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次迭代，都深度加1，且取左右子树的最小深度</span><br><span class="line">        return 1 + Math.min(leftH, rightH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol>
<li>由点的集合和边的集合组成</li>
<li>虽然存在有向图和无向图，但都可以用有向图来表示</li>
<li>边上可能带有权值</li>
</ol>
<h2 id="图的结构表达"><a href="#图的结构表达" class="headerlink" title="图的结构表达"></a>图的结构表达</h2><ol>
<li>邻接表法</li>
<li>邻接矩阵法</li>
<li>除此之外还有其他众多方法</li>
</ol>
<p><strong>邻接表法</strong></p>
<p>每个节点直接指向的下一个节点。一个表，第一列是当前节点，后面是可到达节点。</p>
<p>A:(B3),(C1)</p>
<p>B:(C2)</p>
<p>C:(A5)</p>
<p><strong>邻接矩阵法</strong></p>
<p>节点的nxn矩阵，无穷表示不可达，有值则表示权值。</p>
<pre><code>A                              B       C
</code></pre>
<p>A  无穷(表示不连接)   3       1 </p>
<p>B 无穷                        无穷   2</p>
<p>C 5                              无穷  无穷</p>
<h2 id="图的面试题如何搞定"><a href="#图的面试题如何搞定" class="headerlink" title="图的面试题如何搞定"></a>图的面试题如何搞定</h2><p>图的算法不算难，只不过coding的代价比较高</p>
<ol>
<li>先用最熟悉的方式，实验图结构的表达</li>
<li>在自己熟悉的结构上，实现所有常用的图算法作为模板</li>
<li>把面试提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class GraphGenerator &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node nodeA = new Node(0);</span><br><span class="line">        Node nodeB = new Node(1);</span><br><span class="line">        int[][] matrix = &#123;&#123;3, 0, 1&#125;&#125;;</span><br><span class="line">        Graph ga = createGraph(matrix);</span><br><span class="line">        System.out.println(ga);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Graph createGraph(int[][] matrix) &#123;</span><br><span class="line">        // 将不熟悉的图结构转化为熟悉的图结构</span><br><span class="line">        // 这种结构不是最精简，但能覆盖大多数题目</span><br><span class="line">        Graph graph = new Graph();</span><br><span class="line">        for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            // 拿到每一条边， matrix[i]</span><br><span class="line">            // 权值</span><br><span class="line">            int weight = matrix[i][0];</span><br><span class="line">            // 起点</span><br><span class="line">            int from = matrix[i][1];</span><br><span class="line">            // 终点</span><br><span class="line">            int to = matrix[i][2];</span><br><span class="line">            // 是否添加到节点集</span><br><span class="line">            if (!graph.nodes.containsKey(from)) &#123;</span><br><span class="line">                graph.nodes.put(from, new Node(from));</span><br><span class="line">            &#125;</span><br><span class="line">            // 是否添加到节点集</span><br><span class="line">            if (!graph.nodes.containsKey(to)) &#123;</span><br><span class="line">                graph.nodes.put(to, new Node(to));</span><br><span class="line">            &#125;</span><br><span class="line">            // 核心：上述完成图的节点集</span><br><span class="line">            Node fromNode = graph.nodes.get(from);</span><br><span class="line">            Node toNode = graph.nodes.get(to);</span><br><span class="line">            // 创建一个边集</span><br><span class="line">            Edge newEdge = new Edge(weight, fromNode, toNode);</span><br><span class="line">            // 起点加了一个指出的邻接点</span><br><span class="line">            fromNode.nexts.add(toNode);</span><br><span class="line">            // 起点出度加1</span><br><span class="line">            fromNode.out++;</span><br><span class="line">            // 起点添加边集</span><br><span class="line">            fromNode.edges.add(newEdge);</span><br><span class="line">            // 终点入度加1</span><br><span class="line">            toNode.in++;</span><br><span class="line">            // 核心：完成图的边集</span><br><span class="line">            graph.edges.add(newEdge);</span><br><span class="line">        &#125;</span><br><span class="line">        return graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Graph &#123;</span><br><span class="line">        // 熟悉的图结构信息</span><br><span class="line">        // 节点的集合</span><br><span class="line">        public HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        // 节点出去的有向边的集合</span><br><span class="line">        public HashSet&lt;Edge&gt; edges;</span><br><span class="line">        public Graph() &#123;</span><br><span class="line">            nodes = new HashMap&lt;&gt;();</span><br><span class="line">            edges = new HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Edge &#123;</span><br><span class="line">        // 有向边的信息</span><br><span class="line">        // 权值</span><br><span class="line">        public int weight;</span><br><span class="line">        // 起点</span><br><span class="line">        public Node from;</span><br><span class="line">        // 终点</span><br><span class="line">        public Node to;</span><br><span class="line">        public Edge(int weight, Node from, Node to) &#123;</span><br><span class="line">            this.weight = weight;</span><br><span class="line">            this.from = from;</span><br><span class="line">            this.to = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        // 节点的信息</span><br><span class="line">        // 节点值</span><br><span class="line">        public int value;</span><br><span class="line">        // 节点的入度即指入的有向边数</span><br><span class="line">        public int in;</span><br><span class="line">        // 节点的出度即指出的有向边数</span><br><span class="line">        public int out;</span><br><span class="line">        // 节点指出的邻接节点</span><br><span class="line">        public ArrayList&lt;Node&gt; nexts;</span><br><span class="line">        // 节点指出的邻接有向边</span><br><span class="line">        public ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        public Node(int val) &#123;</span><br><span class="line">            this.value = val;</span><br><span class="line">            this.in = 0;</span><br><span class="line">            this.out = 0;</span><br><span class="line">            this.nexts = new ArrayList&lt;&gt;();</span><br><span class="line">            this.edges = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的宽度-广度-优先遍历BFS"><a href="#图的宽度-广度-优先遍历BFS" class="headerlink" title="图的宽度(广度)优先遍历BFS"></a>图的宽度(广度)优先遍历BFS</h2><p><strong>定义：BFS（Breadth First Search）,每一层逐一遍历，同层顺序可任意。</strong></p>
<ol>
<li>利用队列实现</li>
<li>从源节点开始依次按照宽度进队列，然后弹出</li>
<li>每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</li>
<li>直到队列变空</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 从node出发，进行宽度(广度)优先遍历</span><br><span class="line">    public static void bfs(Node start) &#123;</span><br><span class="line">        if (start == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 准备一个队列，先进先出</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        // 准备一个set，登记不允许重复进入</span><br><span class="line">        HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        // 入队列</span><br><span class="line">        queue.add(start);</span><br><span class="line">        // 登记</span><br><span class="line">        set.add(start);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            // 只要队列不为空，就弹出</span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            // 出队列即打印</span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">            // 将当前节点的邻接节点都加入set</span><br><span class="line">            for (Node next : cur.nexts) &#123;</span><br><span class="line">                if (!set.contains(next)) &#123;</span><br><span class="line">                    // 必须是没有被添加过set的节点,否则容易死循环</span><br><span class="line">                    // 登记</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    // 入队列</span><br><span class="line">                    queue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的深度优先遍历DFS"><a href="#图的深度优先遍历DFS" class="headerlink" title="图的深度优先遍历DFS"></a>图的深度优先遍历DFS</h2><p><strong>定义:DFS（Depth First Search）,一句话，每次都要走到死胡同才走新的路</strong></p>
<ol>
<li>利用栈实现</li>
<li>从源节点开始把节点按照深度放入栈，然后弹出</li>
<li>每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</li>
<li>直到栈变空</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 深度优先遍历</span><br><span class="line">    public static void dfs(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 栈本质上保存了当前深度的一条路</span><br><span class="line">        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        // 登记表</span><br><span class="line">        HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        // 压栈</span><br><span class="line">        stack.add(node);</span><br><span class="line">        // 登记</span><br><span class="line">        set.add(node);</span><br><span class="line">        // 每次压栈时打印</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            // 这里会不停的回溯到所有节点，一句话，每次都要走到死胡同才走新的路</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            // 遍历当前节点的所有邻接点</span><br><span class="line">            for (Node next : cur.nexts) &#123;</span><br><span class="line">                if (!set.contains(next)) &#123;</span><br><span class="line">                    // 如果其中一个邻接点没有登记过，则登记并压栈当前节点和邻接点</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    // 每次压栈时打印</span><br><span class="line">                    System.out.println(next.value);</span><br><span class="line">                    // 后续的邻接点直接跳过，因为有回溯</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的拓扑排序算法"><a href="#图的拓扑排序算法" class="headerlink" title="图的拓扑排序算法"></a>图的拓扑排序算法</h2><ol>
<li>在图中找到所有入度为0的点输出</li>
<li>把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始</li>
<li>图的所有点都被删除后，依次输出的顺序就是拓扑排序</li>
</ol>
<p>要求：一定是<strong>有向无环图</strong>即有向图且没有环</p>
<p>应用：事件安排、编译顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// directed graph and no loop有向无环图的拓扑算法排序</span><br><span class="line">    public static List&lt;Node&gt; sortedTopology(Graph graph) &#123;</span><br><span class="line">        // key 某个节点   value 剩余的入度</span><br><span class="line">        HashMap&lt;Node, Integer&gt; inMap = new HashMap&lt;&gt;();</span><br><span class="line">        // 只有剩余入度为0的点，才进入这个队列</span><br><span class="line">        Queue&lt;Node&gt; zeroInQueue = new LinkedList&lt;&gt;();</span><br><span class="line">        for (Node node : graph.nodes.values()) &#123;</span><br><span class="line">            // 遍历所有图的节点</span><br><span class="line">            inMap.put(node, node.in);</span><br><span class="line">            if (node.in == 0) &#123;</span><br><span class="line">                // 找到第一批入度为0的点</span><br><span class="line">                zeroInQueue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        while (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">            // 周而复始的查找入度为0的节点</span><br><span class="line">            Node cur = zeroInQueue.poll();</span><br><span class="line">            // 弹出队列，并添加到list</span><br><span class="line">            result.add(cur);</span><br><span class="line">            // 遍历当前节点的所有邻接节点</span><br><span class="line">            for (Node next : cur.nexts) &#123;</span><br><span class="line">                // 邻接节点的入度减1</span><br><span class="line">                inMap.put(next, inMap.get(next) - 1);</span><br><span class="line">                if (inMap.get(next) == 0) &#123;</span><br><span class="line">                    // 找到入度为0的点</span><br><span class="line">                    zeroInQueue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树之Kruskal即K算法"><a href="#最小生成树之Kruskal即K算法" class="headerlink" title="最小生成树之Kruskal即K算法"></a>最小生成树之Kruskal即K算法</h2><p><strong>最小生成树定义</strong>：所有的点都连通且无环的最小权值边的集合。</p>
<ol>
<li>总是从权值最小的边开始考虑，依次考察权值依次变大的边，可用小根堆排序</li>
<li>遍历所有边，当前的边要么进入最小生成树的集合，要么丢弃</li>
<li>如果边的2个节点至少1个不在最小生成树的集合中，就要当前边</li>
<li>如果边的2个节点都在最小生成树的集合中，就不要当前边</li>
<li>考察完所有边之后，最小生成树的集合也得到了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Kruskal &#123;</span><br><span class="line">    public static Set&lt;Edge&gt; kruskalMST(Graph graph) &#123;</span><br><span class="line">        // K算法</span><br><span class="line">        UnionFind unionFind = new UnionFind();</span><br><span class="line">        unionFind.makeSets(graph.nodes.values());</span><br><span class="line">        // 从小的边到大的边，依次弹出，小根堆！</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;&gt;(new EdgeComparator());</span><br><span class="line">        for (Edge edge : graph.edges) &#123; // M 条边</span><br><span class="line">            priorityQueue.add(edge);  // O(logM)</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Edge&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">        // 遍历所有的边集</span><br><span class="line">        while (!priorityQueue.isEmpty()) &#123; // M 条边</span><br><span class="line">            // 依次弹出最小权值的边</span><br><span class="line">            Edge edge = priorityQueue.poll(); // O(logM)</span><br><span class="line">            // 判断边的2个节点是否在最小生成树的集合并查集里</span><br><span class="line">            if (!unionFind.isSameSet(edge.from, edge.to)) &#123; // O(1)</span><br><span class="line">                // 不在，则添加</span><br><span class="line">                result.add(edge);</span><br><span class="line">                unionFind.union(edge.from, edge.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Union-Find Set左神的并查集</span><br><span class="line">    public static class UnionFind &#123;</span><br><span class="line">        // key 某一个节点， value key节点往上的节点</span><br><span class="line">        private HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">        // key 某一个集合的代表节点, value key所在集合的节点个数</span><br><span class="line">        private HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        public UnionFind() &#123;</span><br><span class="line">            fatherMap = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">            sizeMap = new HashMap&lt;Node, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void makeSets(Collection&lt;Node&gt; nodes) &#123;</span><br><span class="line">            fatherMap.clear();</span><br><span class="line">            sizeMap.clear();</span><br><span class="line">            for (Node node : nodes) &#123;</span><br><span class="line">                fatherMap.put(node, node);</span><br><span class="line">                sizeMap.put(node, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private Node findFather(Node n) &#123;</span><br><span class="line">            Stack&lt;Node&gt; path = new Stack&lt;&gt;();</span><br><span class="line">            while (n != fatherMap.get(n)) &#123;</span><br><span class="line">                path.add(n);</span><br><span class="line">                n = fatherMap.get(n);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!path.isEmpty()) &#123;</span><br><span class="line">                fatherMap.put(path.pop(), n);</span><br><span class="line">            &#125;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isSameSet(Node a, Node b) &#123;</span><br><span class="line">            return findFather(a) == findFather(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void union(Node a, Node b) &#123;</span><br><span class="line">            if (a == null || b == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Node aDai = findFather(a);</span><br><span class="line">            Node bDai = findFather(b);</span><br><span class="line">            if (aDai != bDai) &#123;</span><br><span class="line">                int aSetSize = sizeMap.get(aDai);</span><br><span class="line">                int bSetSize = sizeMap.get(bDai);</span><br><span class="line">                if (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">                    fatherMap.put(aDai, bDai);</span><br><span class="line">                    sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">                    sizeMap.remove(aDai);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fatherMap.put(bDai, aDai);</span><br><span class="line">                    sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">                    sizeMap.remove(bDai);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class EdgeComparator implements Comparator&lt;Edge&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Edge o1, Edge o2) &#123;</span><br><span class="line">            return o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树之Prim即P算法"><a href="#最小生成树之Prim即P算法" class="headerlink" title="最小生成树之Prim即P算法"></a>最小生成树之Prim即P算法</h2><p>核心：点解锁边，边解锁点，点解锁边…不断重复下去，直到所有点加入集合中</p>
<p>定义一个已解锁点集合nodeSet和一个已解锁边集合edgeSet</p>
<ol>
<li>随机选择一个点加入nodeSet中，并将与它相连的边加入edgeSet。假设我们选择了A点</li>
<li>选择已解锁边集合中权值最小且边的另一个点不在已解锁点集合中，选择后将该边从已解锁边集合删除，并把另一个点加入已解锁点集合中</li>
<li>重复第②步直到所有的点加入了已解锁集合</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Prim &#123;</span><br><span class="line">    //定义一个堆比较器，将边的权值从小到大排序</span><br><span class="line">    public static class EdgeComparator implements Comparator&lt;Edge&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Edge o1, Edge o2) &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            return o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Set&lt;Edge&gt; primSet(Graph graph) &#123;</span><br><span class="line">        // P算法</span><br><span class="line">        // 优先级队列，按照从小到大排序</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;&gt;(new EdgeComparator());</span><br><span class="line">        //解锁出来的Node</span><br><span class="line">        HashSet&lt;Node&gt; nodeSet = new HashSet&lt;&gt;();</span><br><span class="line">        //解锁出来的edge,也可以不用，用了可以提高效率和去重</span><br><span class="line">        HashSet&lt;Edge&gt; edgeSet = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Edge&gt; result = new HashSet&lt;&gt;();    //依次挑选的边放在result</span><br><span class="line">        for (Node node : graph.nodes.values()) &#123;    //随便挑了一个点,此for循环防止出现森林即多个独立的图</span><br><span class="line">            //node是开始点，任意点开始</span><br><span class="line">            if (!nodeSet.contains(node)) &#123;</span><br><span class="line">                // 当前节点不在集合中，则可解锁</span><br><span class="line">                nodeSet.add(node);</span><br><span class="line">                // 点解锁边</span><br><span class="line">                for (Edge edge : node.edges) &#123;    //由该点解锁所有相关的边</span><br><span class="line">                    if (!edgeSet.contains(edge)) &#123;</span><br><span class="line">                        // 过滤当前节点没有被解锁的边集</span><br><span class="line">                        priorityQueue.add(edge);</span><br><span class="line">                        edgeSet.add(edge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 逐一遍历已解锁的最小权值的边集</span><br><span class="line">                while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                    Edge edge = priorityQueue.poll();    //弹出已解锁边中的最小边</span><br><span class="line">                    Node toNode = edge.to;    //可能的新一个节点</span><br><span class="line">                    // 边解锁点</span><br><span class="line">                    if (!nodeSet.contains(toNode)) &#123;</span><br><span class="line">                        nodeSet.add(toNode);</span><br><span class="line">                        result.add(edge);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 点解锁边</span><br><span class="line">                    for (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                        if (!edgeSet.contains(nextEdge)) &#123;</span><br><span class="line">                            priorityQueue.add(nextEdge);</span><br><span class="line">                            edgeSet.add(nextEdge);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最短路径算法之Dijkstra算法"><a href="#最短路径算法之Dijkstra算法" class="headerlink" title="最短路径算法之Dijkstra算法"></a>最短路径算法之Dijkstra算法</h2><p><strong>狄利克斯拉算法</strong>是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。 迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</p>
<ul>
<li>解法1：贪心法遍历所有节点</li>
<li>解法2：改进后的dijkstra算法，就是利用动态小根堆，优化getMinDistanceAndUnselectedNode方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line">public class Code06_Dijkstra &#123;</span><br><span class="line">    // 狄利克斯拉算法</span><br><span class="line">    public static class Edge &#123;</span><br><span class="line">        // 有向边的信息</span><br><span class="line">        // 权值</span><br><span class="line">        public int weight;</span><br><span class="line">        // 起点</span><br><span class="line">        public Node from;</span><br><span class="line">        // 终点</span><br><span class="line">        public Node to;</span><br><span class="line">        public Edge(int weight, Node from, Node to) &#123;</span><br><span class="line">            this.weight = weight;</span><br><span class="line">            this.from = from;</span><br><span class="line">            this.to = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        // 节点的信息</span><br><span class="line">        // 节点值</span><br><span class="line">        public int value;</span><br><span class="line">        // 节点的入度即指入的有向边数</span><br><span class="line">        public int in;</span><br><span class="line">        // 节点的出度即指出的有向边数</span><br><span class="line">        public int out;</span><br><span class="line">        // 节点指出的邻接节点</span><br><span class="line">        public ArrayList&lt;Node&gt; nexts;</span><br><span class="line">        // 节点指出的邻接有向边</span><br><span class="line">        public ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        public Node(int val) &#123;</span><br><span class="line">            this.value = val;</span><br><span class="line">            this.in = 0;</span><br><span class="line">            this.out = 0;</span><br><span class="line">            this.nexts = new ArrayList&lt;&gt;();</span><br><span class="line">            this.edges = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法1：贪心法遍历所有节点</span><br><span class="line">    public static HashMap&lt;Node, Integer&gt; dijkstra1(Node from) &#123;</span><br><span class="line">        // 狄利克斯拉算法:从任意一个点出发，得到一个map的最小距离表</span><br><span class="line">        HashMap&lt;Node, Integer&gt; distanceMap = new HashMap&lt;&gt;();</span><br><span class="line">        // 键表示默认form-key，比如from到from,所以距离为0</span><br><span class="line">        distanceMap.put(from, 0);</span><br><span class="line">        // 已经计算好的节点，把它锁定</span><br><span class="line">        HashSet&lt;Node&gt; selectedNodes = new HashSet&lt;&gt;();</span><br><span class="line">        // 在剩下已有的最短距离表中，剔除掉锁定算好的节点，依次找出最小距离的点。定义为当前最小距离点</span><br><span class="line">        Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">        while (minNode != null) &#123;</span><br><span class="line">            //  原始点form  -&gt;  minNode(跳转点)   最小距离distance</span><br><span class="line">            int distance = distanceMap.get(minNode);</span><br><span class="line">            // 取出最小距离点的所有指向边</span><br><span class="line">            for (Edge edge : minNode.edges) &#123;</span><br><span class="line">                // 遍历所有的边，以便接下来完成该点的更新</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                if (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                    // 如果最小距离表中没有该节点，直接添加。注意需要加上之前的距离</span><br><span class="line">                    distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">                &#125; else &#123; // toNode</span><br><span class="line">                    // 如果添加过，则判断过去的值与当前值，取最小值更新</span><br><span class="line">                    distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前最小距离点计算完后，就锁定，后续不再更新它的最短距离，完成该点的更新</span><br><span class="line">            selectedNodes.add(minNode);</span><br><span class="line">            // 继续找下一个当前最小距离点</span><br><span class="line">            minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        return distanceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Node getMinDistanceAndUnselectedNode(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes) &#123;</span><br><span class="line">        // 方法名很长，很唬人，本质是返回最小距离表中，未被锁定且最小距离的节点。方便后续继续计算最短记录。</span><br><span class="line">        Node minNode = null;</span><br><span class="line">        int minDistance = Integer.MAX_VALUE;</span><br><span class="line">        for (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">            // 遍历最小距离表</span><br><span class="line">            Node node = entry.getKey();</span><br><span class="line">            int distance = entry.getValue();</span><br><span class="line">            if (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">                // 找出最小距离表中，未被锁定且最小距离的节点</span><br><span class="line">                minNode = node;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NodeRecord &#123;</span><br><span class="line">        // 最小距离表的节点</span><br><span class="line">        public Node node;</span><br><span class="line">        // 最短距离</span><br><span class="line">        public int distance;</span><br><span class="line"></span><br><span class="line">        public NodeRecord(Node node, int distance) &#123;</span><br><span class="line">            this.node = node;</span><br><span class="line">            this.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NodeHeap &#123;</span><br><span class="line">        // 动态小根堆结构</span><br><span class="line">        private Node[] nodes; // 实际的堆结构</span><br><span class="line">        // 节点索引记录表：key 某一个node， value 上面堆中的位置</span><br><span class="line">        private HashMap&lt;Node, Integer&gt; heapIndexMap;</span><br><span class="line">        // key 某一个节点， value 从源节点出发到该节点的目前最小距离</span><br><span class="line">        private HashMap&lt;Node, Integer&gt; distanceMap;</span><br><span class="line">        private int size; // 堆上有多少个点</span><br><span class="line"></span><br><span class="line">        public NodeHeap(int size) &#123;</span><br><span class="line">            nodes = new Node[size];</span><br><span class="line">            heapIndexMap = new HashMap&lt;&gt;();</span><br><span class="line">            distanceMap = new HashMap&lt;&gt;();</span><br><span class="line">            size = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return size == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span><br><span class="line">        // 集成添加，更新，直接跳过</span><br><span class="line">        public void addOrUpdateOrIgnore(Node node, int distance) &#123;</span><br><span class="line">            // 已经在小根堆里，更新最小距离，然后上窜</span><br><span class="line">            if (inHeap(node)) &#123;</span><br><span class="line">                // 更新最短距离</span><br><span class="line">                distanceMap.put(node, Math.min(distanceMap.get(node), distance));</span><br><span class="line">                // 上窜</span><br><span class="line">                insertHeapify(heapIndexMap.get(node));</span><br><span class="line">            &#125;</span><br><span class="line">            // 没有进去过记录表的，直接添加，然后上窜</span><br><span class="line">            if (!isEntered(node)) &#123;</span><br><span class="line">                nodes[size] = node;</span><br><span class="line">                heapIndexMap.put(node, size);</span><br><span class="line">                distanceMap.put(node, distance);</span><br><span class="line">                // 上窜</span><br><span class="line">                insertHeapify(size++);</span><br><span class="line">            &#125;</span><br><span class="line">            // 已经记录并更新的节点，锁定，直接跳过</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 弹出小根堆顶部最小值，并继续小根堆化</span><br><span class="line">        public NodeRecord pop() &#123;</span><br><span class="line">            NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));</span><br><span class="line">            swap(0, size - 1);</span><br><span class="line">            heapIndexMap.put(nodes[size - 1], -1);</span><br><span class="line">            distanceMap.remove(nodes[size - 1]);</span><br><span class="line">            // free C++同学还要把原本堆顶节点析构，对java同学不必</span><br><span class="line">            nodes[size - 1] = null;</span><br><span class="line">            // 下窜</span><br><span class="line">            heapify(0, --size);</span><br><span class="line">            return nodeRecord;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 上窜</span><br><span class="line">        private void insertHeapify(int index) &#123;</span><br><span class="line">            while (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - 1) / 2])) &#123;</span><br><span class="line">                swap(index, (index - 1) / 2);</span><br><span class="line">                index = (index - 1) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 下窜</span><br><span class="line">        private void heapify(int index, int size) &#123;</span><br><span class="line">            int left = index * 2 + 1;</span><br><span class="line">            while (left &lt; size) &#123;</span><br><span class="line">                int smallest = left + 1 &lt; size &amp;&amp; distanceMap.get(nodes[left + 1]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">                        ? left + 1</span><br><span class="line">                        : left;</span><br><span class="line">                smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">                if (smallest == index) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(smallest, index);</span><br><span class="line">                index = smallest;</span><br><span class="line">                left = index * 2 + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private boolean isEntered(Node node) &#123;</span><br><span class="line">            return heapIndexMap.containsKey(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private boolean inHeap(Node node) &#123;</span><br><span class="line">            return isEntered(node) &amp;&amp; heapIndexMap.get(node) != -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void swap(int index1, int index2) &#123;</span><br><span class="line">            heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">            heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">            Node tmp = nodes[index1];</span><br><span class="line">            nodes[index1] = nodes[index2];</span><br><span class="line">            nodes[index2] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法2：改进后的dijkstra算法，就是利用动态小根堆，优化getMinDistanceAndUnselectedNode方法。</span><br><span class="line">    // 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span><br><span class="line">    public static HashMap&lt;Node, Integer&gt; dijkstra2(Node head, int size) &#123;</span><br><span class="line">        NodeHeap nodeHeap = new NodeHeap(size);</span><br><span class="line">        // 从0开始更新</span><br><span class="line">        nodeHeap.addOrUpdateOrIgnore(head, 0);</span><br><span class="line">        HashMap&lt;Node, Integer&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        while (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">            // 从小根堆汇总逐一弹出顶部节点</span><br><span class="line">            NodeRecord record = nodeHeap.pop();</span><br><span class="line">            Node cur = record.node;</span><br><span class="line">            int distance = record.distance;</span><br><span class="line">            // 遍历节点的所有指向边</span><br><span class="line">            for (Edge edge : cur.edges) &#123;</span><br><span class="line">                // 继续更新最短距离点</span><br><span class="line">                nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新一个节点，锁定一个，返回一个</span><br><span class="line">            result.put(cur, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TSP问题"><a href="#TSP问题" class="headerlink" title="TSP问题"></a>TSP问题</h2><p>也叫商旅问题，非常之难。问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。</p>
<h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h2><p>题目：给出两个单词（<code>start</code>和<code>end</code>）和一个字典，找出所有从<code>start</code>到<code>end</code>的最短转换序列。</p>
<p>变换规则如下：</p>
<ol>
<li>每次只能改变一个字母。</li>
<li>变换过程中的中间单词必须在字典中出现。</li>
</ol>
<ul>
<li>解法1：图的宽度优先遍历和深度优先遍历的最强综合应用。返回从start变换到end的所有最短路径集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">// 本题测试链接 : https://leetcode.com/problems/word-ladder-ii/</span><br><span class="line">public class Code04_WordLadderII &#123;</span><br><span class="line">   // 解法1：图的宽度优先遍历和深度优先遍历的最强综合应用。返回从start变换到end的所有最短路径集合</span><br><span class="line">   public static List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; list) &#123;</span><br><span class="line">      list.add(start);</span><br><span class="line">      // 返回list列表的,每个字符串对应的所有直接邻居(限制在当前list)。因为是所有list元素的直接邻居，可以认为是一张list节点的图</span><br><span class="line">      HashMap&lt;String, List&lt;String&gt;&gt; nexts = getNexts(list);</span><br><span class="line">      // 在图的结构中，获取所有节点到start节点的最短距离，利用宽度优先遍历求解，横向一直走，只保留距离+1的节点</span><br><span class="line">      HashMap&lt;String, Integer&gt; fromDistances = getDistances(start, nexts);</span><br><span class="line">      List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">      // 如果最短距离列表中，没有目的节点，那么一定不能变换，返回空</span><br><span class="line">      if (!fromDistances.containsKey(end)) &#123;</span><br><span class="line">         return res;</span><br><span class="line">      &#125;</span><br><span class="line">      // 同上</span><br><span class="line">      HashMap&lt;String, Integer&gt; toDistances = getDistances(end, nexts);</span><br><span class="line">      LinkedList&lt;String&gt; pathList = new LinkedList&lt;&gt;();</span><br><span class="line">      // 获取最短路径，入参：从start当前节点变换到ends字符串，nexts是邻居表，fromDistances是当前节点到start节点的距离，toDistances是当前节点到end节点的距离，pathList表示实时路径，res是最终路径集合</span><br><span class="line">      getShortestPaths(start, end, nexts, fromDistances, toDistances, pathList, res);</span><br><span class="line">      return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static HashMap&lt;String, List&lt;String&gt;&gt; getNexts(List&lt;String&gt; words) &#123;</span><br><span class="line">      HashSet&lt;String&gt; dict = new HashSet&lt;&gt;(words);</span><br><span class="line">      HashMap&lt;String, List&lt;String&gt;&gt; nexts = new HashMap&lt;&gt;();</span><br><span class="line">      for (int i = 0; i &lt; words.size(); i++) &#123;</span><br><span class="line">         nexts.put(words.get(i), getNext(words.get(i), dict));</span><br><span class="line">      &#125;</span><br><span class="line">      return nexts;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // word, 在表中，有哪些邻居，把邻居们，生成list返回</span><br><span class="line">   public static List&lt;String&gt; getNext(String word, HashSet&lt;String&gt; dict) &#123;</span><br><span class="line">      ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">      char[] chs = word.toCharArray();</span><br><span class="line">      for (char cur = &#x27;a&#x27;; cur &lt;= &#x27;z&#x27;; cur++) &#123;</span><br><span class="line">         for (int i = 0; i &lt; chs.length; i++) &#123;</span><br><span class="line">            if (chs[i] != cur) &#123;</span><br><span class="line">               char tmp = chs[i];</span><br><span class="line">               chs[i] = cur;</span><br><span class="line">               if (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                  res.add(String.valueOf(chs));</span><br><span class="line">               &#125;</span><br><span class="line">               chs[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 图的宽度优先遍历：生成距离表，从start开始，根据邻居表，宽度优先遍历，对于能够遇到的所有字符串，生成(字符串，距离)这条记录，放入距离表中</span><br><span class="line">   public static HashMap&lt;String, Integer&gt; getDistances(String start, HashMap&lt;String, List&lt;String&gt;&gt; nexts) &#123;</span><br><span class="line">      HashMap&lt;String, Integer&gt; distances = new HashMap&lt;&gt;();</span><br><span class="line">      distances.put(start, 0);</span><br><span class="line">      Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(start);</span><br><span class="line">      HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">      set.add(start);</span><br><span class="line">      while (!queue.isEmpty()) &#123;</span><br><span class="line">         String cur = queue.poll();</span><br><span class="line">         for (String next : nexts.get(cur)) &#123;</span><br><span class="line">            if (!set.contains(next)) &#123;</span><br><span class="line">               distances.put(next, distances.get(cur) + 1);</span><br><span class="line">               queue.add(next);</span><br><span class="line">               set.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return distances;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // cur 当前来到的字符串 可变</span><br><span class="line">   // to 目标，固定参数</span><br><span class="line">   // nexts 每一个字符串的邻居表</span><br><span class="line">   // cur 到开头距离5 -&gt; 到开头距离是6的支路 fromDistances距离表</span><br><span class="line">   // cur 到结尾距离5 -&gt; 到开头距离是4的支路 toDistances距离表</span><br><span class="line">   // path : 来到cur之前，深度优先遍历之前的历史是什么</span><br><span class="line">   // res : 当遇到cur，把历史，放入res，作为一个结果</span><br><span class="line">   // 图的深度优先遍历</span><br><span class="line">   public static void getShortestPaths(String cur, String to, HashMap&lt;String, List&lt;String&gt;&gt; nexts,</span><br><span class="line">         HashMap&lt;String, Integer&gt; fromDistances, HashMap&lt;String, Integer&gt; toDistances, LinkedList&lt;String&gt; path,</span><br><span class="line">         List&lt;List&lt;String&gt;&gt; res) &#123;</span><br><span class="line">      // 直接添加当前节点</span><br><span class="line">      path.add(cur);</span><br><span class="line">      if (to.equals(cur)) &#123;</span><br><span class="line">         // 当前节点和目的节点相同，说明变换成功了，直接记录一条路径</span><br><span class="line">         res.add(new LinkedList&lt;String&gt;(path));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         // 递归邻居表</span><br><span class="line">         for (String next : nexts.get(cur)) &#123;</span><br><span class="line">            // 当下一个节点放进来后，往前的距离+1，往后的距离-1，才进行递归</span><br><span class="line">            if (fromDistances.get(next) == fromDistances.get(cur) + 1</span><br><span class="line">                  &amp;&amp; toDistances.get(next) == toDistances.get(cur) - 1) &#123;</span><br><span class="line">               getShortestPaths(next, to, nexts, fromDistances, toDistances, path, res);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果不满足上述条件，需要弹出前面添加的节点，路径重新添加分支走下去</span><br><span class="line">      path.pollLast();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>重要重要重要：笔试最差也要改为傻缓存dp表跟随的动态规划（也就是记忆化搜索方法），面试尽可能改为精细化动态规划填dp表</p>
<p><strong>动态规划的终极套路</strong></p>
<ol>
<li>先写<em>暴力递归的尝试过程</em></li>
<li>将暴力递归改为为<em>记忆化搜索</em>即带缓存的暴力递归，leetcode能通过。记忆化搜索也是dp的一种。</li>
<li>用dp状态转移方程精细化后变成<em>动态规划</em>，leetcode能通过</li>
</ol>
<blockquote>
<p><strong>动态规划的4种经典尝试模型</strong></p>
<ol>
<li><strong>DP1：从左往右的尝试模型</strong>，关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</li>
<li><strong>DP2：从L–R范围上的尝试模型</strong>，关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</li>
<li><strong>DP3：多样本位置对应的尝试模型</strong>，2个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</li>
<li><strong>DP4：业务限制类的尝试模型</strong>，比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>记忆化搜索即带缓存的暴力递归-leetcode通过</strong></p>
<p>用缓存dp替代暴力递归中的重复计算过程。</p>
<p>暴力递归改为记忆化搜索套路：</p>
<ul>
<li>(1)先判断下重复过程，dp跟几个参数有关就是几维数组。</li>
<li>(2)递归过程一定携带dp,注意递归还是递归，不改</li>
<li>(3)return的地方改写为取dp值，注意先缓存，再返回值</li>
</ul>
</blockquote>
<blockquote>
<p><strong>动态规划-leetcode通过</strong></p>
<p>将记忆化搜索或暴力递归，直接改写为填写dp表，返回结果需要用到的dp值。前提：需要将记忆化搜索直观的转成可理解的dp表，最好画图。</p>
<p>暴力递归改为dp动态规划套路：</p>
<ul>
<li>(1)return的地方就是设置dp值</li>
<li>(2)添加遍历，注意是dp是几维数组就是几维遍历，关键分析是从左到右，还是从上到下，这个重要</li>
<li>(3)所有递归调用的地方，直接改为dp。这里需要注意前面return的，就是这里的限制条件。<br>这里的本质：填写dp表，把最终的结果用dp表的值返回</li>
</ul>
</blockquote>
<p><strong>任何一个暴力递归优化成结构化描述的动态规划，需要满足两个条件：</strong></p>
<ul>
<li>暴力递归中有重复计算的过程</li>
<li>有限的可变参数影响结果</li>
</ul>
<p>不满足以上2个条件的暴力递归，要么无法改为动态规划(不是有限可变参数)，要么即使改成动态规划也意义不大(没有重复过程，缓存没有意义)。</p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p>暴力递归就是尝试</p>
<ol>
<li>把问题转化为规模缩小的同类问题的子问题</li>
<li>有明确的不需要继续进行递归的条件(base case)</li>
<li>有当得到了子问题的结果之后的决策过程</li>
<li>不记录每一个子问题的解。如果真的要记录了，就是动态规划了</li>
</ol>
<p><strong>熟悉什么叫尝试</strong></p>
<ul>
<li>1.打印n层汉诺塔从最左边移动到最右边的全过程</li>
<li>2.打印一个字符串的全部子序列</li>
<li>3.打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复</li>
<li>4.打印一个字符串的全部排列</li>
<li>5.打印一个字符串的全部排列，要求不重复的排列</li>
</ul>
<p><strong>子串、子序列、排列区别：</strong></p>
<p>例子：abcd</p>
<ul>
<li>子串：连续的有序，a,ab,abc,abcd,b,bc,bcd,c,cd</li>
<li>子序列：不连续有序，是a,b,c,d,ab,ac,ad,bc,bd,cd,abc,abd,acd,abcd</li>
<li>全排列：不连续无序，abcd,abdc,acbd,acdb…</li>
<li>排列组合：不连续无序，a,b,c,ab,ac,ad….</li>
</ul>
<p><strong>1.汉诺塔问题</strong></p>
<p>题目：三个柱子，A、B、C，在A柱子上从上到下依次放着从小到大的盘子，每次只能拿一个盘子，怎么把盘子搬动到另外的柱子上而保证盘子的大小顺序完全一致？要求搬动过程中，必须保证大盘子在下，小盘子在上。</p>
<p>思路：核心就是拆解为三大步,假设三个柱子是from other to。N层汉诺塔问题的步数一定是<strong>2^N-1</strong>步。</p>
<blockquote>
<p>第一步：1到N-1个盘子从from移动到other,腾位置给后续第N个盘子移动</p>
<p>第二步：第N个盘子从from移动到to</p>
<p>第三步：1到N-1个盘子从other移动到to。搞定</p>
</blockquote>
<ul>
<li>解法1：暴力递归的三步曲</li>
<li>解法2：暴力递归的三部曲优化为from起点,to终点,other其他.推荐</li>
<li>解法3：非递归方法，利用栈模拟递归调用，关键参数base表示多少层，finish1表示第一步是否完成。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class Code02_Hanoi &#123;</span><br><span class="line">    public static void hanoi1(int n) &#123;</span><br><span class="line">        // 解法1：暴力递归的三步曲</span><br><span class="line">        leftToRight(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 请把1~N层圆盘 从左 -&gt; 右</span><br><span class="line">    public static void leftToRight(int n) &#123;</span><br><span class="line">        // 明确的不需要继续进行递归的条件(base case)即左边只剩下一个N号盘子，直接移动过去</span><br><span class="line">        if (n == 1) &#123; // base case</span><br><span class="line">            System.out.println(&quot;Move 1 from left to right&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一步：1到N-1个盘子从from移动到other,腾位置给后续第N个盘子移动</span><br><span class="line">        leftToMid(n - 1);</span><br><span class="line">        // 第二步：第N个盘子从from移动到to</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from left to right&quot;);</span><br><span class="line">        // 第三步：1到N-1个盘子从other移动到to。</span><br><span class="line">        midToRight(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 请把1~N层圆盘 从左 -&gt; 中</span><br><span class="line">    public static void leftToMid(int n) &#123;</span><br><span class="line">        // 同上一样的三步曲</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Move 1 from left to mid&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        leftToRight(n - 1);</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from left to mid&quot;);</span><br><span class="line">        rightToMid(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void rightToMid(int n) &#123;</span><br><span class="line">        // 同上一样的三步曲</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Move 1 from right to mid&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        rightToLeft(n - 1);</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from right to mid&quot;);</span><br><span class="line">        leftToMid(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void midToRight(int n) &#123;</span><br><span class="line">        // 同上一样的三步曲</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Move 1 from mid to right&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        midToLeft(n - 1);</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from mid to right&quot;);</span><br><span class="line">        leftToRight(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void midToLeft(int n) &#123;</span><br><span class="line">        // 同上一样的三步曲</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Move 1 from mid to left&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        midToRight(n - 1);</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from mid to left&quot;);</span><br><span class="line">        rightToLeft(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void rightToLeft(int n) &#123;</span><br><span class="line">        // 同上一样的三步曲</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Move 1 from right to left&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        rightToMid(n - 1);</span><br><span class="line">        System.out.println(&quot;Move &quot; + n + &quot; from right to left&quot;);</span><br><span class="line">        midToLeft(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void hanoi2(int n) &#123;</span><br><span class="line">        // 解法2：暴力递归的三部曲优化为from起点,to终点,other其他.</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            func(n, &quot;left&quot;, &quot;right&quot;, &quot;mid&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // n个盘子，从from移动到to,借助other</span><br><span class="line">    public static void func(int N, String from, String to, String other) &#123;</span><br><span class="line">        if (N == 1) &#123; // base case</span><br><span class="line">            // 最后form剩下N号盘子，直接移动过去</span><br><span class="line">            System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // from还有盘子话</span><br><span class="line">            // 第一步：1到N-1个盘子从from移动到other,腾位置</span><br><span class="line">            func(N - 1, from, other, to);</span><br><span class="line">            // 第二步：第N个盘子从from移动到to</span><br><span class="line">            System.out.println(&quot;Move &quot; + N + &quot; from &quot; + from + &quot; to &quot; + to);</span><br><span class="line">            // 第三步：1到N-1个盘子从other移动到to。搞定</span><br><span class="line">            func(N - 1, other, to, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Record &#123;</span><br><span class="line">        public boolean finish1;</span><br><span class="line">        public int base;</span><br><span class="line">        public String from;</span><br><span class="line">        public String to;</span><br><span class="line">        public String other;</span><br><span class="line"></span><br><span class="line">        public Record(boolean f1, int b, String f, String t, String o) &#123;</span><br><span class="line">            finish1 = false;</span><br><span class="line">            base = b;</span><br><span class="line">            from = f;</span><br><span class="line">            to = t;</span><br><span class="line">            other = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法3：非递归方法，利用栈模拟递归调用，关键参数base表示多少层，finish1表示第一步是否完成。</span><br><span class="line">    public static void hanoi3(int N) &#123;</span><br><span class="line">        if (N &lt; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Record&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.add(new Record(false, N, &quot;left&quot;, &quot;right&quot;, &quot;mid&quot;));</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            Record cur = stack.pop();</span><br><span class="line">            if (cur.base == 1) &#123;</span><br><span class="line">                // 第二步：第N个盘子从from移动到to</span><br><span class="line">                System.out.println(&quot;Move 1 from &quot; + cur.from + &quot; to &quot; + cur.to);</span><br><span class="line">                if (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.peek().finish1 = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!cur.finish1) &#123;</span><br><span class="line">                    // 表示没完成</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    // 第一步：1到N-1个盘子从from移动到other,腾位置</span><br><span class="line">                    stack.push(new Record(false, cur.base - 1, cur.from, cur.other, cur.to));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 第一步完成了，执行下面</span><br><span class="line">                    System.out.println(&quot;Move &quot; + cur.base + &quot; from &quot; + cur.from + &quot; to &quot; + cur.to);</span><br><span class="line">                    // 第三步：1到N-1个盘子从other移动到to。搞定</span><br><span class="line">                    stack.push(new Record(false, cur.base - 1, cur.other, cur.to, cur.from));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = 3;</span><br><span class="line">        hanoi1(n);</span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">        hanoi2(n);</span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">  hanoi3(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.打印一个字符串的全部子序列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 打印一个字符串的全部子序列</span><br><span class="line">public static List&lt;String&gt; subs(String s) &#123;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        String path = &quot;&quot;;</span><br><span class="line">        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        process1(str, 0, ans, path);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // str 固定参数</span><br><span class="line">    // 来到了str[index]字符，index是位置</span><br><span class="line">    // str[0..index-1]已经走过了！之前的决定，都在path上</span><br><span class="line">    // 之前的决定已经不能改变了，就是path</span><br><span class="line">    // str[index....]还能决定，之前已经确定，而后面还能自由选择的话，</span><br><span class="line">    // 把所有生成的子序列，放入到ans里去</span><br><span class="line">    public static void process1(char[] str, int index, List&lt;String&gt; ans, String path) &#123;</span><br><span class="line">        // 索引已经来到最后一个字符，找到了字符串，加入到list</span><br><span class="line">        if (index == str.length) &#123;</span><br><span class="line">            ans.add(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分支左：没有要index位置的字符，path继续</span><br><span class="line">        process1(str, index + 1, ans, path);</span><br><span class="line">        // 分支右：要了index位置的字符，path拼接起来</span><br><span class="line">        process1(str, index + 1, ans, path + String.valueOf(str[index]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 打印一个字符串的全部子序列，要求不重复的字面值的子序列,如abcdac可能出现重复。</span><br><span class="line">public static List&lt;String&gt; subsNoRepeat(String s) &#123;</span><br><span class="line">     // 最终结果使用set集合即可，同题目2，99%相似</span><br><span class="line">     char[] str = s.toCharArray();</span><br><span class="line">     String path = &quot;&quot;;</span><br><span class="line">     HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">     process2(str, 0, set, path);</span><br><span class="line">     List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">     for (String cur : set) &#123;</span><br><span class="line">         ans.add(cur);</span><br><span class="line">     &#125;</span><br><span class="line">     return ans;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void process2(char[] str, int index, HashSet&lt;String&gt; set, String path) &#123;</span><br><span class="line">     if (index == str.length) &#123;</span><br><span class="line">         set.add(path);</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     String no = path;</span><br><span class="line">     process2(str, index + 1, set, no);</span><br><span class="line">     String yes = path + String.valueOf(str[index]);</span><br><span class="line">     process2(str, index + 1, set, yes);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.打印一个字符串的全部排列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; permutation2(String s) &#123;</span><br><span class="line">    // 打印一个字符串的全部排列</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] str = s.toCharArray();</span><br><span class="line">    g1(str, 0, ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void g1(char[] str, int index, List&lt;String&gt; ans) &#123;</span><br><span class="line">    // 索引已经来到最后一个字符，找到了字符串，加入到list</span><br><span class="line">    if (index == str.length) &#123;</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 尝试将索引值index及其后续的字符交换到index上，找到字符串</span><br><span class="line">        for (int i = index; i &lt; str.length; i++) &#123;</span><br><span class="line">            // 交换</span><br><span class="line">            swap(str, index, i);</span><br><span class="line">            // 递归下一个索引值</span><br><span class="line">            g1(str, index + 1, ans);</span><br><span class="line">            // 每次交换完，再恢复到原始现场，方便下次递归使用原始变量</span><br><span class="line">            swap(str, index, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.打印一个字符串的全部排列，要求不重复的排列</strong></p>
<p>最终结果也可以使用set集合即可，同题目4，99%相似。</p>
<p>优化方法：利用分支限界，提前杀死分支支路。即出现过的字符，则不再执行逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; permutation3(String s) &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] str = s.toCharArray();</span><br><span class="line">    g2(str, 0, ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">public static void g2(char[] str, int index, List&lt;String&gt; ans) &#123;</span><br><span class="line">    if (index == str.length) &#123;</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 分支限界，visited类似hash表记录字符是否已被使用过</span><br><span class="line">        boolean[] visited = new boolean[256];</span><br><span class="line">        for (int i = index; i &lt; str.length; i++) &#123;</span><br><span class="line">            if (!visited[str[i] - &#x27;a&#x27;]) &#123;</span><br><span class="line">                // 使用过的字符，不再使用</span><br><span class="line">                visited[str[i] - &#x27;a&#x27;] = true;</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">                g2(str, index + 1, ans);</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈的逆序</strong></p>
<p>题目：给你一个栈，请你逆序这个栈。不能申请额外的数据结构。只能使用递归函数。如何实现。</p>
<p>思路：递归自己一级一级捋。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class Code05_ReverseStackUsingRecursive &#123;</span><br><span class="line">    public static void reverse(Stack&lt;Integer&gt; stack) &#123;</span><br><span class="line">        if (stack.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // i临时记录栈底的元素，并剩余元素盖下来</span><br><span class="line">        int i = f(stack);</span><br><span class="line">        // 递归调用反转函数</span><br><span class="line">        reverse(stack);</span><br><span class="line">        // 先压入1，然后2，然后3</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 功能：返回移除掉的栈底元素，上面的元素盖下来。</span><br><span class="line">    /*</span><br><span class="line">     * 1</span><br><span class="line">     * 2         1</span><br><span class="line">     * 3         2</span><br><span class="line">     * 栈，返回3，栈</span><br><span class="line">     * */</span><br><span class="line">    public static int f(Stack&lt;Integer&gt; stack) &#123;</span><br><span class="line">        // r临时记录栈顶元素，最后是要返回的</span><br><span class="line">        int result = stack.pop();</span><br><span class="line">        if (stack.isEmpty()) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // l临时记录栈底元素</span><br><span class="line">            int last = f(stack);</span><br><span class="line">            // 栈底的元素再压进来，这样每次都是先压上面的</span><br><span class="line">            stack.push(result);</span><br><span class="line">            return last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; test = new Stack&lt;Integer&gt;();</span><br><span class="line">        test.push(1);</span><br><span class="line">        test.push(2);</span><br><span class="line">        test.push(3);</span><br><span class="line">        test.push(4);</span><br><span class="line">        test.push(5);</span><br><span class="line">        reverse(test);</span><br><span class="line">        while (!test.isEmpty()) &#123;</span><br><span class="line">            System.out.println(test.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尝试模型"><a href="#尝试模型" class="headerlink" title="尝试模型"></a>尝试模型</h2><h3 id="从左往右的尝试模型1-字符串转化"><a href="#从左往右的尝试模型1-字符串转化" class="headerlink" title="从左往右的尝试模型1-字符串转化"></a>从左往右的尝试模型1-字符串转化</h3><p>题目：规定1和A对应，2和B对应，3和C对应，那么一串“111”可以转化为“AAA”，“KA”，“AK”三种转化结果。问给定一个只有数字字符组成的字符串str,有多少种转化结果。</p>
<ul>
<li>解法1：暴力递归的尝试过程</li>
<li>解法2：记忆化搜索即带缓存dp的暴力递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">public class Code02_ConvertToLetterString &#123;</span><br><span class="line">    // str只含有数字字符0~9</span><br><span class="line">    // 返回多少种转化方案</span><br><span class="line">    public static int number(String str) &#123;</span><br><span class="line">        // 解法1：暴力递归的尝试过程</span><br><span class="line">        // 边界条件</span><br><span class="line">        if (str == null || str.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录从0开始往后有多少种转换方法</span><br><span class="line">        return process(str.toCharArray(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // str[0..i-1]转化无需过问</span><br><span class="line">    // 表示str[i.....]去转化，返回有多少种转化方法</span><br><span class="line">    public static int process(char[] str, int i) &#123;</span><br><span class="line">        // i到最后，说明没有有字符，记录一种转化方法</span><br><span class="line">        if (i == str.length) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 单独的0是不能记录为一种转化方法的</span><br><span class="line">        if (str[i] == &#x27;0&#x27;) &#123; // 之前的决定有问题</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // str[i] != &#x27;0&#x27;</span><br><span class="line">        // 可能性一，1-9都是可以单独转换的，i不用管,继续往后转换，从i+1开始，有多少种转换</span><br><span class="line">        int ways = process(str, i + 1);</span><br><span class="line">        // 可能性二，10到26即小于27的两位数都是可以转换的</span><br><span class="line">        if (i + 1 &lt; str.length &amp;&amp; (str[i] - &#x27;0&#x27;) * 10 + str[i + 1] - &#x27;0&#x27; &lt; 27) &#123;</span><br><span class="line">            // 继续向后转换</span><br><span class="line">            ways += process(str, i + 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return ways;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从右往左的动态规划</span><br><span class="line">    // 就是上面方法的动态规划版本</span><br><span class="line">    // dp[i]表示：str[i...]有多少种转化方式</span><br><span class="line">    public static int dp1(String s) &#123;</span><br><span class="line">        // 解法2：暴力递归改为dp动态规划</span><br><span class="line">        /*暴力递归改为dp动态规划的核心核心，重要重要重要</span><br><span class="line">         * (1)return的地方就是设置dp值</span><br><span class="line">         * (2)添加遍历，注意是dp是几维数组就是几维遍历，关键分析是从左到右，还是从上到下，这个重要</span><br><span class="line">         * (3)所有递归调用的地方，直接改为dp。这里需要注意前面return的，就是这里的限制条件。</span><br><span class="line">         * */</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        int N = str.length;</span><br><span class="line">        // 开始改写为dp。因为每个所有的字符都要用到，所以N也要。那么久需要N+1的长度。</span><br><span class="line">        int[] dp = new int[N + 1];</span><br><span class="line">        /*dp对应的暴力代码</span><br><span class="line">        if (i == str.length) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;*/</span><br><span class="line">        // return的地方就是设置dp值</span><br><span class="line">        dp[N] = 1;</span><br><span class="line">        // 因为dp是一维数组</span><br><span class="line">        // 前面的值依赖后面的值，所以从右往左遍历</span><br><span class="line">        for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 因为前面的return,所以加限制条件</span><br><span class="line">            if (str[i] != &#x27;0&#x27;) &#123;</span><br><span class="line">                // 递归调用的地方，直接改为dp</span><br><span class="line">                int ways = dp[i + 1];</span><br><span class="line">                if (i + 1 &lt; str.length &amp;&amp; (str[i] - &#x27;0&#x27;) * 10 + str[i + 1] - &#x27;0&#x27; &lt; 27) &#123;</span><br><span class="line">                    ways += dp[i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                // return的地方就是设置dp值</span><br><span class="line">                dp[i] = ways;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为暴力递归是要return process(str.toCharArray(), 0);返回0转态的，所以是0</span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从左往右的动态规划</span><br><span class="line">    // dp[i]表示：str[0...i]有多少种转化方式</span><br><span class="line">    public static int dp2(String s) &#123;</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        int N = str.length;</span><br><span class="line">        if (str[0] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[N];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">            if (str[i] == &#x27;0&#x27;) &#123;</span><br><span class="line">                // 如果此时str[i]==&#x27;0&#x27;，那么他是一定要拉前一个字符(i-1的字符)一起拼的，</span><br><span class="line">                // 那么就要求前一个字符，不能也是‘0’，否则拼不了。</span><br><span class="line">                // 前一个字符不是‘0’就够了嘛？不够，还得要求拼完了要么是10，要么是20，如果更大的话，拼不了。</span><br><span class="line">                // 这就够了嘛？还不够，你们拼完了，还得要求str[0...i-2]真的可以被分解！</span><br><span class="line">                // 如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行，因为之前的搞定不了。</span><br><span class="line">                if (str[i - 1] == &#x27;0&#x27; || str[i - 1] &gt; &#x27;2&#x27; || (i - 2 &gt;= 0 &amp;&amp; dp[i - 2] == 0)) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i] = i - 2 &gt;= 0 ? dp[i - 2] : 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">                if (str[i - 1] != &#x27;0&#x27; &amp;&amp; (str[i - 1] - &#x27;0&#x27;) * 10 + str[i] - &#x27;0&#x27; &lt;= 26) &#123;</span><br><span class="line">                    dp[i] += i - 2 &gt;= 0 ? dp[i - 2] : 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[N - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了测试</span><br><span class="line">    public static String randomString(int len) &#123;</span><br><span class="line">        char[] str = new char[len];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            str[i] = (char) ((int) (Math.random() * 10) + &#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了测试</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 30;</span><br><span class="line">        int testTime = 1000000;</span><br><span class="line">        System.out.println(&quot;测试开始&quot;);</span><br><span class="line">        for (int i = 0; i &lt; testTime; i++) &#123;</span><br><span class="line">            int len = (int) (Math.random() * N);</span><br><span class="line">            String s = randomString(len);</span><br><span class="line">            int ans0 = number(s);</span><br><span class="line">            int ans1 = dp1(s);</span><br><span class="line">            int ans2 = dp2(s);</span><br><span class="line">            if (ans0 != ans1 || ans0 != ans2) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(ans0);</span><br><span class="line">                System.out.println(ans1);</span><br><span class="line">                System.out.println(ans2);</span><br><span class="line">                System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;测试结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从左往右的尝试模型2-背包问题"><a href="#从左往右的尝试模型2-背包问题" class="headerlink" title="从左往右的尝试模型2-背包问题"></a>从左往右的尝试模型2-背包问题</h3><p>题目：给定两个长度都为N的weights和values,weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag,表示一个载重bag的袋子，你能装的物品不总重量不能超过bag。返回你能装下的最多价值是多少？</p>
<ul>
<li>解法1：暴力递归</li>
<li>解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Code01_Knapsack &#123;</span><br><span class="line">    // 所有的货，重量和价值，都在w和v数组里</span><br><span class="line">    // 为了方便，其中没有负数</span><br><span class="line">    // bag背包容量，不能超过这个载重</span><br><span class="line">    // 返回：不超重的情况下，能够得到的最大价值</span><br><span class="line">    public static int maxValue(int[] w, int[] v, int bag) &#123;</span><br><span class="line">        // 解法1：暴力递归</span><br><span class="line">        if (w == null || v == null || w.length != v.length || w.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 尝试函数！</span><br><span class="line">        return process(w, v, 0, bag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 表示0到index-1已做好货物选择，后续做选择的情况返回</span><br><span class="line">    // 返回-1，表示不能成立，不能选择</span><br><span class="line">    // 返回非-1，表示返回值是货物的实际价值</span><br><span class="line">    // rest 表示背包剩余的可用价值</span><br><span class="line">    public static int process(int[] w, int[] v, int index, int rest) &#123;</span><br><span class="line">        // 剩余空间小于0，则不能选择</span><br><span class="line">        if (rest &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 重量没超，但是后面没货了，那就是0</span><br><span class="line">        if (index == w.length) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可能性一：不要当前货物，直接求后续货物</span><br><span class="line">        int p1 = process(w, v, index + 1, rest);</span><br><span class="line">        int p2 = 0;</span><br><span class="line">        // 可能性二：要当前货物，计算后续货物实际价值</span><br><span class="line">        int next = process(w, v, index + 1, rest - w[index]);</span><br><span class="line">        if (next != -1) &#123;</span><br><span class="line">            // 后续货物还可以放，没超，即要了当前货物+后续货物实际价值</span><br><span class="line">            p2 = v[index] + next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 取两种可能性的最大值，并返回能装下的货物的最终实际价值</span><br><span class="line">        return Math.max(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int dp(int[] w, int[] v, int bag) &#123;</span><br><span class="line">        // 解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行</span><br><span class="line">        if (w == null || v == null || w.length != v.length || w.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int N = w.length;</span><br><span class="line">        /*</span><br><span class="line">        dp二维表，行表示已处理好的货物索引位置index,列表示剩余可用的重量bag。x表示不需要统计计算</span><br><span class="line">        所以根据确定的最终结果，初始值是最后一行，那么后面一定是从第N行推出第N-1行，N-1行推出N-2行...以此类推</span><br><span class="line">          0 1 2 3 4 5  ——bag</span><br><span class="line">        0 x x x x x x</span><br><span class="line">        1</span><br><span class="line">        2</span><br><span class="line">        3</span><br><span class="line">        4 0 0 0 0 0 0(初始值)</span><br><span class="line">        |</span><br><span class="line">        index</span><br><span class="line">        */</span><br><span class="line">        int[][] dp = new int[N + 1][bag + 1];</span><br><span class="line">        // 第一步：计算初始位置值,因为dp二维数组默认就给0，所以不用再计算赋值</span><br><span class="line">        // dp[N][0到bag] = 0</span><br><span class="line">        // 第二步：开始规划计算，根据确定的最终结果，初始值是最后一行，那么后面一定是从第N行推出第N-1行，N-1行推出N-2行...以此类推</span><br><span class="line">        /*将以下过程改为dp</span><br><span class="line">        * // 可能性一：不要当前货物，直接求后续货物</span><br><span class="line">        int p1 = process(w, v, index + 1, rest);</span><br><span class="line">        int p2 = 0;</span><br><span class="line">        // 可能性二：要当前货物，计算后续货物实际价值</span><br><span class="line">        int next = process(w, v, index + 1, rest - w[index]);</span><br><span class="line">        if (next != -1) &#123;</span><br><span class="line">            // 后续货物还可以放，没超，即要了当前货物+后续货物实际价值</span><br><span class="line">            p2 = v[index] + next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 取两种可能性的最大值，并返回能装下的货物的最终实际价值</span><br><span class="line">        return Math.max(p1, p2);</span><br><span class="line">        * */</span><br><span class="line">        for (int index = N - 1; index &gt;= 0; index--) &#123;</span><br><span class="line">            for (int rest = 0; rest &lt;= bag; rest++) &#123;</span><br><span class="line">                // 拿暴力递归过程逐行转换为dp</span><br><span class="line">                int p1 = dp[index + 1][rest];</span><br><span class="line">                int p2 = 0;</span><br><span class="line">                // 这里改造dp注意数组越界</span><br><span class="line">                int next = rest - w[index] &lt; 0 ? -1 : dp[index + 1][rest - w[index]];</span><br><span class="line">                if (next != -1) &#123;</span><br><span class="line">                    p2 = v[index] + next;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回0位置，剩余空间bag的对应值</span><br><span class="line">        return dp[0][bag];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] weights = &#123;3, 2, 4, 7, 3, 1, 7&#125;;</span><br><span class="line">        int[] values = &#123;5, 6, 3, 19, 12, 4, 2&#125;;</span><br><span class="line">        int bag = 15;</span><br><span class="line">        // 解法1：暴力递归</span><br><span class="line">        System.out.println(maxValue(weights, values, bag));</span><br><span class="line">        // 解法2：动态规划，将暴力递归改为动态规划，不太需要关注业务，只需要逻辑就行</span><br><span class="line">        System.out.println(dp(weights, values, bag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范围上的尝试模型-纸牌游戏"><a href="#范围上的尝试模型-纸牌游戏" class="headerlink" title="范围上的尝试模型-纸牌游戏"></a>范围上的尝试模型-纸牌游戏</h3><p>题目：给定一个整形数组arr,代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张牌，规定玩家A先拿，B后拿。但每个玩家每次只能拿走最左或最右的牌。玩家AB都绝顶聪明(都是心机婊，只允许自己拿牌比下一次对方拿牌大)。请但会最后获胜者的分数。</p>
<ul>
<li>解法1：暴力递归的尝试过程</li>
<li>解法2：记忆化搜索即带缓存dp的暴力递归</li>
<li>解法3：动态规划</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public class Code02_CardsInLine &#123;</span><br><span class="line">    // 根据规则，返回获胜者的分数</span><br><span class="line">    public static int win1(int[] arr) &#123;</span><br><span class="line">        // 解法1：暴力递归的尝试过程</span><br><span class="line">        if (arr == null || arr.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 先手人拿牌和后手人拿牌，看下谁大</span><br><span class="line">        int first = f1(arr, 0, arr.length - 1);</span><br><span class="line">        int second = g1(arr, 0, arr.length - 1);</span><br><span class="line">        return Math.max(first, second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // arr[L..R]，先手获得的最好分数返回</span><br><span class="line">    public static int f1(int[] arr, int L, int R) &#123;</span><br><span class="line">        // 还剩一张牌，先手人直接拿走</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        // 可能性1：先手的人拿走左边牌，然后变成当前的后手拿牌，求和</span><br><span class="line">        int p1 = arr[L] + g1(arr, L + 1, R);</span><br><span class="line">        // 可能性1：先手的人拿走右边牌，然后变成当前的后手拿牌，求和</span><br><span class="line">        int p2 = arr[R] + g1(arr, L, R - 1);</span><br><span class="line">        // 因为先手人是心机婊，他一定想拿最大值</span><br><span class="line">        return Math.max(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // arr[L..R]，后手获得的最好分数返回</span><br><span class="line">    public static int g1(int[] arr, int L, int R) &#123;</span><br><span class="line">        // 还剩一张牌，后手人一定是等先手人拿走最后一张，自己球都没有，得0分</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可能性1：先手人拿走左边牌，后手人被迫在剩下的进行先手拿牌</span><br><span class="line">        int p1 = f1(arr, L + 1, R); // 对手拿走了L位置的数</span><br><span class="line">        // 可能性2：先手人拿走右边牌，后手人被迫在剩下的进行先手拿牌</span><br><span class="line">        int p2 = f1(arr, L, R - 1); // 对手拿走了R位置的数</span><br><span class="line">        // 因为先手人是心机婊，他不会允许后手人拿到较大的牌，最会留较小牌给你</span><br><span class="line">        return Math.min(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int win2(int[] arr) &#123;</span><br><span class="line">        // 解法2：记忆化搜索即带缓存dp的暴力递归</span><br><span class="line">        if (arr == null || arr.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        int[][] fmap = new int[N][N];</span><br><span class="line">        int[][] gmap = new int[N][N];</span><br><span class="line">        // 第一步：计算初始位置值，随便给值都行，-1也可以</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">                fmap[i][j] = -1;</span><br><span class="line">                gmap[i][j] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第二步：开始改写dp</span><br><span class="line">        int first = f2(arr, 0, arr.length - 1, fmap, gmap);</span><br><span class="line">        int second = g2(arr, 0, arr.length - 1, fmap, gmap);</span><br><span class="line">        return Math.max(first, second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // arr[L..R]，先手获得的最好分数返回</span><br><span class="line">    public static int f2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) &#123;</span><br><span class="line">        if (fmap[L][R] != -1) &#123;</span><br><span class="line">            return fmap[L][R];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            ans = arr[L];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int p1 = arr[L] + g2(arr, L + 1, R, fmap, gmap);</span><br><span class="line">            int p2 = arr[R] + g2(arr, L, R - 1, fmap, gmap);</span><br><span class="line">            ans = Math.max(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        fmap[L][R] = ans;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // // arr[L..R]，后手获得的最好分数返回</span><br><span class="line">    public static int g2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) &#123;</span><br><span class="line">        if (gmap[L][R] != -1) &#123;</span><br><span class="line">            return gmap[L][R];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        if (L != R) &#123;</span><br><span class="line">            int p1 = f2(arr, L + 1, R, fmap, gmap); // 对手拿走了L位置的数</span><br><span class="line">            int p2 = f2(arr, L, R - 1, fmap, gmap); // 对手拿走了R位置的数</span><br><span class="line">            ans = Math.min(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        gmap[L][R] = ans;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int win3(int[] arr) &#123;</span><br><span class="line">        // 解法3：动态规划</span><br><span class="line">        if (arr == null || arr.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        int[][] fmap = new int[N][N];</span><br><span class="line">        int[][] gmap = new int[N][N];</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            // 第一步：计算初始位置值，设置对角线值</span><br><span class="line">            fmap[i][i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        // 第二步：开始填写两张dp表，然后最终返回需要的dp表结果值</span><br><span class="line">        for (int startCol = 1; startCol &lt; N; startCol++) &#123;</span><br><span class="line">            int L = 0;</span><br><span class="line">            int R = startCol;</span><br><span class="line">            while (R &lt; N) &#123;</span><br><span class="line">                // 根据解法2的物理逻辑，可以转成两张dp表的取值逻辑</span><br><span class="line">                fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);</span><br><span class="line">                gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);</span><br><span class="line">                L++;</span><br><span class="line">                R++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(fmap[0][N - 1], gmap[0][N - 1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;5, 7, 4&#125;;</span><br><span class="line">        // 解法1：暴力递归的尝试过程</span><br><span class="line">        System.out.println(win1(arr));</span><br><span class="line">        // 解法2：记忆化搜索即带缓存dp的暴力递归</span><br><span class="line">        System.out.println(win2(arr));</span><br><span class="line">        // 解法3：动态规划</span><br><span class="line">        System.out.println(win3(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务限制类的尝试模型-N皇后"><a href="#业务限制类的尝试模型-N皇后" class="headerlink" title="业务限制类的尝试模型-N皇后"></a><strong>业务限制类的尝试模型</strong>-N皇后</h3><p>题目：N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一斜线上。给定一个整数n,返回n皇后的摆法有多少种。</p>
<ul>
<li>解法1：暴力递归，返回所有的皇后的合理摆法</li>
</ul>
<ul>
<li>解法2：利用位运算，最多解决32个皇后问题。超过就不行了。因为二进制最多32位。两者时间复杂度均为N的N次方，只不过解法2比1常数项系数更小。<strong>核心是基于位运算的左移右移和斜线逻辑刚好一致。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Code03_NQueens &#123;</span><br><span class="line">    public static int num1(int n) &#123;</span><br><span class="line">        // 解法1：暴力递归</span><br><span class="line">        if (n &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] record = new int[n];</span><br><span class="line">        // 从0开始，所有的皇后摆法</span><br><span class="line">        // 0是第0行开始，record是记录每一行的皇后列摆放位置，n是共多少行</span><br><span class="line">        return process1(0, record, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 潜台词：record[0...i-1]的皇后已摆好</span><br><span class="line">    // 目前来到第i行，要求第i行的皇后与之前的任意皇后不共行，不共列，不共斜线</span><br><span class="line">    // record[0...i-1]表示之前的行，摆放了皇后的位置</span><br><span class="line">    // 例如int[] record record[x] = y 之前的第x行的皇后，放在了y列上</span><br><span class="line">    // 返回：不关心i以上发生了什么。返回值是i.... 后续有多少合法的方法数</span><br><span class="line">    public static int process1(int i, int[] record, int n) &#123;</span><br><span class="line">        // 暴力递归，摆完所有的行，统计一种情况</span><br><span class="line">        if (i == n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 对于第i行来说，遍历所有的列，尝试能不能摆皇后</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            // 假设黑盒函数判断能摆皇后</span><br><span class="line">            if (isValid(record, i, j)) &#123;</span><br><span class="line">                // record函数记录第i行的皇后的摆放位置j</span><br><span class="line">                record[i] = j;</span><br><span class="line">                // 同时记录累加递归计算下一行</span><br><span class="line">                res += process1(i + 1, record, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isValid(int[] record, int i, int j) &#123;</span><br><span class="line">        // 判断第(i,j)的皇后位置不能合record数组中的皇后位置冲突</span><br><span class="line">        for (int k = 0; k &lt; i; k++) &#123;</span><br><span class="line">            // 遍历record所有之前的皇后位置，判断是否冲突</span><br><span class="line">            // 注意不用判断同行，因为一定不同行</span><br><span class="line">            // 如果同列或同斜线，则冲突，返回false。Math.abs是绝对值判断法，简单粗暴</span><br><span class="line">            if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 请不要超过32皇后问题</span><br><span class="line">    public static int num2(int n) &#123;</span><br><span class="line">        // 解法2：巧妙的位运算</span><br><span class="line">        if (n &lt; 1 || n &gt; 32) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果你是13皇后问题，limit 最右13个1，其他都是0</span><br><span class="line">        // limit表示问题的规模，有多少个皇后，则表示右边有多少个连续的1</span><br><span class="line">        int limit = n == 32 ? -1 : (1 &lt;&lt; n) - 1;</span><br><span class="line">        return process2(limit, 0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // limit : 0....0 1 1 1 1 1 1 1</span><br><span class="line">    // 之前皇后的列影响：colLim，列的限制即之前皇后已经摆放过的列，后续皇后就不能摆放这些列</span><br><span class="line">    // 之前皇后的左下对角线影响：leftDiaLim，左斜线限制同上理解</span><br><span class="line">    // 之前皇后的右下对角线影响：rightDiaLim，右斜线限制</span><br><span class="line">    public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) &#123;</span><br><span class="line">        // 当列的限制等于原始规模，就表示所有皇后都摆完了，记录一种情况</span><br><span class="line">        if (colLim == limit) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // pos中所有是1的位置，是你可以去尝试皇后的位置</span><br><span class="line">        int pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">        // 提取出一个二进制的最右1的值</span><br><span class="line">        int mostRightOne = 0;</span><br><span class="line">        // 记录多少种最终返回情况</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 只要pos不为0，表示当前还可以尝试放皇后</span><br><span class="line">        while (pos != 0) &#123;</span><br><span class="line">            // 左神最常规的取出最右的1的值</span><br><span class="line">            mostRightOne = pos &amp; (~pos + 1);</span><br><span class="line">            // 当前值减去最右1，这样最右的第2个1变成了最右的第1个1，继续循环提取pos上所有1即列的位置</span><br><span class="line">            pos = pos - mostRightOne;</span><br><span class="line">            // 当前的限制加上最右的位置成为最新的限制，继续递归统计</span><br><span class="line">            res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &lt;&lt; 1, (rightDiaLim | mostRightOne) &gt;&gt;&gt; 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = 14;</span><br><span class="line">        // 解法2：位运算算法</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(num2(n));</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;cost time: &quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        // 解法1：常规暴力递归算法</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(num1(n));</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;cost time: &quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表按照划分值分组"><a href="#单链表按照划分值分组" class="headerlink" title="单链表按照划分值分组"></a>单链表按照划分值分组</h2><p>题目：将单链表按照某划分值分成左边小、中间相等、右边大的形式。</p>
<ul>
<li>解法1：(笔试用)将链表节点全部入数组，在数组上玩荷兰国旗的Partition，然后按照顺序串成链表</li>
<li>解法2：(面试用)利用6个变量指针，分成3个区域的链表，小于pivot区域，等于pivot区域，大于pivot区域，然后前后串起来即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">public class Code03_SmallerEqualBigger &#123;</span><br><span class="line">   public static class Node &#123;</span><br><span class="line">      public int value;</span><br><span class="line">      public Node next;</span><br><span class="line">      public Node(int data) &#123;</span><br><span class="line">         this.value = data;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法1：(笔试用)将链表节点全部入数组，在数组上玩荷兰国旗的Partition，然后按照顺序串成链表</span><br><span class="line">   public static Node listPartition1(Node head, int pivot) &#123;</span><br><span class="line">      if (head == null) &#123;</span><br><span class="line">         return head;</span><br><span class="line">      &#125;</span><br><span class="line">      Node cur = head;</span><br><span class="line">      int i = 0;</span><br><span class="line">      while (cur != null) &#123;</span><br><span class="line">         i++;</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      Node[] nodeArr = new Node[i];</span><br><span class="line">      i = 0;</span><br><span class="line">      cur = head;</span><br><span class="line">      for (i = 0; i != nodeArr.length; i++) &#123;</span><br><span class="line">         nodeArr[i] = cur;</span><br><span class="line">         cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      arrPartition(nodeArr, pivot);</span><br><span class="line">      for (i = 1; i != nodeArr.length; i++) &#123;</span><br><span class="line">         nodeArr[i - 1].next = nodeArr[i];</span><br><span class="line">      &#125;</span><br><span class="line">      nodeArr[i - 1].next = null;</span><br><span class="line">      return nodeArr[0];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void arrPartition(Node[] nodeArr, int pivot) &#123;</span><br><span class="line">      int small = -1;</span><br><span class="line">      int big = nodeArr.length;</span><br><span class="line">      int index = 0;</span><br><span class="line">      while (index != big) &#123;</span><br><span class="line">         if (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++small, index++);</span><br><span class="line">         &#125; else if (nodeArr[index].value == pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            swap(nodeArr, --big, index);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void swap(Node[] nodeArr, int a, int b) &#123;</span><br><span class="line">      Node tmp = nodeArr[a];</span><br><span class="line">      nodeArr[a] = nodeArr[b];</span><br><span class="line">      nodeArr[b] = tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 解法2：(面试用)利用6个变量指针，分成3个区域的链表，小于pivot区域，等于pivot区域，大于pivot区域，然后前后串起来即可。</span><br><span class="line">   public static Node listPartition2(Node head, int pivot) &#123;</span><br><span class="line">      Node sH = null; // small head小于划分值pivot区域的头结点</span><br><span class="line">      Node sT = null; // small tail小于划分值pivot区域的尾结点</span><br><span class="line">      Node eH = null; // equal head</span><br><span class="line">      Node eT = null; // equal tail</span><br><span class="line">      Node mH = null; // big head</span><br><span class="line">      Node mT = null; // big tail</span><br><span class="line">      Node next = null; // save next node</span><br><span class="line">      // every node distributed to three lists</span><br><span class="line">      while (head != null) &#123;</span><br><span class="line">         // 先记录下当前节点的下一个节点，方便下一次while遍历</span><br><span class="line">         next = head.next;</span><br><span class="line">         // 开始断开当前节点的next指针</span><br><span class="line">         head.next = null;</span><br><span class="line">         if (head.value &lt; pivot) &#123;</span><br><span class="line">            // 小于pivot区域</span><br><span class="line">            if (sH == null) &#123;</span><br><span class="line">               // 一个节点都没有，直接加进来，调整头尾指针</span><br><span class="line">               sH = head;</span><br><span class="line">               sT = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               // 老尾巴的下一个节点指向当前节点</span><br><span class="line">               sT.next = head;</span><br><span class="line">               // 尾指针移动到当前插入的节点</span><br><span class="line">               sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else if (head.value == pivot) &#123;</span><br><span class="line">            // 等于pivot区域，逻辑同上</span><br><span class="line">            if (eH == null) &#123;</span><br><span class="line">               eH = head;</span><br><span class="line">               eT = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               eT.next = head;</span><br><span class="line">               eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            // 大于pivot区域，逻辑同上</span><br><span class="line">            if (mH == null) &#123;</span><br><span class="line">               mH = head;</span><br><span class="line">               mT = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               mT.next = head;</span><br><span class="line">               mT = head;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //下一次while遍历赋值</span><br><span class="line">         head = next;</span><br><span class="line">      &#125;</span><br><span class="line">      // 接下来就是链表前后串起来：小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头。注意因为划分值不同，可能小于区域，等于区域，大于区域不存在。</span><br><span class="line">      if (sT != null) &#123; // 如果小于区域存在</span><br><span class="line">         // 第一步：小于区域的尾节点连接到等于区域的头节点</span><br><span class="line">         sT.next = eH;</span><br><span class="line">         // 找下等于区域的尾指针在哪里，</span><br><span class="line">         eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT</span><br><span class="line">      &#125;</span><br><span class="line">      // 第二步：一定是需要用eT 去接 大于区域的头</span><br><span class="line">      // 有等于区域，eT -&gt; 等于区域的尾结点</span><br><span class="line">      // 无等于区域，eT -&gt; 小于区域的尾结点</span><br><span class="line">      // eT 尽量不为空的尾巴节点</span><br><span class="line">      if (eT != null) &#123; // 如果小于区域和等于区域，不是都没有</span><br><span class="line">         // 第三步：等于区域的尾指针连接大于区域的头指针。至此链表全部串起来了</span><br><span class="line">         eT.next = mH;</span><br><span class="line">      &#125;</span><br><span class="line">      // 最后返回头结点，注意各个头结点是否存在</span><br><span class="line">      return sH != null ? sH : (eH != null ? eH : mH);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void printLinkedList(Node node) &#123;</span><br><span class="line">      System.out.print(&quot;Linked List: &quot;);</span><br><span class="line">      while (node != null) &#123;</span><br><span class="line">         System.out.print(node.value + &quot; &quot;);</span><br><span class="line">         node = node.next;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Node head1 = new Node(7);</span><br><span class="line">      head1.next = new Node(9);</span><br><span class="line">      head1.next.next = new Node(1);</span><br><span class="line">      head1.next.next.next = new Node(8);</span><br><span class="line">      head1.next.next.next.next = new Node(5);</span><br><span class="line">      head1.next.next.next.next.next = new Node(2);</span><br><span class="line">      head1.next.next.next.next.next.next = new Node(5);</span><br><span class="line">      printLinkedList(head1);</span><br><span class="line">      // head1 = listPartition1(head1, 4);</span><br><span class="line">      head1 = listPartition2(head1, 5);</span><br><span class="line">      printLinkedList(head1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="暴力递归到动态规划"><a href="#暴力递归到动态规划" class="headerlink" title="暴力递归到动态规划"></a>暴力递归到动态规划</h2><p><strong>该方法可以解决所有的动态规划问题</strong></p>
<p><strong>什么叫动态规划？</strong></p>
<p>把暴力递归中的重复计算想办法用缓存替代，就是动态规划。只不过这种叫记忆化搜索的动态规划。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>题目：在数学当中，由斐波那契数字（Fibonacci number，记作 Fn ）构成的序列，被称为斐波那契数列（Fibonacci sequence）。该数列中的每一个数字等于排在它前面的两个数字之和。</p>
<ul>
<li>数列从0和1开始： F0=0 , F1=1</li>
<li>数列第n个（n&gt;1）数字为：Fn=Fn−1+Fn−2</li>
</ul>
<p>按照上述公式，计算得到斐波那契数列为：0,1,1,2,3,5,8,13,21,34,55,89,…</p>
<ul>
<li>解法1：最暴力的方法，之所以暴力，是因为有大量重复的计算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int f(int N) &#123;</span><br><span class="line">        // 解法1：斐波那契数列的最暴力解法</span><br><span class="line">        if (N &lt; 2) &#123;</span><br><span class="line">         return N;</span><br><span class="line">     &#125;</span><br><span class="line">        return f(N - 2) + f(N - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="阿里面试题爬楼"><a href="#阿里面试题爬楼" class="headerlink" title="阿里面试题爬楼"></a>阿里面试题爬楼</h3><p>题目：假设有排成一行的N个位置，几位1~N,N一定大于或等于2。</p>
<p>开始时机器人在其中的N位置上(M一定是1~N中的一个)；</p>
<p>如果机器人来到1位置，那么下一步只能往右走来到2位置；</p>
<p>如果机器人来到N位置，那么下一步只能往左走来到N-1位置;</p>
<p>如果机器人来到中间位置，那么下一步可以往左走也可以往右走；</p>
<p>规定机器人必须走K步，最终能来到P位置。</p>
<p>给定四个参数N,M,K,P,返回机器人能走的多少种方法数。</p>
<ul>
<li><p>解法1：暴力递归，中间有重复计算的冗余过程。leetcode提交代码一定超时，不通过</p>
</li>
<li><p>解法2：带缓存的暴力递归，本质：在暴力递归的基础上，利用缓存数组，去掉中间有重复计算的冗余过程。leetcode可以通过</p>
</li>
<li><p>解法3：动态规划，将解法2的暴力递归过程优化为结构化描述的动态规划。因为此题有重复计算过程和有限个参数的相关计算(M,k两个变量)。leetcode可以通过</p>
</li>
</ul>
<p>从解法1到解法2，总结：不是所有的暴力递归都可以改为动态规划，<strong>所有的动态规划都来自于暴力递归的改写</strong>。</p>
<p><strong>任何一个暴力递归优化成结构化描述的动态规划，需要满足两个条件：</strong></p>
<ul>
<li>暴力递归中有重复计算的过程</li>
<li>有限的可变参数影响结果</li>
</ul>
<p>不满足以上2个条件的暴力递归，要么无法改为动态规划(不是有限可变参数)，要么即使改成动态规划也意义不大(没有重复过程，缓存没有意义)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public class Code01_RobotWalk &#123;</span><br><span class="line">    public static int ways1(int N, int M, int K, int P) &#123;</span><br><span class="line">        // 解法1：暴力递归，中间有重复计算的冗余过程</span><br><span class="line">        // 参数无效直接返回 0</span><br><span class="line">        if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span><br><span class="line">        return walk1(N, M, K, P);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 机器人当前来到的位置是cur，</span><br><span class="line">    // 机器人还有rest步需要去走，</span><br><span class="line">    // 最终的目标是P，</span><br><span class="line">    // 返回：机器人从cur出发，走过rest步之后，最终停在P的方法数，是多少？</span><br><span class="line">    public static int walk1(int N, int cur, int rest, int P) &#123;</span><br><span class="line">        // 如果没有剩余步数了，看下当前cur位置在哪里</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            // cur当前位置在最终位置P,则之前的移动有效，记录为一种情况。否则，无效记为0.</span><br><span class="line">            return cur == P ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果cur当前位置在1位置上，那么接下来只能往右边的2移动</span><br><span class="line">        if (cur == 1) &#123; // 1 -&gt; 2</span><br><span class="line">            return walk1(N, cur + 1, rest - 1, P);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果cur当前位置在N位置上，那么接下来只能往左边的N-1移动</span><br><span class="line">        if (cur == N) &#123; // N-1 &lt;- N</span><br><span class="line">            return walk1(N, cur - 1, rest - 1, P);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果cur当前位置在中间，那么有可能性往左移动、有可能往右移动，累加起来</span><br><span class="line">        return walk1(N, cur - 1, rest - 1, P) + walk1(N, cur + 1, rest - 1, P);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int ways2(int N, int M, int K, int P) &#123;</span><br><span class="line">        // 解法2：带缓存的暴力递归，本质：在暴力递归的基础上，利用缓存数组，去掉中间有重复计算的冗余过程</span><br><span class="line">        // 参数无效直接返回 0</span><br><span class="line">        if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // dp就是缓存表，M有可能从1-N，K的话最多K，所以用长度N+1,K+1</span><br><span class="line">        // dp[cur][rest] == -1 -&gt; process1(cur, rest)之前没算过！</span><br><span class="line">        // dp[cur][rest] != -1 -&gt; process1(cur, rest)之前算过！返回值，dp[cur][rest]</span><br><span class="line">        // N+1 * K+1</span><br><span class="line">        int[][] dp = new int[N + 1][K + 1];</span><br><span class="line">        for (int i = 0; i &lt;= N; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= K; j++) &#123;</span><br><span class="line">                dp[i][j] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span><br><span class="line">        return walk2(N, M, K, P, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int walk2(int N, int cur, int rest, int P, int[][] dp) &#123;</span><br><span class="line">        // 先去找缓存表，因为N和P是固定值，返回值只与cur、rest有关</span><br><span class="line">        if (dp[cur][rest] != -1) &#123;</span><br><span class="line">            // 先去缓存表找一下，如果找到有缓存，直接把结果返回</span><br><span class="line">            return dp[cur][rest];</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果没有缓存，说明之前没算过！那就先缓存，再把缓存结果返回</span><br><span class="line">        int ans = 0;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans = cur == P ? 1 : 0;</span><br><span class="line">        &#125; else if (cur == 1) &#123;</span><br><span class="line">            ans = walk2(N, cur + 1, rest - 1, P, dp);</span><br><span class="line">        &#125; else if (cur == N) &#123;</span><br><span class="line">            ans = walk2(N, cur - 1, rest - 1, P, dp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = walk2(N, cur - 1, rest - 1, P, dp) + walk2(N, cur + 1, rest - 1, P, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        // 先缓存</span><br><span class="line">        dp[cur][rest] = ans;</span><br><span class="line">        // 再返回结果</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int ways3(int N, int M, int K, int P) &#123;</span><br><span class="line">        // 解法3：动态规划，将解法2的暴力递归过程优化为动态计算的动态规划。因为此题是关于有限个参数的相关计算(M,k两个变量)</span><br><span class="line">        // 参数无效直接返回 0</span><br><span class="line">        if (N &lt; 2 || K &lt; 1 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        二维表，行表示cur,列表示rest。假设N=5,P=3.x表示不存在的情况，不要统计计算。</span><br><span class="line">          0 1 2 3 4 5  ——rest</span><br><span class="line">        0 x x x x x x</span><br><span class="line">        1 0 0 取左下斜线值</span><br><span class="line">        2 0 取左上斜线值和左下斜线值</span><br><span class="line">        3 1</span><br><span class="line">        4 0 取左上斜线值</span><br><span class="line">        |</span><br><span class="line">        cur</span><br><span class="line">        */</span><br><span class="line">        int[][] dp = new int[N + 1][K + 1];</span><br><span class="line">        // 第一步：根据确定的最终结果，计算初始位置值,dp[其他值][0]=0.所以初始值是第一列，那么后面一定是从第1列推出第2列，2列推出3列...以此类推</span><br><span class="line">        dp[P][0] = 1;</span><br><span class="line">        // 因为cur=P且rest=0.已经初始化了，接下啦只需要计算rest从1到K,cur从1到N</span><br><span class="line">        // 第二步：开始规划计算</span><br><span class="line">        for (int rest = 1; rest &lt;= K; rest++) &#123;</span><br><span class="line">            // 当cur在1的位置,取左下斜线值</span><br><span class="line">            dp[1][rest] = dp[2][rest - 1];</span><br><span class="line">            // 当cur在2到N-1的位置,取左上斜线值和左下斜线值</span><br><span class="line">            for (int cur = 2; cur &lt; N; cur++) &#123;</span><br><span class="line">                dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            // 当cur在N位置，取左上斜线值</span><br><span class="line">            dp[N][rest] = dp[N - 1][rest - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[M][K];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ways1(7, 4, 9, 5));</span><br><span class="line">        System.out.println(ways2(7, 4, 9, 5));</span><br><span class="line">        System.out.println(ways3(7, 4, 9, 5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="货币面值问题"><a href="#货币面值问题" class="headerlink" title="货币面值问题"></a>货币面值问题</h3><p>题目：不同金额的货币，可以使用多张，凑成目标值的方法数。现在有arr[1元，5元，10元].确定每种面额的纸币有多少张，最终来判断，不同张数的组合最终是否等于x元。比如x=10,那么有10张1元，2张5元，1张10元…</p>
<ul>
<li>解法1：暴力递归的尝试过程</li>
<li>解法2：暴力递归的尝试过程改为记忆化搜索</li>
<li>解法3：动态规划，根据暴力递归填写dp表。</li>
<li>解法4：动态规划的优化版，将解法3中枚举的遍历人为直观的转变下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">public class Code03_CoinsWayNoLimit &#123;</span><br><span class="line"></span><br><span class="line">    public static int way(int[] arr, int aim) &#123;</span><br><span class="line">        // 解法1：暴力递归的尝试过程</span><br><span class="line">        if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return process(arr, 0, aim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span><br><span class="line">    public static int process(int[] arr, int index, int rest) &#123;</span><br><span class="line">        /* 剩余的钱数都为负数了，说明这方法不行，记为0。这段可以去掉，因为在调用zhang * arr[index] &lt;= rest保证了不小于0</span><br><span class="line">        if (rest &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">        // 后续没有钱可以选了，那么看下剩余的可用钱是否都刚好用完。如果刚好用完，记为一种用法。否则无效记为0</span><br><span class="line">        if (index == arr.length) &#123; // 没钱了</span><br><span class="line">            return rest == 0 ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ways = 0;</span><br><span class="line">        // 先不要抽象画过程，先具象化过程</span><br><span class="line">        /*</span><br><span class="line">         * arr[10,...] 要完成1000元任务</span><br><span class="line">         * 情况1 不用10元，f(1,1000)</span><br><span class="line">         * 情况2 用1个10元，f1(1,1000-10)</span><br><span class="line">         * 情况3 用2个10元，f1(1,1000-20)</span><br><span class="line">         * 直到1000-x&gt;=0</span><br><span class="line">         * 那么可以设置变量可用的钱的张数为张，rest-(张数Xarr[index]面值)&gt;=0。循环遍历即可，把每种情况累加起来。</span><br><span class="line">         * */</span><br><span class="line">        for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">            ways += process(arr, index + 1, rest - (zhang * arr[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后返回累加的结果值</span><br><span class="line">        return ways;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int way1(int[] arr, int aim) &#123;</span><br><span class="line">        // 解法2：暴力递归的尝试过程改为记忆化搜索</span><br><span class="line">        if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // arr[10,100,...],用了10张10元和用了1张100元，剩余情况是相同，有重复过程。所以dp是二维表，记录剩下的。</span><br><span class="line">        // dp记录了所有情况</span><br><span class="line">        int[][] dp = new int[arr.length + 1][aim + 1];</span><br><span class="line">        return process1(arr, 0, aim, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span><br><span class="line">    public static int process1(int[] arr, int index, int rest, int[][] dp) &#123;</span><br><span class="line">        // 判断是否有缓存，默认是0.不为0，说明写入了，就返回</span><br><span class="line">        if (dp[index][rest] != 0) &#123;</span><br><span class="line">            // return地方改为dp</span><br><span class="line">            return dp[index][rest];</span><br><span class="line">        &#125;</span><br><span class="line">        // 后续没有钱可以选了，那么看下剩余的可用钱是否都刚好用完。如果刚好用完，记为一种用法。否则无效记为0</span><br><span class="line">        if (index == arr.length) &#123; // 没钱了</span><br><span class="line">            // return地方改为dp，先写入缓存，再返回</span><br><span class="line">            dp[index][rest] = rest == 0 ? 1 : 0;</span><br><span class="line">            return dp[index][rest];</span><br><span class="line">        &#125;</span><br><span class="line">        int ways = 0;</span><br><span class="line">        // 先不要抽象画过程，先具象化过程</span><br><span class="line">        /*</span><br><span class="line">         * arr[10,...] 要完成1000元任务</span><br><span class="line">         * 情况1 不用10元，f(1,1000)</span><br><span class="line">         * 情况2 用1个10元，f1(1,1000-10)</span><br><span class="line">         * 情况3 用2个10元，f1(1,1000-20)</span><br><span class="line">         * 直到1000-x&gt;=0</span><br><span class="line">         * 那么可以设置变量可用的钱的张数为张，rest-(张数Xarr[index]面值)&gt;=0。循环遍历即可，把每种情况累加起来。</span><br><span class="line">         * */</span><br><span class="line">        for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">            ways += process1(arr, index + 1, rest - (zhang * arr[index]), dp);</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后返回累加的结果值</span><br><span class="line">        // return地方改为dp，先写入缓存，再返回</span><br><span class="line">        dp[index][rest] = ways;</span><br><span class="line">        return dp[index][rest];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int dp1(int[] arr, int aim) &#123;</span><br><span class="line">        // 解法3：动态规划，根据暴力递归填写dp表。</span><br><span class="line">        if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        int[][] dp = new int[N + 1][aim + 1];</span><br><span class="line">        // 第一步：根据确定的最终结果，计算初始位置值.最后知道的结果一定是index来到N,同时剩余空间为0.这是一种情况，记录为1.</span><br><span class="line">        dp[N][0] = 1;</span><br><span class="line">        for (int index = N - 1; index &gt;= 0; index--) &#123;</span><br><span class="line">            for (int rest = 0; rest &lt;= aim; rest++) &#123;</span><br><span class="line">                // 二维表dp填写</span><br><span class="line">                // 按照原来的逻辑逐行替代为dp</span><br><span class="line">                int ways = 0;</span><br><span class="line">                for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">                    ways += dp[index + 1][rest - (zhang * arr[index])];</span><br><span class="line">                &#125;</span><br><span class="line">                // return的地方改为dp赋值</span><br><span class="line">                dp[index][rest] = ways;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最终结果是[arr从0开始,aim]的dp返回值</span><br><span class="line">        return dp[0][aim];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int dp2(int[] arr, int aim) &#123;</span><br><span class="line">        // 解法4：动态规划的优化版，将解法3中枚举的遍历人为直观的转变下。</span><br><span class="line">        /*</span><br><span class="line">         * 要想做出解法4，必须经过解法1，2,3。某些奸人也是经过解法123，但不说，直接告诉解法4.然后强行</span><br><span class="line">         * 拿某种关系解释。看起来很牛，太奸了。</span><br><span class="line">         * */</span><br><span class="line">        if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        int[][] dp = new int[N + 1][aim + 1];</span><br><span class="line">        // 第一步：根据确定的最终结果，计算初始位置值.最后知道的结果一定是index来到N,同时剩余空间为0.这是一种情况，记录为1.</span><br><span class="line">        dp[N][0] = 1;</span><br><span class="line">        // 第二步：从最后一行往前推，因为最后一行已知。每行从左往右推。</span><br><span class="line">        for (int index = N - 1; index &gt;= 0; index--) &#123;</span><br><span class="line">            for (int rest = 0; rest &lt;= aim; rest++) &#123;</span><br><span class="line">                // 这个关系是画图看出来的</span><br><span class="line">                dp[index][rest] = dp[index + 1][rest];</span><br><span class="line">                // 这个关系是画图和递归逻辑看出来的</span><br><span class="line">                if (rest - arr[index] &gt;= 0) &#123;</span><br><span class="line">                    dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最终结果是[arr从0开始,aim]的dp返回值</span><br><span class="line">        return dp[0][aim];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了测试</span><br><span class="line">    public static int[] randomArray(int maxLen, int maxValue) &#123;</span><br><span class="line">        int N = (int) (Math.random() * maxLen);</span><br><span class="line">        int[] arr = new int[N];</span><br><span class="line">        boolean[] has = new boolean[maxValue + 1];</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                arr[i] = (int) (Math.random() * maxValue) + 1;</span><br><span class="line">            &#125; while (has[arr[i]]);</span><br><span class="line">            has[arr[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了测试</span><br><span class="line">    public static void printArray(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了测试</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int maxLen = 10;</span><br><span class="line">        int maxValue = 30;</span><br><span class="line">        int testTime = 1000000;</span><br><span class="line">        System.out.println(&quot;测试开始&quot;);</span><br><span class="line">        for (int i = 0; i &lt; testTime; i++) &#123;</span><br><span class="line">            int[] arr = randomArray(maxLen, maxValue);</span><br><span class="line">            int aim = (int) (Math.random() * maxValue);</span><br><span class="line">            int ans1 = way(arr, aim);</span><br><span class="line">            int ans4 = way1(arr, aim);</span><br><span class="line">            int ans2 = dp1(arr, aim);</span><br><span class="line">            int ans3 = dp2(arr, aim);</span><br><span class="line">            if (ans1 != ans2 || ans1 != ans3 || ans1 != ans4) &#123;</span><br><span class="line">                System.out.println(&quot;Oops!&quot;);</span><br><span class="line">                printArray(arr);</span><br><span class="line">                System.out.println(aim);</span><br><span class="line">                System.out.println(ans1);</span><br><span class="line">                System.out.println(ans2);</span><br><span class="line">                System.out.println(ans3);</span><br><span class="line">                System.out.println(ans4);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;测试结束&quot;);</span><br><span class="line">//        int[] arr = randomArray(maxLen, maxValue);</span><br><span class="line">//        int aim = (int) (Math.random() * maxValue);</span><br><span class="line">//        printArray(arr);</span><br><span class="line">//        System.out.println(aim);</span><br><span class="line">//        System.out.println(way(arr, aim));</span><br><span class="line">//        System.out.println(way1(arr, aim));</span><br><span class="line">//        System.out.println(dp1(arr, aim));</span><br><span class="line">//        System.out.println(dp2(arr, aim));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><ul>
<li>最自然智慧的算法</li>
<li>用一种局部最功利的标准，总是做出当前看来最好的选择</li>
<li>难点在于证明局部最功利的标准可以得到全局最优解</li>
<li>对于贪心算法的学习主要以增加阅历和经验为主</li>
</ul>
<p><strong>字典序</strong></p>
<p>定义：表示英文单词在字典中的先后顺序，类似中文的拼音目录。ab abc abd.</p>
<p>排序规则：字母单词在字典中的顺序，位数一样的依次比较，如果位数不一样，将短的补长为和长的一样长，多的位用0补。逐一从左到右依次比较，小的放前，大的放后。</p>
<h2 id="贪心-最小字典序"><a href="#贪心-最小字典序" class="headerlink" title="贪心-最小字典序"></a>贪心-最小字典序</h2><p>题目：给定一个由字符串组成的数组arrs,必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果。</p>
<ul>
<li>解法1：列出所有的字符串的全排列，找到全局最小。注意求解全排列，有多层循环递归和深度优先遍历两种方法。</li>
<li>解法2：将字符串数组按照字典序排序，直接拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class Code05_LowestLexicography &#123;</span><br><span class="line">    // 解法1：列出所有的字符串的全排列，找到全局最小</span><br><span class="line">    public static String lowestString1(String[] strs) &#123;</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;String&gt; all = new TreeSet&lt;&gt;();</span><br><span class="line">        // 解法a:多层循环递归，返回全排列</span><br><span class="line">        all = process(strs);</span><br><span class="line">        // 解法b:深度优先遍历，返回全排列</span><br><span class="line">//        HashSet&lt;Integer&gt; use = new HashSet&lt;&gt;();</span><br><span class="line">//        String path = &quot;&quot;;</span><br><span class="line">//        process2(strs, use, path, all);</span><br><span class="line">        String lowest = null;</span><br><span class="line">        // 遍历找到全局最小</span><br><span class="line">        for (String str : all) &#123;</span><br><span class="line">            if (lowest == null) &#123;</span><br><span class="line">                lowest = str;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lowest = str.compareTo(lowest) &lt; 0 ? str : lowest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lowest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法a：多层循环递归，返回全排列。strs中所有字符串全排列，返回所有可能的结果</span><br><span class="line">    public static TreeSet&lt;String&gt; process(String[] strs) &#123;</span><br><span class="line">        TreeSet&lt;String&gt; ans = new TreeSet&lt;&gt;();</span><br><span class="line">        if (strs.length == 0) &#123;</span><br><span class="line">            // 数组为空，直接返回</span><br><span class="line">            ans.add(&quot;&quot;);</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从前往后遍历，使用当前元素+(剩余元素的组合list)一一匹配</span><br><span class="line">        for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            String first = strs[i];</span><br><span class="line">            // 排除当前元素，剩余还有哪些元素</span><br><span class="line">            String[] nexts = removeIndexString(strs, i);</span><br><span class="line">            // 返回剩余元素的所有排列组合</span><br><span class="line">            TreeSet&lt;String&gt; next = process(nexts);</span><br><span class="line">            // 当前元素+剩余元素，遍历组合，一一匹配</span><br><span class="line">            for (String cur : next) &#123;</span><br><span class="line">                ans.add(first + cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法b：深度优先遍历，strs中所有字符串全排列，返回所有可能的结果</span><br><span class="line">    public static void process2(String[] strs, HashSet&lt;Integer&gt; use, String path, TreeSet&lt;String&gt; all) &#123;</span><br><span class="line">        // str放着所有字符串，use表示使用过的字符串索引，path表示当前的字符串拼接路径，all就是所有字符串的排列组合</span><br><span class="line">        if (use.size() == strs.length) &#123;</span><br><span class="line">            // 全部都用了，就加入一条路径</span><br><span class="line">            all.add(path);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">                // 遍历所有元素，找到没加入过的元素，更新use,更新path,递归剩下元素</span><br><span class="line">                if (!use.contains(strs[i])) &#123;</span><br><span class="line">                    // 更新use</span><br><span class="line">                    use.add(i);</span><br><span class="line">                    // 更新path,递归剩下元素</span><br><span class="line">                    process2(strs, use, path + strs[i], all);</span><br><span class="line">                    // 注意，深度优先遍历，一定要回溯，就要删除刚加的元素，恢复现场</span><br><span class="line">                    use.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // &#123;&quot;abc&quot;, &quot;cks&quot;, &quot;bct&quot;&#125;</span><br><span class="line">    // 0 1 2</span><br><span class="line">    // removeIndexString(arr , 1) -&gt; &#123;&quot;abc&quot;, &quot;bct&quot;&#125;</span><br><span class="line">    // 返回arr删除index索引的元素剩下的元素</span><br><span class="line">    public static String[] removeIndexString(String[] arr, int index) &#123;</span><br><span class="line">        int N = arr.length;</span><br><span class="line">        String[] ans = new String[N - 1];</span><br><span class="line">        int ansIndex = 0;</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (i != index) &#123;</span><br><span class="line">                ans[ansIndex++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MyComparator implements Comparator&lt;String&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String a, String b) &#123;</span><br><span class="line">            return (a + b).compareTo(b + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 解法2：将字符串数组按照字典序排序，直接拼接</span><br><span class="line">    public static String lowestString2(String[] strs) &#123;</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs, new MyComparator());</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            res += strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static String generateRandomString(int strLen) &#123;</span><br><span class="line">        char[] ans = new char[(int) (Math.random() * strLen) + 1];</span><br><span class="line">        for (int i = 0; i &lt; ans.length; i++) &#123;</span><br><span class="line">            int value = (int) (Math.random() * 5);</span><br><span class="line">            ans[i] = (Math.random() &lt;= 0.5) ? (char) (65 + value) : (char) (97 + value);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static String[] generateRandomStringArray(int arrLen, int strLen) &#123;</span><br><span class="line">        String[] ans = new String[(int) (Math.random() * arrLen) + 1];</span><br><span class="line">        for (int i = 0; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = generateRandomString(strLen);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for test</span><br><span class="line">    public static String[] copyStringArray(String[] arr) &#123;</span><br><span class="line">        String[] ans = new String[arr.length];</span><br><span class="line">        for (int i = 0; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = String.valueOf(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arrLen = 6;</span><br><span class="line">        int strLen = 5;</span><br><span class="line">        int testTimes = 10000;</span><br><span class="line">        System.out.println(&quot;test begin&quot;);</span><br><span class="line">        for (int i = 0; i &lt; testTimes; i++) &#123;</span><br><span class="line">            String[] arr1 = generateRandomStringArray(arrLen, strLen);</span><br><span class="line">            String[] arr2 = copyStringArray(arr1);</span><br><span class="line">            if (!lowestString1(arr1).equals(lowestString2(arr2))) &#123;</span><br><span class="line">                for (String str : arr1) &#123;</span><br><span class="line">                    System.out.print(str + &quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(&quot;Oops!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;finish!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>定义：是一棵二叉树。它的特点是：每个结点表示的是一个线段，或者说是一个区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_SegmentTree</span> &#123;</span><br><span class="line">    <span class="comment">// 线段树的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">        <span class="comment">// arr[]为原序列的信息从0开始，但在arr里是从1开始的，注意从下标1开始是为了方便使用位运算。</span></span><br><span class="line">        <span class="comment">// MAXN是拷贝数组的长度</span></span><br><span class="line">        <span class="comment">// sum[]模拟线段树维护区间和</span></span><br><span class="line">        <span class="comment">// lazy[]为累加和标记即懒加和标记</span></span><br><span class="line">        <span class="comment">// change[]为更新的值</span></span><br><span class="line">        <span class="comment">// update[]为更新标记即懒更新标记</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> MAXN;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] sum;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] lazy;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] change;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span>[] update;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数,初始化所有数组空间</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] origin)</span> &#123;</span><br><span class="line">            <span class="comment">// 创建原数组origin对应的拷贝数组arr，从下标1开始，方便后续的位运算</span></span><br><span class="line">            MAXN = origin.length + <span class="number">1</span>;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN]; <span class="comment">// arr[0] 不用 从1开始使用</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">                arr[i] = origin[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为了把所有数都刚好让左右等范围cover住，申请长度MAXN*4即左移2位</span></span><br><span class="line">            sum = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>]; <span class="comment">// 用来支持脑补概念中，某一个范围的累加和信息</span></span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>]; <span class="comment">// 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務</span></span><br><span class="line">            change = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>]; <span class="comment">// 用来支持脑补概念中，某一个范围有没有更新操作的任务</span></span><br><span class="line">            update = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN &lt;&lt; <span class="number">2</span>]; <span class="comment">// 用来支持脑补概念中，某一个范围更新任务，更新成了什么</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点收集左右子节点的和信息。懒加和，懒更新后，都需要执行这个操作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * rt是当前节点索引</span></span><br><span class="line"><span class="comment">             * rt对应的左子节点是rt*2即rt &lt;&lt; 1</span></span><br><span class="line"><span class="comment">             * rt对应的右子节点是rt*2+1即rt &lt;&lt; 1|1</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下发懒更新和懒加和。懒加和，懒更新，都需要把自己的任务下发给左右子节点。分发策略:从父范围，分发给左右边界</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> ln, <span class="type">int</span> rn)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * ln表示左子树元素结点个数，rn表示右子树结点个数</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 如果当前节点懒更新标记为true,则下发懒更新</span></span><br><span class="line">            <span class="keyword">if</span> (update[rt]) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 下发给左右节点懒更新时，</span></span><br><span class="line"><span class="comment">                 * 左右节点的懒更新标记为true</span></span><br><span class="line"><span class="comment">                 * 左右节点的懒更新值为父节点值</span></span><br><span class="line"><span class="comment">                 * 左右节点的懒加和清空，置为0</span></span><br><span class="line"><span class="comment">                 * 左右节点的区间和，直接计算为长度*懒更新值</span></span><br><span class="line"><span class="comment">                 * 当前自己节点的懒更新标记为false，清空，表示后续不用再下发</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                update[rt &lt;&lt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                update[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                change[rt &lt;&lt; <span class="number">1</span>] = change[rt];</span><br><span class="line">                change[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt];</span><br><span class="line">                lazy[rt &lt;&lt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                sum[rt &lt;&lt; <span class="number">1</span>] = change[rt] * ln;</span><br><span class="line">                sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt] * rn;</span><br><span class="line">                update[rt] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点懒加和标记不为0,则下发懒加和</span></span><br><span class="line">            <span class="keyword">if</span> (lazy[rt] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 下发给左右节点懒加和时，</span></span><br><span class="line"><span class="comment">                 * 左右节点的懒加和=之前的值+当前父节点的值</span></span><br><span class="line"><span class="comment">                 * 左右节点的区间和=当前懒加和*长度</span></span><br><span class="line"><span class="comment">                 * 当前自己节点的懒加和标记为0，清空，表示后续不用再下发</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">                lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt];</span><br><span class="line">                sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * ln;</span><br><span class="line">                sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt] * rn;</span><br><span class="line">                lazy[rt] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线段树：构建线段树的初值，sum数组填充。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 在arr[l~r]范围上，去build构建sum数组信息。</span></span><br><span class="line"><span class="comment">             * rt是sum数组的下标索引</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                sum[rt] = arr[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            build(l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            build(mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">            pushUp(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在L到R索引范围上，每个元素都加上C</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *L~R, C 表示任务的3个变量</span></span><br><span class="line"><span class="comment">             * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 任务如果把此时的范围全包了！那么这个节点区间直接命中</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">                <span class="comment">// 区间和=之前值+c*区间长度</span></span><br><span class="line">                sum[rt] += C * (r - l + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 懒加载和=之前值+当前值C</span></span><br><span class="line">                lazy[rt] += C;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务没有把你全包！</span></span><br><span class="line">            <span class="comment">// 取二分中点，l  r  mid = (l+r)/2</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 先下发懒更新和懒加和</span></span><br><span class="line">            pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">            <span class="comment">// 如果任务的左边界越过区间的中点，去左边了，则去左子节点继续递归。rt &lt;&lt; 1等于rt*2</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">                add(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务的右边界越过区间的中点，去右边了，则去右子节点继续递归.rt &lt;&lt; 1|1等于rt*2+1</span></span><br><span class="line">            <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">                add(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等前面的子节点信息填好了后，再当前节点收集左右子节点的和信息</span></span><br><span class="line">            pushUp(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在L到R索引范围上，每个元素都更新为C</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *L~R, C 表示任务的3个变量</span></span><br><span class="line"><span class="comment">             * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 任务如果把此时的范围全包了！那么这个节点区间直接命中</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 当前节点的懒更新标记为true</span></span><br><span class="line"><span class="comment">                 * 当前节点的懒更新值为C</span></span><br><span class="line"><span class="comment">                 * 当前节点的区间和=C*区间长度</span></span><br><span class="line"><span class="comment">                 * 当前节点的懒加和清空，为0</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                update[rt] = <span class="literal">true</span>;</span><br><span class="line">                change[rt] = C;</span><br><span class="line">                sum[rt] = C * (r - l + <span class="number">1</span>);</span><br><span class="line">                lazy[rt] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前任务躲不掉，无法懒更新，要往下发</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 先下发懒更新和懒加和</span></span><br><span class="line">            pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">            <span class="comment">// 如果任务的左边界越过区间的中点，去左边了，则去左子节点继续递归。rt &lt;&lt; 1等于rt*2</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">                update(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务的右边界越过区间的中点，去右边了，则去右子节点继续递归.rt &lt;&lt; 1|1等于rt*2+1</span></span><br><span class="line">            <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">                update(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等前面的子节点信息填好了后，再当前节点收集左右子节点的和信息</span></span><br><span class="line">            pushUp(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询L~R上的累加和是多少</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *L~R 表示任务的2个变量</span></span><br><span class="line"><span class="comment">             * l,r是线段树的某个节点的左右区间，rt是某个节点的索引。这三个值可以认为是固定值。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 任务区间包括了节点的区间值，命中</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum[rt];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 先下发懒更新和懒加和</span></span><br><span class="line">            pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果任务的左边界越过区间的中点，去左边了。去左节点收集和</span></span><br><span class="line">            <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">                ans += query(L, R, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果任务的右边界越过区间的中点，去右边了。去右节点收集和</span></span><br><span class="line">            <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">                ans += query(L, R, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后返回</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Right</span> &#123;</span><br><span class="line">        <span class="comment">// 对数器：最暴力的直接求和</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Right</span><span class="params">(<span class="type">int</span>[] origin)</span> &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">int</span>[origin.length + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; origin.length; i++) &#123;</span><br><span class="line">                arr[i + <span class="number">1</span>] = origin[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= R; i++) &#123;</span><br><span class="line">                arr[i] = C;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= R; i++) &#123;</span><br><span class="line">                arr[i] += C;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= R; i++) &#123;</span><br><span class="line">                ans += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] genarateRandomArray(<span class="type">int</span> len, <span class="type">int</span> max) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * len) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] origin = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            origin[i] = (<span class="type">int</span>) (Math.random() * max) - (<span class="type">int</span>) (Math.random() * max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addOrUpdateTimes</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">queryTimes</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] origin = genarateRandomArray(len, max);</span><br><span class="line">            <span class="type">SegmentTree</span> <span class="variable">seg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SegmentTree</span>(origin);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * S,N是线段树的某个节点的左右区间，root是某个节点的索引。这三个值可以认为是固定值。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> origin.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 初始化线段树</span></span><br><span class="line">            seg.build(S, N, root);</span><br><span class="line">            <span class="comment">// 对数器的数组</span></span><br><span class="line">            <span class="type">Right</span> <span class="variable">rig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Right</span>(origin);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; addOrUpdateTimes; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.min(num1, num2);</span><br><span class="line">                <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.max(num1, num2);</span><br><span class="line">                <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * max) - (<span class="type">int</span>) (Math.random() * max);</span><br><span class="line">                <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="comment">// 等概率小于0.5的添加值</span></span><br><span class="line">                    seg.add(L, R, C, S, N, root);</span><br><span class="line">                    rig.add(L, R, C);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 等概率大于等于0.5的更新值</span></span><br><span class="line">                    seg.update(L, R, C, S, N, root);</span><br><span class="line">                    rig.update(L, R, C);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 测试500次，和对数器逐一比对，死都测出来</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; queryTimes; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.min(num1, num2);</span><br><span class="line">                <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.max(num1, num2);</span><br><span class="line">                <span class="type">long</span> <span class="variable">ans1</span> <span class="operator">=</span> seg.query(L, R, S, N, root);</span><br><span class="line">                <span class="type">long</span> <span class="variable">ans2</span> <span class="operator">=</span> rig.query(L, R);</span><br><span class="line">                <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] origin = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">SegmentTree</span> <span class="variable">seg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SegmentTree</span>(origin);</span><br><span class="line">        <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 整个区间的开始位置，规定从1开始，不从0开始 -&gt; 固定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> origin.length; <span class="comment">// 整个区间的结束位置，规定能到N，不是N-1 -&gt; 固定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 整棵树的头节点位置，规定是1，不是0 -&gt; 固定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 操作区间的开始位置 -&gt; 可变</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 操作区间的结束位置 -&gt; 可变</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 要加的数字或者要更新的数字 -&gt; 可变</span></span><br><span class="line">        <span class="comment">// 区间生成，必须在[S,N]整个范围上build</span></span><br><span class="line">        seg.build(S, N, root);</span><br><span class="line">        <span class="comment">// 区间修改，可以改变L、R和C的值，其他值不可改变</span></span><br><span class="line">        seg.add(L, R, C, S, N, root);</span><br><span class="line">        <span class="comment">// 区间更新，可以改变L、R和C的值，其他值不可改变</span></span><br><span class="line">        seg.update(L, R, C, S, N, root);</span><br><span class="line">        <span class="comment">// 区间查询，可以改变L和R的值，其他值不可改变</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> seg.query(L, R, S, N, root);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;对数器测试开始...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结果 : &quot;</span> + (test() ? <span class="string">&quot;通过&quot;</span> : <span class="string">&quot;未通过&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><h3 id="每种能力的最高报酬"><a href="#每种能力的最高报酬" class="headerlink" title="每种能力的最高报酬"></a>每种能力的最高报酬</h3><p>题目：每种工作有难度和报酬，规定如下：class Job{public int hard;public int money;}。给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作，选工作的标准是难度不超过自身能力值，选择报酬最高的岗位。求返回int数组，表示每个人按照标准选择的最高报酬。</p>
<p>思路：</p>
<ul>
<li>先将job数组按照难度值升序且报酬值降序排列，难度值相同的情况下，只保留最大报酬值的那个</li>
<li>在剩余数组中，逐一比较，如果难度值上升，报酬值也上升，这样的数据保留。否则，删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Problem07_ChooseWork &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Job&gt; job = new ArrayList&lt;Job&gt;();</span><br><span class="line">        Job job1 = new Job(1,1);</span><br><span class="line">        Job job2 = new Job(2,5);</span><br><span class="line">        Job job3 = new Job(4,4);</span><br><span class="line">        Job job4 = new Job(5,7);</span><br><span class="line">        Job job5 = new Job(8,8);</span><br><span class="line">        job.add(job1);</span><br><span class="line">        job.add(job2);</span><br><span class="line">        job.add(job3);</span><br><span class="line">        job.add(job4);</span><br><span class="line">        job.add(job5);</span><br><span class="line">        int[] ans = getMoneys((job.toArray(new Job[job.size()])),new int[]&#123;1,2,3&#125;);</span><br><span class="line">        System.out.println(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Job &#123;</span><br><span class="line">        public int money;</span><br><span class="line">        public int hard;</span><br><span class="line"></span><br><span class="line">        public Job(int m, int h) &#123;</span><br><span class="line">            money = m;</span><br><span class="line">            hard = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class JobComparator implements Comparator&lt;Job&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Job o1, Job o2) &#123;</span><br><span class="line">            return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] getMoneys(Job[] job, int[] ability) &#123;</span><br><span class="line">        Arrays.sort(job, new JobComparator());</span><br><span class="line">        // key : 难度   value：报酬</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">        map.put(job[0].hard, job[0].money);</span><br><span class="line">        // pre : 上一份进入map的工作</span><br><span class="line">        Job pre = job[0];</span><br><span class="line">        for (int i = 1; i &lt; job.length; i++) &#123;</span><br><span class="line">            if (job[i].hard != pre.hard &amp;&amp; job[i].money &gt; pre.money) &#123;</span><br><span class="line">                // hard值相同的只取一个，报酬也要递增，很巧妙</span><br><span class="line">                pre = job[i];</span><br><span class="line">                map.put(pre.hard, pre.money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // map中就是各个难度岗位的最高报酬值，接下来就是匹配目标值向下取整即不超过目标能力值的报酬。</span><br><span class="line">        int[] ans = new int[ability.length];</span><br><span class="line">        for (int i = 0; i &lt; ability.length; i++) &#123;</span><br><span class="line">            // ability[i] 当前人的能力 &lt;= ability[i]  且离它最近的</span><br><span class="line">            Integer key = map.floorKey(ability[i]);</span><br><span class="line">            ans[i] = key != null ? map.get(key) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单背包问题"><a href="#简单背包问题" class="headerlink" title="简单背包问题"></a>简单背包问题</h3><p>题目：背包容量为w,一共有n袋零食，第i袋零食体积为v[i]&gt;0.总体积不超过背包容量的情况下，一共有多少种零食放法(总体积为0也算是一种放法)</p>
<p>思路：</p>
<ul>
<li>解法1：暴力递归的尝试过程</li>
<li>解法2：暴力递归改写的dp</li>
<li>解法3：另一种解法的dp</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class Code02_SnacksWays &#123;</span><br><span class="line">   public static int ways1(int[] arr, int w) &#123;</span><br><span class="line">      // 解法1：暴力递归的尝试过程</span><br><span class="line">      return process(arr, 0, w);</span><br><span class="line">   &#125;</span><br><span class="line">   // 从左往右的经典模型</span><br><span class="line">   // 还剩的容量是rest，arr[index...]自由选择，</span><br><span class="line">   // 返回选择方案</span><br><span class="line">   // index ： 0～N，当前来到的零食索引值，表示纵坐标</span><br><span class="line">   // rest : 0~w，当前还剩余的可用容积，表示横坐标</span><br><span class="line">   public static int process(int[] arr, int index, int rest) &#123;</span><br><span class="line">      if (rest &lt; 0) &#123; // 没有容量了</span><br><span class="line">         // -1 无方案的意思</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      // rest&gt;=0,</span><br><span class="line">      if (index == arr.length) &#123; // 无零食可选</span><br><span class="line">         return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      // rest &gt;=0</span><br><span class="line">      // 有零食index</span><br><span class="line">      // index号零食，要 or 不要</span><br><span class="line">      // index, rest</span><br><span class="line">      // (index+1, rest)</span><br><span class="line">      // (index+1, rest-arr[i])</span><br><span class="line">      int next1 = process(arr, index + 1, rest); // 不要</span><br><span class="line">      int next2 = process(arr, index + 1, rest - arr[index]); // 要</span><br><span class="line">      return next1 + next2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int ways2(int[] arr, int w) &#123;</span><br><span class="line">      // 解法2：暴力递归改简单动态规划，从下到上，从左到右改写。利用未使用容量求解</span><br><span class="line">      // dp[i][j]中i：0～N中，第i个位置，剩余容量j的方法数</span><br><span class="line">      int N = arr.length;</span><br><span class="line">      int[][] dp = new int[N + 1][w + 1];</span><br><span class="line">      // 从N袋零食后，无零食可选了，就是一种方法了</span><br><span class="line">      for (int j = 0; j &lt;= w; j++) &#123;</span><br><span class="line">         dp[N][j] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">         for (int j = 0; j &lt;= w; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i + 1][j] + ((j - arr[i] &gt;= 0) ? dp[i + 1][j - arr[i]] : 0);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 返回index号零食开始，容量还剩w的方法数</span><br><span class="line">      return dp[0][w];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int ways3(int[] arr, int w) &#123;</span><br><span class="line">      // 解法3：暴力递归改简单动态规划，利用已使用容量求解，不太好理解就使用解法2.</span><br><span class="line">      // dp[i][j]中i：0～N中，第i个位置，已使用的容量j的方法数</span><br><span class="line">      int N = arr.length;</span><br><span class="line">      int[][] dp = new int[N][w + 1];</span><br><span class="line">      for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">         dp[i][0] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (arr[0] &lt;= w) &#123;</span><br><span class="line">         dp[0][arr[0]] = 1;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">         for (int j = 1; j &lt;= w; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + ((j - arr[i]) &gt;= 0 ? dp[i - 1][j - arr[i]] : 0);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int ans = 0;</span><br><span class="line">      for (int j = 0; j &lt;= w; j++) &#123;</span><br><span class="line">         ans += dp[N - 1][j];</span><br><span class="line">      &#125;</span><br><span class="line">      return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int[] arr = &#123; 4, 3, 2, 9 &#125;;</span><br><span class="line">      int w = 8;</span><br><span class="line">      System.out.println(ways1(arr, w));</span><br><span class="line">      System.out.println(ways2(arr, w));</span><br><span class="line">      System.out.println(ways3(arr, w));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>题目：注意区分子串和子序列的不同。给定两个字符串str1和str2，求两个字符串的最长公共子串。</p>
<p>思路：动态规划的空间压缩技巧</p>
<ul>
<li>解法1：直接填写dp表，并统计最大值，返回max和i.</li>
<li>解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">// 最长公共子串问题是面试常见题目之一</span><br><span class="line">public class Code03_LongestCommonSubstringConquerByHeight &#123;</span><br><span class="line">    public static String lcs1(String str1, String str2) &#123;</span><br><span class="line">        // 解法1：直接填写dp表，并统计最大值，返回max和i.</span><br><span class="line">        if (str1 == null || str2 == null || str1.equals(&quot;&quot;) || str2.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chs1 = str1.toCharArray();</span><br><span class="line">        char[] chs2 = str2.toCharArray();</span><br><span class="line">        int[][] dp = getdp(chs1, chs2);</span><br><span class="line">        int end = 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        // 遍历找到最大值</span><br><span class="line">        for (int i = 0; i &lt; chs1.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; chs2.length; j++) &#123;</span><br><span class="line">                if (dp[i][j] &gt; max) &#123;</span><br><span class="line">                    end = i;</span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str1.substring(end - max + 1, end + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[][] getdp(char[] str1, char[] str2) &#123;</span><br><span class="line">        // 填写dp表，dp[i][j]表示以str1的第i个字符结尾，以str2的第j个字符结尾的公共子串的长度</span><br><span class="line">        int[][] dp = new int[str1.length][str2.length];</span><br><span class="line">        // 对于第一列，只有ij对应的字符相等，长度才为1</span><br><span class="line">        for (int i = 0; i &lt; str1.length; i++) &#123;</span><br><span class="line">            if (str1[i] == str2[0]) &#123;</span><br><span class="line">                dp[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对于第一行，只有ij对应的字符相等，长度才为1</span><br><span class="line">        for (int j = 1; j &lt; str2.length; j++) &#123;</span><br><span class="line">            if (str1[0] == str2[j]) &#123;</span><br><span class="line">                dp[0][j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他的行列，就需要根据前面的值推导</span><br><span class="line">        for (int i = 1; i &lt; str1.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; str2.length; j++) &#123;</span><br><span class="line">                if (str1[i] == str2[j]) &#123;</span><br><span class="line">                    // 如果当前字符相同，则当前长度在前面的基础上+1.不相同，则默认为0</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String lcs2(String s1, String s2) &#123;</span><br><span class="line">        // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量</span><br><span class="line">        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str1 = s1.toCharArray();</span><br><span class="line">        char[] str2 = s2.toCharArray();</span><br><span class="line">        // 用行列两个变量简单记录，替代dp的二维表结构</span><br><span class="line">        // 定义行索引</span><br><span class="line">        int row = 0;</span><br><span class="line">        // 定义列索引</span><br><span class="line">        int col = str2.length - 1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        // 遍历行索引(遍历行，遍历列)</span><br><span class="line">        /*</span><br><span class="line">         * --------&lt;---</span><br><span class="line">         * |</span><br><span class="line">         * |</span><br><span class="line">         * V</span><br><span class="line">         * |</span><br><span class="line">         * */</span><br><span class="line">        while (row &lt; str1.length) &#123;</span><br><span class="line">            // 局部变量i,j</span><br><span class="line">            int i = row;</span><br><span class="line">            int j = col;</span><br><span class="line">            int len = 0;</span><br><span class="line">            // 相当于斜着扫一遍</span><br><span class="line">            while (i &lt; str1.length &amp;&amp; j &lt; str2.length) &#123;</span><br><span class="line">                if (str1[i] != str2[j]) &#123;</span><br><span class="line">                    // 字符不相同，当前字符串的公共长度为0</span><br><span class="line">                    len = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 字符相同，则在前者的基础上累加。除非遇到不同，才置0.</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (len &gt; max) &#123;</span><br><span class="line">                    // 每次都找到全局最大值</span><br><span class="line">                    max = len;</span><br><span class="line">                    end = i;</span><br><span class="line">                &#125;</span><br><span class="line">                // 斜着扫一遍</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (col &gt; 0) &#123;</span><br><span class="line">                // 遍历列</span><br><span class="line">                col--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 遍历行</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s1.substring(end - max + 1, end + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  随机生成字符串</span><br><span class="line">    public static String randomNumberString(int len, int range) &#123;</span><br><span class="line">        char[] str = new char[len];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            str[i] = (char) ((int) (Math.random() * range) + &#x27;a&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long start;</span><br><span class="line">        long end;</span><br><span class="line">        String str1 = &quot;zxcvbn&quot;;</span><br><span class="line">        String str2 = &quot;2e8ucvboi9u&quot;;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        // 解法1：直接填写dp表，并统计最大值，返回max和i.</span><br><span class="line">        System.out.println(&quot;方法1结果 : &quot; + lcs1(str1, str2) + &quot; , 运行时间 : &quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">        // 解法2：不使用dp二维数组，而是用有限的几个变量记录。将dp二维空间压缩到有限的几个变量</span><br><span class="line">        System.out.println(&quot;方法2结果 : &quot; + lcs2(str1, str2) + &quot; , 运行时间 : &quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
<ul>
<li>解法1：暴力递归的尝试模型，leetcode超时</li>
<li>解法2：暴力递归改写dp。leetcode通过</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">// 这个问题leetcode上可以直接测</span><br><span class="line">// 链接：https://leetcode.com/problems/longest-common-subsequence/</span><br><span class="line">public class Code04_LongestCommonSubsequence &#123;</span><br><span class="line">    public static int longestCommonSubsequence1(String s1, String s2) &#123;</span><br><span class="line">        // 解法1：暴力递归的尝试模型，leetcode超时</span><br><span class="line">        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str1 = s1.toCharArray();</span><br><span class="line">        char[] str2 = s2.toCharArray();</span><br><span class="line">        // 尝试</span><br><span class="line">        return process1(str1, str2, str1.length - 1, str2.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // str1[0...i]和str2[0...j]，这个范围上最长公共子序列长度是多少？</span><br><span class="line">    // 可能性分类:</span><br><span class="line">    // a) 最长公共子序列，不以str1[i]字符结尾、不以str2[j]字符结尾</span><br><span class="line">    // b) 最长公共子序列，以str1[i]字符结尾、不以str2[j]字符结尾</span><br><span class="line">    // c) 最长公共子序列，不以str1[i]字符结尾、以str2[j]字符结尾</span><br><span class="line">    // d) 最长公共子序列，以str1[i]字符结尾、以str2[j]字符结尾</span><br><span class="line">    // 注意：a)、b)、c)、d)并不是完全互斥的，他们可能会有重叠的情况</span><br><span class="line">    // 但是可以肯定，答案不会超过这四种可能性的范围</span><br><span class="line">    // 那么我们分别来看一下，这几种可能性怎么调用后续的递归。</span><br><span class="line">    // a) 最长公共子序列，一定不以str1[i]字符结尾、也一定不以str2[j]字符结尾</span><br><span class="line">    //    如果是这种情况，那么有没有str1[i]和str2[j]就根本不重要了，因为这两个字符一定没用啊</span><br><span class="line">    //    所以砍掉这两个字符，最长公共子序列 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归)</span><br><span class="line">    // b) 最长公共子序列，可能以str1[i]字符结尾、但是一定不以str2[j]字符结尾</span><br><span class="line">    //    如果是这种情况，那么我们可以确定str2[j]一定没有用，要砍掉；但是str1[i]可能有用，所以要保留</span><br><span class="line">    //    所以，最长公共子序列 = str1[0...i]与str2[0...j-1]的最长公共子序列长度(后续递归)</span><br><span class="line">    // c) 最长公共子序列，一定不以str1[i]字符结尾、但是可能以str2[j]字符结尾</span><br><span class="line">    //    跟上面分析过程类似，最长公共子序列 = str1[0...i-1]与str2[0...j]的最长公共子序列长度(后续递归)</span><br><span class="line">    // d) 最长公共子序列，必须以str1[i]字符结尾、也必须以str2[j]字符结尾</span><br><span class="line">    //    同时可以看到，可能性d)存在的条件，一定是在str1[i] == str2[j]的情况下，才成立的</span><br><span class="line">    //    所以，最长公共子序列总长度 = str1[0...i-1]与str2[0...j-1]的最长公共子序列长度(后续递归) + 1(共同的结尾)</span><br><span class="line">    // 综上，四种情况已经穷尽了所有可能性。四种情况中取最大即可</span><br><span class="line">    public static int process1(char[] str1, char[] str2, int i, int j) &#123;</span><br><span class="line">        // base case</span><br><span class="line">        if (i == 0 &amp;&amp; j == 0) &#123;</span><br><span class="line">            // str1[0..0]和str2[0..0]，都只剩一个字符了</span><br><span class="line">            // 那如果字符相等，公共子序列长度就是1，不相等就是0</span><br><span class="line">            return str1[i] == str2[j] ? 1 : 0;</span><br><span class="line">        &#125; else if (i == 0) &#123;</span><br><span class="line">            // 这里的情况为：</span><br><span class="line">            // str1[0...0]和str2[0...j]，str1只剩1个字符了，但是str2不只一个字符</span><br><span class="line">            // 因为str1只剩一个字符了，所以str1[0...0]和str2[0...j]公共子序列最多长度为1</span><br><span class="line">            // 如果str1[0] == str2[j]，那么此时相等已经找到了！公共子序列长度就是1，也不可能更大了</span><br><span class="line">            // 如果str1[0] != str2[j]，只是此时不相等而已，那么str2[0...j-1]上有没有字符等于str1[0]呢？不知道，所以递归继续找</span><br><span class="line">            if (str1[i] == str2[j]) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return process1(str1, str2, i, j - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (j == 0) &#123;</span><br><span class="line">            // 和上面的else if同理</span><br><span class="line">            if (str1[i] == str2[j]) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return process1(str1, str2, i - 1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // i != 0 &amp;&amp; j != 0</span><br><span class="line">            // 这里的情况为：</span><br><span class="line">            // str1[0...i]和str2[0...i]，str1和str2都不只一个字符</span><br><span class="line">            // 对应可能性a</span><br><span class="line">            int p1 = process1(str1, str2, i - 1, j - 1);</span><br><span class="line">            // 对应可能性c</span><br><span class="line">            int p2 = process1(str1, str2, i - 1, j);</span><br><span class="line">            // 对应可能性b</span><br><span class="line">            int p3 = process1(str1, str2, i, j - 1);</span><br><span class="line">            // 对应可能性d</span><br><span class="line">            // 如果str1[i] == str2[j]，那么p3就求出来，参与pk</span><br><span class="line">            // 如果str1[i] != str2[j]，那么让p3等于0，然后去参与pk，反正不影响</span><br><span class="line">            int p4 = 0;</span><br><span class="line">            if (str1[i] == str2[j]) &#123;</span><br><span class="line">                p4 = 1 + p1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 取p1,p2,p3,p4中的最大值</span><br><span class="line">            return Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int longestCommonSubsequence2(String s1, String s2) &#123;</span><br><span class="line">        // 解法2：暴力递归改写dp。leetcode通过</span><br><span class="line">        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str1 = s1.toCharArray();</span><br><span class="line">        char[] str2 = s2.toCharArray();</span><br><span class="line">        int N = str1.length;</span><br><span class="line">        int M = str2.length;</span><br><span class="line">        // dp[i][j]表示以str1以i结尾，str2以j结尾的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[N][M];</span><br><span class="line">        dp[0][0] = str1[0] == str2[0] ? 1 : 0;</span><br><span class="line">        for (int j = 1; j &lt; M; j++) &#123;</span><br><span class="line">            dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">            dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; M; j++) &#123;</span><br><span class="line">                int p1 = dp[i - 1][j];</span><br><span class="line">                int p2 = dp[i][j - 1];</span><br><span class="line">                int p3 = dp[i-1][j - 1];</span><br><span class="line">                int p4 = str1[i] == str2[j] ? (1 + p3) : 0;</span><br><span class="line">                // 取p1,p2,p3,p4中的最大值填写到dp表</span><br><span class="line">                dp[i][j] = Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[N - 1][M - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词频最大前K个字符串"><a href="#词频最大前K个字符串" class="headerlink" title="词频最大前K个字符串"></a>词频最大前K个字符串</h3><p>题目：给定一个由字符串组成的数组String[] strs,给定一个正数K.返回词频最大的前K个字符串，假设结果是唯一的。</p>
<p><strong>思路</strong>：先搞一个HashMap，遍历整个数组。</p>
<ul>
<li>解法1：搞一个大根堆，然后遍历HashMap建立，最后从堆顶拿K个。</li>
<li>解法2：搞一个Size大小规定为K的小根堆，每次从HashMap里拿的时候直接跟栈顶比较，如果小于栈顶直接不考虑（即，进入小根堆的门槛），大于栈顶则丢掉栈顶，加入这个元素.最后的小根堆就是最大的前K个字符串。这个比较经典。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Code06_TopKTimes &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] s = &#123;&quot;abc&quot;,&quot;ab&quot;,&quot;ab&quot;,&quot;bc&quot;,&quot;ac&quot;,&quot;abc&quot;,&quot;ef&quot;,&quot;kisd&quot;,&quot;ef&quot;,&quot;ef&quot;&#125;;</span><br><span class="line">        printTopKAndRank(s,2);</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public String str;</span><br><span class="line">        public int times;</span><br><span class="line"></span><br><span class="line">        public Node(String s, int t) &#123;</span><br><span class="line">            this.str = s;</span><br><span class="line">            this.times = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 按照词频规则排序</span><br><span class="line">    public static class  NodeComparator implements Comparator&lt;Node&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Node o1, Node o2) &#123;</span><br><span class="line">            return o1.times - o2.times;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法2：创建小根堆，遍历剔除顶部值，最终留下的小根堆就是topk的字符串</span><br><span class="line">    public static void printTopKAndRank(String[] arr, int topK) &#123;</span><br><span class="line">        if (arr == null || arr.length == 0 || topK &lt; 1 || topK &gt; arr.length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 构建字符串和词频的键值对</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (String str : arr) &#123;</span><br><span class="line">            if (!map.containsKey(str)) &#123;</span><br><span class="line">                map.put(str, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(str, map.get(str) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        topK = Math.min(arr.length,topK);</span><br><span class="line">        // 按照词频建立小根堆</span><br><span class="line">        PriorityQueue heap = new PriorityQueue&lt;&gt;(new NodeComparator());</span><br><span class="line">        for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            // 新建节点</span><br><span class="line">            Node cur = new Node(entry.getKey(), entry.getValue());</span><br><span class="line">            if (heap.size() &lt; topK) &#123;</span><br><span class="line">                // 如果小根堆不足k个，直接添加</span><br><span class="line">                heap.add(cur);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Node node = (Node)heap.peek();</span><br><span class="line">                if (node.times &lt; cur.times) &#123;</span><br><span class="line">                    // 如果当前值大于小根堆的顶部值，把当期值替换顶部值，小根堆内部heapfy</span><br><span class="line">                    heap.poll();</span><br><span class="line">                    heap.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!heap.isEmpty()) &#123;</span><br><span class="line">            // 依次弹出所有的小根堆数据，刚好就是前K个最大词频字符串</span><br><span class="line">            Node node = (Node)heap.poll();</span><br><span class="line">            System.out.println(node.str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词频最大的K个元素"><a href="#词频最大的K个元素" class="headerlink" title="词频最大的K个元素"></a>词频最大的K个元素</h3><p>题目：在实时数据流中找到最常使用的k个单词.实现<em>TopK</em>类中的三个方法:<br><code>TopK(k)</code>, 构造方法<br><code>add(word)</code>, 增加一个新单词<br><code>topk()</code>, 得到当前最常使用的k个单词.</p>
<ul>
<li>解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">// 本题测试链接：https://www.lintcode.com/problem/top-k-frequent-words-ii/</span><br><span class="line">// 以上的代码不要粘贴, 把以下的代码粘贴进java环境编辑器</span><br><span class="line">// 把类名和构造方法名改成TopK, 可以直接通过</span><br><span class="line">public class Code02_TopK &#123;</span><br><span class="line">    private Node[] heap;</span><br><span class="line">    private int heapSize;</span><br><span class="line">    // 词频表   key  abc   value  (abc,7)</span><br><span class="line">    private HashMap&lt;String, Node&gt; strNodeMap;</span><br><span class="line">    // 自己实现的动态小根堆-索引表</span><br><span class="line">    private HashMap&lt;Node, Integer&gt; nodeIndexMap;</span><br><span class="line">    private NodeHeapComp comp;</span><br><span class="line">    // 自己实现的动态小根堆</span><br><span class="line">    private TreeSet&lt;Node&gt; treeSet;</span><br><span class="line"></span><br><span class="line">    public Code02_TopK(int K) &#123;</span><br><span class="line">        heap = new Node[K];</span><br><span class="line">        heapSize = 0;</span><br><span class="line">        strNodeMap = new HashMap&lt;String, Node&gt;();</span><br><span class="line">        nodeIndexMap = new HashMap&lt;Node, Integer&gt;();</span><br><span class="line">        comp = new NodeHeapComp();</span><br><span class="line">        treeSet = new TreeSet&lt;&gt;(new NodeTreeSetComp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        public String str;</span><br><span class="line">        public int times;</span><br><span class="line">        public Node(String s, int t) &#123;</span><br><span class="line">            str = s;</span><br><span class="line">            times = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NodeHeapComp implements Comparator&lt;Node&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Node o1, Node o2) &#123;</span><br><span class="line">            return o1.times != o2.times ? (o1.times - o2.times) : (o2.str.compareTo(o1.str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NodeTreeSetComp implements Comparator&lt;Node&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Node o1, Node o2) &#123;</span><br><span class="line">            return o1.times != o2.times ? (o2.times - o1.times) : (o1.str.compareTo(o2.str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解法：小根堆加入节点，注意只有比小根堆顶点值大的节点才能加入，始终保证大值入堆。因为复杂度要求是O(logk),所以只能是自己实现的动态小根堆。</span><br><span class="line">    public void add(String str) &#123;</span><br><span class="line">        if (heap.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // str   找到对应节点  curNode</span><br><span class="line">        Node curNode = null;</span><br><span class="line">        // 对应节点  curNode  在堆上的位置</span><br><span class="line">        int preIndex = -1;</span><br><span class="line">        if (!strNodeMap.containsKey(str)) &#123;</span><br><span class="line">            curNode = new Node(str, 1);</span><br><span class="line">            strNodeMap.put(str, curNode);</span><br><span class="line">            nodeIndexMap.put(curNode, -1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curNode = strNodeMap.get(str);</span><br><span class="line">            // 要在time++之前，先在treeSet中删掉</span><br><span class="line">            // 原因是因为一但times++，curNode在treeSet中的排序就失效了</span><br><span class="line">            // 这种失效会导致整棵treeSet出现问题</span><br><span class="line">            if (treeSet.contains(curNode)) &#123;</span><br><span class="line">                treeSet.remove(curNode);</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.times++;</span><br><span class="line">            preIndex = nodeIndexMap.get(curNode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (preIndex == -1) &#123;</span><br><span class="line">            if (heapSize == heap.length) &#123;</span><br><span class="line">                if (comp.compare(heap[0], curNode) &lt; 0) &#123;</span><br><span class="line">                    treeSet.remove(heap[0]);</span><br><span class="line">                    treeSet.add(curNode);</span><br><span class="line">                    nodeIndexMap.put(heap[0], -1);</span><br><span class="line">                    nodeIndexMap.put(curNode, 0);</span><br><span class="line">                    heap[0] = curNode;</span><br><span class="line">                    heapify(0, heapSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                treeSet.add(curNode);</span><br><span class="line">                nodeIndexMap.put(curNode, heapSize);</span><br><span class="line">                heap[heapSize] = curNode;</span><br><span class="line">                heapInsert(heapSize++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            treeSet.add(curNode);</span><br><span class="line">            heapify(preIndex, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回topK个最大的节点即最终的小根堆</span><br><span class="line">    public List&lt;String&gt; topk() &#123;</span><br><span class="line">        ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (Node node : treeSet) &#123;</span><br><span class="line">            ans.add(node.str);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void heapInsert(int index) &#123;</span><br><span class="line">        while (index != 0) &#123;</span><br><span class="line">            int parent = (index - 1) / 2;</span><br><span class="line">            if (comp.compare(heap[index], heap[parent]) &lt; 0) &#123;</span><br><span class="line">                swap(parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void heapify(int index, int heapSize) &#123;</span><br><span class="line">        int l = index * 2 + 1;</span><br><span class="line">        int r = index * 2 + 2;</span><br><span class="line">        int smallest = index;</span><br><span class="line">        while (l &lt; heapSize) &#123;</span><br><span class="line">            if (comp.compare(heap[l], heap[index]) &lt; 0) &#123;</span><br><span class="line">                smallest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r &lt; heapSize &amp;&amp; comp.compare(heap[r], heap[smallest]) &lt; 0) &#123;</span><br><span class="line">                smallest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            if (smallest != index) &#123;</span><br><span class="line">                swap(smallest, index);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            index = smallest;</span><br><span class="line">            l = index * 2 + 1;</span><br><span class="line">            r = index * 2 + 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int index1, int index2) &#123;</span><br><span class="line">        nodeIndexMap.put(heap[index1], index2);</span><br><span class="line">        nodeIndexMap.put(heap[index2], index1);</span><br><span class="line">        Node tmp = heap[index1];</span><br><span class="line">        heap[index1] = heap[index2];</span><br><span class="line">        heap[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知树的先序和中序，求后序"><a href="#已知树的先序和中序，求后序" class="headerlink" title="已知树的先序和中序，求后序"></a>已知树的先序和中序，求后序</h3><p>题目：已知一棵二叉树中没有重复节点，给定它的先序和中序遍历数组，求后序遍历数组。比如int[] pre={1,2,4,5,3,6,7},int[] in={4,2,5,1,6,3,7}返回{4,5,2,6,7,3,1}</p>
<ul>
<li>解法1：暴力递归，每次查询树范围索引mid,不断左树右树递归，恢复pos数组</li>
<li>解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_PreAndInArrayToPosArray</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">  <span class="keyword">public</span> Node left;</span><br><span class="line">  <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">   value = v;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] preInToPos1(<span class="type">int</span>[] pre, <span class="type">int</span>[] in) &#123;</span><br><span class="line">  <span class="comment">// 解法1：暴力递归，每次查询树范围索引</span></span><br><span class="line">  <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length != in.length) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> pre.length;</span><br><span class="line">  <span class="type">int</span>[] pos = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">  <span class="comment">// 传入2个数组和索引值，将后序数组pos排好即可</span></span><br><span class="line">  process1(pre, <span class="number">0</span>, N - <span class="number">1</span>, in, <span class="number">0</span>, N - <span class="number">1</span>, pos, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传入2个数组和索引值，将后序数组pos排好即可</span></span><br><span class="line"> <span class="comment">// L1...R1 L2...R2 L3...R3</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span>[] in, <span class="type">int</span> L2, <span class="type">int</span> R2, <span class="type">int</span>[] pos, <span class="type">int</span> L3, <span class="type">int</span> R3)</span> &#123;</span><br><span class="line">  <span class="comment">// 边界，索引值不对，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果只有一个元素了，先序的第一个节点即根节点就是后续的最后一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">   pos[L3] = pre[L1];</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首先，先序的第一个节点即根节点就是后续的最后一个节点。取出了根节点，然后就要取出左右节点范围</span></span><br><span class="line">  pos[R3] = pre[L1];</span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L2;</span><br><span class="line">  <span class="keyword">for</span> (; mid &lt;= R2; mid++) &#123;</span><br><span class="line">   <span class="comment">// 在中序数组中，找到对应头结点的索引。mid索引值大小就是区分左右节点的范围</span></span><br><span class="line">   <span class="keyword">if</span> (in[mid] == pre[L1]) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> mid - L2;</span><br><span class="line">  <span class="comment">// [L1 + 1, L1 + leftSize]对应先序的左树，[L2, mid - 1]对应中序的左树，[L3, L3 + leftSize - 1]对应后序的左树。剩余的左树范围的pos后序数组继续填充</span></span><br><span class="line">  process1(pre, L1 + <span class="number">1</span>, L1 + leftSize, in, L2, mid - <span class="number">1</span>, pos, L3, L3 + leftSize - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// ...右树，右树，右树。剩余的右树范围的pos后序数组继续填充</span></span><br><span class="line">  process1(pre, L1 + leftSize + <span class="number">1</span>, R1, in, mid + <span class="number">1</span>, R2, pos, L3 + leftSize, R3 - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] preInToPos2(<span class="type">int</span>[] pre, <span class="type">int</span>[] in) &#123;</span><br><span class="line">  <span class="comment">// 解法2：暴力递归，提前缓存好中序遍历的所有节点索引，方便直接取出</span></span><br><span class="line">  <span class="keyword">if</span> (pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length != in.length) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> pre.length;</span><br><span class="line">  <span class="comment">// 缓存map</span></span><br><span class="line">  HashMap&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">   inMap.put(in[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span>[] pos = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">  process2(pre, <span class="number">0</span>, N - <span class="number">1</span>, in, <span class="number">0</span>, N - <span class="number">1</span>, pos, <span class="number">0</span>, N - <span class="number">1</span>, inMap);</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span>[] in, <span class="type">int</span> L2, <span class="type">int</span> R2, <span class="type">int</span>[] pos, <span class="type">int</span> L3, <span class="type">int</span> R3,</span></span><br><span class="line"><span class="params">   HashMap&lt;Integer, Integer&gt; inMap)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">   pos[L3] = pre[L1];</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pos[R3] = pre[L1];</span><br><span class="line">  <span class="comment">// 直接取出索引值</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> inMap.get(pre[L1]);</span><br><span class="line">  <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> mid - L2;</span><br><span class="line">  process2(pre, L1 + <span class="number">1</span>, L1 + leftSize, in, L2, mid - <span class="number">1</span>, pos, L3, L3 + leftSize - <span class="number">1</span>, inMap);</span><br><span class="line">  process2(pre, L1 + leftSize + <span class="number">1</span>, R1, in, mid + <span class="number">1</span>, R2, pos, L3 + leftSize, R3 - <span class="number">1</span>, inMap);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">   System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] pre=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="type">int</span>[] in=&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="type">int</span>[] ans1 = preInToPos1(pre, in);</span><br><span class="line">  <span class="type">int</span>[] ans2 = preInToPos2(pre, in);</span><br><span class="line">  print(ans1);</span><br><span class="line">  print(ans2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目：给出数组{4,10,4,3,8,9}，求最长的递增子序列的长度。</p>
<p>思路：子序列可以不连续，但要按照原数组顺序。还要递增。所以{3,8,9}或{4,8,9}等等 长度为3.</p>
<ul>
<li>解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做</li>
<li>解法2：ends数组辅助加速获取最大递增子序列的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题测试链接 : https://leetcode.com/problems/longest-increasing-subsequence</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_LIS</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] arr=&#123;<span class="number">4</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">      System.out.println(lengthOfLIS0(arr));</span><br><span class="line">      System.out.println(lengthOfLIS1(arr));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS0</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">      <span class="comment">// 解法1：定义dp[i]表示第i个位置的最长递增子序列长度.必须双重循环来做</span></span><br><span class="line">      <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">      <span class="comment">// 取dp数组最大值返回</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">dpMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="comment">// 逐一比较,找到前面的所有序列的最大长度值</span></span><br><span class="line">            <span class="comment">// 固定i,j从0到i-1扫一遍，如果arr[i]&gt;arr[j]，长度是dp[j]+1.否则长度就是1.记录全局最大值即可</span></span><br><span class="line">            max=Math.max(max,arr[i]&gt;arr[j]?dp[j]+<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         dp[i]=max;</span><br><span class="line">         dpMax = Math.max(dpMax,max);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dpMax;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">      <span class="comment">// 解法2：ends数组辅助加速获取最大递增子序列的长度。</span></span><br><span class="line">      <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ends数组,非常难以理解，它是一个递增数组。更新ends规则：要么更新，要么扩容添加。它用来加速获取最大递增子序列值，避免了双重循环。</span></span><br><span class="line">      <span class="comment">// ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾元素</span></span><br><span class="line">      <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">      <span class="comment">// 根据含义, 一开始ends[0] = arr[0]</span></span><br><span class="line">      ends[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// ends有效区范围是0...right，right往右为无效区</span></span><br><span class="line">      <span class="comment">// 所以一开始right = 0, 表示有效区只有0...0范围</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 寻找 &gt;= 当前数(arr[i])的最左位置，赋值给l</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">         <span class="comment">// 在ends[l...r]范围上二分</span></span><br><span class="line">         <span class="comment">// 如果 当前数(arr[i]) &gt; ends[m]，砍掉左侧</span></span><br><span class="line">         <span class="comment">// 如果 当前数(arr[i]) &lt;= ends[m]，砍掉右侧</span></span><br><span class="line">         <span class="comment">// 整个二分就是在ends里寻找 &gt;= 当前数(arr[i])的最左位置,即l</span></span><br><span class="line">         <span class="comment">// 如果存在l,则更新值。如果不存在l,则扩容添加</span></span><br><span class="line">         <span class="comment">// 比如存在l : ends = &#123; 3, 5, 9, 12, 再往右无效&#125;</span></span><br><span class="line">         <span class="comment">// 如果当前数为8, 从while里面出来时，l将来到2位置，ends更新为&#123; 3, 5, 8, 12, 再往右无效&#125;</span></span><br><span class="line">         <span class="comment">// 比如不存在l : ends = &#123; 3, 5, 9, 12, 再往右无效&#125;</span></span><br><span class="line">         <span class="comment">// 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，扩容到4位置，ends扩容添加为&#123; 3, 5, 9, 12, 13,再往右无效&#125;</span></span><br><span class="line">         <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; ends[m]) &#123;</span><br><span class="line">               l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 从while里面出来，看l的位置</span></span><br><span class="line">         <span class="comment">// 如果l比right大，说明扩充了有效区，那么right变量要随之变大---&gt;扩容</span></span><br><span class="line">         <span class="comment">// 如果l不比right大，说明l没有来到有效区的越界位置，right不变---&gt;更新</span></span><br><span class="line">         right = Math.max(right, l);</span><br><span class="line">         <span class="comment">// l的位置，就是当前数应该填到ends数组里的位置，更新或扩容添加，都要赋值</span></span><br><span class="line">         ends[l] = arr[i];</span><br><span class="line">         <span class="comment">// 更新全局变量，一定是end中最大值的索引+1</span></span><br><span class="line">         max = Math.max(max, l + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="俄罗斯套娃信封"><a href="#俄罗斯套娃信封" class="headerlink" title="俄罗斯套娃信封"></a><strong>俄罗斯套娃信封</strong></h3><p>题目：给一定数量的信封，带有整数对 <code>(w, h)</code> 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。<br>求最大的信封嵌套层数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">最大的信封嵌套层数是 <span class="number">3</span> ([<span class="number">2</span>,<span class="number">3</span>] =&gt; [<span class="number">5</span>,<span class="number">4</span>] =&gt; [<span class="number">6</span>,<span class="number">7</span>])。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">// 本题测试链接 : https://leetcode.com/problems/russian-doll-envelopes/</span><br><span class="line">public class Code04_EnvelopesProblem &#123;</span><br><span class="line"> public static int maxEnvelopes(int[][] matrix) &#123;</span><br><span class="line">  // 解法1：对象数组按照长度升序高度降序排序，然后把各自的高度挑出来，组成数组，它的最大递增子序列长度就是返回值</span><br><span class="line">  Envelope[] arr = sort(matrix);</span><br><span class="line">  int[] ends = new int[matrix.length];</span><br><span class="line">  ends[0] = arr[0].h;</span><br><span class="line">  int right = 0;</span><br><span class="line">  int l = 0;</span><br><span class="line">  int r = 0;</span><br><span class="line">  int m = 0;</span><br><span class="line">  // 二分法，查找l</span><br><span class="line">  for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">   l = 0;</span><br><span class="line">   r = right;</span><br><span class="line">   while (l &lt;= r) &#123;</span><br><span class="line">    m = (l + r) / 2;</span><br><span class="line">    if (arr[i].h &gt; ends[m]) &#123;</span><br><span class="line">     l = m + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     r = m - 1;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   right = Math.max(right, l);</span><br><span class="line">   ends[l] = arr[i].h;</span><br><span class="line">  &#125;</span><br><span class="line">  return right + 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static class Envelope &#123;</span><br><span class="line">  public int l;</span><br><span class="line">  public int h;</span><br><span class="line"></span><br><span class="line">  public Envelope(int weight, int hight) &#123;</span><br><span class="line">   l = weight;</span><br><span class="line">   h = hight;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static class EnvelopeComparator implements Comparator&lt;Envelope&gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  // l升序，h降序</span><br><span class="line">  public int compare(Envelope o1, Envelope o2) &#123;</span><br><span class="line">   return o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static Envelope[] sort(int[][] matrix) &#123;</span><br><span class="line">  Envelope[] res = new Envelope[matrix.length];</span><br><span class="line">  for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">   res[i] = new Envelope(matrix[i][0], matrix[i][1]);</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(res, new EnvelopeComparator());</span><br><span class="line">  return res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最大累加和"><a href="#最大累加和" class="headerlink" title="最大累加和"></a>最大累加和</h3><p>题目：给定一个数组arr,返回子数组的最大累加和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题测试链接 : https://leetcode.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_SubArrayMaxSum</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 解法1：利用两个变量记录cur和max.</span></span><br><span class="line">      <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">      <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 记录实时累加值</span></span><br><span class="line">         cur += arr[i];</span><br><span class="line">      <span class="comment">// 比较获取全局最大值</span></span><br><span class="line">         max = Math.max(max, cur);</span><br><span class="line">      <span class="comment">// 如果实时累加值为负数的，则前面的直接丢弃，从0重新开始累加计算</span></span><br><span class="line">         cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树转为双向链表"><a href="#二叉树转为双向链表" class="headerlink" title="二叉树转为双向链表"></a>二叉树转为双向链表</h3><p>题目：将BST二叉搜索树转换为已排序的循环双向链表。可以将左右指针视为双向链表中上一个和下一个指针的同义词。</p>
<ul>
<li>解法1：使用二叉树递归套路，利用中序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 本题测试链接 : https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</span><br><span class="line">public class Code04_BSTtoDoubleLinkedList &#123;</span><br><span class="line">   // 提交时不要提交这个类</span><br><span class="line">   public static class Node &#123;</span><br><span class="line">      public int value;</span><br><span class="line">      public Node left;</span><br><span class="line">      public Node right;</span><br><span class="line">      public Node(int data) &#123;</span><br><span class="line">         this.value = data;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 提交下面的代码</span><br><span class="line">   public static Node treeToDoublyList(Node head) &#123;</span><br><span class="line">      // 解法1：使用二叉树递归套路，利用中序遍历</span><br><span class="line">      if (head == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      Info allInfo = process(head);</span><br><span class="line">      // 因为是双向链表，最后还要首尾连接起来</span><br><span class="line">      allInfo.end.right = allInfo.start;</span><br><span class="line">      allInfo.start.left = allInfo.end;</span><br><span class="line">      return allInfo.start;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 组装头尾节点数据结构，头节点和尾节点</span><br><span class="line">   public static class Info &#123;</span><br><span class="line">      public Node start;</span><br><span class="line">      public Node end;</span><br><span class="line">      public Info(Node start, Node end) &#123;</span><br><span class="line">         this.start = start;</span><br><span class="line">         this.end = end;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 给定一个根节点为x的树，转化为链表后，返回头尾节点数据结构</span><br><span class="line">   public static Info process(Node X) &#123;</span><br><span class="line">      if (X == null) &#123;</span><br><span class="line">         return new Info(null, null);</span><br><span class="line">      &#125;</span><br><span class="line">      // 得到左子树的头尾节点</span><br><span class="line">      Info lInfo = process(X.left);</span><br><span class="line">      // 得到右子树的头尾节点</span><br><span class="line">      Info rInfo = process(X.right);</span><br><span class="line">      // 将x与左子树串起来</span><br><span class="line">      X.left = lInfo.end;</span><br><span class="line">      // 将x与右子树串起来</span><br><span class="line">      X.right = rInfo.start;</span><br><span class="line">      // 将左子树与x串起来</span><br><span class="line">      if (lInfo.end != null) &#123;</span><br><span class="line">         lInfo.end.right = X;</span><br><span class="line">      &#125;</span><br><span class="line">      // 将右子树与x串起来</span><br><span class="line">      if (rInfo.start != null) &#123;</span><br><span class="line">         rInfo.start.left = X;</span><br><span class="line">      &#125;</span><br><span class="line">      // 整体链表的头，继续往左子树找    lInfo.start != null ? lInfo.start : X</span><br><span class="line">      // 整体链表的尾，继续往右子树找    rInfo.end != null ? rInfo.end : X</span><br><span class="line">      return new Info(lInfo.start != null ? lInfo.start : X, rInfo.end != null ? rInfo.end : X);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="str1编辑成str2的最小代价"><a href="#str1编辑成str2的最小代价" class="headerlink" title="str1编辑成str2的最小代价"></a><strong>str1编辑成str2的最小代价</strong></h3><p>题目：给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。</p>
<p>【举例】</p>
<p>str1=”abc”，str2=”adc”，ic=5，dc=3，rc=2 从”abc”编辑成”adc”，把’b’替换成’d’是代价最小的，所以返回2</p>
<p>str1=”abc”，str2=”adc”，ic=5，dc=3，rc=100 从”abc”编辑成”adc”，先删除’b’，然后插入’d’是代价最小的，所以返回8</p>
<p>str1=”abc”，str2=”abc”，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_EditCost</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCost1</span><span class="params">(String s1, String s2, <span class="type">int</span> ic, <span class="type">int</span> dc, <span class="type">int</span> rc)</span> &#123;</span><br><span class="line">      <span class="comment">// 解法1：直接写dp，dp[i][j]表示s1的前i个字符串变成s2的前j个字符串的最小代价</span></span><br><span class="line">      <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">      <span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">      <span class="comment">// dp[0][0] = 0，不用任何操作</span></span><br><span class="line">      <span class="comment">// dp边界，从有字符串变成空，需要依次删除的代价</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">         dp[i][<span class="number">0</span>] = dc * i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// dp边界，从空变成有字符串，需要依次添加的代价</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">         dp[<span class="number">0</span>][j] = ic * j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*s1变成s2,正常的四种情况</span></span><br><span class="line"><span class="comment">      * s1 0---i-1,i</span></span><br><span class="line"><span class="comment">      * s2 0---j-1,j</span></span><br><span class="line"><span class="comment">      * 1.如果s1的前i-1和s2的前j-1是相等的</span></span><br><span class="line"><span class="comment">      * a.s1[i]==s2[j],代价就是dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">      * b.s1[i]!=s2[j],代价就是dp[i-1][j-1]+rc(一个替换的代价)</span></span><br><span class="line"><span class="comment">      * 2.如果s1的前i-1和s2的前j-1是不等的</span></span><br><span class="line"><span class="comment">      * c.s1[0---i]替换s2[0---j-1],代价是dp[i][j-1]+ic(一个新增的代价，因为从i变成了j-1,理论上字符变少了一个，所以最后要追加一个)</span></span><br><span class="line"><span class="comment">      * d.s1[0---i-1]替换s2[0---j],代价是dp[i-1][j]+dc(一个删除的代价，因为从i-1变成了j,理论上字符变多了一个，所以最后要删除一个)</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="comment">// 情况a,情况b</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>] ? <span class="number">0</span> : rc);</span><br><span class="line">            <span class="comment">// 情况c</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + ic);</span><br><span class="line">            <span class="comment">// 情况d</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + dc);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最后返回s1前N个字符串变成s2前M个字符串的代价。N个对应N-1的索引</span></span><br><span class="line">      <span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>str1删除成str2的最小个数字符</strong></p>
<p>题目：给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = “abcde”，s2 = “axbc”。返回 1</p>
<ul>
<li>解法1：求出str2所有的子序列，然后按照长度排序，长度大的排在前面。然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Code04_DeleteMinCost &#123;</span><br><span class="line"> // 解法一</span><br><span class="line"> // 求出str2所有的子序列，然后按照长度排序，长度大的排在前面。</span><br><span class="line"> // 然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。</span><br><span class="line"> // 分析：</span><br><span class="line"> // 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。</span><br><span class="line"> // 但是如果某一次考试给定的s2长度远大于s1，这么做就不合适了。</span><br><span class="line"> public static int minCost1(String s1, String s2) &#123;</span><br><span class="line">  List&lt;String&gt; s2Subs = new ArrayList&lt;&gt;();</span><br><span class="line">  // 递归求解s2的所有子序列</span><br><span class="line">  process(s2.toCharArray(), 0, &quot;&quot;, s2Subs);</span><br><span class="line">  // 对所有子序列的长度按照降序排列</span><br><span class="line">  s2Subs.sort(new LenComp());</span><br><span class="line">  for (String str : s2Subs) &#123;</span><br><span class="line">   // 查看s2的所有子序列是否是s1的子串</span><br><span class="line">   if (s1.indexOf(str) != -1) &#123; // indexOf底层和KMP算法代价几乎一样，也可以用KMP代替</span><br><span class="line">    // 只要找到了，那么删除的长度就是s2-当前子序列的长度</span><br><span class="line">    return s2.length() - str.length();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果一个都没找到，说明要全删除</span><br><span class="line">  return s2.length();</span><br><span class="line"> &#125;</span><br><span class="line"> public static class LenComp implements Comparator&lt;String&gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(String o1, String o2) &#123;</span><br><span class="line">   return o2.length() - o1.length();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求完全二叉树节点的个数"><a href="#求完全二叉树节点的个数" class="headerlink" title="求完全二叉树节点的个数"></a>求完全二叉树节点的个数</h3><p>题目：要求时间复杂度低于O(N).</p>
<ul>
<li><pre><code>解法1：递归套路，O(h2)即O((logN)2)，之前是O(n)
 * a.计算出最大深度，一直向左窜
 * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树
 * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树
 * d.直到某个节点来到最大深度，节点个数为1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
//本题测试链接 : https://leetcode.cn/problems/count-complete-tree-nodes/
public class Code04_CompleteTreeNodeNumber &#123;
  // 提交时不要提交这个类
  public class TreeNode &#123;
      int val;
      TreeNode left;
      TreeNode right;
  &#125;

  /*
   * 解法1：递归套路，O(h2)即O((logN)2)，之前是O(n)
   * a.计算出最大深度，一直向左窜
   * b.如果右子树的最左节点的深度达到最大深度，则说明左树满的，直接计算左树节点个数+1根节点+递归右子树
   * c.否则右树是满的，直接计算右树节点个数+1根节点+递归左子树
   * d.直到某个节点来到最大深度，节点个数为1
   * */
  public static int countNodes(TreeNode head) &#123;
      if (head == null) &#123;
          return 0;
      &#125;
      // 给定头结点，节点的所在层数，节点的树高度，返回节点个数
      return bs(head, 1, mostLeftLevel(head, 1));
  &#125;

  // 当前来到node节点，node节点在level层，总层数是h
  // 返回node为头的子树(必是完全二叉树)，有多少个节点
  public static int bs(TreeNode node, int Level, int h) &#123;
      // base case:说明节点来到了最后一层
      if (Level == h) &#123;
          return 1;
      &#125;
      // 判断节点的右子树的最左节点是否到达最后一层
      if (mostLeftLevel(node.right, Level + 1) == h) &#123;
          // 如果到达最后一层，说明左子树是满的，继续递归右子树
          // 已知高度h计算节点个数：(2^h)-1,所以2^(h - Level)左树节点 -1 +1根节点
          return (1 &lt;&lt; (h - Level)) + bs(node.right, Level + 1, h);
      &#125; else &#123;
          // 如果没有到达最后一层，说明右子树是满的，继续递归左子树
          // 2^(h - Level-1)右树节点 —1 +1根节点
          return (1 &lt;&lt; (h - Level - 1)) + bs(node.left, Level + 1, h);
      &#125;
  &#125;

  // 如果node在第level层，求以node为头的子树，最大深度是多少。这是一个固定值
  // 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。定义根节点是第1层
  public static int mostLeftLevel(TreeNode node, int level) &#123;
      // 因为是完全二叉树，所以可以左节点一直往下扎，计算树的高度
      while (node != null) &#123;
          level++;
          node = node.left;
      &#125;
      // 高度
      return level - 1;
  &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### LRU算法</span><br><span class="line"></span><br><span class="line">LRU算法全称是最近最少使用算法（Least Recently Use），广泛的应用于缓存机制中。如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。所以顾名思义，LRU算法会选出最近最少使用的数据进行淘汰。</span><br><span class="line"></span><br><span class="line">- 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)</span><br><span class="line">- 解法2：基于LinkedHashMap实现的LRU</span><br><span class="line"></span><br></pre></td></tr></table></figure>
import java.util.HashMap;
// 本题测试链接 : https://leetcode.com/problems/lru-cache/
// 提交时把类名和构造方法名改成 : LRUCache
public class Code01_LRUCache &#123;
  public Code01_LRUCache(int capacity) &#123;
      cache = new MyCache&lt;&gt;(capacity);
  &#125;
  private MyCache&lt;Integer, Integer&gt; cache;

  public int get(int key) &#123;
      Integer ans = cache.get(key);
      return ans == null ? -1 : ans;
  &#125;

  public void put(int key, int value) &#123;
      cache.set(key, value);
  &#125;
  public static class Node&lt;K, V&gt; &#123;
      public K key;
      public V value;
      public Node&lt;K, V&gt; last;
      public Node&lt;K, V&gt; next;

      public Node(K key, V value) &#123;
          this.key = key;
          this.value = value;
      &#125;
  &#125;

  // 双向链表，LRU的关键，头结点是最不常使用，尾节点是最长使用。所以LRU是删除头结点，更新尾节点
  public static class NodeDoubleLinkedList&lt;K, V&gt; &#123;
      private Node&lt;K, V&gt; head;
      private Node&lt;K, V&gt; tail;

      public NodeDoubleLinkedList() &#123;
          head = null;
          tail = null;
      &#125;

      // 现在来了一个新的node，请挂到尾巴上去
      public void addNode(Node&lt;K, V&gt; newNode) &#123;
          if (newNode == null) &#123;
              return;
          &#125;
          if (head == null) &#123;
              head = newNode;
              tail = newNode;
          &#125; else &#123;
              tail.next = newNode;
              newNode.last = tail;
              tail = newNode;
          &#125;
      &#125;

      // 将当前节点挂到整个链表的尾巴上
      public void moveNodeToTail(Node&lt;K, V&gt; node) &#123;
          if (tail == node) &#123;
              return;
          &#125;
          if (head == node) &#123;
              // 如果要移动的节点是头结点
              // 当前节点的下一个节点变成新头
              head = node.next;
              // 头结点的上一节点指向空
              head.last = null;
          &#125; else &#123;
              // 如果要移动的节点是其他结点，那么这个节点前后节点要重新粘起来。如：当前节点的上一个节点的下一个指向当前节点的下一个节点。
              node.last.next = node.next;
              node.next.last = node.last;
          &#125;
          // 当前节点的上一个节点指向老尾巴节点
          node.last = tail;
          // 老尾巴节点的下一个节点指向当前节点
          tail.next = node;
          // 当前节点的下一节点指向空
          node.next = null;
          // 新尾巴更新为当前节点
          tail = node;
      &#125;

      // 双向链表删除头结点
      public Node&lt;K, V&gt; removeHead() &#123;
          if (head == null) &#123;
              return null;
          &#125;
          // 先提取出返回值
          Node&lt;K, V&gt; res = head;
          // 调整头尾指针
          if (head == tail) &#123;
              // 头尾节点相同，说明只有一个节点，直接全指向空
              head = null;
              tail = null;
          &#125; else &#123;
              // 说明至少有2个节点
              // 新头部指向当前节点下一个节点
              head = res.next;
              // 新头部的前一个节点指向空
              head.last = null;
              // 当前节点的下一个节点 断开
              res.next = null;
          &#125;
          return res;
      &#125;

  &#125;

  // 解法1：哈希表+双向链表实现LRU最近最少使用算法，关键是链表的头部是最远使用，尾部是最近使用。put()和get()操作的时间复杂度都是O(1)，空间复杂度为O(N)
  public static class MyCache&lt;K, V&gt; &#123;
      // map中key对应节点key，value对应节点的内存地址
      private HashMap&lt;K, Node&lt;K, V&gt;&gt; keyNodeMap;
      // 节点的双向链表
      private NodeDoubleLinkedList&lt;K, V&gt; nodeList;
      // LRU的容量
      private final int capacity;

      public MyCache(int cap) &#123;
          keyNodeMap = new HashMap&lt;K, Node&lt;K, V&gt;&gt;();
          nodeList = new NodeDoubleLinkedList&lt;K, V&gt;();
          capacity = cap;
      &#125;

      // 读取节点，更新链表尾巴
      public V get(K key) &#123;
          if (keyNodeMap.containsKey(key)) &#123;
              Node&lt;K, V&gt; res = keyNodeMap.get(key);
              // 节点移动到尾巴
              nodeList.moveNodeToTail(res);
              // 返回节点value值
              return res.value;
          &#125;
          return null;
      &#125;

      // 新增或更新节点，更新链表尾巴和更新哈希表
      public void set(K key, V value) &#123;
          // 如果是更新节点，直接移动节点到链表尾巴
          if (keyNodeMap.containsKey(key)) &#123;
              Node&lt;K, V&gt; node = keyNodeMap.get(key);
              node.value = value;
              // 直接移动节点到链表尾巴
              nodeList.moveNodeToTail(node);
          &#125; else &#123;
              // 如果是新增节点，直接添加到链表尾巴
              // 新增！注意先删除，再添加
              if (keyNodeMap.size() == capacity + 1) &#123;
                  // 超出容量，移除头结点
                  removeMostUnusedCache();
              &#125;
              Node&lt;K, V&gt; newNode = new Node&lt;K, V&gt;(key, value);
              keyNodeMap.put(key, newNode);
              nodeList.addNode(newNode);
          &#125;
      &#125;

      // 删除LRU缓存时，要删除链表头节点和哈希表中的节点
      private void removeMostUnusedCache() &#123;
          Node&lt;K, V&gt; removeNode = nodeList.removeHead();
          keyNodeMap.remove(removeNode.key);
      &#125;
  &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Easy Equation</span><br><span class="line"></span><br><span class="line">题目：求助</span><br><span class="line"></span><br><span class="line">已知有n个整数，x1,x2,x3….xn.(1&lt;=n&lt;=10，0&lt;=xi&lt;=30)，以及m个整数a1,a2,a3….am(1&lt;=m&lt;=20,0&lt;=ai&lt;=25);</span><br><span class="line">现在取出所有的a1,a2,a3…am.将他们随意分成n组，每组求和的值为b1,b2,b3…bn，然后成为x1,x2,x3…xn的系数。</span><br><span class="line">（可以选择0个ai，组成一个对应的bj=0,但是数组a中的所有的ai必须选完）。</span><br><span class="line">求满足b1*x1+b2*x2+b3*x3+…+bn*xn=s的分组方法数。其中s为输入的一个数据（0&lt;=s&lt;=20000）。</span><br><span class="line">但是这个方法数也许会比较巨大,请输出分组方法数mod 1000000007 的结果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
输入：
4 4 68
1 2 4 8
1 2 4 8
输出：
3
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
public class 139 &#123;
public static void main(String[] args) &#123;
    Scanner scanner = new Scanner(System.in);
    int n = scanner.nextInt();
    int m = scanner.nextInt();
    int s = scanner.nextInt();
    int[] x = new int[n];
    int[] a = new int[m];
    for (int i = 0; i &lt; n; i++) &#123;
        x[i] = scanner.nextInt();
    &#125;
    for (int i = 0; i &lt; m; i++) &#123;
        a[i] = scanner.nextInt();
    &#125;
    // result[i] 表示取a前i个参数（后面参数视为0）所构成的等式的结果种数
    int[][] result = new int[m][s + 1];
    for (int i = 0; i &lt; n; i++) &#123;
        // 初始化第一行，表示取a中第一个参数构成的等式的的结果种数
        // 如x = &#123;1,1,2,2&#125; ，a=&#123;1,2&#125;，那么 取a的第一个参数就构成的等式结果 为&#123;0，2，2&#125;
        result[0][x[i] * a[0]] += 1;
    &#125;
    for (int i = 1; i &lt; m; i++) &#123;
        for (int j = 0; j &lt;= s; j++) &#123;
            for (int k = 0; k &lt; n; k++) &#123;
                // 等式构成的结果减去增加的新项，无需管分组求和
                // 因为(a1+a2) * x1 = a1*x1 + a2*x1，这里的a[i] * x[k]就是 a2*x1，index就是a1*x1
                int index = j - a[i] * x[k];
                if (index &lt; 0) &#123;
                    continue;
                &#125;
                // 增加的新项构成的等式结果种树 就等于 index的结果+已经有的
                result[i][j] += result[i - 1][index];
                result[i][j] = result[i][j] % 1000000007;
            &#125;
        &#125;
    &#125;
    System.out.println(result[m - 1][s]);
&#125;
&#125;
</code></pre>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://fuyunjinglong.github.io/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" title="E_左神" target="_blank" rel="external">https://fuyunjinglong.github.io/2022/11/13/E_数据结构_左神/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://fuyunjinglong.github.io/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://fuyunjinglong.github.io/" target="_blank"><span class="text-dark">Elven</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/" title="插件"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/10/22/Test/" title="(no title)"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>