<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>做好16点，打造团队Vue3前端架构 | Hexo</title>
  <meta name="description" content="前言由于 vue3.2 版本的发布，&lt;script setup&gt; 的实验性标志已经去掉，这说明这个语法提案已经正式开始使用，并且我个人对这个方案表示非常喜欢，其他的更新[1]请自行了解。到目前为止，我认为 vue3 已经完全可以用于生产环境。在此将我的开发体验，总结至此，分享给大家。 我认为前端架构核心工作是定制一套适合当前业务需求的解决方案，从而降低需求的增加而带来的技术实现的复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="做好16点，打造团队Vue3前端架构">
<meta property="og:url" content="https://fuyunjinglong.github.io/2022/06/26/Z_%E5%81%9A%E5%A5%BD16%E7%82%B9%EF%BC%8C%E6%89%93%E9%80%A0%E5%9B%A2%E9%98%9FVue3%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言由于 vue3.2 版本的发布，&lt;script setup&gt; 的实验性标志已经去掉，这说明这个语法提案已经正式开始使用，并且我个人对这个方案表示非常喜欢，其他的更新[1]请自行了解。到目前为止，我认为 vue3 已经完全可以用于生产环境。在此将我的开发体验，总结至此，分享给大家。 我认为前端架构核心工作是定制一套适合当前业务需求的解决方案，从而降低需求的增加而带来的技术实现的复杂度">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-25T23:33:16.000Z">
<meta property="article:modified_time" content="2022-12-11T09:48:39.093Z">
<meta property="article:author" content="Elven">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://fuyunjinglong.github.io/2022/06/26/Z_%E5%81%9A%E5%A5%BD16%E7%82%B9%EF%BC%8C%E6%89%93%E9%80%A0%E5%9B%A2%E9%98%9FVue3%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://fuyunjinglong.github.io/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Elven</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AA-%E9%9D%A2%E8%AF%95/">AA_面试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/">H_工程热点</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue2%E5%92%8CVue3%E6%AF%94%E8%BE%83/" class="title">Vue2和Vue3比较</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-11T23:33:16.000Z" itemprop="datePublished">2023-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue2.0%E5%8E%9F%E7%90%86/" class="title">Vue2.0原理</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-11T23:33:16.000Z" itemprop="datePublished">2023-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/12/D_%E6%A1%86%E6%9E%B6_Vue3.0%E5%8E%9F%E7%90%86/" class="title">Vue3.0原理</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-11T23:33:16.000Z" itemprop="datePublished">2023-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/12/D_%E6%A1%86%E6%9E%B6_%E6%BA%90%E7%A0%81_Vue2.0/" class="title">源码_Vue2.0</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-11T23:33:16.000Z" itemprop="datePublished">2023-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/12/D_%E6%A1%86%E6%9E%B6_%E6%BA%90%E7%A0%81_Vue3.0/" class="title">源码_Vue3.0</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-11T23:33:16.000Z" itemprop="datePublished">2023-09-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">1.搭建脚手架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BA%94%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">1.1 前端脚手架应具备哪些功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%9F"><span class="toc-text">1.2 如何开发一款自己的脚手架？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E9%80%89%E9%A1%B9%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-text">1.3 如何根据选项生成文件？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E-vite-%E7%9A%84%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF"><span class="toc-text">2.基于 vite 的搭建基础模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE"><span class="toc-text">2.1 创建基本模板项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90"><span class="toc-text">2.2 常用插件推荐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Typescript"><span class="toc-text">3.使用 Typescript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">4.配置环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1 配置模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">4.2 常用的环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%B0%81%E8%A3%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">4.3 封装静态资源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%B0%81%E8%A3%85-SVG-%E7%9A%84%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6"><span class="toc-text">4.4 封装 SVG 的图标组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8C%89%E9%9C%80%E8%87%AA%E5%8A%A8%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6"><span class="toc-text">5.按需自动引入组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-text">5.1 安装与配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%94%B9%E5%8F%98%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2 改变全局组件注册方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%87%AA%E5%8A%A8%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5.3 自动引入组件库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%A0%B7%E5%BC%8F"><span class="toc-text">6.样式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%A2%84%E8%AE%BE%E5%9F%BA%E7%A1%80%E6%A0%B7%E5%BC%8F"><span class="toc-text">6.1 预设基础样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-CSS-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">6.2 CSS 预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%BC%80%E5%90%AF-scoped"><span class="toc-text">6.3 开启 scoped</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">6.4 深度选择器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B8%83%E5%B1%80"><span class="toc-text">7.布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%B8%B8%E8%A7%84%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text">7.1 常规的布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text">7.2 特殊的布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9B%86%E6%88%90-Tailwind-css"><span class="toc-text">8.集成 Tailwind.css</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87"><span class="toc-text">8.1 效率提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-JIT-%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.2 JIT 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%85%B3%E4%BA%8E%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF"><span class="toc-text">8.3 关于打包体积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-vuex-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-pinia"><span class="toc-text">9.vuex 替代方案 pinia</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8-Pinia"><span class="toc-text">9.1 为什么采用 Pinia ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%88%9B%E5%BB%BA-Store"><span class="toc-text">9.2 创建 Store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-State"><span class="toc-text">9.3 State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Getters"><span class="toc-text">9.4 Getters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-Actions"><span class="toc-text">9.5 Actions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-Devtools"><span class="toc-text">9.6 Devtools</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9F%BA%E4%BA%8E-mitt-%E5%A4%84%E7%90%86%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BA%8B%E4%BB%B6%E8%81%94%E5%8A%A8"><span class="toc-text">10.基于 mitt 处理组件间事件联动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-mitt-%EF%BC%9F"><span class="toc-text">10.1 为什么选择 mitt ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%B8%A5%E9%87%8D%E8%AD%A6%E5%91%8A"><span class="toc-text">10.2 严重警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-mitt-%EF%BC%9F"><span class="toc-text">10.3 如何使用 mitt ？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">11.异步请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%9F%BA%E4%BA%8E-axios-%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">11.1 基于 axios 的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E4%B8%BA-axios-%E5%A2%9E%E5%8A%A0%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">11.2 为 axios 增加泛型的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%B0%81%E8%A3%85%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84-useRequest"><span class="toc-text">11.3 封装更方便的 useRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%BB%9F%E4%B8%80%E7%9A%84-API-%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="toc-text">11.4 统一的 API 接口管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-mock"><span class="toc-text">11.5 mock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%B7%AF%E7%94%B1"><span class="toc-text">12.路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">12.1 创建路由三部曲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E4%BD%BF%E7%94%A8-meta-%E4%B8%B0%E5%AF%8C%E4%BD%A0%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="toc-text">12.2 使用 meta 丰富你的路由</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%B8%8E%E7%BB%86%E8%8A%82%E4%BC%98%E5%8C%96"><span class="toc-text">13.项目性能与细节优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E5%BC%80%E5%90%AF-gzip"><span class="toc-text">13.1 开启 gzip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E9%A1%B5%E9%9D%A2%E8%BD%BD%E5%85%A5%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-text">13.2 页面载入进度条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-Title"><span class="toc-text">13.3 Title</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BD%BF%E7%94%A8-vh-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">13.4 解决移动端使用 vh 的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E5%8F%AF%E4%BB%A5%E5%B8%B8%E9%A9%BB%E7%9A%84-JavaScript-%E5%BA%93"><span class="toc-text">13.5 可以常驻的 JavaScript 库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="toc-text">14.代码风格与流程规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-ESLint"><span class="toc-text">14.1 ESLint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-StyleLint"><span class="toc-text">14.2 StyleLint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83"><span class="toc-text">14.3 代码提交规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E7%BC%96%E5%86%99%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3"><span class="toc-text">15.编写使用文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E4%BD%BF%E7%94%A8-vitepress-%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3"><span class="toc-text">15.1 使用 vitepress 搭建文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E6%96%87%E6%A1%A3%E9%83%A8%E7%BD%B2"><span class="toc-text">15.2 文档部署</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%8F%92%E4%BB%B6"><span class="toc-text">16.插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-VSCode-%E6%8F%92%E4%BB%B6"><span class="toc-text">16.1 VSCode 插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-Chrome-%E6%8F%92%E4%BB%B6"><span class="toc-text">16.2 Chrome 插件</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Z_做好16点，打造团队Vue3前端架构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      做好16点，打造团队Vue3前端架构
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/06/26/Z_%E5%81%9A%E5%A5%BD16%E7%82%B9%EF%BC%8C%E6%89%93%E9%80%A0%E5%9B%A2%E9%98%9FVue3%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/" class="article-date">
	  <time datetime="2022-06-25T23:33:16.000Z" itemprop="datePublished">2022-06-26</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/06/26/Z_%E5%81%9A%E5%A5%BD16%E7%82%B9%EF%BC%8C%E6%89%93%E9%80%A0%E5%9B%A2%E9%98%9FVue3%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于 <strong>vue3.2</strong> 版本的发布，<code>&lt;script setup&gt;</code> 的实验性标志已经去掉，这说明这个语法提案已经正式开始使用，并且我个人对这个方案表示非常喜欢，其他的<strong>更新</strong>[1]请自行了解。到目前为止，我认为 vue3 已经完全可以用于生产环境。在此将我的开发体验，总结至此，分享给大家。</p>
<p>我认为前端架构核心工作是定制一套适合当前业务需求的解决方案，从而降低需求的增加而带来的技术实现的复杂度。下面我将从 16 个方向，逐渐带领大家搭建一套属于你自己的脚手架，制定一套合理的解决方案，为项目打下良好的基础，与同伴形成合适的开发习惯。</p>
<h1 id="1-搭建脚手架"><a href="#1-搭建脚手架" class="headerlink" title="1.搭建脚手架"></a>1.搭建脚手架</h1><p>使用 <code>vue-cli</code> 或 <code>vite</code> ，通过一系列的配置，初始化一个开发模板，无需从零开始搭建开发环境，可以有效的提升开发效率，相信也是大多数开发者接手一个新项目所使用的一种方式。尽管官方提供的脚手架已经足够优秀，但未必是真正符合我们自己团队的使用习惯，所以从官方的基础上，开发一款属于我们自己的脚手架，能更多的提升开发效率。</p>
<h2 id="1-1-前端脚手架应具备哪些功能？"><a href="#1-1-前端脚手架应具备哪些功能？" class="headerlink" title="1.1 前端脚手架应具备哪些功能？"></a>1.1 前端脚手架应具备哪些功能？</h2><ul>
<li>减少重复的初始化工作，不需要再复制其他类似的项目删除无关代码，或从零搭建一个项目。</li>
<li>可以根据团队需求，使用简单的交互操作生成相应的目录结构和文件。</li>
<li>统一团队的开发习惯、代码风格，保证构建结果的一致性。</li>
<li>完整的使用文档，降低新人上手、开发和后期维护成本。</li>
</ul>
<h2 id="1-2-如何开发一款自己的脚手架？"><a href="#1-2-如何开发一款自己的脚手架？" class="headerlink" title="1.2 如何开发一款自己的脚手架？"></a>1.2 如何开发一款自己的脚手架？</h2><p>提到构建前端工程化中脚手架，相信大家已经看过不少文章，几年前我也曾经写过一篇关于<strong>脚手架构建的文章</strong>[69]，随便搜一下关键词可以看到很多相关的文章，在这里不做太多的介绍，主要讲一些这些文章中很少提到的如何根据选项生成文件。</p>
<h2 id="1-3-如何根据选项生成文件？"><a href="#1-3-如何根据选项生成文件？" class="headerlink" title="1.3 如何根据选项生成文件？"></a>1.3 如何根据选项生成文件？</h2><p>说实话我也不知道大佬们是怎么根据各种配置编译成相应的文件，这块希望大家踊跃发言，寻求一种更佳高效简洁的方式。在这里跟大家分享一下我的方案：</p>
<p>交互方面，搭建过脚手架的同学一定知道 <strong>inquirer</strong>[70]，这个库可以很方便的通过交互式操作获取到我们选择的一些自定义配置参数。那么问题来了，如何通过这些配置相应的创建对应的文件呢？</p>
<p>这里我推荐使用 <strong>EJS</strong>[71] + <strong>Prettier</strong>[72] 生成代码，通过 <strong>fs-extra</strong>[73] 写入最终的文件。</p>
<ul>
<li><strong>EJS</strong></li>
</ul>
<p><strong>EJS</strong> 是一款 JavaScript 模板引擎，我们可以通过传入参数，生成对应的代码串，例如创建一个 <code>package.ejs</code> 用来生成 <code>package.json</code> 中，如果我们选择使用了 <code>scss</code> 作为 CSS 预处理器，然后将 <code>sass</code> 和 <code>stylelint-scss</code> 作为项目的安装依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (precss === &#x27;scss&#x27;) &#123; -%&gt;</span><br><span class="line">  &quot;sass&quot;: &quot;1.26.5&quot;,</span><br><span class="line">  &quot;stylelint-scss&quot;: &quot;^3.20.1&quot;,</span><br><span class="line">&lt;% &#125; -%&gt;</span><br></pre></td></tr></table></figure>

<p>模板引擎可以帮你通过参数生成代码，它并不会限制你生成任何类型的代码文件，因为我们生成的是纯代码，最后通过读取 <code>.ejs</code> 文件对应生成相应的类型文件即可。</p>
<ul>
<li><strong>Prettier</strong></li>
</ul>
<p><strong>Prettier</strong> 是一款代码格式化工具，相信大家对它并不陌生。使用 EJS 生成的目的还是给开发人员阅读和编辑，所以生成的代码应该符合最终的格式要求，因为后续我们会为脚手架添加 ESLint 和 StyleLint 等工具，刚刚创建的项目里面一堆红线报错可是十分不友好的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import prettier = require(&quot;prettier&quot;);</span><br><span class="line">prettier.format(code, &#123; parser: &#x27;json&#x27; &#125;))</span><br></pre></td></tr></table></figure>

<p><code>parser</code> 是 prettier 的解析器，常见的 typescript、css、less、json 等文件都可以进行格式化。</p>
<h1 id="2-基于-vite-的搭建基础模板"><a href="#2-基于-vite-的搭建基础模板" class="headerlink" title="2.基于 vite 的搭建基础模板"></a>2.基于 vite 的搭建基础模板</h1><p>最早搭建 vue3 脚手架的时候，我选择的用 vue/cli 搭建，因为生态不健全，有些基于 webpack 的功能无法使用，但现在 vite 生态已经比较完善了，所以重构脚手架，由 webpack 转向 vite，这一步极大的提升了开发体验。</p>
<h2 id="2-1-创建基本模板项目"><a href="#2-1-创建基本模板项目" class="headerlink" title="2.1 创建基本模板项目"></a>2.1 创建基本模板项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest</span><br><span class="line">yarn create vite</span><br><span class="line">pnpm create vite</span><br></pre></td></tr></table></figure>

<p>然后按照提示操作即可，vite 提供的选项很少，只有 vue 或 vue + ts，不像 vue/cli 提供那么多的配置方式，所以剩下的东西需要我们手动配置。</p>
<p>当然 vite 也提供了很多模板，但是我认为做加法比做减法更加容易，在众多的模板中很难找到适合我们自己的。</p>
<h2 id="2-2-常用插件推荐"><a href="#2-2-常用插件推荐" class="headerlink" title="2.2 常用插件推荐"></a>2.2 常用插件推荐</h2><p>这里先简单了解几个好用的 vite 插件：</p>
<ul>
<li><strong>unplugin-vue-components</strong>[74]：组件的按需自动导入。</li>
<li><strong>vite-plugin-svg-icons</strong>[75]：用于生成 svg 雪碧图。</li>
<li><strong>vite-plugin-compression</strong>[76]：使用 gzip 或者 brotli 来压缩资源。</li>
</ul>
<p>为什么只推荐这么几个插件？因为 <code>vite</code> 对许多 <code>webpack</code> 需要安装的 <code>loader</code> 或 <code>plugin</code> 都有着天生的支持，比如 less、sass、typescript，后续会在相应的章节说明用法。</p>
<h1 id="3-使用-Typescript"><a href="#3-使用-Typescript" class="headerlink" title="3.使用 Typescript"></a>3.使用 Typescript</h1><p><strong>vue2.x 版本对 TypeScript 的支持是硬伤</strong>，而 TypeScript 对大型项目的保障能力是被普遍认可的。这一点在 vue3.x 版本中得到了非常友好的支持。</p>
<blockquote>
<p>Vite 天然支持引入 <code>.ts</code> 文件。</p>
</blockquote>
<p>这里对 tsconfig.json 做了一些修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;types&quot;: [&quot;vite/client&quot;],</span><br><span class="line">    &quot;baseUrl&quot;: &quot;src&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@/*&quot;: [&quot;./*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [&quot;node_modules&quot;]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在初期使用 typeScript 的时候，很多人都很喜欢使用 any 类型，把 typeScript 写成了 anyScript ，虽然使用起来很方便，但是这就失去了 typeScript 的类型检查意义了，当然写类型的习惯是需要慢慢去养成的，不用急于一时。</p>
</blockquote>
<h1 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h1><p>vite 提供了两种模式：具有开发服务器的开发模式（development）和生产模式（production）。</p>
<p>这里我们可以建立 4 个 <code>.env</code> 文件，一个通用配置和三种环境：开发、测试、生产。</p>
<h2 id="4-1-配置模式"><a href="#4-1-配置模式" class="headerlink" title="4.1 配置模式"></a>4.1 配置模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=development # 开发模式</span><br><span class="line">NODE_ENV=production # 生产模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>.env 通用配置，我个人喜欢把他当作项目的配置文件，例如项目的 title，此文件不对应任何模式。</li>
<li>.env.development 开发环境，使用 development 模式。</li>
<li>.env.staging 测试环境，因为要部署到测试服务器，或本地使用 serve 命令预览，所以使用 production 模式。</li>
<li>.env.production 生产环境，因为要部署到测试服务器，或本地使用 serve 命令预览，所以使用 production 模式。</li>
</ul>
<p>package.json 内 script 需要增加 staging 命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,</span><br><span class="line">  &quot;staging&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build --mode staging&quot;,</span><br><span class="line">  &quot;serve&quot;: &quot;vite preview --host&quot;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-2-常用的环境变量"><a href="#4-2-常用的环境变量" class="headerlink" title="4.2 常用的环境变量"></a>4.2 常用的环境变量</h2><p>推荐使用以下常见的三个变量：</p>
<ul>
<li><strong>VITE_APP_BASE_URL</strong></li>
</ul>
<p>接口请求地址。</p>
<p>通常后端会区分三种环境，部署在不同的地址下。</p>
<ul>
<li><strong>VITE_APP_STATIC_URL</strong></li>
</ul>
<p>静态资源地址。</p>
<blockquote>
<p>静态资源我是不建议你直接放在项目中，这会导致项目仓库变得巨大。</p>
</blockquote>
<p>本地开发和测试环境我会选在使用本地搭建的静态资源服务器，你可以找后端运维的同学帮你搭建，或者你使用 http-server 在本地启动一个服务器也可以。生产环境建议上传至 OSS。</p>
<ul>
<li><strong>VITE_PUBLIC_PATH</strong></li>
</ul>
<p>构建资源公共路径。</p>
<p>这个与 vue/cli 中的 publicPath 同理，有的时候你构建的项目并不是存放在跟路径下，例如 <code>http://ip:port/&#123;项目名&#125;</code>。</p>
<h2 id="4-3-封装静态资源文件"><a href="#4-3-封装静态资源文件" class="headerlink" title="4.3 封装静态资源文件"></a>4.3 封装静态资源文件</h2><p>如果你配置了 VITE_APP_STATIC_URL 静态资源环境变量，那么你需要封装以下两个东西：</p>
<ul>
<li>根据环境返回实际的资源地址函数。</li>
<li>方便使用的静态资源组件。</li>
</ul>
<p><strong>baseStaticUrl.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 处理静态资源链接</span><br><span class="line">export default function baseStaticUrl(src = &#x27;&#x27;) &#123;</span><br><span class="line">  const &#123; VITE_APP_STATIC_URL &#125; = import.meta.env;</span><br><span class="line">  if (src) &#123;</span><br><span class="line">    return `$&#123;VITE_APP_STATIC_URL&#125;$&#123;src&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">  return VITE_APP_STATIC_URL as string;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>静态资源组件</strong></p>
<p>静态资源主要有图片、音频和视频三种常见的形式。</p>
<ul>
<li>通过 src 写入相对的路径，使用上述的函数来补全完整的路径，即可在不同的环境下使用不同地址的静态资源。</li>
<li>通过 type 传入图片、音频和视频的类型。</li>
<li>autoplay 是解决以视频为背景的情况下，视频无法自动播放的问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; computed, ref, Ref, withDefaults, onMounted, watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; baseStaticUrl &#125; from &#x27;@/libs/utils&#x27;;</span><br><span class="line">import useDevice from &#x27;@/hooks/useDevice&#x27;;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">  src?: string;</span><br><span class="line">  type?: string;</span><br><span class="line">  autoplay?: boolean;</span><br><span class="line">&#125;</span><br><span class="line">const props = withDefaults(defineProps&lt;Props&gt;(), &#123;</span><br><span class="line">  src: &#x27;&#x27;,</span><br><span class="line">  type: &#x27;img&#x27;,</span><br><span class="line">  autoplay: true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const envSrc = computed(() =&gt; baseStaticUrl(props.src));</span><br><span class="line">// 处理视频自动播放（解决 chrome 无法自动播放的问题）</span><br><span class="line">const &#123; deviceType &#125; = useDevice();</span><br><span class="line">const poster = computed(() =&gt;</span><br><span class="line">  deviceType.value === &#x27;desktop&#x27; ? &#x27;&#x27; : baseStaticUrl(props.src),</span><br><span class="line">);</span><br><span class="line">const videoRef: Ref&lt;HTMLVideoElement | null&gt; = ref(null);</span><br><span class="line"></span><br><span class="line">// 解决移动端视频无法自动播放的问题</span><br><span class="line">function videoAutoPlay() &#123;</span><br><span class="line">  if (props.type === &#x27;video&#x27; &amp;&amp; videoRef.value !== null) &#123;</span><br><span class="line">    videoRef.value.src = baseStaticUrl(props.src);</span><br><span class="line">  &#125;</span><br><span class="line">  if (props.autoplay &amp;&amp; videoRef.value) &#123;</span><br><span class="line">    videoRef.value.oncanplay = () =&gt; &#123;</span><br><span class="line">      if (videoRef.value) videoRef.value.play();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自动播放视频</span><br><span class="line">onMounted(() =&gt; &#123; videoAutoPlay();&#125;);</span><br><span class="line">// 监听视频 src，如果存在则自动播放</span><br><span class="line"></span><br><span class="line">watch(envSrc, () =&gt; &#123; if (videoRef.value) videoRef.value.play(); &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123; name: &#x27;StaticFile&#x27; &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img v-if=&quot;type === &#x27;img&#x27;&quot; :src=&quot;envSrc&quot; /&gt;</span><br><span class="line">  &lt;video ref=&quot;videoRef&quot; v-else-if=&quot;type === &#x27;video&#x27;&quot; muted :poster=&quot;poster&quot; /&gt;</span><br><span class="line">  &lt;audio v-else :src=&quot;envSrc&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-4-封装-SVG-的图标组件"><a href="#4-4-封装-SVG-的图标组件" class="headerlink" title="4.4 封装 SVG 的图标组件"></a>4.4 封装 <code>SVG</code> 的图标组件</h2><p>svg 图标比较小，而且都是可读的 xml 文本，所以我们把它直接放在项目中即可，通过 <code>vite-plugin-svg-icons</code> 插件，实现自动引入 svg 图标。</p>
<p>配置 vite.config.ts：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  viteSvgIcons(&#123;</span><br><span class="line">    iconDirs: [resolve(process.cwd(), &#x27;src/assets/icons&#x27;)],</span><br><span class="line">    symbolId: &#x27;icon-[dir]-[name]&#x27;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>封装一个 vue 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; computed, withDefaults &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">  prefix?: string;</span><br><span class="line">  name?: string;</span><br><span class="line">  color?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const props = withDefaults(defineProps&lt;Props&gt;(), &#123;</span><br><span class="line">  prefix: &#x27;icon&#x27;,</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  color: &#x27;#000&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const symbolId = computed(() =&gt; `#$&#123;props.prefix&#125;-$&#123;props.name&#125;`);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href=&quot;symbolId&quot; :fill=&quot;color&quot; /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先将下载的 .svg 图标放入 @/assets/icons 文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg-icon name=&quot;&quot; color=&quot;&quot; /&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>name 放置在 @/assets/icons 文件夹下的文件名。</li>
<li>color 颜色填充，使用此项会默认覆盖图标颜色。</li>
</ul>
<h1 id="5-按需自动引入组件"><a href="#5-按需自动引入组件" class="headerlink" title="5.按需自动引入组件"></a>5.按需自动引入组件</h1><p><strong>unplugin-vue-components</strong>[77] 是一款非常强大的插件（极力推荐），核心功能就是帮助你自动按需引入组件，Tree-shakable，只注册你使用的组件。这里说一下他的两个核心使用方式和配置方式。</p>
<blockquote>
<p>此插件不仅支持 vue3，同时也支持 vue2，并且支持 Vite、Webpack、Vue CLI、Rollup。</p>
</blockquote>
<h2 id="5-1-安装与配置"><a href="#5-1-安装与配置" class="headerlink" title="5.1 安装与配置"></a>5.1 安装与配置</h2><p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i unplugin-vue-components -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// vite.config.ts</span><br><span class="line">import Components from &#x27;unplugin-vue-components/vite&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    Components(&#123; /* options */ &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里的 options 可以配置一些选项，后面提到的组件库注册会使用到。</p>
<h2 id="5-2-改变全局组件注册方式"><a href="#5-2-改变全局组件注册方式" class="headerlink" title="5.2 改变全局组件注册方式"></a>5.2 改变全局组件注册方式</h2><p>我们通常将全局的组件封装在 <code>@/src/components</code> 中，然后通过 <code>app.component()</code> 注册全局组件。使用此插件后，无需手写注册，直接在模板中使用组件即可：</p>
<p>这里引入官方的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>自动编译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#x27;./src/components/HelloWorld.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="5-3-自动引入组件库"><a href="#5-3-自动引入组件库" class="headerlink" title="5.3 自动引入组件库"></a>5.3 自动引入组件库</h2><p>在使用组件库时，常规组件我们也会注册到全局，如果使用局部注册由于页面中会使用到多个组件，会非常麻烦，所以这个功能绝佳，例如我们使用 ant-design-vue 组件库。</p>
<p>直接在模板中使用即可，无需手动注册或局部引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;a-button&gt;按钮&lt;/a-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，你还需要在 vite 中引入它的解析器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Components from &#x27;unplugin-vue-components/vite&#x27;</span><br><span class="line">import &#123; AntDesignVueResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;</span><br><span class="line"></span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    Components(&#123;</span><br><span class="line">      resolvers: [</span><br><span class="line">        AntDesignVueResolver(),</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>目前支持的解析器，根据你的喜好去选择：</p>
<ul>
<li><strong>Ant Design Vue</strong>[78]</li>
<li><strong>Element Plus</strong>[79]</li>
<li><strong>Element UI</strong>[80]</li>
<li><strong>Headless UI</strong>[81]</li>
<li><strong>IDux</strong>[82]</li>
<li><strong>Naive UI</strong>[83]</li>
<li><strong>Prime Vue</strong>[84]</li>
<li><strong>Vant</strong>[85]</li>
<li><strong>VEUI</strong>[86]</li>
<li><strong>Varlet UI</strong>[87]</li>
<li><strong>View UI</strong>[88]</li>
<li><strong>Vuetify</strong>[89]</li>
<li><strong>VueUse Components</strong>[90]</li>
<li><strong>Quasar</strong>[91]</li>
</ul>
<h1 id="6-样式"><a href="#6-样式" class="headerlink" title="6.样式"></a>6.样式</h1><p>项目中最好使用通用样式，可以创建 <code>src/styles</code> 目录存放，这里推荐一些分类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">styles</span><br><span class="line">  ├── antd # 组件库样式覆盖，命名自取，这里以 ant design 为例</span><br><span class="line">  ├── color.less # 颜色</span><br><span class="line">  ├── index.less # 入口</span><br><span class="line">  ├── global.less # 公共类</span><br><span class="line">  ├── transition.less # 动画相关</span><br><span class="line">  └── variable.less # 变量</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="6-1-预设基础样式"><a href="#6-1-预设基础样式" class="headerlink" title="6.1 预设基础样式"></a>6.1 预设基础样式</h2><p>相信用过 <strong>normalize</strong>[92] 的同学不在少数，它可以重置 css 样式，使各浏览器效果保持一致。后面的章节会提到 tailwind.css，它内置了预设样式重置的功能，与 normalize 还是有一定的区别，有兴趣的同学可以<strong>了解一下</strong>[93]。</p>
<h2 id="6-2-CSS-预处理器"><a href="#6-2-CSS-预处理器" class="headerlink" title="6.2 CSS 预处理器"></a>6.2 CSS 预处理器</h2><p>虽然 vite 原生支持 less/sass/scss/stylus，但是你必须手动安装他们的预处理器依赖，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D less</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如何选择预处理器？</p>
<p>推荐使用你是所使用的组件库的样式语言，因为 css 预处理器学会一种后，入手其他几乎没有学习成本。</p>
<h2 id="6-3-开启-scoped"><a href="#6-3-开启-scoped" class="headerlink" title="6.3 开启 scoped"></a>6.3 开启 scoped</h2><p>没有加 scoped 属性，会编译成全局样式，造成全局污染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="6-4-深度选择器"><a href="#6-4-深度选择器" class="headerlink" title="6.4 深度选择器"></a>6.4 深度选择器</h2><p>有时我们可能想明确地制定一个针对子组件的规则。</p>
<p>如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符。有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。</p>
<h1 id="7-布局"><a href="#7-布局" class="headerlink" title="7.布局"></a>7.布局</h1><p>页面整体布局是一个产品最外层的框架结构，往往会包含导航、页脚、侧边栏等。在页面之中，也有很多区块的布局结构。在真实项目中，页面布局通常统领整个应用的界面，有非常重要的作用，所以单独拆分出来也是非常有必要的。</p>
<p>在脚手架中，所有的通用布局组件都应该放在 src/layouts 中，这种封装比较简单，这里就不贴代码了，大家按照自己实际情况自行发挥，在此仅提供一下封装思路。</p>
<h2 id="7-1-常规的布局"><a href="#7-1-常规的布局" class="headerlink" title="7.1 常规的布局"></a>7.1 常规的布局</h2><p><strong>BasicLayout</strong></p>
<p>基础页面布局，包含了头部导航，侧边栏等。</p>
<p><strong>BlankLayout</strong></p>
<p>空白的布局。</p>
<h2 id="7-2-特殊的布局"><a href="#7-2-特殊的布局" class="headerlink" title="7.2 特殊的布局"></a>7.2 特殊的布局</h2><p><strong>RouteLayout</strong></p>
<p>如果你的项目在路由切换中需要对某些二级页面进行缓存，那么推荐你创建一个 RouteLayout，通过路由 <code>meta</code> 中的配置，返回 <code>router-view</code> 或者使用 <code>keep-alive</code> 包裹的 <code>router-view</code>。</p>
<p><strong>UserLayout</strong></p>
<p>用于用户登录注册等页面抽离出来。</p>
<p><strong>PageLayout</strong></p>
<p>基础布局，包含了面包屑等信息，内含 slot。</p>
<h1 id="8-集成-Tailwind-css"><a href="#8-集成-Tailwind-css" class="headerlink" title="8.集成 Tailwind.css"></a>8.集成 Tailwind.css</h1><p><strong>Tailwind.css</strong>[94] 在我第一次看到它的时候，内心是比较反感的，但实际上手之后又觉得真香。从 vue2 项目中，我已经引入了 tailwind，整体的开发结果就是，基本很少再使用 <code>&lt;style&gt;</code> 标签去转本定义一些 class 和样式，毕竟起名字这种事，一个是涉及到规范，一个是涉及到英语。如果你选择 tailwind，CSS 预处理器的作用就会显得微乎其微，因为你无需再自定定义各种变量和 mixins。</p>
<p>总体来说，学习成本并不高，花上两个小时足够上手，记住不用死记硬背那些类名。</p>
<h2 id="8-1-效率提升"><a href="#8-1-效率提升" class="headerlink" title="8.1 效率提升"></a>8.1 效率提升</h2><p>很多人总是说样式要与 HTML 分离，现在为什么又要提倡 tailwind 这种与 HTML 紧密结合的工具？这是因为现在使用 vue 这类框架已经高度组件化，样式分离是为了方便复用和维护，但在组件化面前样式分离只能是降低开发效率。</p>
<p>下面介绍一下 tailwind 提供了哪些提升效率的功能：</p>
<ul>
<li>提供了大量的功能类，极大的提高了可维护性。</li>
<li>响应式设计，各种设备一把梭。</li>
<li>悬停、焦点和其它状态。</li>
<li>深色模式。</li>
<li>支持配置，例如颜色方面很难做到跟你的设计师统一。</li>
<li>不用为起名字而纠结???</li>
</ul>
<h2 id="8-2-JIT-模式"><a href="#8-2-JIT-模式" class="headerlink" title="8.2 JIT 模式"></a>8.2 JIT 模式</h2><p>如果你的环境支持 postcss8（ vue/cli 构建的 vue2 项目是 postcss7 ），那么 <strong>JIT</strong> 模式直接带你起飞。</p>
<ul>
<li>超快的构建速度。</li>
<li>支持变体，你甚至可以这么写 <code>sm:hover:active:disabled:opacity-75</code>。</li>
<li>支持任意样式，例如 <code>md:top-[-113px]</code>。</li>
<li>开发和生产环境结果是一致的，（我在 vue2 项目中就遇到过组件库构建结果不一致的问题）。</li>
</ul>
<p>如果你使用 vscode 那你一定要安装 <strong>Tailwind CSS IntelliSense</strong>[95] 插件，它可以自动补全类名，显著降低学习成本。</p>
<h2 id="8-3-关于打包体积"><a href="#8-3-关于打包体积" class="headerlink" title="8.3 关于打包体积"></a>8.3 关于打包体积</h2><p>使用默认配置，未压缩是 <strong>3739.4kB</strong> ，Gzip压缩 是 293.9kB，Brotli压缩 是 73.2kB。这似乎看起来很大，这是因为 tailwind 提供了成千上万的功能类，其中绝大部分你不会使用到。</p>
<p>当构建生产时，你应该使用 purge 选项来 <strong>tree-shake</strong> 优化未使用的样式，并优化您的最终构建大小当使用 Tailwind 删除未使用的样式时，很难最终得到超过 <strong>10kb</strong> 的压缩 CSS。</p>
<p>还有一点，<code>Atom CSS</code> 极大的提升了样式的复用程度，从而直接降低了构建体积。</p>
<h1 id="9-vuex-替代方案-pinia"><a href="#9-vuex-替代方案-pinia" class="headerlink" title="9.vuex 替代方案 pinia"></a>9.vuex 替代方案 pinia</h1><p>由于 <code>vuex 4</code> 对 typescript 的支持让人感到难过，所以状态管理弃用了 vuex 而采取了 <strong>pinia</strong>[96]。</p>
<p>忘记在哪看到，尤大好像说 <strong>pinia</strong>[97] 可能会代替 vuex，所以请放心使用。</p>
<h2 id="9-1-为什么采用-Pinia"><a href="#9-1-为什么采用-Pinia" class="headerlink" title="9.1 为什么采用 Pinia ?"></a>9.1 为什么采用 Pinia ?</h2><ul>
<li><strong>Pinia</strong> 的 API 设计非常接近 <code>Vuex 5</code> 的<strong>提案</strong>[98]。（作者是 Vue 核心团队成员）</li>
<li>无需像 <code>Vuex 4</code> 自定义复杂的类型来支持 typescript，天生具备完美的类型推断。</li>
<li>模块化设计，你引入的每一个 store 在打包时都可以自动拆分他们。</li>
<li>无嵌套结构，但你可以在任意的 store 之间交叉组合使用。</li>
<li><strong>Pinia</strong> 与 <strong>Vue devtools</strong> 挂钩，不会影响 Vue 3 开发体验。</li>
</ul>
<p>下面简单的介绍一下如何使用 Pinia，并对比 vuex 有哪些区别与注意事项，具体请参考<strong>官方文档</strong>[99]。</p>
<h2 id="9-2-创建-Store"><a href="#9-2-创建-Store" class="headerlink" title="9.2 创建 Store"></a>9.2 创建 Store</h2><p>Pinia 已经内置在脚手架中，并且与 vue 已经做好了关联，你可以在任何位置创建一个 store：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">export const useUserStore = defineStore(&#123;</span><br><span class="line">  id: &#x27;user&#x27;,</span><br><span class="line">  state: () =&gt;(&#123;&#125;),</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这与 Vuex 有很大不同，它是标准的 Javascript 模块导出，这种方式也让开发人员和你的 IDE 更加清楚 store 来自哪里。</p>
<p>Pinia 与 Vuex 的区别：</p>
<ul>
<li><strong>id</strong> 是必要的，它将所使用 store 连接到 devtools。</li>
<li>创建方式：<code>new Vuex.Store(...)</code>(vuex3)，<code>createStore(...)</code>(vuex4)。</li>
<li>对比于 vuex3 ，state 现在是一个<strong>函数返回对象</strong>。</li>
<li>没有 <strong>mutations</strong>，不用担心，state 的变化依然记录在 devtools 中。</li>
</ul>
<h2 id="9-3-State"><a href="#9-3-State" class="headerlink" title="9.3 State"></a>9.3 State</h2><p>创建好 store 之后，可以在 state 中创建一些属性了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state: () =&gt; (&#123; name: &#x27;codexu&#x27;, age: 18 &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>将 store 中的 state 属性设置为一个函数，该函数返回一个包含不同状态值的对象，这与我们在组件中定义数据的方式非常相似。</p>
<p>在模板中使用 store：</p>
<p>现在我们想从 store 中获取到 name 的状态，我们只需要使用以下的方式即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123;userStore.name&#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">const userStore = useUserStore()</span><br><span class="line">return &#123; userStore &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>注意这里并不需要 <code>userStore.state.name</code>。</p>
<p>虽然上面的写法很舒适，但是你一定不要用解构的方式去提取它内部的值，这样做的话，会失去它的响应式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name, email &#125; = useUserStore()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="9-4-Getters"><a href="#9-4-Getters" class="headerlink" title="9.4 Getters"></a>9.4 Getters</h2><p>Pinia 中的 getter 与 Vuex 中的 getter 、组件中的计算属性具有相同的功能，传统的函数声明使用 this 代替了 state 的传参方法，但箭头函数还是要使用函数的第一个参数来获取 state ，因为箭头函数处理 this 的作用范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  nameLength() &#123;</span><br><span class="line">    return this.name.length</span><br><span class="line">  &#125;,</span><br><span class="line">  nameLength: state =&gt; state.name.length,</span><br><span class="line">  nameLength: ()=&gt; this.name.length ❌ </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="9-5-Actions"><a href="#9-5-Actions" class="headerlink" title="9.5 Actions"></a>9.5 Actions</h2><p>这里与 Vuex 有极大的不同，Pinia 仅提供了一种方法来定义如何更改状态的规则，<strong>放弃 mutations 只依靠 Actions</strong>，这是一项重大的改变。</p>
<p>Pinia 让 Actions 更加的灵活：</p>
<ul>
<li>可以通过<strong>组件</strong>或其他 <strong>action</strong> 调用</li>
<li>可以从<strong>其他 store</strong> 的 action 中调用</li>
<li>直接在商店实例上调用</li>
<li>支持<strong>同步</strong>或<strong>异步</strong></li>
<li>有任意数量的参数</li>
<li>可以包含有关如何更改状态的逻辑（也就是 vuex 的 mutations 的作用）</li>
<li>可以 <code>$patch</code> 方法直接更改状态属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  async insertPost(data)&#123;</span><br><span class="line">    await doAjaxRequest(data);</span><br><span class="line">    this.name = &#x27;...&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="9-6-Devtools"><a href="#9-6-Devtools" class="headerlink" title="9.6 Devtools"></a>9.6 Devtools</h2><p>脚手架已内置下面的代码，这将添加 devtools 支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia, PiniaPlugin &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(PiniaPlugin)</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>时间旅行功能貌似已经可以使用了，这块后续会关注。</p>
<h1 id="10-基于-mitt-处理组件间事件联动"><a href="#10-基于-mitt-处理组件间事件联动" class="headerlink" title="10.基于 mitt 处理组件间事件联动"></a>10.基于 mitt 处理组件间事件联动</h1><p>如果你曾经是 Vue2.x 的开发者，那么请阅读下面引用<strong>官方文档</strong>[100]的一段话：</p>
<blockquote>
<p>我们从实例中完全移除了 <code>$on</code>、<code>$off</code> 和 <code>$once</code> 方法。<code>$emit</code> 仍然包含于现有的 API 中，因为它用于触发由父组件声明式添加的事件处理函数。</p>
<p>在 Vue 3 中，已经不可能使用这些 API 从组件内部监听组件自己发出的事件了，该用例暂没有迁移的方法。但是该 eventHub 模式可以被替换为实现了事件触发器接口的外部库，例如 <code>mitt</code> 或 <code>tiny-emitter</code>。</p>
</blockquote>
<h2 id="10-1-为什么选择-mitt-？"><a href="#10-1-为什么选择-mitt-？" class="headerlink" title="10.1 为什么选择 mitt ？"></a>10.1 为什么选择 mitt ？</h2><ul>
<li>足够小，仅有 200bytes。</li>
<li>支持全部事件的监听和批量移除。</li>
<li>无依赖，不论是什么框架都可以直接使用。</li>
</ul>
<h2 id="10-2-严重警告"><a href="#10-2-严重警告" class="headerlink" title="10.2 严重警告"></a>10.2 严重警告</h2><p>我们已经无法在项目中使用 <strong>eventBus</strong>，仅推荐你在<strong>特殊场合</strong>下使用 mitt，<strong>它并不是开发的常态</strong>，你一定要确保知道自己在做什么？否则你的项目将难以维护！！！</p>
<h2 id="10-3-如何使用-mitt-？"><a href="#10-3-如何使用-mitt-？" class="headerlink" title="10.3 如何使用 mitt ？"></a>10.3 如何使用 mitt ？</h2><p>在使用 mitt 前建议请阅读<strong>官方文档</strong>[101]：</p>
<p>脚手架默认提供一个可以直接使用的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import emitter from &#x27;@/libs/emitter&#x27;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然你也可以引入已经安装好的 mitt：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import mitt from &#x27;mitt&#x27;</span><br><span class="line"></span><br><span class="line">const emitter = mitt()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>mitt 提供了非常简单的 API，下面代码是官方演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// listen to an event</span><br><span class="line">emitter.on(&#x27;foo&#x27;, e =&gt; console.log(&#x27;foo&#x27;, e) )</span><br><span class="line"></span><br><span class="line">// listen to all events</span><br><span class="line">emitter.on(&#x27;*&#x27;, (type, e) =&gt; console.log(type, e) )</span><br><span class="line"></span><br><span class="line">// fire an event</span><br><span class="line">emitter.emit(&#x27;foo&#x27;, &#123; a: &#x27;b&#x27; &#125;)</span><br><span class="line"></span><br><span class="line">// clearing all events</span><br><span class="line">emitter.all.clear()</span><br><span class="line"></span><br><span class="line">// working with handler references:</span><br><span class="line">function onFoo() &#123;&#125;</span><br><span class="line">emitter.on(&#x27;foo&#x27;, onFoo)   // listen</span><br><span class="line">emitter.off(&#x27;foo&#x27;, onFoo)  // unlisten</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="11-异步请求"><a href="#11-异步请求" class="headerlink" title="11.异步请求"></a>11.异步请求</h1><p>绝大多数项目想必逃脱不了接口的对接，如果你的项目存在大量的接口，我建议做到以下几点：</p>
<ul>
<li>封装请求。</li>
<li>统一的 API 接口管理。</li>
<li>Mock 数据功能（根据需求斟酌使用）。</li>
</ul>
<p>上述的主要目的就是在帮助我们简化代码和利于后期的更新维护。</p>
<h2 id="11-1-基于-axios-的封装"><a href="#11-1-基于-axios-的封装" class="headerlink" title="11.1 基于 axios 的封装"></a>11.1 基于 axios 的封装</h2><p>相信开发过 vue2 项目的同学已经对 axios 非常熟悉的，在这里提供一些封装的思路：</p>
<ul>
<li>通过 <code>import.meta.env.VITE_APP_BASE_URL</code> 获取环境变量，配置 <code>baseURL</code>，如果接口存在多个不同域名，可以通过 js 变量控制。</li>
<li>设置 <code>timeout</code> 请求超时、断网情况处理。</li>
<li>设置<strong>请求头</strong>，携带 <code>token</code>。</li>
<li><strong>异常拦截处理</strong>，后端通过你携带的 <code>token</code> 判断你是否过期，如果返回 <code>401</code> 你可能需要跳转到登录页面，并提示需要重新登录。</li>
<li><strong>响应拦截</strong>，通常后端返回 code、data、msg，如果是请求正常，我们可以直接返回 data 数据，如果是异常的 code，我们也可以在这里直接弹出报错提示。</li>
<li><strong>无感刷新 token</strong>，如果你的 token 过期，可以通过后端返回的 refreshToken 调用刷新接口，获取新的 token。当然这里涉及到很多细节，例如终端请求、重新发送请求、重新请求列队。</li>
<li><strong>中断请求</strong>，例如页面切换时，我们要中断正在发生的请求。</li>
</ul>
<p><strong>相关代码（仅供参考）</strong>[102]</p>
<h2 id="11-2-为-axios-增加泛型的支持"><a href="#11-2-为-axios-增加泛型的支持" class="headerlink" title="11.2 为 axios 增加泛型的支持"></a>11.2 为 axios 增加泛型的支持</h2><p>到目前为止，axios 请求返回的类型是 any，这时我们对请求后的数据进行操作时，没有享受到 ts 带来的类型提示，这显然不符合我们的预期。</p>
<p>这时我们要做的就是重新声明 axios 模块：新建一个 shims.d.ts，然后在调用时加上泛型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">declare module &#x27;axios&#x27; &#123;</span><br><span class="line">  export interface AxiosInstance &#123;</span><br><span class="line">    &lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    request&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    get&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    delete&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    head&lt;T = any&gt;(url: string, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    post&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    put&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">    patch&lt;T = any&gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>做好这一步后，你就必须在创建接口时，声明请求相应数据的类型。</p>
<h2 id="11-3-封装更方便的-useRequest"><a href="#11-3-封装更方便的-useRequest" class="headerlink" title="11.3 封装更方便的 useRequest"></a>11.3 封装更方便的 useRequest</h2><p>设想一下，编写请求代码时，我们通常会定义这么几个变量：</p>
<ul>
<li><strong>data</strong>: 储存请求数据</li>
<li><strong>loading</strong>: 请求加载状态</li>
</ul>
<p>尤其是 loading，我们需要在请求前设置为 true，请求结束后设置为 false。</p>
<p>上面的封装方式，是对基础的功能封装，因为我们在使用 vue3，所以可以进行再一次的封装成为 <strong>hook</strong>，我们使用起来会更加方便。</p>
<p>例如下面这个样子：</p>
<p>使用 useRequest 定义一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default getUserInfo(id) &#123;</span><br><span class="line">  return useRequest(&#123;</span><br><span class="line">    method: &#x27;get&#x27;,</span><br><span class="line">    url: &#x27;/api/user&#x27;,</span><br><span class="line">    params: &#123; id &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用此接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; data, loading &#125; = getUserInfo();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里的 data 是响应式的。</p>
</blockquote>
<p>这是我想到的一种思路，目前还没有做很好的封装，<strong>相关代码仅供参考</strong>[103]，你也可以借鉴一些成熟方案，比如 vueuse 中的 <strong>useFetch</strong>[104]，但是他是基于 Fetch API 设计的，并不符合我的预期要求，有更好的方案请大家在下面留言。</p>
<h2 id="11-4-统一的-API-接口管理"><a href="#11-4-统一的-API-接口管理" class="headerlink" title="11.4 统一的 API 接口管理"></a>11.4 统一的 API 接口管理</h2><p>自从前端和后端分家之后，前后端接口对接就成为了常态，而对接接口的过程就离不开接口文档，比较主流就是 Swagger，但是如何在前端项目中更好的去管理跟后端对接的接口呢？</p>
<p>在 src 目录中 创建 api 目录，内部目录应按照后端制定的模块创建。</p>
<p>每个模块中创建多个 ts 文件，一个接口应对应一个 ts 文件，其中包含了以下内容：</p>
<ul>
<li>请求<strong>参数</strong>的类型声明。</li>
<li>响应<strong>数据</strong>的类型声明。</li>
<li>返回定义好的请求函数（url、method、params、data 等）。</li>
</ul>
<p>统一去定义和管理 API 接口，只要后端规范的命名和你认真的写好类型声明，对前端来说 typescript 就是最好的接口文档。</p>
<h2 id="11-5-mock"><a href="#11-5-mock" class="headerlink" title="11.5 mock"></a>11.5 mock</h2><p>vite 使用 mock 数据非常简单，你可以使用 <strong>vite-plugin-mock</strong>[105] 插件，如果你了解 mockjs，你可以快速上手。</p>
<h1 id="12-路由"><a href="#12-路由" class="headerlink" title="12.路由"></a>12.路由</h1><p>路由和菜单是组织起一个应用的关键骨架。</p>
<h2 id="12-1-创建路由三部曲"><a href="#12-1-创建路由三部曲" class="headerlink" title="12.1 创建路由三部曲"></a>12.1 创建路由三部曲</h2><p>通常一个项目需要做到这几步：</p>
<ul>
<li>使用 <strong>createRouter</strong> 创建路由，这时候根据需求选择 <strong>Hash</strong> 路由或者 <strong>History</strong> 路由。</li>
<li>根据业务需求<strong>配置路由</strong>，注意这里很可能就用到前文提到过的<strong>布局组件</strong>。</li>
<li>如果有权限相关的业务，你需要创建 <strong>permission.ts</strong> 在路由钩子触发时做一些事情。</li>
</ul>
<blockquote>
<p>如果你的页面比较多，建议你创建 routes 目录，分模块声明路由。</p>
</blockquote>
<p><strong>参考代码</strong>[106]</p>
<h2 id="12-2-使用-meta-丰富你的路由"><a href="#12-2-使用-meta-丰富你的路由" class="headerlink" title="12.2 使用 meta 丰富你的路由"></a>12.2 使用 meta 丰富你的路由</h2><p>vue-router4.x 支持 typescript，配置路由的类型是 RouteRecordRaw，这里 meta 可以让我们有更多的发挥空间，这里提供一些参考：</p>
<ul>
<li>title: string; 页面标题，通常必选。</li>
<li>icon?: string; 图标，一般配合菜单使用。</li>
<li>auth?: boolean; 是否需要登录权限。</li>
<li>ignoreAuth?: boolean; 是否忽略权限。</li>
<li>roles?: RoleEnum[]; 可以访问的角色</li>
<li>keepAlive?: boolean; 是否开启页面缓存</li>
<li>hideMenu?: boolean; 有些路由我们并不想在菜单中显示，比如某些编辑页面。</li>
<li>order?: number; 菜单排序。</li>
<li>frameUrl?: string; 嵌套外链。</li>
</ul>
<blockquote>
<p>这里只提供一些思路，每个项目多多少少会涉及到这些问题，具体如何实现请查阅资料自行解决。</p>
</blockquote>
<h1 id="13-项目性能与细节优化"><a href="#13-项目性能与细节优化" class="headerlink" title="13.项目性能与细节优化"></a>13.项目性能与细节优化</h1><h2 id="13-1-开启-gzip"><a href="#13-1-开启-gzip" class="headerlink" title="13.1 开启 gzip"></a>13.1 开启 gzip</h2><p>开启 gzip 可以极大的压缩静态资源，对页面加载的速度起到了显著的作用。</p>
<p>使用 <strong>vite-plugin-compression</strong>[107] 可以 <strong>gzip</strong> 或 <strong>brotli</strong> 的方式来压缩资源，这一步需要服务器端的配合，vite 只能帮你打包出 <code>.gz</code> 文件。此插件使用简单，你甚至无需配置参数，引入即可。</p>
<h2 id="13-2-页面载入进度条"><a href="#13-2-页面载入进度条" class="headerlink" title="13.2 页面载入进度条"></a>13.2 页面载入进度条</h2><p>页面路由切换时，附带一个加载进度条会显得非常友好，不至于白屏时间过长，让用户以为页面假死。</p>
<p>这时候我们可以用到 <strong>nprogress</strong>[108]，在路由切换时开启和关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import NProgress from &#x27;nprogress&#x27;;</span><br><span class="line"></span><br><span class="line">router.beforeEach(async (to, from, next) =&gt; &#123;</span><br><span class="line">  NProgress.start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.afterEach((to) =&gt; &#123;</span><br><span class="line">  NProgress.done();</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="13-3-Title"><a href="#13-3-Title" class="headerlink" title="13.3 Title"></a>13.3 Title</h2><p>在不同的路由下显示不同的标题是常规的操作，我们可以通过路由钩子获取 meta 中的 title 属性改变标签页上的 title。</p>
<p>你可以使用 vueuse 提供的 <strong>useTitle</strong>[109]，或者 window.document.title 自行封装。</p>
<p>你也可以通过环境变量将你的主标题拼接在路由标题的后面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; VITE_APP_TITLE &#125; = import.meta.env;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="13-4-解决移动端使用-vh-的问题"><a href="#13-4-解决移动端使用-vh-的问题" class="headerlink" title="13.4 解决移动端使用 vh 的问题"></a>13.4 解决移动端使用 vh 的问题</h2><p>有兴趣的同学可以尝试一下 chrome 移动端浏览器上的 100vh，是真正的视口高度的 100% 嘛。</p>
<p>为了解决这一问题，我们可以通过 postCss 插件解决。</p>
<p>安装 <strong>postcss-viewport-height-correction</strong>[110] 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D postcss-viewport-height-correction</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在 postcss.config.js 中增加 plugin：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &#x27;postcss-viewport-height-correction&#x27;: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>添加这一段 js 代码在全局，你可以直接添加在 index.html 上即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const customViewportCorrectionVariable = &#x27;vh&#x27;;</span><br><span class="line">function setViewportProperty(doc) &#123;</span><br><span class="line">  let prevClientHeight;</span><br><span class="line">  const customVar = `--$&#123;customViewportCorrectionVariable || &#x27;vh&#x27;&#125;`;</span><br><span class="line">  function handleResize() &#123;</span><br><span class="line">    const &#123; clientHeight &#125; = doc;</span><br><span class="line">    if (clientHeight === prevClientHeight) return;</span><br><span class="line">    requestAnimationFrame(function updateViewportHeight() &#123;</span><br><span class="line">      doc.style.setProperty(customVar, `$&#123;clientHeight * 0.01&#125;px`);</span><br><span class="line">      prevClientHeight = clientHeight;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleResize();</span><br><span class="line">  return handleResize;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, setViewportProperty(document.documentElement));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="13-5-可以常驻的-JavaScript-库"><a href="#13-5-可以常驻的-JavaScript-库" class="headerlink" title="13.5 可以常驻的 JavaScript 库"></a>13.5 可以常驻的 JavaScript 库</h2><ul>
<li>前文提到过的 <strong>vueuse</strong>[111]，非常强大，强烈建议尝试。</li>
<li><strong>lodash</strong>[112]，用了都说好，早用早下班。</li>
</ul>
<h1 id="14-代码风格与流程规范"><a href="#14-代码风格与流程规范" class="headerlink" title="14.代码风格与流程规范"></a>14.代码风格与流程规范</h1><h2 id="14-1-ESLint"><a href="#14-1-ESLint" class="headerlink" title="14.1 ESLint"></a>14.1 ESLint</h2><p>不管是多人合作还是个人项目，代码规范都是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。</p>
<p>这里推荐使用 <strong>airbnb</strong> 规范。</p>
<p><strong>配置参考</strong>[113]</p>
<h2 id="14-2-StyleLint"><a href="#14-2-StyleLint" class="headerlink" title="14.2 StyleLint"></a>14.2 StyleLint</h2><p>尽管前文提到过 tailwind，可以让你几乎不写 css，但是涉及到团队协作，这一点也要严谨。</p>
<p>StyleLint 是一个强大的、现代化的 CSS 检测工具, 与 ESLint 类似, 是通过定义一系列的编码风格规则帮助我们避免在样式表中出现错误，配合编辑器的自动修复，可以很好的统一团队项目 css 风格。</p>
<p><strong>配置参考</strong>[114]</p>
<h2 id="14-3-代码提交规范"><a href="#14-3-代码提交规范" class="headerlink" title="14.3 代码提交规范"></a>14.3 代码提交规范</h2><p>在多人协作的背景下，git 仓库和 workflow 的作用很重要。而对于 commit 提交的信息说明存在一定规范，现使用 <strong>commitlint</strong> + <strong>husky</strong> 规范 git commit -m “” 中的描述信息。我们都知道，在使用 git commit 时，git 会提示我们填入此次提交的信息。可不要小看了这些 commit，团队中规范了 commit 可以更清晰的查看每一次代码提交记录，还可以根据自定义的规则，自动生成 changeLog 文件。</p>
<p><strong>提交格式（注意冒号后面有空格）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>type ：用于表明我们这次提交的改动类型。</li>
<li>optional scope：可选，用于标识此次提交主要涉及到代码中哪个模块。</li>
<li>description：一句话描述此次提交的主要内容，做到言简意赅。</li>
</ul>
<p><strong>Type 类型</strong></p>
<ul>
<li>build：编译相关的修改，例如发布版本、对项目构建或者依赖的改动</li>
<li>chore：其他修改, 比如改变构建流程、或者增加依赖库、工具等</li>
<li>ci：持续集成修改</li>
<li>docs：文档修改</li>
<li>feat：新特性、新功能</li>
<li>fix：修改bug</li>
<li>perf：优化相关，比如提升性能、体验</li>
<li>refactor：代码重构</li>
<li>revert：回滚到上一个版本</li>
<li>style：代码格式修改, 注意不是 css 修改</li>
<li>test：测试用例修改</li>
</ul>
<p>关于 commitlint + husky 的配置文章有很多，大同小异，请根据自己的实际情况配置。</p>
<h1 id="15-编写使用文档"><a href="#15-编写使用文档" class="headerlink" title="15.编写使用文档"></a>15.编写使用文档</h1><p>做到这一步，你的整个脚手架开发已经接近于尾声，但是你做了这么多，你的同事并不知道如何使用，甚至你过一段时间也会忘记，所以你必须养成良好的编写文档习惯。</p>
<h2 id="15-1-使用-vitepress-搭建文档"><a href="#15-1-使用-vitepress-搭建文档" class="headerlink" title="15.1 使用 vitepress 搭建文档"></a>15.1 使用 vitepress 搭建文档</h2><p>这里我推荐使用 vuepress 或者 vitepress，说实话你只写文档 vitepress 会让你更舒服，因为它很快。</p>
<p><strong>vitepress</strong>[115] 很适合构建博客网站、技术文档，就是因为它可以直接用 markdown 进行书写，所有写过博客的人，都应该对它不陌生。一个 .md 文件，即可生成一张页面，十分方便。</p>
<p>创建一个 vitepress 文档实在是太过于简单，你可以参考官方文档，或者参考我的<strong>文档</strong>[116]。</p>
<h2 id="15-2-文档部署"><a href="#15-2-文档部署" class="headerlink" title="15.2 文档部署"></a>15.2 文档部署</h2><p>如果你的团队可以帮助你搭建 CI/CD 自动部署是再好不过了，如果没有这个条件，你也可以通过 github 提供的 actions 功能，完成自动部署。</p>
<p><strong>代码参考</strong>[117]</p>
<h1 id="16-插件"><a href="#16-插件" class="headerlink" title="16.插件"></a>16.插件</h1><p>如果你想更痛快的用上述功能，建议你安装下面的插件。</p>
<h2 id="16-1-VSCode-插件"><a href="#16-1-VSCode-插件" class="headerlink" title="16.1 VSCode 插件"></a>16.1 VSCode 插件</h2><ul>
<li><strong>Vue Language Features (Volar)</strong>[118]，你现在查 Volar 可能找不到，你需要的是这个。</li>
<li><strong>Vue 3 Snippets</strong>[119]，vue3 快捷输入。</li>
<li><strong>Tailwind CSS IntelliSense</strong>[120]，tailwind 代码提示。</li>
<li><strong>Stylelint</strong>[121]</li>
<li><strong>Prettier - Code formatter</strong>[122]</li>
<li><strong>ESLint</strong>[123]</li>
</ul>
<h2 id="16-2-Chrome-插件"><a href="#16-2-Chrome-插件" class="headerlink" title="16.2 Chrome 插件"></a>16.2 Chrome 插件</h2><ul>
<li><strong>Vue.js devtools</strong>[124]，你当然要安装支持 vue3 的版本，而且此版本对 pinia 支持的也非常友好。</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://fuyunjinglong.github.io/2022/06/26/Z_%E5%81%9A%E5%A5%BD16%E7%82%B9%EF%BC%8C%E6%89%93%E9%80%A0%E5%9B%A2%E9%98%9FVue3%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/" title="做好16点，打造团队Vue3前端架构" target="_blank" rel="external">https://fuyunjinglong.github.io/2022/06/26/Z_做好16点，打造团队Vue3前端架构/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://fuyunjinglong.github.io/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://fuyunjinglong.github.io/" target="_blank"><span class="text-dark">Elven</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/06/26/Z_%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F_Typora%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/" title="Typora常用用法"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/05/29/B_JS_%E5%8E%9F%E5%BD%A2%E9%97%AD%E5%8C%85/" title="继承原形闭包专题"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>