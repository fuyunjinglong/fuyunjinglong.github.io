<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>0基础_JS | Hexo</title>
  <meta name="description" content="基础电脑是怎么把代码转换成可执行程序的编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成 编译器是一种翻译程序，它用于将源语言（程序设计语言写成）翻译为用二进制表示的伪机器代码程序，通常有两种方式进行翻译，一种是编译，另一种是解释。  想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，你可以通过两种方式遵循其指示。 首先是有人已经为你翻译成英">
<meta property="og:type" content="article">
<meta property="og:title" content="0基础_JS">
<meta property="og:url" content="https://fuyunjinglong.github.io/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础电脑是怎么把代码转换成可执行程序的编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成 编译器是一种翻译程序，它用于将源语言（程序设计语言写成）翻译为用二进制表示的伪机器代码程序，通常有两种方式进行翻译，一种是编译，另一种是解释。  想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，你可以通过两种方式遵循其指示。 首先是有人已经为你翻译成英">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211201070616431.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209072317064.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209072730664.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209072755682.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209072828890.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209073441948.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211209074403859.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220222215742735.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220504095928130.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220222220554956.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220313115045079.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220313115410595.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220313120537563.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220320214519742.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220320221047255.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211207073137249.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211207073246002.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211207235441427.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211208000338908.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20211208001049548.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220123200002149.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20230614063620124.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20230614063755823.png">
<meta property="og:image" content="https://fuyunjinglong.github.io/img/image-20220114072242443.png">
<meta property="article:published_time" content="2099-05-28T23:33:16.000Z">
<meta property="article:modified_time" content="2023-07-16T03:50:35.263Z">
<meta property="article:author" content="Elven">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuyunjinglong.github.io/img/image-20211201070616431.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://fuyunjinglong.github.io/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://fuyunjinglong.github.io/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Elven</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AA-%E9%9D%A2%E8%AF%95/">AA_面试</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/">H_工程热点</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/11/">十一月 2099</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/09/">九月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/06/">六月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/05/">五月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2099/03/">三月 2099</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9/">H_工程热点</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/06/H_%E5%B7%A5%E7%A8%8B%E7%83%AD%E7%82%B9_0%E5%9F%BA%E7%A1%80/" class="title">0基础_工程热点</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-05T22:33:16.000Z" itemprop="datePublished">2099-11-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/05/I_%E7%A7%BB%E5%8A%A8%E7%AB%AF_0%E5%9F%BA%E7%A1%80/" class="title">0基础_移动端</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-04T22:33:16.000Z" itemprop="datePublished">2099-11-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/04/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0%E5%9F%BA%E7%A1%80/" class="title">0基础_计算机网络</a>
              </p>
              <p class="item-date">
                <time datetime="2099-11-03T22:33:16.000Z" itemprop="datePublished">2099-11-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/01/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_0%E5%9F%BA%E7%A1%80/" class="title">0基础_数据结构</a>
              </p>
              <p class="item-date">
                <time datetime="2099-10-31T22:33:16.000Z" itemprop="datePublished">2099-11-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a>
              </p>
              <p class="item-title">
                <a href="/2099/11/01/J_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%9F%BA%E7%A1%80/" class="title">0基础_设计模式</a>
              </p>
              <p class="item-date">
                <time datetime="2099-10-31T22:33:16.000Z" itemprop="datePublished">2099-11-01</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%84%91%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84"><span class="toc-text">电脑是怎么把代码转换成可执行程序的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">8种数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-%E5%AF%B9%E8%B1%A1-%E6%95%B0%E7%BB%84"><span class="toc-text">JS 类型判断-对象,数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-typeof-instanceof-constructor-toString"><span class="toc-text">JS类型判断-typeof,  instanceof, constructor,toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-text">模块化规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice-splice-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">slice(),splice()两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-text">typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">JS对象的两类属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E3%80%81ES5%E3%80%81ES6"><span class="toc-text">JavaScript、ES5、ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="toc-text">合并数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async%E5%92%8Cdefer%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">async和defer的作用是什么？有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">三大山-原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82this"><span class="toc-text">彻底搞懂this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-apply-bind"><span class="toc-text">call&#x2F;apply&#x2F;bind</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-text">三大山-作用域和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">作用域-执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1-VO-AO-GO"><span class="toc-text">作用域-变量对象(VO&#x2F;AO&#x2F;GO)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">作用域-作用域与作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E5%BC%95%E6%93%8E"><span class="toc-text">V8引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存溢出和内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-text">如何创建私有变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%B1%B1-%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">三大山-异步和单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%AD%E5%A4%A7%E6%96%B9%E6%A1%88"><span class="toc-text">JS异步编程六大方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">消息队列和事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">防抖和节流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM"><span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9"><span class="toc-text">获取节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-text">创建节点添加节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E6%88%96%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-text">获取屏幕或容器的宽高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">JS绑定解除事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-text">JS事件冒泡和事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%B8%B2%E5%8F%A3%E5%8F%98%E5%8C%96"><span class="toc-text">监听串口变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ajax%E5%8E%9F%E7%90%86"><span class="toc-text">Ajax原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99setTimeout%E5%AE%9E%E7%8E%B0setInterval"><span class="toc-text">手写setTimeout实现setInterval</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-EventBus"><span class="toc-text">手写-EventBus</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-JSON-stringfy-%E5%92%8CJSON-parse"><span class="toc-text">手写-JSON.stringfy()和JSON.parse()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-%E7%AE%80%E5%8D%95%E8%B7%AF%E7%94%B1"><span class="toc-text">手写-简单路由</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">手写-JS实现图片懒加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-rem%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">手写-rem实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-AJAX"><span class="toc-text">手写-AJAX</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD"><span class="toc-text">手写-实现拖拽</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99-%E5%85%B6%E4%BB%96"><span class="toc-text">手写-其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99forEach"><span class="toc-text">手写forEach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99map"><span class="toc-text">手写map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99reduce"><span class="toc-text">手写reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99filter"><span class="toc-text">手写filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99push"><span class="toc-text">手写push</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建函数的几种方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#try%E2%80%A6catch%E2%80%A6finally"><span class="toc-text">try…catch…finally</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">九种跨域方式原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS-%E8%AF%86%E5%88%AB%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-text">JS 识别不同浏览器信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="toc-text">高级函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">自执行函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8"><span class="toc-text">尾调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92-tail-recursion"><span class="toc-text">尾递归(tail recursion)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96-%E5%AE%9E%E7%8E%B0add-1-2-3-6"><span class="toc-text">柯里化-实现add(1)(2)(3)&#x3D;6</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#devDependencies-%E5%92%8C-dependencies-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">devDependencies 和 dependencies 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#args%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8Earguments%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%B1%BB%E6%95%B0%E7%BB%84"><span class="toc-text">args剩余参数与arguments函数形参类数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8padStart-%E5%92%8CpadEnd"><span class="toc-text">字符串自动补全padStart()和padEnd()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%9010%E4%BB%A5%E4%B8%8B%E6%AD%A3%E6%95%B0"><span class="toc-text">随机生成10以下正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%B7%AE%E9%9B%86%EF%BC%8C%E5%B9%B6%E9%9B%86%EF%BC%8C%E8%A1%A5%E9%9B%86"><span class="toc-text">数组的交集，差集，并集，补集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8Eurl%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0"><span class="toc-text">从url获取参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">检查对象是否为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2"><span class="toc-text">生成随机十六进制颜色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B"><span class="toc-text">检查设备类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF"><span class="toc-text">文字复制到剪贴板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-B_JS_0基础" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      0基础_JS
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/" class="article-date">
	  <time datetime="2099-05-28T23:33:16.000Z" itemprop="datePublished">2099-05-29</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/B-JS/">B_JS</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="电脑是怎么把代码转换成可执行程序的"><a href="#电脑是怎么把代码转换成可执行程序的" class="headerlink" title="电脑是怎么把代码转换成可执行程序的"></a>电脑是怎么把代码转换成可执行程序的</h2><p>编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成</p>
<p>编译器是一种翻译程序，它用于将源语言（程序设计语言写成）翻译为用二进制表示的伪机器代码程序，通常有两种方式进行翻译，一种是编译，另一种是解释。</p>
<blockquote>
<p>想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，你可以通过两种方式遵循其指示。</p>
<p>首先是有人已经为你翻译成英文，你可以阅读食谱的英语版本，做鹰嘴豆泥。那么翻译的配方就是 <em>编译版本</em>。</p>
<p>第二种方法是，如果你有一位了解古希腊语的朋友，当你准备制作鹰嘴豆泥时，你的朋友会坐在你的旁边，将菜谱逐行翻译成英语。在这种情况下，你的朋友是食谱 <em>解释版本</em> 的解释者。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">编译型</th>
<th align="center">解释型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">特点</td>
<td align="center">可直接执行，每次需要进行更改时，你都需要“重建”程序</td>
<td align="center">一边编译一边执行，逐行解释，逐行执行程序的每个命令</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">快</td>
<td align="center">语言更加灵活，并且通常具有诸如动态键入和程序较小。解释器自己执行源程序代码，因此代码本身相对于平台是独立的</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">编译步骤需要额外的时间，生成的二进制代码对平台的依赖性</td>
<td align="center">慢，因为在运行时翻译代码的过程增加了开销，并可能导致程序整体变慢。</td>
</tr>
<tr>
<td align="center">举例</td>
<td align="center">java,C，C ++，Erlang，Rust 和 Go</td>
<td align="center">PHP，Ruby，Python 和 JavaScript</td>
</tr>
</tbody></table>
<h2 id="8种数据类型"><a href="#8种数据类型" class="headerlink" title="8种数据类型"></a>8种数据类型</h2><ul>
<li>基本类型：Number,String,Boolean,Null,undefined,symbol</li>
<li>引用类型：Object,Array,function</li>
</ul>
<p><strong>null和undefined</strong></p>
<p>null 表示“定义了但是为空”,判空：if(a)。null 典型用法是： </p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象。 </li>
<li>作为对象原型链的终点。</li>
</ul>
<p>undefined 表示未定义，它的类型只有一个值，就是 undefined，判空：if(a===undefined)，未定义的值和定义未赋值的为 undefined</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于 undefined。 </li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。 </li>
<li>对象没有赋值的属性，该属性的值为 undefined。 </li>
<li>函数没有返回值时，默认返回 undefined。</li>
</ul>
<p><strong>从内存来看 null 和 undefined 本质的区别是什么？</strong></p>
<blockquote>
<p>给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。</p>
<p>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</p>
</blockquote>
<h2 id="JS-类型判断-对象-数组"><a href="#JS-类型判断-对象-数组" class="headerlink" title="JS 类型判断-对象,数组"></a>JS 类型判断-对象,数组</h2><p>第一，使用 typeof 加 length 属性</p>
<p>数组有 length 属性，object 没有，而 typeof 数组与对象都返回 object，所以我们可以这么判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="keyword">function</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> o.<span class="property">length</span> == <span class="string">&#x27;number&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二，使用 instanceof</p>
<p>利用 instanceof 判断数据类型是对象还是数组时应该优先判断 array，最后判断 object。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="keyword">function</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( o <span class="keyword">instanceof</span> <span class="title class_">Object</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JS类型判断-typeof-instanceof-constructor-toString"><a href="#JS类型判断-typeof-instanceof-constructor-toString" class="headerlink" title="JS类型判断-typeof,  instanceof, constructor,toString"></a>JS类型判断-typeof,  instanceof, constructor,toString</h2><p><strong>typeof</strong></p>
<p>缺点：无法区分null，数组，对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>            ------------------&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]         ------------------&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> ibj          ------------------&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>()      ------------------&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>()    ------------------&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;helloworld&quot;</span>    ------------------&gt;<span class="string">&quot;string&quot;</span>     </span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>             ------------------&gt;<span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Function</span>()  ------------------&gt;<span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>()        ------------------&gt;<span class="string">&quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>            ------------------&gt;<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>       ------------------&gt;<span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;undefined&#x27;</span>     ------------------&gt;<span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>instanceof</strong></p>
<p>缺点：不能区分undefined和null，不能区分Object和Function。对于基本类型如果不是用new声明的则也测试不出来，对于是使用new声明的类型，它还可以检测出多层继承关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">console.log(bool instanceof Boolean);// false</span><br><span class="line">console.log(num instanceof Number);// false</span><br><span class="line">console.log(str instanceof String);// false</span><br><span class="line">console.log(und instanceof Object);// false</span><br><span class="line">console.log(arr instanceof Array);// true</span><br><span class="line">console.log(nul instanceof Object);// false</span><br><span class="line">console.log(obj instanceof Object);// true</span><br><span class="line">console.log(fun instanceof Function);// true</span><br><span class="line"></span><br><span class="line">var bool2 = new Boolean()</span><br><span class="line">console.log(bool2 instanceof Boolean);// true</span><br><span class="line"></span><br><span class="line">var num2 = new Number()</span><br><span class="line">console.log(num2 instanceof Number);// true</span><br><span class="line"></span><br><span class="line">var str2 = new String()</span><br><span class="line">console.log(str2 instanceof String);//  true</span><br><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line">var per = new Person()</span><br><span class="line">console.log(per instanceof Person);// true</span><br><span class="line"></span><br><span class="line">function Student()&#123;&#125;</span><br><span class="line">Student.prototype = new Person()</span><br><span class="line">var haoxl = new Student()</span><br><span class="line">console.log(haoxl instanceof Student);// true</span><br><span class="line">console.log(haoxl instanceof Person);// true</span><br></pre></td></tr></table></figure>

<p>手写instanceof</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const self_instanceof = function (instance, constructor) &#123;</span><br><span class="line">    let instance_proto = instance.__proto__;</span><br><span class="line">    let constructor_proto = constructor.prototype;</span><br><span class="line"></span><br><span class="line">    while(true) &#123;</span><br><span class="line">        // 找到终点返回false</span><br><span class="line">       if (instance_proto === null) &#123;return false&#125;;</span><br><span class="line">       // 找到返回true</span><br><span class="line">       if (instance_proto === constructor_proto) &#123;return true&#125;;</span><br><span class="line">        // 当实例与构造函数原型不相同, 沿着原型链继续向上查找</span><br><span class="line">        instance_proto = instance_proto.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log([] instanceof Array)   // true</span><br><span class="line">console.log(self_instanceof([], Array))  // true</span><br></pre></td></tr></table></figure>

<p><strong>constructor</strong></p>
<p><code>constructor</code>主要是利用原型上的<code>prototype.constructor</code>指向实例的构造函数来进行判断的。</p>
<p>缺点：不能判断undefined和null，并且使用它是不安全的，因为contructor的指向是可以改变的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;1&#x27;.constructor === String);  // true</span><br><span class="line">console.log(new Number(1).constructor === Number); // true</span><br><span class="line">console.log(true.constructor === Boolean); // true</span><br><span class="line">console.log(alert.constructor === Function); // true</span><br><span class="line">console.log([].constructor === Array); // true</span><br><span class="line">console.log(new Date().constructor === Date); // true</span><br></pre></td></tr></table></figure>

<p><strong>toString</strong></p>
<p><code>toString</code>是<code>Object.prototype</code>上的一个方法, 常用方式为 <code>Object.prototype.toString.call(target)</code>返回值是 <code>[object 类型]</code>字符串,该方法基本上能判断所有的数据类型(自定义数据类型除外)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义判断类型函数</span><br><span class="line">let getType = target =&gt; Object.prototype.toString.call(target)</span><br><span class="line"></span><br><span class="line">console.log(getType(&#x27;&#x27;)); // [object String]</span><br><span class="line">console.log(getType(2)); // [object Number]</span><br><span class="line">console.log(getType(true)); // [object Boolean]</span><br><span class="line">console.log(getType(undefined)); // [object Undefined]</span><br><span class="line">console.log(getType(null)); // [object Null]</span><br><span class="line">console.log(getType(Symbol())); // [object Symbol]</span><br><span class="line">console.log(getType(&#123;&#125;)); // [object Object]</span><br><span class="line">console.log(getType([])); // [object Array]</span><br><span class="line">console.log(getType(alert)); // [object Function]</span><br><span class="line">console.log(getType(new RegExp())); // [object RegExp]</span><br><span class="line">console.log(getType(new Date())); // [object Date]</span><br></pre></td></tr></table></figure>

<h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903744518389768#heading-2">前端模块化详解(完整版)</a></li>
</ul>
<p><strong>模块化是什么？</strong></p>
<ul>
<li>按照一定的规则(规范)封装成几个块(文件), 并自由组合在一起</li>
<li>对内数据封装，对外暴露接口</li>
</ul>
<p><strong>模块化详解</strong></p>
<ul>
<li>ESModule支持es6语法的浏览器规范</li>
<li>CommonJS 是同步支持nodejs的后端规范</li>
<li>UMD统一模块规范，支持amd和cmd(amd和cmd一般不单独使用)，支持全局变量Vue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常用的是ESM和CJS,其中UMD还可以指定全局变量</span><br><span class="line">浏览器端使用ESM和UMD,nodejs使用CJS</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ESModule</strong></p>
</blockquote>
<p>简称ESM,是一个符合ES6语法的模块化规范，语法为：import export。</p>
<p>ECMAScript 6 的一个目标是解决作用域的问题，也为了使 JS 应用程序显得有序，于是引进了模块。目前部分主流浏览器已原生支持 ES Module，使用 type = module 指定为模块引入即可<br>注意：使用该方式执行 JS 时自动应用 defer 属性。</p>
<p>ESM由于具有简单的语法，<strong>同步异步</strong>加载的特性，适用于前后端，以及<strong>Tree-shakeable</strong>的特性.具有Tree-shakeable的特性，这是由于<strong>ES6的静态模块</strong>结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./myLib&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// your Function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">function1</span>() &#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">function2</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在很多<a href="https://link.juejin.cn/?target=https://caniuse.com/es6-module">现代浏览器</a>可以使用</li>
<li>它兼具两方面的优点：具有 <code>CJS</code> 的简单语法和 <code>AMD</code> 的异步</li>
<li>得益于 <code>ES6</code> 的<a href="https://link.juejin.cn/?target=https://exploringjs.com/es6/ch_modules.html%23sec_design-goals-es6-modules">静态模块结构</a>，可以进行 <a href="https://link.juejin.cn/?target=https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/"> Tree Shaking</a></li>
<li><code>ESM</code> 允许像 <code>Rollup</code> 这样的打包器，<a href="https://link.juejin.cn/?target=https://dev.to/bennypowers/you-should-be-using-esm-kn3">删除不必要的代码</a>，减少代码包可以获得更快的加载</li>
<li>可以在 <code>HTML</code> 中调用，只要如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;func1&#125; <span class="keyword">from</span> <span class="string">&#x27;my-lib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">func1</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**CommonJS **</p>
</blockquote>
<p>简称CJS,是同步支持nodejs的后端规范。语法为：module.exports，require。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// importing </span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="built_in">require</span>(<span class="string">&#x27;./doSomething.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// exporting</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>很多人可以从 <code>Node</code> 中立刻认出 <code>CJS</code> 的语法。这是因为 <code>Node</code> 就是使用 <a href="https://link.juejin.cn/?target=https://blog.risingstack.com/node-js-at-scale-module-system-commonjs-require/"><code>CJS</code> 模块</a>的</li>
<li><code>CJS</code> 是同步导入模块</li>
<li>你可以从 <code>node_modules</code> 中引入一个库或者从本地目录引入一个文件 。如 <code>const myLocalModule = require(&#39;./some/local/file.js&#39;)</code> 或者 <code>var React = require(&#39;react&#39;);</code> ，都可以起作用</li>
<li>当 <code>CJS</code> 导入时，它会给你一个导入对象的副本</li>
<li><code>CJS</code> 不能在浏览器中工作。它必须经过转换和打包</li>
</ul>
<p>CommonJS和es6区别</p>
<blockquote>
<ul>
<li>因为CommonJS的<code>require</code>语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ；</li>
<li>CommonJS 模块输出的是一个值的拷贝，而ES6 模块输出的是值的引用；</li>
<li>CommonJS 模块是动态引入，执行时引入，而ES6 模块是静态引入，编译时引入；</li>
<li>因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用<code>import</code>加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</li>
<li>关于模块顶层的<code>this</code>指向问题，在CommonJS顶层，<code>this</code>指向当前模块；而在ES6模块中，<code>this</code>指向<code>undefined</code>；</li>
</ul>
</blockquote>
<blockquote>
<p><strong>UMD</strong></p>
</blockquote>
<p>简称统一模块规范，支持amd和cmd(amd和cmd一般不单独使用)，支持全局变量Vue</p>
<ul>
<li>当使用 <code>Rollup/Webpack</code> 之类的打包器时，<code>UMD</code> 通常用作备用模块</li>
</ul>
<p><code>AMD</code> 代表异步模块定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;dep1&#x27;</span>, <span class="string">&#x27;dep2&#x27;</span>], <span class="keyword">function</span> (<span class="params">dep1, dep2</span>) &#123;</span><br><span class="line">    <span class="comment">//Define the module value by returning a value.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">或者</span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">&#x27;dep1&#x27;</span>),</span><br><span class="line">        dep2 = <span class="built_in">require</span>(<span class="string">&#x27;dep2&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AMD</code> 是异步(<code>asynchronously</code>)导入模块的(因此得名)</li>
<li>一开始被提议的时候，<code>AMD</code> 是为前端而做的(而 <code>CJS</code> 是后端)</li>
<li><code>AMD</code> 的语法不如 <code>CJS</code> 直观。我认为 <code>AMD</code> 和 <code>CJS</code> 完全相反</li>
</ul>
<p><strong>模块化进化过程</strong></p>
<blockquote>
<p><strong>全局function模式</strong> </p>
</blockquote>
<p> 将不同的功能封装成不同的全局函数</p>
<ul>
<li>编码: 将不同的功能封装成不同的全局函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
<blockquote>
<p><strong>namespace模式</strong> </p>
</blockquote>
<p>简单对象封装</p>
<ul>
<li>作用: 减少了全局变量，解决命名冲突</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let myModule = &#123;</span><br><span class="line">  data: &#x27;www.baidu.com&#x27;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(`foo() $&#123;this.data&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  bar() &#123;</span><br><span class="line">    console.log(`bar() $&#123;this.data&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = &#x27;other data&#x27; //能直接修改模块内部的数据</span><br><span class="line">myModule.foo() // foo() other data</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IIFE模式</strong></p>
</blockquote>
<p>匿名函数自调用(闭包)</p>
<ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>
<li>问题: 如果当前这个模块依赖另一个模块怎么办?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    myModule.data = &#x27;xxxx&#x27; //不是修改的模块内部的data</span><br><span class="line">    myModule.foo() //没有改变</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// module.js文件</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  let data = &#x27;www.baidu.com&#x27;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&#x27;otherFun()&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125; //ES6写法</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IIFE模式增强</strong> </p>
</blockquote>
<p> 引入依赖,这就是现代模块实现的基石。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// module.js文件</span><br><span class="line">(function(window, $) &#123;</span><br><span class="line">  let data = &#x27;www.baidu.com&#x27;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">    $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&#x27;otherFun()&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure>

<h2 id="slice-splice-两种方法"><a href="#slice-splice-两种方法" class="headerlink" title="slice(),splice()两种方法"></a>slice(),splice()两种方法</h2><p>slice(start,end)有两个参数(start必需,end选填),都是索引,返回值不包括end,<strong>不改变原数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];</span><br><span class="line">console.log(heroes.slice(1,4))//  [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ]开始索引为1 结束索引为4(不包括4)</span><br><span class="line">console.log(heroes)// 不改变原数组  [&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>

<p>splice(index,howmany,item1…itemX)只返回被删除的数据,类型为数组(<strong>改变原数组</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heroes=[&quot;0&quot;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];</span><br><span class="line">console.log(heroes.splice(1,2))//  [ &quot;1&quot;, &quot;2&quot;]开始索引为1 删除2个元素</span><br><span class="line">console.log(heroes)// 不改变原数组  [&quot;0&quot;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h2><p>6种基本数据类型：string,Number,boolean,undefined,null,symbol,其他类型如object,function,Array等</p>
<ul>
<li><code>typeof</code>会返回一个变量的基本类型，typeof ‘1’ // ‘string’</li>
<li><code>instanceof</code> 可以准确地判断复杂引用数据类型，[1] instanceof Array //true</li>
</ul>
<p>其中instance原理参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line">    if(typeof left !== &#x27;object&#x27; || left === null) return false;</span><br><span class="line">    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line">    let proto = Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;                  </span><br><span class="line">        if(proto === null) return false;</span><br><span class="line">        if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line">        proto = Object.getPrototypeof(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终极检查数据类型工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br><span class="line"></span><br><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;); </span><br><span class="line">&#125;</span><br><span class="line">getType(&#x27;123&#x27;)  // &quot;string&quot;</span><br></pre></td></tr></table></figure>

<h2 id="JS对象的两类属性"><a href="#JS对象的两类属性" class="headerlink" title="JS对象的两类属性"></a>JS对象的两类属性</h2><p>第一类属性，数据属性具有四个特征</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定for in能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>第二类属性是访问器（getter/setter）属性，它也有四个特征。</p>
<ul>
<li>getter：函数或undefined，在取属性值时被调用。</li>
<li>setter：函数或undefined，在设置属性值时被调用。</li>
<li>enumerable：决定for in能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<h2 id="JavaScript、ES5、ES6"><a href="#JavaScript、ES5、ES6" class="headerlink" title="JavaScript、ES5、ES6"></a>JavaScript、ES5、ES6</h2><p><strong>什么是JavaScript</strong></p>
<p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能</p>
<p>JavaScript由三部分组成：</p>
<ul>
<li>ECMAScript（核心）</li>
<li>DOM（文档对象模型）</li>
<li>BOM （浏览器对象模型）</li>
</ul>
<blockquote>
<p>1.ECMAScript（核心）</p>
</blockquote>
<p>作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象</p>
<blockquote>
<p>2.DOM（文档对象模型）</p>
</blockquote>
<p>DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。</p>
<p>PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。</p>
<blockquote>
<p>3.BOM （浏览器对象模型）</p>
</blockquote>
<p>支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。</p>
<p>PS：BOM未形成规范</p>
<p><strong>什么是ES5</strong></p>
<p>作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下：</p>
<blockquote>
<p>1.strict模式</p>
</blockquote>
<p>严格模式，限制一些用法，’use strict’;</p>
<blockquote>
<p>2.Array增加方法</p>
</blockquote>
<p>增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法</p>
<p>PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now</p>
<blockquote>
<p>3.Object方法</p>
</blockquote>
<p>Object.getPrototypeOf</p>
<p>Object.create</p>
<p>Object.getOwnPropertyNames</p>
<p>Object.defineProperty</p>
<p>Object.getOwnPropertyDescriptor</p>
<p>Object.defineProperties</p>
<p>Object.keys</p>
<p>Object.preventExtensions / Object.isExtensible</p>
<p>Object.seal / Object.isSealed</p>
<p>Object.freeze / Object.isFrozen</p>
<p>PS：只讲有什么，不讲是什么。</p>
<p><strong>什么是ES6</strong></p>
<p>ECMAScript6在保证向下兼容的前提下，提供大量新特性：</p>
<blockquote>
<p>1.块级作用域 关键字let, 常量const</p>
</blockquote>
<blockquote>
<p>2.对象字面量的属性赋值简写（property value shorthand）</p>
</blockquote>
<blockquote>
<p>3.赋值解构</p>
</blockquote>
<blockquote>
<p>4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread）</p>
</blockquote>
<blockquote>
<p>5.箭头函数 Arrow functions</p>
</blockquote>
<p>(1).简化了代码形式，默认return表达式结果。</p>
<p>(2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。</p>
<blockquote>
<p>6.字符串模板 Template strings</p>
</blockquote>
<blockquote>
<p>7.Iterators（迭代器）+ for..of</p>
</blockquote>
<p>迭代器有个next方法，调用会返回：</p>
<p>(1).返回迭代对象的一个元素：{ done: false, value: elem }</p>
<p>(2).如果已到迭代对象的末端：{ done: true, value: retVal }</p>
<blockquote>
<p>8.生成器 （Generators）</p>
</blockquote>
<blockquote>
<p>9.Class,有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）</p>
</blockquote>
<blockquote>
<p>10.Modules</p>
</blockquote>
<p>ES6的内置模块功能借鉴了CommonJS和AMD各自的优点：</p>
<p>(1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。</p>
<p>(2).类似AMD，支持异步加载和可配置的模块加载。</p>
<blockquote>
<p>11.Map + Set + WeakMap + WeakSet</p>
</blockquote>
<p>四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。</p>
<blockquote>
<p>12.Math + Number + String + Array + Object APIs</p>
</blockquote>
<blockquote>
<p>13.Proxy,使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。</p>
</blockquote>
<p>可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。</p>
<blockquote>
<p>14.Symbols</p>
</blockquote>
<p>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。</p>
<blockquote>
<p>15.Promises,Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。</p>
</blockquote>
<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>使用 Array.concat()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line">var array2 = [4, 5, 6];</span><br><span class="line">console.log(array1.concat(array2)); // [1,2,3,4,5,6];</span><br></pre></td></tr></table></figure>

<p>不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存.</p>
<p>可以使用 Array.push.apply(arr1, arr2) 来代替创建新的数组，它可以把第二个数组合并到第一个中，从而较少内存消耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(array1.push.apply(array1, array2)); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<h2 id="async和defer的作用是什么？有什么区别"><a href="#async和defer的作用是什么？有什么区别" class="headerlink" title="async和defer的作用是什么？有什么区别?"></a>async和defer的作用是什么？有什么区别?</h2><ul>
<li><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li>
<li><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li>
<li><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li>
</ul>
<p><img src="/img/image-20211201070616431.png" alt="image-20211201070616431"></p>
<h1 id="三大山-原型和原型链"><a href="#三大山-原型和原型链" class="headerlink" title="三大山-原型和原型链"></a>三大山-原型和原型链</h1><h2 id="彻底搞懂this"><a href="#彻底搞懂this" class="headerlink" title="彻底搞懂this"></a>彻底搞懂this</h2><p>小结：</p>
<ul>
<li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li>
<li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li>
<li>在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</li>
<li>call、apply和bind：this 是第一个参数</li>
<li>箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</li>
</ul>
<p><strong>为什么要有 this？</strong></p>
<p>官方解释：</p>
<blockquote>
<p><code>this</code> 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 <code>API</code> 设计或者函数变得更加简洁，而且还更容易复用。</p>
</blockquote>
<p>看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function say() &#123;</span><br><span class="line">  console.log(&quot;你好！&quot;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">let person1 = &#123;</span><br><span class="line">  name: &#x27;小猪课堂&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let person2 = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;</span><br><span class="line">&#125;</span><br><span class="line">say.call(person1); // 你好！ 小猪课堂</span><br><span class="line">say.call(person2); // 你好！ 张三</span><br></pre></td></tr></table></figure>

<p>如果我们没有 <code>this</code>，那么我们就需要显式的将上下文对象传入函数，即显式传入 <code>person1</code> 和 <code>person2</code> 对象。</p>
<p><strong>this的定义</strong></p>
<p><code>this</code> 就是一个对象，<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<blockquote>
<ul>
<li>this 是在运行时绑定的，不是在编写时绑定</li>
<li>this 的绑定与函数的声明和位置没有任何关系</li>
<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</li>
</ul>
</blockquote>
<p><strong>this的绑定规则</strong></p>
<blockquote>
<p>绑定流程：先确定函数调用位置，然后确定使用哪条规则，然后根据规则确定 <code>this</code> 绑定。</p>
<p>绑定优先级：默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</p>
</blockquote>
<p>4条核心绑定规则</p>
<blockquote>
<ul>
<li>默认绑定(函数的普通调用)：<code>this</code> 绑定到全局对象</li>
<li>隐式绑定(函数作为对象方法调用)：一般绑定到调用对象，如 <code>obj.foo</code> 绑定到 <code>obj</code></li>
<li>显示绑定(函数通过<code>call</code>、<code>apply</code>、<code>bind</code>间接调用)：通过 <code>call</code>、<code>apply</code> 指定 <code>this</code> 绑定到哪里。使用 <code>bind</code> 函数硬绑定</li>
<li>new绑定(函数作为构造函数调用)：使用 <code>new</code> 关键词，绑定到当前函数对象</li>
</ul>
</blockquote>
<p>判断 this 最终指向，总体流程：</p>
<blockquote>
<ol>
<li>判断函数调用时是否使用了 <code>new</code>，即 <code>new</code> 绑定，如果使用了，则 <code>this</code> 绑定的是新创建的对象。</li>
<li>函数调用是否使用了 <code>call</code>、<code>apply</code> 等显式绑定，或者硬绑定（bind），如果是的话，<code>this</code> 指向指定的对象。</li>
<li>函数是否在某个上下文对象中调用，即隐式绑定，如 <code>obj1.foo</code>，如果是的话，<code>this</code> 指向绑定的那个上下文对象。</li>
<li>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，在严格模式下，默认绑定的 <code>this</code> 是 <code>undefined</code>，非严格模式下绑定到全局对象。</li>
</ol>
</blockquote>
<p><strong>1.默认绑定(函数的普通调用)</strong></p>
<blockquote>
<p>当函数不带用任何修饰进行调用时，此时 <code>this</code> 的绑定就是默认绑定规则，<code>this</code> 指向全局对象。</p>
<p>let变量声明不会绑定在window上面，只有var声明的才会，这是需要注意的。除此之外，严格模式下上段代码的 <code>this</code> 是 <code>undefined</code>，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;小猪课堂&#x27;;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this) // Window&#123;&#125;</span><br><span class="line">  console.log(this.name) // 小猪课堂</span><br><span class="line">&#125;</span><br><span class="line">foo(); // 小猪课堂</span><br></pre></td></tr></table></figure>

<p>在全局作用域中定义了一个变量<code>name</code>，然后我们在函数 <code>foo</code> 中使用<code>this.name</code>，输出的结果就是全局变量<code>name</code>，这说明我们 <code>this</code> 指向了全局作用域，也就是说 <code>this</code> 绑定到了 <code>window</code> 对象上。</p>
<p>函数的这种调用方式就被称为默认绑定，默认绑定规则下的 <code>this</code> 指向全局对象。</p>
<p><strong>2.隐式绑定(函数作为对象方法调用)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.name) // 小猪课堂</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;小猪课堂&#x27;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>在 <code>obj</code> 对象中引用了函数 <code>foo</code>，然后我们使用 <code>obj.foo</code>（函数别名）的方式调用了该函数，此时不是独立函数调用，我们不能使用默认绑定规则。</p>
<p>此时 <code>this</code> 的绑定规则称为隐式绑定规则，因为我们不能直接看出函数的调用位置，它的实际调用位置在 <code>obj</code> 对象里面，调用 <code>foo</code> 时，它的执行上下文对象为 <code>obj</code> 对象，所以 <code>this</code> 将会被绑定到 <code>obj</code> 对象上，所以我们函数中的 <code>this.name</code> 其实就是<code>obj.name</code>。这就是我们的隐式绑定规则。</p>
<p>i.多个引用调用</p>
<p>如果我们调用函数时有多个引用调用，比如<code>obj1.obj2.foo()</code>。这个时候函数 <code>foo</code> 中的 <code>this</code> 指向哪儿呢？其实不管引用链多长，<code>this</code> 的绑定都由最顶层调用位置确定，即<code>obj1.obj2.foo()</code>的 <code>this</code> 还是绑定带 <code>obj2</code>。</p>
<p>ii隐式绑定中 this 丢失</p>
<p>在隐式绑定规则中，我们认为谁调用了函数，<code>this</code> 就绑定谁，比如 <code>obj.foo</code> 中 <code>this</code> 就绑定到 <code>obj</code>，但是有一些情况比较特殊，即使采用的隐式绑定规则，但是 <code>this</code> 并没有按照我们的想法去绑定，这就是所谓的隐式绑定 <code>this</code> 丢失，常见于回调函数中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.name) // 小猪课堂</span><br><span class="line">&#125;</span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">  fn(); // 函数调用位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">let name = &#x27;小猪课堂&#x27;;</span><br><span class="line">doFoo(obj.foo); // 小猪课堂</span><br></pre></td></tr></table></figure>

<p>上段代码中我们很容易会以为 <code>foo</code> 绑定的 <code>this</code> 是 <code>obj</code> 对象，因为我们使用了 <code>obj.foo</code> 的方式，这种方式就是遵循隐式绑定规则。但是事实上 <code>this</code> 却绑定到了全局对象上去，这是因为我们在 <code>doFoo</code> 函数中调用 <code>fn</code> 时，这里才是函数的实际调用位置，此时是独立函数调用，所以 <code>this</code> 指向了全局对象。</p>
<p>实际项目中我们容易遇到这种问题的场景可能就是定时器了，比如下面的代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.foo, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这种写法就很容易造成 <code>this</code> 丢失。</p>
<p><strong>3.显示绑定(函数通过<code>call</code>、<code>apply</code>、<code>bind</code>间接调用)</strong></p>
<p>明确的将函数的 <code>this</code> 绑定在某个对象上。使用call、apply、bind。其中bind就是硬绑定。</p>
<p>虽然显式绑定本身不能解决 <code>this</code> 绑定丢失的问题，但是我们可以通过变通的方式来解决这个问题，也被称作<strong>硬绑定</strong>。</p>
<p>硬绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.name) // 小猪课堂</span><br><span class="line">&#125;</span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">  fn(); // 函数调用位置</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let bar = function () &#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line">let name = &#x27;小猪课堂&#x27;;</span><br><span class="line">doFoo(bar); // 张三</span><br><span class="line">setTimeout(bar, 100); // 张三</span><br></pre></td></tr></table></figure>

<p>其实思路也比较简单，出现 <code>this</code> 绑定丢失原因无非就是我们传入的回调函数在被执行时，<code>this</code> 绑定规则变为了默认绑定，那么为了解决这个问题，我们不妨在封装一个函数，将 <code>foo</code> 函数的 <code>this</code> 显式绑定到 <code>obj</code> 对象上去即可。</p>
<p>这里提一点，下面写法是错误的：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">doFoo</span>(foo.call(obj));</span><br></pre></td></tr></table></figure>

<p>因为回调函数是在 <code>doFoo</code> 里面执行的，上面的写法相当于 <code>foo</code> 函数立即执行了。</p>
<p><strong>4.new绑定(函数作为构造函数调用)</strong></p>
<p>使用 new 来调用函数时，会执行下面操作：</p>
<ul>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行原型连接</li>
<li>这个新对象会绑定到函数调用的 <code>this</code></li>
<li>如果函数没有返回其它对象，那么 <code>new</code> 表达式种的函数调用会自动返回这个新对象</li>
</ul>
<p>我们可以看到 <code>new</code> 的操作中就有 <code>this</code> 的绑定，我们在来看看代码。</p>
<p>代码如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(name) &#123;</span><br><span class="line">  <span class="attr">this.name</span> = name<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="attr">bar</span> = new foo(<span class="string">&#x27;小猪课堂&#x27;</span>)<span class="comment">;</span></span><br><span class="line">console.log(bar.name)<span class="comment">; // 小猪课堂</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上段代码我们使用 <code>new</code> 关键词调用了 <code>foo</code> 函数，大家注意这不是默认调用规则，这是 <code>new</code> 绑定规则。</p>
<p>练习绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;</span><br><span class="line"></span><br><span class="line">const person1 = &#123;</span><br><span class="line">  name: &#x27;person1&#x27;,</span><br><span class="line">  show1: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  show2: () =&gt; console.log(this.name),</span><br><span class="line">  show3: function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  show4: function () &#123;</span><br><span class="line">    return () =&gt; console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person2 = &#123; name: &#x27;person2&#x27; &#125;</span><br><span class="line"></span><br><span class="line">person1.show1()                     // person1 函数作为对象方法调用，this指向对象</span><br><span class="line">person1.show1.call(person2)         // person2 使用call间接调用函数，this指向传入的person2</span><br><span class="line"></span><br><span class="line">person1.show2()                     // window  箭头函数无this绑定，在全局环境找到this，指向window</span><br><span class="line">person1.show2.call(person2)         // window  间接调用改变this指向对箭头函数无效</span><br><span class="line"></span><br><span class="line">person1.show3()()                   // window  person1.show3()返回普通函数，相当于普通函数调用，this指向window</span><br><span class="line">person1.show3().call(person2)       // person2 使用call间接调用函数，this指向传入的person2</span><br><span class="line">person1.show3.call(person2)()       // window  person1.show3.call(person2)仍然返回普通函数</span><br><span class="line"></span><br><span class="line">person1.show4()()                   // person1 person1.show4调用对象方法，this指向person1，返回箭头函数，this在person1.show4调用时的词法环境中找到，指向person1</span><br><span class="line">person1.show4().call(person2)       // person1  间接调用改变this指向对箭头函数无效</span><br><span class="line">person1.show4.call(person2)()       // person2  改变了person1.show4调用时this的指向，所以返回的箭头函数的内this解析改变</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<p><a href="https:/面试官：JS中this指向哪儿？你是如何确定this的？/juejin.cn/post/7115390077353590792#heading-13">面试官：JS中this指向哪儿？你是如何确定this的？</a></p>
<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h2><p>回顾call/apply/bind用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function sayHelloTo (to) &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; say hello to $&#123;to&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">var Jerry = &#123;</span><br><span class="line">  name: &#x27;Jerry&#x27;</span><br><span class="line">&#125;</span><br><span class="line">sayHelloTo.call(Jerry, &#x27;Tom&#x27;)</span><br><span class="line">//Jerry say hello to Tom.</span><br><span class="line"></span><br><span class="line">var Foo = &#123;</span><br><span class="line">  name: &#x27;Foo&#x27;</span><br><span class="line">&#125;</span><br><span class="line">sayHelloTo.apply(Foo, [&#x27;Bar&#x27;])</span><br><span class="line">//Foo say hello to Bar.</span><br><span class="line"></span><br><span class="line">var XYZ = &#123;</span><br><span class="line">  name: &#x27;XYZ&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var say = sayHelloTo.bind(XYZ)</span><br><span class="line">say(&#x27;ABC&#x27;)</span><br><span class="line">//XYZ say hello to ABC.</span><br></pre></td></tr></table></figure>

<p><strong>call/apply</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 第一个参数就是改变 this 的指向，写谁就是谁，在非严格模式下，null/undefined 指向的是 window。</span><br><span class="line">- call/apply 的唯一区别就是，传递参数不一样，apply 第二个参数是数组，call的参数是一个一个传递。</span><br><span class="line">- call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候）</span><br></pre></td></tr></table></figure>

<p><strong>bind</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-  call/apply都是改变this的同时就把函数执行了，但是bind不是立即执行函数，属于预先改变this和传递一些内容，利用的是柯理化的思想。</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<blockquote>
<ol>
<li>当我们使用一个函数需要改变<code>this</code>指向的时候才会用到<code>call``apply``bind</code></li>
<li>如果你要传递的参数不多，则可以使用<code>fn.call(thisObj, arg1, arg2 ...)</code></li>
<li>如果你要传递的参数很多，则可以用数组将参数整理好调用<code>fn.apply(thisObj, [arg1, arg2 ...])</code></li>
<li>如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用<code>const newFn = fn.bind(thisObj); newFn(arg1, arg2...)</code></li>
</ol>
</blockquote>
<p>经典面试题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 谁调用我，我就指向谁</span><br><span class="line">var name = 222</span><br><span class="line">var a=&#123;</span><br><span class="line">  name:111,</span><br><span class="line">  say:function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fun = a.say</span><br><span class="line">fun() // fun.call(window)</span><br><span class="line">a.say() // a.say.call(a)</span><br><span class="line"></span><br><span class="line">var b=&#123;</span><br><span class="line">  name:333,</span><br><span class="line">  say:function(fn)&#123;</span><br><span class="line">    fn(); // fn.call(window),难点</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say) // 相当于把函数当进去执行，这种函数作为入参的，都是指向全局window，所以就是fn.call(window)</span><br><span class="line">b.say=a.say</span><br><span class="line"></span><br><span class="line">b.say() // b.say.call(b)</span><br></pre></td></tr></table></figure>

<p><strong>call、apply、bind更详细用法</strong></p>
<ol>
<li>怎么利用 call、apply 来求一个数组中最大或者最小值 ?</li>
<li>如何利用 call、apply 来做继承 ?</li>
<li>apply、call、bind 的区别和主要应用场景 ?</li>
</ol>
<p>利用 call、apply 来求一个数组中最大或者最小值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,8,6]</span><br><span class="line">Math.max.apply(Math或null, arr); //8</span><br><span class="line">Math.max.call(Math或null, 1,8,6); //8</span><br><span class="line">Math.max(...arr); //8 es6扩展运算符法</span><br></pre></td></tr></table></figure>

<p><strong>手写call</strong></p>
<p>核心思路是：</p>
<ol>
<li>为传入的<code>context</code>扩展一个属性，将原函数指向这个属性</li>
<li>将<code>context</code>之外的所有参数全部传递给这个新属性，并将运行结果返回。</li>
</ol>
<p>一些细节：</p>
<ol>
<li>利用<strong>rest 参数</strong>(<code>…args</code>)可以存储函数多余的参数</li>
<li>为传入的<code>context</code>扩展参数扩展新属性使用了**<code>Symbol()</code>数据类型**，这样确保不会影响到传入的<code>context</code>，因为Symbol值一定是独一无二的。</li>
<li>用<strong>扩展运算符</strong>(<code>…</code>)将原来是数组的<code>args</code>转发为逗号分隔一个个参数传入到函数中</li>
</ol>
<p>为什么能找到<code>this.name</code>呢？因为<code>context[fnSymbol]</code>中的<code>this</code>指向的是<code>context</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context, ...args) &#123;</span><br><span class="line">  // 判断是否是undefined和null</span><br><span class="line">  if (typeof context === &#x27;undefined&#x27; || context === null) &#123;</span><br><span class="line">    context = window</span><br><span class="line">  &#125;</span><br><span class="line">  // 思路和call是一样的只是传参不同方式</span><br><span class="line">  let fnSymbol = Symbol()</span><br><span class="line">  context[fnSymbol] = this</span><br><span class="line">  //通过隐式绑定的方式调用函数</span><br><span class="line">  let fn = context[fnSymbol] (...args)</span><br><span class="line">  //删除添加的属性</span><br><span class="line">  delete context[fnSymbol] </span><br><span class="line">  return fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手写apply</strong></p>
<p>思路和<code>call</code>是一样的只是传参不同方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context, args) &#123;</span><br><span class="line">  // 判断是否是undefined和null</span><br><span class="line">  if (typeof context === &#x27;undefined&#x27; || context === null) &#123;</span><br><span class="line">    context = window</span><br><span class="line">  &#125;</span><br><span class="line">  let fnSymbol = Symbol()</span><br><span class="line">  context[fnSymbol] = this</span><br><span class="line">  let fn = context[fnSymbol] (...args)</span><br><span class="line">  return fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手写bind</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">// 判断是否是undefined和null</span><br><span class="line">    if (typeof context === &quot;undefined&quot; || context === null) &#123;</span><br><span class="line">     context = window;</span><br><span class="line">    &#125;</span><br><span class="line">    self = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">     return self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69070129">手写源码系列（一）——call、apply、bin</a></p>
<h1 id="三大山-作用域和闭包"><a href="#三大山-作用域和闭包" class="headerlink" title="三大山-作用域和闭包"></a>三大山-作用域和闭包</h1><h2 id="作用域-执行上下文"><a href="#作用域-执行上下文" class="headerlink" title="作用域-执行上下文"></a>作用域-执行上下文</h2><p>参考</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li>
<li><a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li>
<li><a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li>
<li><a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li>
</ul>
<p><strong>执行上下文</strong></p>
<p>定义：执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。</p>
<ul>
<li><p>它包含<strong>三部分</strong></p>
<ul>
<li>变量对象（VO）</li>
<li>作用域链（词法作用域）</li>
<li>this 指向</li>
</ul>
</li>
<li><p>它的<strong>类型</strong>：</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 执行上下文</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
<li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>
<li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</li>
</ul>
</blockquote>
<ul>
<li>代码执行<strong>过程</strong>：<ul>
<li>创建 <strong>全局上下文</strong>（global EC）</li>
<li>全局执行上下文（caller）<strong>自上而下</strong> 逐行执行。遇到函数时，<strong>函数执行上下文</strong>（callee）被 push 到执行栈顶</li>
<li>函数执行上下文被激活，成为 active EC，开始执行函数中的代码，caller 被挂起</li>
<li>函数执行完后，callee 被 pop 移除出执行栈，控制权交还给全局上下文（caller）继续执行</li>
</ul>
</li>
</ul>
<p>包括三个阶段：<strong>创建阶段→执行阶段→回收阶段</strong></p>
<p>1.创建阶段</p>
<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>
<ul>
<li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>
<li>确定this指向：包括多种情况，下文会详细说明</li>
</ul>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。</p>
<p>2.执行阶段</p>
<p>执行变量赋值、代码执行</p>
<p>3.回收阶段</p>
<p>执行上下文出栈等待虚拟机回收执行上下文</p>
<p><strong>作用域与执行上下文</strong></p>
<p>JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段。解释阶段确定作用域规则，执行阶段确定上下文。太妙了</p>
<p>解释阶段：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<p>执行阶段：</p>
<ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<blockquote>
<p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p>
</blockquote>
<h2 id="作用域-变量对象-VO-AO-GO"><a href="#作用域-变量对象-VO-AO-GO" class="headerlink" title="作用域-变量对象(VO/AO/GO)"></a>作用域-变量对象(VO/AO/GO)</h2><p>JS有两个特性，一个是单线程，一个是解释性语言。</p>
<p>JS运行步骤：1.语法分析2.预编译3.解释执行</p>
<p>函数执行四部曲：</p>
<p>1.创建AO对象，供js引擎自己去访问</p>
<p>activation object （活跃对象/执行期上下文）</p>
<p>2.找变量和形参的声明，作为AO对象的属性名，值是undefined</p>
<p>3.实参和形参相统一，实参赋值给形参</p>
<p>4.找函数声明(注意不是函数表达式)，会覆盖变量的声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,c</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//function a()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//function c()&#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> d= <span class="number">678</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//function ()&#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//function c()&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="literal">undefined</span>,<span class="number">1</span>,<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="attr">c</span>:<span class="literal">undefined</span>,<span class="number">2</span>,<span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="attr">d</span>:<span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态作用域与动态作用域</strong></p>
<blockquote>
<p>JavaScript 采用词法作用域(lexical scoping)，就是静态作用域。</p>
</blockquote>
<p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line">// 结果是 ???</span><br></pre></td></tr></table></figure>

<p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p>
<p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value (价值) ，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value (价值) 等于 1，所以结果会打印 1。</p>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p>
<p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value (价值) 。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value (价值) 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p>
<p>来自《JavaScript权威指南》中的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>

<p>两段代码都会打印：<code>local scope</code>。因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。</p>
<blockquote>
<p>引用《JavaScript权威指南》的回答就是：</p>
<p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope (范围) 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p>
</blockquote>
<p><strong>变量提升</strong></p>
<ul>
<li>变量声明提升</li>
<li>函数声明提升</li>
</ul>
<blockquote>
<p>有个细节必须注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明提升</span><br><span class="line">console.log(a)// undefined</span><br><span class="line">var a = 10</span><br><span class="line"></span><br><span class="line">// 函数声明提升</span><br><span class="line">function test() &#123;</span><br><span class="line">    foo(); // Uncaught TypeError &quot;foo is not a function&quot;</span><br><span class="line">    bar(); // &quot;this will run!&quot;</span><br><span class="line">    var foo = function () &#123; // function expression assigned to local variable &#x27;foo&#x27;</span><br><span class="line">        alert(&quot;this won&#x27;t run!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() &#123; // function declaration, given the name &#x27;bar&#x27;</span><br><span class="line">        alert(&quot;this will run!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">// 复杂点例子</span><br><span class="line">function test(arg)&#123;</span><br><span class="line">    // 1. 形参 arg 是 &quot;hi&quot;</span><br><span class="line">    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function</span><br><span class="line">    console.log(arg);  </span><br><span class="line">    var arg = &#x27;hello&#x27;; // 3.var arg 变量声明被忽略， arg = &#x27;hello&#x27;被执行</span><br><span class="line">    function arg()&#123;</span><br><span class="line"> console.log(&#x27;hello world&#x27;) </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg);  </span><br><span class="line">&#125;</span><br><span class="line">test(&#x27;hi&#x27;);</span><br><span class="line">/* 输出：</span><br><span class="line">function arg()&#123;</span><br><span class="line">    console.log(&#x27;hello world&#x27;) </span><br><span class="line">    &#125;</span><br><span class="line">hello </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="作用域-作用域与作用域链"><a href="#作用域-作用域与作用域链" class="headerlink" title="作用域-作用域与作用域链"></a>作用域-作用域与作用域链</h2><p><strong><code>作用域</code></strong> 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。</p>
<p><strong><code>作用域链</code></strong> 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。</p>
<p>作用域具体可细分为四种：**<code>全局作用域</code><strong>、</strong><code>模块作用域</code><strong>、</strong><code>函数作用域</code><strong>、</strong><code>块级作用域</code>**</p>
<p><strong>全局作用域：</strong> 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。</p>
<p><strong>模块作用域：</strong> 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（AMD、CommonJS、UMD、ES6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。</p>
<p><strong>函数作用域：</strong> 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。</p>
<p><strong>块级作用域：</strong> 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// var demo</span><br><span class="line">for(var i=0; i&lt;10; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); // 10</span><br><span class="line"></span><br><span class="line">// let demo</span><br><span class="line">for(let i=0; i&lt;10; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); //ReferenceError：i is not defined</span><br></pre></td></tr></table></figure>

<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>var obj={}</p>
<p>obj存放在栈内存中，{}实例存在在堆中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//example 1</span><br><span class="line">let a=&#123;&#125;, b=&#x27;0&#x27;, c=0;</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;培训&#x27;, 对象的key数字和字符串等效</span><br><span class="line"></span><br><span class="line">// ---------------------</span><br><span class="line">//example 2</span><br><span class="line">let a=&#123;&#125;, b=Symbol(&#x27;1&#x27;), c=Symbol(&#x27;1&#x27;);</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;珠峰&#x27;, Symbol的特点，都是唯一的</span><br><span class="line"></span><br><span class="line">// ---------------------</span><br><span class="line">//example 3</span><br><span class="line">let a=&#123;&#125;, b=&#123;n:&#x27;1&#x27;&#125;, c=&#123;m:&#x27;2&#x27;&#125;;</span><br><span class="line">a[b]=&#x27;珠峰&#x27;;</span><br><span class="line">a[c]=&#x27;培训&#x27;;</span><br><span class="line">console.log(a[b]); // &#x27;培训&#x27;, key会转化成字符串[Obejct object]</span><br></pre></td></tr></table></figure>

<p><strong>赋值、浅拷贝、深拷贝</strong></p>
<p>赋值：把一个对象赋给一个新变量，赋的其实是该对象在栈中的地址，所有值都会相互影响</p>
<p>浅拷贝：重新在堆中创建内存，拷贝后的基本数据类型不影响，但是引用类型属性是相互影响共用</p>
<p>深拷贝：重新在堆中创建内存，所有值都不相互影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值，全部影响</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">play</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =person;</span><br><span class="line">person2.<span class="property">name</span>=<span class="string">&#x27;lucy&#x27;</span>;</span><br><span class="line">person2.<span class="property">play</span>[<span class="number">0</span>]=<span class="string">&#x27;爵士&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝，基本类型不影响，引用类型数据共用</span></span><br><span class="line"><span class="comment">// 1. ...扩展运算符实现</span></span><br><span class="line"><span class="keyword">let</span> copy1 = &#123;...&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.assign实现</span></span><br><span class="line"><span class="keyword">let</span> copy2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝，所有数据不影响</span></span><br><span class="line"><span class="comment">// 1. JOSN.stringify()/JSON.parse()</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 递归拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> copy = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">      copy[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepClone</span>(obj[i]) : obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a><strong>V8引擎</strong></h2><p>1.定义</p>
<p><code>V8</code>是一个由<code>Google</code>开源的采用<code>C++</code>编写的高性能<code>JavaScript</code>和<code>WebAssembly</code>引擎。</p>
<p>主要工作：</p>
<ul>
<li>编译和执行js代码，即将js代码转换为机器代码；</li>
<li>处理调用栈；</li>
<li>内存分配和垃圾回收；</li>
</ul>
<p>2.原理</p>
<p><code>V8</code>的内部有很多模块，其中最重要的4个：</p>
<ul>
<li><strong>Parser</strong>解析器:负责将js源代码解析成AST抽象语法树</li>
<li><strong>Interpreter</strong>解释器:负责将AST解释为bytecode字节码文件，同时也有直接解释执行bytecode能力</li>
<li><strong>complier</strong>编译器:负责编译出运行更加高效的机器代码</li>
<li><strong>Orinoco</strong>: 垃圾回收器，负责进行内存空间回收</li>
</ul>
<p><img src="/img/image-20211209072317064.png" alt="image-20211209072317064"></p>
<p>(1)AST抽象语法树</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST 抽象语法树——最基础的 javascript 重点知识，99% 的人根本不了解</a></p>
<p><img src="/img/image-20211209072730664.png" alt="image-20211209072730664"></p>
<p>Parser解析器在转换过程中有两个重要的阶段：<code>词法分析（Lexical Analysis）</code>和<code>语法分析（Syntax Analysis）</code>.</p>
<ul>
<li>词法分析,也称为分词，是将字符串形式的代码转换为标记（token）序列的过程。</li>
<li>语法分析,语法分心是将词法分析产生的<code>token</code>按照某种给定的形式文法转换成<code>AST</code>的过程。也就是把单词组合成句子的过程.</li>
</ul>
<p>(2)byteCode</p>
<p><img src="/img/image-20211209072755682.png" alt="image-20211209072755682"></p>
<p>(3)machine code</p>
<p><img src="/img/image-20211209072828890.png" alt="image-20211209072828890"></p>
<p>3.V8发展史</p>
<p>(1)早期的V8</p>
<p>早期的版本5.8以前，V8没有解释器，只有2个编译器。</p>
<p>所以流程是这样的：</p>
<ul>
<li>解析器对js解析成AST，<strong>Full-codegen</strong>编译器(也叫基准编译器)对AST编译成机器代码(省去了bytecode，执行效率更高)。</li>
<li>在执行的过程，有分析线程对机器代码进行优化，需要解析器对js解析成AST，<strong>Crankshaft</strong>编译器(也称为优化编译器)对代码进行优化。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：省去了bytecode的转化，直接生成更加高效的machine code机器代码.</span><br><span class="line"></span><br><span class="line">缺点：V8团队的官方博客这样说,</span><br><span class="line">a.生成的机器码占用了大量内存</span><br><span class="line">b.缺少中间层的bytecode，很多性能优化策略无法实施</span><br><span class="line">c.js引擎无法很好的支持新的语法</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20211209073441948.png" alt="image-20211209073441948"></p>
<p>(2)2017年4月新的V8架构</p>
<p>V8团队这样评价新架构：<strong>它代表了V8团队通过实际测量Javascript性能，并仔细研究Full-codegen和Crankshaft的缺点后收集到的共同见解的顶峰</strong>。</p>
<p>所以新的流程是这样的：</p>
<ul>
<li>解析器对js解析成AST，<strong>Igniton</strong>基准解释器解释成bytecode字节码，并执行</li>
<li>执行一段时间后，<strong>TruboFan</strong>优化编译对bytecode字节码优化为更加高效的机器码</li>
</ul>
<p>有几个优化点：</p>
<p>1.函数<strong>只声明未被调用</strong>，不会被解析成AST</p>
<p>2.函数<strong>只被调用一次</strong>，bytecode直接被解释执行，TruboFan不会进行优化编译</p>
<p>3.函数<strong>被调用多次</strong>，可能被标记为热点函数，可能被编译成机器代码</p>
<p><img src="/img/image-20211209074403859.png" alt="image-20211209074403859"></p>
<p>(3)新架构的特点</p>
<p>将优化后的bytecode和machine code形成共存的状态。</p>
<p>这里要注意<strong>deoptimization</strong>即回退字节码，即由解释器解释执行。函数类型发生变化时，<strong>Igniton</strong>会检测到变化，会将字节码回退，重新解释为新的字节码。</p>
<p>建议：</p>
<p>1.不要将函数的类型变来变去，尽量保证类型一致，如sum(x,y) x一会是int,一会儿是num</p>
<p>优点：</p>
<p>1.第一次执行，直接使用中间层的字节码，省去了机器码，同时编译器生成字节码的速度远远大于机器码</p>
<p>2.优化线程不需要从源码从新编译，而是从bytecode字节码开始优化就可以了。同时<strong>deoptimization</strong>只需要回退到字节码即可。</p>
<p>优化点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.隐藏类（hidden class）</span><br><span class="line">2.内联缓存（incline caching）</span><br><span class="line">3.优化 Orinoco</span><br><span class="line">3.1增量标记 - Incremental marking</span><br><span class="line">3.2懒性清理 - Lazy sweeping</span><br><span class="line">3.3并发 - Concurrent</span><br><span class="line">3.4并行 - Parallel</span><br></pre></td></tr></table></figure>

<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>JS内存空间分为<strong>栈(stack)<strong>、</strong>堆(heap)<strong>、</strong>池(一般也会归类为栈中)<strong>。 其中</strong>栈</strong>存放基本变量，<strong>堆</strong>存放应用对象(引用地址存放在栈，真实变量在堆)，<strong>池</strong>存放常量，所以也叫常量池。</p>
<p><strong>几个问题</strong></p>
<p>问题1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 这时a的值是多少？</span></span><br></pre></td></tr></table></figure>

<p>问题2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;前端开发&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;进阶&#x27;</span>;</span><br><span class="line"><span class="comment">// 这时a.name的值是多少</span></span><br></pre></td></tr></table></figure>

<p>问题3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;前端开发&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 这时b的值是多少</span></span><br></pre></td></tr></table></figure>

<p>现在来解答一下，三个问题的答案分别是<code>20</code>、<code>‘进阶’</code>、<code>&#123; name: &#39;前端开发&#39; &#125;</code></p>
<ul>
<li>对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。</li>
<li>对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改<code>b.name</code>的值后，相应的<code>a.name</code>也就发生了改变。</li>
<li>对于问题3，首先要说明的是<code>null</code>是基本类型，<code>a = null</code>之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。</li>
</ul>
<p><strong>JS的内存生命周期</strong></p>
<ul>
<li>1、分配你所需要的内存</li>
<li>2、使用分配到的内存（读、写）</li>
<li>3、不需要时将其释放、归还</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><p><strong>(1)定义</strong></p>
<p>JavaScript 中自动垃圾回收机制的原理为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找出那些不再使用的变量，然后释放其占用的内存。</span><br><span class="line">垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</span><br></pre></td></tr></table></figure>

<p><strong>(2)内存生命周期</strong></p>
<p>不管什么程序语言，内存生命周期基本是一致的：</p>
<ul>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放归还</li>
</ul>
<p>对于javascript而言，</p>
<ul>
<li>简单类型，内存是保存在栈（stack）空间</li>
<li>复杂数据类型，内存是保存在堆（heap）空间</li>
</ul>
<p><strong>(3)为什么需要垃圾回收机制？</strong></p>
<p>在Chrome中，v8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制？</p>
<ul>
<li>表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景。JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</li>
<li>深层原因是，V8的垃圾回收机制的限制（垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，那么性能和应用直线下降）</li>
</ul>
<p><strong>(4)垃圾收集机制</strong></p>
<p>V8的垃圾回收策略主要是基于<code>分代垃圾回收机制</code>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p>
<p>(1.1)内存模型</p>
<ul>
<li>新生代：生存时间短的对象，支持 1～8M 的容量</li>
<li>老年代：生存时间长的对象，容量较大</li>
</ul>
<p>为了提高回收效率，V8 分别使用两个不同的垃圾回收器，</p>
<ul>
<li>副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。</li>
<li>主垃圾回收器 - Mark-Sweep &amp; Mark-Compact：主要负责老生代的垃圾回收。</li>
</ul>
<p>(1.2)新生代回收</p>
<p>在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。</p>
<p>Scavange算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>。</p>
<p>工作过程如下：</p>
<ul>
<li>标记活动对象和非活动对象</li>
<li>复制 from space 的活动对象到 to space 并对其进行排序</li>
<li>释放 from space 中的非活动对象的内存</li>
<li>将 from space 和 to space 角色互换</li>
</ul>
<img src="/img/image-20220222215742735.png" alt="image-20220222215742735" style="zoom: 80%;" />

<p>新生代又细分为<code>nursery</code>子代和<code>intermediate</code>子代两个区域。一个对象第一次分配内存时会被分配到新生代中的<code>nursery</code>子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 <code>intermediate</code> 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为<strong>晋升</strong>。</p>
<p>对象晋升的条件主要有以下两个：</p>
<ul>
<li>对象是否经历过一次<code>Scavenge</code>算法</li>
<li><code>To</code>空间的内存占比是否已经超过<code>25%</code>(之所以有<code>25%</code>的内存限制是因为<code>To</code>空间在经历过一次<code>Scavenge</code>算法后会和<code>From</code>空间完成角色互换，会变为<code>From</code>空间，后续的内存分配都是在<code>From</code>空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理)</li>
</ul>
<p>(1.3)老年代回收</p>
<p>scavenge算法缺陷：</p>
<ul>
<li>scavenge为复制算法，重复复制活动对象会使得效率低下</li>
<li>scavenge是牺牲空间来换取时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题</li>
</ul>
<p>老年代采用 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。</p>
<p>1.）Mark-Sweep</p>
<p>Mark-Sweep处理时分为两阶段，标记阶段和清理阶段。看起来与Scavenge类似，不同的是，Mark-Sweep在标记了活动对象和非活动对象之后，直接把非活动对象清除。</p>
<ul>
<li>标记阶段：对老生代进行第一次扫描，标记活动对象</li>
<li>清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象</li>
</ul>
<img src="/img/image-20220504095928130.png" alt="11" style="zoom: 80%;" />

<p>但是遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。</p>
<p>2.)Mark-Compact</p>
<p>若不清理这些内存碎片，如果出现需要分配一个大对象的时候，这时所有的碎片空间都完全无法完成分配，就会提前触发垃圾回收,而这次回收其实不是必要的。</p>
<p>Mark-Compact被提出，它是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>
<img src="/img/image-20220222220554956.png" alt="image-20220222220554956" style="zoom: 80%;" />

<p>(1.4)全停顿 Stop-The-World</p>
<p>由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为<code>全停顿</code>（stop-the-world）。</p>
<p>在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。</p>
<p><strong>(5)标记活动对象和非活动对象的策略</strong></p>
<p>通常有两个：<strong>引用计数</strong>和<strong>标记清除</strong></p>
<ul>
<li>引用计数-dom的垃圾回收机制</li>
<li>标记清除-js的垃圾回收机制</li>
</ul>
<p>(1.1)引用计数</p>
<p>定义：每个值被引用的次数。声明一个变量后，当使用引用类型值赋值时，+1，当这个变量又赋值另外一值，计数-1。</p>
<p>这是最初级的垃圾收集算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>缺陷:在循环的情况下，引用计数算法存在很大的局限性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">存在内存泄漏</span><br><span class="line">function problem() &#123;</span><br><span class="line">var objA = new Object();</span><br><span class="line">var objB = new Object();</span><br><span class="line">objA.someOtherObject = objB;</span><br><span class="line">objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br><span class="line">objectA 和objectB 通过各自的属性相互引用，即这两个对象的引用次数都是2，在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和objectB 还说明将继续存在，因为它们的引用次数永远不会是0。</span><br><span class="line"></span><br><span class="line">DOM中也如此</span><br><span class="line">var element=document.getElementById（&#x27;&#x27;）；</span><br><span class="line">var myObj=new Object();</span><br><span class="line">myObj.element=element;</span><br><span class="line">element.someObject=myObj;</span><br></pre></td></tr></table></figure>

<p>(1.2)标记清除</p>
<p>定义：当变量进入环境时，标记“进入环境”。当变量离开环境时，标记“离开环境”。</p>
<p>垃圾回收器创建了一个“roots”列表,“window”对象是一个全局变量，被当作root.</p>
<p>从root开始的所有对象如果是可达的，它就不被当作垃圾。所有未被标记的内存会被当做垃圾，收集器现在可以释放内存。</p>
<p>循环引用的问题迎刃而解，缺点: 算法运行时程序执行被暂停。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下几种情况都可以作为根节点：</span><br><span class="line">全局对象</span><br><span class="line">本地函数的局部变量和参数</span><br><span class="line">当前嵌套调用链上的其他函数的变量和参数</span><br></pre></td></tr></table></figure>

<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p><strong>概念</strong></p>
<p>内存溢出：当程序需要的内存超过了剩余内存，就会抛出内存溢出错误。</p>
<p>内存泄漏：<strong>不再用到的内存，没有及时释放，就叫做内存泄漏。</strong>应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。</p>
<p><strong>内存泄漏的几种原因</strong></p>
<blockquote>
<ul>
<li>意外的全局变量</li>
<li>被遗忘的定时器或回调函数</li>
<li>被遗忘的dom引用</li>
<li>闭包</li>
</ul>
</blockquote>
<p>(1)意外的全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar = &quot;this is a hidden global variable&quot;;</span><br><span class="line">    this.bar = &quot;potential accidental global&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">真相是：</span><br><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar = &quot;this is an explicit global variable&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实战：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;botton onclick=&quot;grow()&quot;&gt;点击测试内存泄漏&lt;/botton&gt;</span><br><span class="line">&lt;botton onclick=&quot;clearGrow()&quot;&gt;点击释放内存&lt;/botton&gt;</span><br><span class="line">&lt;div id=&quot;nodes&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var largeObj = []</span><br><span class="line">function grow()&#123;</span><br><span class="line">grow3()</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow()&#123;</span><br><span class="line">clearGrow3()</span><br><span class="line">&#125;</span><br><span class="line">function getBigData()&#123;</span><br><span class="line">let res = []</span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">for(let i=0;i&lt;10000;i++)&#123;</span><br><span class="line">  obj[`key-$&#123;i&#125;`] = `js创建一个很大内存的对象？`</span><br><span class="line">&#125;</span><br><span class="line">res.push(obj)</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line">function grow0()&#123;</span><br><span class="line"> largeObj=[...largeObj,getBigData()]</span><br><span class="line">&#125;</span><br><span class="line">var timer</span><br><span class="line">function grow1()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line"> timer = setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource);</span><br><span class="line">        // 定时器也没有清除</span><br><span class="line">    &#125;</span><br><span class="line">    // node、someResource 存储了大量数据 无法回收</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow1()&#123;</span><br><span class="line">window.clearInterval(timer)</span><br><span class="line">&#125;</span><br><span class="line">var childNode = document.createElement(&#x27;p&#x27;);</span><br><span class="line">function grow2()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">childNode.innerHTML = JSON.stringify(someResource);</span><br><span class="line">node.appendChild(childNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow2()&#123;</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">node.remove();</span><br><span class="line">//childNode = null;</span><br><span class="line">&#125;</span><br><span class="line">function grow3()&#123;</span><br><span class="line">var theThing = null</span><br><span class="line">    var replaceThing = function () &#123;</span><br><span class="line">        var originalThing = theThing</span><br><span class="line">        var unused = function () &#123;</span><br><span class="line">            if (originalThing)</span><br><span class="line">                console.log(&quot;hi&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">            someMethod: function someMethod() &#123;</span><br><span class="line">                console.log(&#x27;someMessage&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    setInterval(replaceThing,100)</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow3()&#123;</span><br><span class="line">解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220313115045079.png" alt="image-20220313115045079"></p>
<p>解决方法：</p>
<ul>
<li>避免创建全局变量</li>
<li>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量</li>
</ul>
<p>(2)被遗忘的定时器或回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var timer</span><br><span class="line">function grow1()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line"> timer = setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource);</span><br><span class="line">        // 定时器也没有清除</span><br><span class="line">    &#125;</span><br><span class="line">    // node、someResource 存储了大量数据 无法回收</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function clearGrow1()&#123;</span><br><span class="line">window.clearInterval(timer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原因:与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。</span><br><span class="line">解决方法： 在定时器完成工作的时候，手动清除定时器和回调函数。</span><br><span class="line">现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220313115410595.png" alt="image-20220313115410595"></p>
<p><img src="/img/image-20220313120537563.png" alt="image-20220313120537563"></p>
<p>(3)被遗忘的dom引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function grow2()&#123;</span><br><span class="line">let someResource = getBigData();</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">childNode.innerHTML = JSON.stringify(someResource);</span><br><span class="line">node.appendChild(childNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearGrow2()&#123;</span><br><span class="line">var node = document.getElementById(&#x27;nodes&#x27;);</span><br><span class="line">node.remove();</span><br><span class="line">//childNode = null;必须主动释放dom引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20220320214519742.png" alt="image-20220320214519742"></p>
<p><strong>原因</strong>: 保留了DOM节点的引用,导致GC没有回收</p>
<p><strong>解决办法</strong>：断开引用，childNode=null</p>
<p>(4)闭包</p>
<p>使用闭包只是让内存常驻，滥用闭包才会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function grow3()&#123;</span><br><span class="line">var theThing = null</span><br><span class="line">    var replaceThing = function () &#123;</span><br><span class="line">        var originalThing = theThing</span><br><span class="line">        var unused = function () &#123;</span><br><span class="line">            if (originalThing)</span><br><span class="line">                console.log(&quot;hi&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">            someMethod: function someMethod() &#123;</span><br><span class="line">                console.log(&#x27;someMessage&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    setInterval(replaceThing,100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearGrow3()&#123;</span><br><span class="line">解决: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们明确一下，unused是一个闭包，因为它引用了自由变量 originalThing，虽然它被没有使用，但v8引擎并不会把它优化掉，因为 JavaScript里存在eval函数，所以v8引擎并不会随便优化掉暂时没有使用的函数。</p>
<p>theThing 引用了someMethod，someMethod这个函数作用域隐式的和unused这个闭包共享一个闭包上下文。所以someMethod也引用了originalThing这个自由变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCHandler -&gt; replaceThing -&gt; theThing -&gt; someMethod -&gt; originalThing -&gt; someMethod(old) -&gt; originalThing(older)-&gt; someMethod(older)</span><br></pre></td></tr></table></figure>

<p>这里面的引用链是：</p>
<p>随着setInterval的不断执行，这条引用链是不会断的，所以内存会不断泄漏，直致程序崩溃。<br>因为是闭包作用域引起的内存泄漏，这时候最好的选择是使用 chrome的heap snapshot的container视图，我们通过container视图能清楚的看到这条不断泄漏内存的引用链</p>
<p><img src="/img/image-20220320221047255.png" alt="image-20220320221047255"></p>
<p>这是一段糟糕的代码,每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了theThing）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。</p>
<p><strong>解决</strong>: 去除unuserd函数或者在replaceThing函数最后一行加上 originlThing = null.</p>
<p><strong>4.内存泄漏排查手段</strong></p>
<blockquote>
<ul>
<li>打开ChromeDevTools-Performance</li>
<li>勾选 Screenshots 和 memory</li>
<li>左上角小圆点开始录制(record)</li>
<li>停止录制</li>
<li>查看heap对内存是否周期性变化</li>
</ul>
</blockquote>
<p>内存泄漏优化</p>
<blockquote>
<ul>
<li>数组优化，用完arr=[]</li>
<li>对象复用，t=null</li>
<li>在循环中的表达式，最好放在循环外面</li>
</ul>
</blockquote>
<p>(1)chrome devtools-memory工具</p>
<p>主要功能分为：Head snapshot堆快照，Allocaiton instrumentastion on timeline(js堆内存在时间线上的回收情况)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;botton @click=&quot;grow()&quot;&gt;&lt;/botton&gt;</span><br><span class="line">function largeObj()&#123;</span><br><span class="line">var largeArr= new Array(1000_10000);</span><br><span class="line">&#125;</span><br><span class="line">var x= [];</span><br><span class="line">fucntion grow()&#123;</span><br><span class="line">var o = new larfeObj();</span><br><span class="line">x.push(new Array(1000_10000));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1)Head snapshot堆快照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.核心参数</span><br><span class="line">Summary：摘要视图</span><br><span class="line">Comparison：对比视图，与其它快照对比，看增、删、Delta数量及内存大小</span><br><span class="line">Containment：俯瞰视图，自顶向下看堆的情况，根节点包括window对象，GC root，原生对象等等列头</span><br><span class="line">Shallow Size   ： 对象本身占用的内存</span><br><span class="line">Retained Size ： 对象本身及其引用总共占用的内存</span><br><span class="line">Distance ：当前对象到根的引用层级距离</span><br><span class="line">Alloc. Size : 新分配的内存</span><br><span class="line">Freed  Size ： 释放的内存</span><br><span class="line">2.其他参数</span><br><span class="line">Detached DOM tree：表示它已经不在DOM树上了，但Javascript仍旧对它有引用</span><br><span class="line">(compiled code) — 未知，估计是程序代码区</span><br><span class="line">(closure) — 闭包(array) — 未知</span><br><span class="line">Object — JS对象类型(system) — 未知</span><br><span class="line">(string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里</span><br><span class="line">Array — JS数组类型cls — 游戏大厅特有的继承类</span><br><span class="line">Window — JS的window对象</span><br><span class="line">Quark.DisplayObjectContainer — Quark引擎的显示容器类</span><br><span class="line">Quark.ImageContainer — Quark引擎的图片类</span><br><span class="line">Quark.Text — Quark引擎的文本类</span><br><span class="line">Quark.ToggleButton — Quark引擎的开关按钮类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>功能：查看两次快照之间的新建对象情况</p>
<p>录制两次可以操作之间的快照，使用object allocation between snashot1 and snapshot选项，比较两次快照间创建的对象，常用这个功能；</p>
<p>使用comparison，比较两次快照的内存增减情况</p>
<p><img src="/img/image-20211207073137249.png" alt="image-20211207073137249"></p>
<p>largeObj的第0个元素，被window全局变量x引用着。</p>
<p>2)Allocaiton instrumentastion on timeline分配栈时间轴</p>
<p>功能：查看内存分配在代码中的位置，查看内存回收的时机和频率，要勾选Record stack</p>
<p>蓝色竖条表示内存未被回收，灰色表示内存回收。</p>
<p><img src="/img/image-20211207073246002.png" alt="image-20211207073246002"></p>
<p>选中蓝色竖条，不仅可以查看Retainer表示的泄漏的对象，还可以通过Allocaiton stack分配栈，定位具体代码位置。</p>
<p><img src="/img/image-20211207235441427.png" alt="image-20211207235441427"></p>
<p>在class filter中输入detached,查看是否存在分离的dom节点，如果能搜索出结果，说明有分离的dom节点</p>
<p><img src="/img/image-20211208000338908.png" alt="image-20211208000338908"></p>
<p>查看Constructor构造器中出现system/Context,说明有函数导致闭包留存，下面的Retainer可以找到是inner函数引起的闭包内存泄漏。</p>
<p><img src="/img/image-20211208001049548.png" alt="image-20211208001049548"></p>
<p>(2)在控制台使用ctrl+shift+p打开command menu，输入performance monitor来监听</p>
<p><strong>内存溢出的几种场景</strong></p>
<p><strong>i.溢出原因</strong></p>
<p>由于过多的函数调用，导致调用堆栈无法容纳这些调用的返回地址，一般在递归中产生。堆栈溢出很可能由无限递归（Infinite recursion）产生，但也可能仅仅是过多的堆栈层级</p>
<p><strong>ii.如何解决堆栈溢出</strong></p>
<p>解决方案：1，引入闭包； 2，引入计时器； 3，尾调优化</p>
<p>(2.1)引入闭包</p>
<p>错误代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> function isEven(num)&#123;</span><br><span class="line">    if(num == 0)&#123;return true;&#125;</span><br><span class="line">    if(num == 1)&#123;return false;&#125;</span><br><span class="line">    return isEven(Math.abs(num)-2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(isEven(100000))//堆栈溢出</span><br></pre></td></tr></table></figure>

<p>引入闭包代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function isEven(num)&#123;</span><br><span class="line">    function isEvenInner(num)&#123;</span><br><span class="line">        if(num === 0)&#123;return true;&#125;</span><br><span class="line">        if(num === 1)&#123;return false;&#125;</span><br><span class="line">        return function()&#123;</span><br><span class="line">        return isEvenInner(Math.abs(num)-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function simplify(func,num)&#123;</span><br><span class="line">        var value=func(num);</span><br><span class="line">        while(typeof value == &#x27;function&#x27;)&#123;</span><br><span class="line">            value=value();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return simplify.bind(null,isEvenInner)(num)</span><br><span class="line">&#125;</span><br><span class="line">console.log(isEven(100000));//这种方法num太大也不可以</span><br></pre></td></tr></table></figure>

<p>(2.3)使用尾递归(尾调用)</p>
<p>错误代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(tailFactorial(5,1))</span><br></pre></td></tr></table></figure>

<p>尾调优化（新增简化函数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(tailFactorial(5,1))</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  return tailFactorial(n, 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(10000))</span><br></pre></td></tr></table></figure>

<p>尾调优化（柯里化）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn,n)&#123;//柯里化要绑定的参数</span><br><span class="line">    return function(m)&#123;//柯里化的函数，m对应输入的唯一一个参数</span><br><span class="line">        return fn.call(this,m,n)  </span><br><span class="line">&#125;//柯里化</span><br><span class="line">&#125;</span><br><span class="line">var factorial_1=currying(tailFactorial,1);</span><br><span class="line">console.log(factorial_1(5));</span><br></pre></td></tr></table></figure>

<p>尾调优化（ES6）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total = 1) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>

<h2 id="如何创建私有变量"><a href="#如何创建私有变量" class="headerlink" title="如何创建私有变量"></a>如何创建私有变量</h2><p><strong>1.使用闭包</strong></p>
<p>使用闭包可以使用私有属性或者方法的封装。利用闭包可以访问外部函数的变量特征</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyProfile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> myTitle = <span class="string">&quot;DevPoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getTitle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> myTitle;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myProfile = <span class="title class_">MyProfile</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myProfile.<span class="title function_">getTitle</span>()); <span class="comment">// DevPoint</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在constructor中用Symbol代替key</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的开发者， 调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">username,password</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">PASSWORD</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">username</span> = username</span><br><span class="line">        <span class="comment">// 使用Symbol 规避了公共访问</span></span><br><span class="line">        <span class="variable language_">this</span>[<span class="variable constant_">PASSWORD</span>] = password;</span><br><span class="line">        <span class="comment">// 1. &#123;&#125; key</span></span><br><span class="line">        <span class="comment">// 2. 怎么存进对象？ key不可访问呢？私有</span></span><br><span class="line">        <span class="comment">// 3. symbol</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">checkPassword</span>(<span class="params">pwd</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable constant_">PASSWORD</span>] == pwd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userA = <span class="keyword">new</span> <span class="title class_">Login</span>(<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="comment">// userA.password = &#x27;123456&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">username</span>)  <span class="comment">//aa</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userA.<span class="property">password</span>)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>3.用对象以Symbol定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const gender = Symbol(&#x27;gender&#x27;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">    name:&#x27;大胖猫&#x27;,</span><br><span class="line">    age:&#x27;3&#x27;,</span><br><span class="line">    [gender]:&#x27;公&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//obj.name  </span><br><span class="line">obj[gender]  //调用成功 </span><br><span class="line">// 不可枚举</span><br><span class="line">console.log(Object.keys(obj));</span><br><span class="line">console.log(JSON.stringify(obj));</span><br></pre></td></tr></table></figure>

<p><strong>4.使用Class优化面向对象的读写操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;   // 公有属性</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get name()&#123;</span><br><span class="line">        console.log(&#x27;get 方法&#x27;);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(str)&#123;</span><br><span class="line">        console.log(&#x27;设置了name 方法&#x27;);</span><br><span class="line">        this.name = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let coco = new Person(&#x27;coco&#x27;);</span><br><span class="line">console.log(coco.name);</span><br></pre></td></tr></table></figure>

<p><strong>5.使用 ES2020 提案</strong></p>
<p>还处于 ES2020 试验草案中，引入了私有方法或者属性的定义，语法比较奇怪，以 <code>#</code> 作为前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ButtonCreator &#123;</span><br><span class="line">    #width;</span><br><span class="line">    #height;</span><br><span class="line">    constructor(width, height) &#123;</span><br><span class="line">        this.#width = width;</span><br><span class="line">        this.#height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    // 私有方法</span><br><span class="line">    #calculateWidth() &#123;</span><br><span class="line">        return this.#width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWidth = () =&gt; this.#calculateWidth();</span><br><span class="line">    getHeight = () =&gt; this.#height;</span><br><span class="line">    setWidth = (width) =&gt; (this.#width = width);</span><br><span class="line">    setHeight = (height) =&gt; (this.#height = height);</span><br><span class="line">&#125;</span><br><span class="line">const button = new ButtonCreator(600, 360);</span><br><span class="line">console.log(button.width); // undefined</span><br><span class="line">console.log(button.getWidth()); // 600</span><br></pre></td></tr></table></figure>

<p><strong>6.使用 WeakMap</strong></p>
<p>这种方法建立在闭包方法之上，使用作用域变量方法创建一个私有 <code>WeakMap</code>，然后使用该 <code>WeakMap</code> 检索与此相关的私有数据。这比作用域变量方法更快，因为所有实例都可以共享一个 <code>WeakMap</code>，所以不需要每次创建实例时都重新创建方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const ButtonCreator = (function () &#123;</span><br><span class="line">    const privateProps = new WeakMap();</span><br><span class="line">    class ButtonCreator &#123;</span><br><span class="line">        constructor(width, height, name) &#123;</span><br><span class="line">            this.name = name; // 公共属性</span><br><span class="line">            privateProps.set(this, &#123;</span><br><span class="line">                width, // 私有属性</span><br><span class="line">                height, // 私有属性</span><br><span class="line">                calculateWidth: () =&gt; privateProps.get(this).width, // 私有方法</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getWidth = () =&gt; privateProps.get(this).calculateWidth();</span><br><span class="line">        getHeight = () =&gt; privateProps.get(this).height;</span><br><span class="line">    &#125;</span><br><span class="line">    return ButtonCreator;</span><br><span class="line">&#125;)();</span><br><span class="line">const button = new ButtonCreator(600, 360);</span><br><span class="line">console.log(button.width); // undefined</span><br><span class="line">console.log(button.getWidth()); // 600</span><br></pre></td></tr></table></figure>

<p><strong>7.使用 TypeScript</strong></p>
<p>可以将 <code>TypeScript</code> 用作 JavaScript 的一种风格，可以使用 <code>private</code> 关键字从面向对象的语言中真正重新创建功能。</p>
<h1 id="三大山-异步和单线程"><a href="#三大山-异步和单线程" class="headerlink" title="三大山-异步和单线程"></a>三大山-异步和单线程</h1><h2 id="JS异步编程六大方案"><a href="#JS异步编程六大方案" class="headerlink" title="JS异步编程六大方案"></a>JS异步编程六大方案</h2><p>参考：<a target="_blank" rel="noopener" href="https://github.com/ljianshu/Blog/issues/53">异步编程方案</a></p>
<ul>
<li>回调函数（Callback）</li>
<li>事件监听</li>
<li>发布订阅</li>
<li>Promise/A+</li>
<li>生成器Generators/ yield</li>
<li>async/await</li>
</ul>
<p><strong>回调函数</strong><br>致命的弱点，就是容易写出回调地狱（Callback hell）。</p>
<ul>
<li>优点：简单、容易理解和实现</li>
<li>缺点：不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>事件监听</strong></p>
<p>这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<ul>
<li>优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。</li>
<li>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</li>
</ul>
<p><strong>发布订阅</strong></p>
<p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p>
<ul>
<li>优点：与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</li>
</ul>
<p><strong>Promise/A+</strong></p>
<p>Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。</p>
<p><strong>生成器Generators/ yield</strong></p>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。</p>
<ul>
<li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</li>
<li>Generator 函数除了状态机，还是一个遍历器对象生成函数。</li>
<li>可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。</li>
<li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li>
</ul>
<p><strong>async/await</strong></p>
<p>它可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p>
<ul>
<li>async/await是基于Promise实现的，它不能用于普通的回调函数。</li>
<li>async/await与Promise一样，是非阻塞的。</li>
<li>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</li>
</ul>
<h2 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h2><p>js是单线程阻塞执行的，js 引擎执行异步代码和支持多线程，主要依靠消息队列和事件循环机制。</p>
<p>为什么js是一门单线程语言呢？最初设计JS是用来在浏览器验证表单以及操控DOM元素，为了避免同一时间对同一个DOM元素进行操作从而导致不可预知的问题，JavaScript从一诞生就是单线程。</p>
<p><strong>基本概念</strong></p>
<ul>
<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li>事件循环：事件循环是指主线程重复异步任务压入消息队列，从消息队列中取消息、执行回调函数的过程。</li>
</ul>
<p><strong>核心流程</strong></p>
<ul>
<li>主线程(调用栈)执行同步代码，异步任务就放入到消息队列中</li>
<li>消息队列按照先进先出原则，异步处理不阻塞主线程</li>
<li>当主线程的同步任务执行完后，开始执行回调函数，处理从消息队列的出来的返回值</li>
</ul>
<p><img src="/img/image-20220123200002149.png" alt="image-20220123200002149"></p>
<p>主线程执行的回调函数，一定是在下一轮事件循环中的开始，属于下一轮。</p>
<p><strong>消息队列</strong></p>
<p>按照异步任务优先级，分为微任务(microtask队列)和宏任务(macrotask队列)。</p>
<ul>
<li>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>MutationObserver</code>。</li>
<li>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>。</li>
</ul>
<p><strong>经典题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaozhumaopao/p/11066005.html">js异步任务</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaozhumaopao/p/11066005.html">js 异步执行顺序</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">加强版练习</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">async function async1() &#123;</span><br><span class="line">  await async2()</span><br><span class="line">  console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#x27;async2 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Promise&#x27;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function() &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">1. 定义函数`async1`、`async2`，**打印`script start`**；</span><br><span class="line">2. 执行`setTimeout`，回调交由`Web API`处理，`Web API`将其加入宏任务队列；</span><br><span class="line">3. 执行`async1`，**打印`async1 start`**；</span><br><span class="line">4. 执行`async2`，**打印`async2`**，由于左边有`await`，将`console.log(&#x27;async1 end&#x27;)`放入微任务队列；</span><br><span class="line">5. 执行`new Promise`，同步执行传入构造函数的函数，**打印`promise1`**；</span><br><span class="line">6. promise完成，将`console.log(&#x27;promise2&#x27;)`所在函数放入微任务队列；</span><br><span class="line">7. **打印`script end`**，当前任务执行完毕；</span><br><span class="line">8. 检查微任务队列并依次取出执行，**打印`async1 end`**、**打印`promise2`**；</span><br><span class="line">9. 微任务队列为空，执行栈为空，检查宏任务队列，取出任务执行，**打印`setTimeout`**；</span><br><span class="line">10. 执行完毕。</span><br></pre></td></tr></table></figure>

<p>async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">	console.log(&#x27;async1 start&#x27;);</span><br><span class="line">	await async2();</span><br><span class="line">	console.log(&#x27;async1 end&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line">async function async1() &#123;</span><br><span class="line">	console.log(&#x27;async1 start&#x27;);</span><br><span class="line">	Promise.resolve(async2()).then(() =&gt; &#123;</span><br><span class="line">                console.log(&#x27;async1 end&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p><strong>小结</strong></p>
<ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但原理不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>debounce防抖<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle节流<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<p><strong>本质上是优化高频率执行代码的一种手段</strong></p>
<ul>
<li><p>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p>
</li>
<li><p>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p>
<p>一个经典的比喻:</p>
<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>
<p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p>
<p>电梯第一个人进来后，15秒后准时运送一次，这是<strong>节流</strong></p>
<p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是<strong>防抖</strong></p>
<p><strong>节流</strong></p>
<p>完成节流可以使用<strong>时间戳与定时器</strong>的写法</p>
<p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> remaining = delay - (curTime - starttime)  <span class="comment">// 从上一次到现在，还剩下多少多余时间</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(fn, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>防抖</strong></p>
<p>  简单版本</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">  timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">  &#125;, wait);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// timeout 不为null</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">          <span class="keyword">let</span> callNow = !timeout; <span class="comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span></span><br><span class="line">          timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              timeout = <span class="literal">null</span>;</span><br><span class="line">          &#125;, wait)</span><br><span class="line">          <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">              func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><p>querySelector() 方法选择指定 CSS 选择器的第一个元素；</p>
<p>querySelectorAll() 方法选择指定的所有元素</p>
<p>比较：</p>
<ul>
<li>query 选择符选出来的元素是静态的，而 getElement 这种方法选出的元素的动态的</li>
<li>Chrome 浏览器下 getElementBy 方法的执行速度基本都高于 querySelector</li>
</ul>
<p><strong>querySelector和getElementById的api相同</strong></p>
<ul>
<li><p>添加class:el.classList.add(“mystyle”, “anotherClass”)</p>
</li>
<li><p>移除class:el.classList.remove(“mystyle”, “anotherClass”)</p>
</li>
<li><p>设置style:el.setAttribute(“class”,classVal )</p>
</li>
<li><p>设置style:el.style.top=’100px’ </p>
</li>
<li><p>el.style[“border-width”]=”10px”</p>
</li>
</ul>
<h2 id="创建节点添加节点"><a href="#创建节点添加节点" class="headerlink" title="创建节点添加节点"></a><strong>创建节点添加节点</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    childNode.<span class="property">innerHTML</span> = <span class="string">&#x27;这里是提示信息〜〜&#x27;</span>;</span><br><span class="line">    <span class="comment">//childNode.setAttribute(&#x27;class&#x27;, &#x27;alerts&#x27;);</span></span><br><span class="line">    <span class="comment">//childNode.setAttribute(&#x27;onclick&#x27;, &#x27;this.style.display = &quot;none&quot;&#x27;);</span></span><br><span class="line">    childNode.<span class="property">className</span> = <span class="string">&#x27;alerts&#x27;</span>;</span><br><span class="line">    childNode.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(childNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取屏幕或容器的宽高"><a href="#获取屏幕或容器的宽高" class="headerlink" title="获取屏幕或容器的宽高"></a>获取屏幕或容器的宽高</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取宽高</span><br><span class="line">元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight</span><br><span class="line">元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth</span><br><span class="line">元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft</span><br><span class="line">元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop</span><br><span class="line"></span><br><span class="line">设置宽高</span><br><span class="line">document.getElementById(&quot;div&quot;).style.width = &quot;120px&quot;;//可行</span><br><span class="line">document.getElementById(&quot;div&quot;).style.offsetWidth = &quot;120px&quot;;//不可行</span><br></pre></td></tr></table></figure>

<h2 id="JS绑定解除事件"><a href="#JS绑定解除事件" class="headerlink" title="JS绑定解除事件"></a>JS绑定解除事件</h2><p>事件有三要素 : <code>事件源</code>、<code>事件</code>、<code>监听器</code> 。</p>
<ul>
<li>第一种<ul>
<li>缺点：HTML与js代码紧密耦合。如果要更换 事件，就要改动两个地方:HTML代码和JS代码，这就不利于后期代码的维护。</li>
</ul>
</li>
<li>第二种<ul>
<li>优点：它最大的优点是就是兼容性很好，所有浏览器都支持</li>
<li>缺点：同一个 dom 元素上，on 只能绑定一个同类型事件，后者会覆盖前者，不同类型的事件可以绑定多个。有一个问题，无法允许团队不同人员对同一元素监听同一事件但做出不用的响应</li>
</ul>
</li>
<li>第三种<ul>
<li>优点：它们可以支持绑定多个同类型事件</li>
<li>缺点：兼容性并不好,它们只兼容相对应的浏览器才有用。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种 直接在标签里绑定 --&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot; onclick=&quot;handleClick()&quot;&gt;</span><br><span class="line">  自定义函数</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> // 利用 DOM0 进行绑定</span><br><span class="line">  var btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">  btn.onclick = handleClick()</span><br><span class="line">  </span><br><span class="line">  // 利用 DOM3 进行绑定</span><br><span class="line">  btn.addEventListener(&#x27;click&#x27;, handleClick)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JS事件冒泡和事件捕获"><a href="#JS事件冒泡和事件捕获" class="headerlink" title="JS事件冒泡和事件捕获"></a>JS事件冒泡和事件捕获</h2><p>DOM事件流（event flow ）存在三个阶段：<strong>事件捕获阶段、处于目标阶段、事件冒泡阶段。</strong></p>
<p><strong>事件捕获：</strong>通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播。</p>
<p><strong>事件冒泡</strong>：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。</p>
<img src="/img/image-20230614063620124.png" alt="image-20230614063620124" style="zoom:80%;" />

<p>1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">userCapture 为false</span><br><span class="line">事件冒泡执行顺序：从内部到外部Document。</span><br><span class="line"></span><br><span class="line">userCapture 为true</span><br><span class="line">事件捕获执行顺序：从Document向内部执行</span><br><span class="line"></span><br><span class="line">Dom事件流：包含userCapture ture 和 false</span><br><span class="line">捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。</span><br><span class="line">目标阶段的处理函数，先注册的先执行，后注册的后执行。</span><br></pre></td></tr></table></figure>

<h2 id="监听串口变化"><a href="#监听串口变化" class="headerlink" title="监听串口变化"></a>监听串口变化</h2><p><strong>Resize事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123;</span><br><span class="line">       this.helpHeight = window.innerHeight - 90</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>ResizeObserverAPI监听元素容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const resizeObserver = new ResizeObserver(entries =&gt; &#123;</span><br><span class="line">  //回调</span><br><span class="line">  this.$chart.resize();</span><br><span class="line">&#125;);</span><br><span class="line">resizeObserver.observe(this.$refs.chart);</span><br><span class="line">// 取消某个元素监听</span><br><span class="line">//resizeObserver.unobserve(this.$refs.chart)</span><br><span class="line">// 取消全部元素监听</span><br><span class="line">//resizeObserver.disconnect()</span><br><span class="line">缺点：但是坏处是，兼容性不高</span><br><span class="line">解决：</span><br><span class="line">github上，已经提供了能够兼容至IE9的 resizeObserver polyfill</span><br><span class="line">yarn add @juggle/resize-observer</span><br><span class="line">import ResizeObserver from &#x27;@juggle/resize-observer&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h1><p><code>AJAX</code>全称(Async Javascript and XML)即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(1)创建对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">(2)打开请求</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;example.txt&#x27;, true);</span><br><span class="line"></span><br><span class="line">(3)发送请求</span><br><span class="line">xhr.send(); 发送请求到服务器</span><br><span class="line"></span><br><span class="line">(4)接收响应</span><br><span class="line">xhr.onreadystatechange =function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">(1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。</span><br><span class="line">(2)当readystate==4时，表示已经接收到全部响应数据。</span><br><span class="line">(3)当status ==200时，表示服务器成功返回页面和数据。</span><br><span class="line">(4)如果(2)和(3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。</span><br></pre></td></tr></table></figure>

<p><strong>服务器响应处理</strong></p>
<p>同步处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  </span><br><span class="line">2. xhr.send();  </span><br><span class="line">3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</span><br></pre></td></tr></table></figure>

<p>异步处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. xhr.onreadystatechange=function()  &#123; </span><br><span class="line">2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; </span><br><span class="line">3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  </span><br><span class="line">4.      &#125;</span><br><span class="line">5.    &#125; </span><br></pre></td></tr></table></figure>

<p>什么是<strong>readyState</strong>？</p>
<p>readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。 readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义。</p>
<p>0：未初始化 – 尚未调用.open()方法；</p>
<p>1：启动 – 已经调用.open()方法，但尚未调用.send()方法；</p>
<p>2：发送 – 已经调用.send()方法，但尚未接收到响应；</p>
<p>3：接收 – 已经接收到部分响应数据；</p>
<p>4：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了；</p>
<p><strong>什么是status？</strong></p>
<p>1：服务器收到请求</p>
<p>2：成功</p>
<p>3：重定向</p>
<p>4：客户端错误</p>
<p>5：服务端错误</p>
<h1 id="手写setTimeout实现setInterval"><a href="#手写setTimeout实现setInterval" class="headerlink" title="手写setTimeout实现setInterval"></a>手写setTimeout实现setInterval</h1><p><strong>为什么要用setTimeout来模拟setInterval的行为？</strong></p>
<p>这里用setInerval不是更方便吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;··· &#125;, n); // n毫秒后执行function</span><br><span class="line">setInterval(function()&#123;··· &#125;, n); // 每隔n毫秒执行一次function</span><br></pre></td></tr></table></figure>

<p>可以看看setInterval有什么缺点：</p>
<blockquote>
<p>再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function, N)  </span><br><span class="line">//即：每隔N秒把function事件推到消息队列中</span><br></pre></td></tr></table></figure>

<img src="/img/image-20230614063755823.png" alt="image-20230614063755823" style="zoom:80%;" />

<p>上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果。</p>
<p>综上所述，setInterval有两个缺点：</p>
<ol>
<li>使用setInterval时，某些间隔会被跳过；</li>
<li>可能多个定时器会连续执行；</li>
</ol>
<blockquote>
<p>可以这么理解：**每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)**。因而我们一般用setTimeout模拟setInterval，来规避掉上面的缺点。</p>
</blockquote>
<p><strong>使用setTimeout实现setInterval</strong></p>
<blockquote>
<p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
</blockquote>
<p> 针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p> 实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 可避免setInterval因执行时间导致的间隔执行时间不一致</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInterval</span>(<span class="params">fn,time</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">interval</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval,time)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(interval,time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval2</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">        <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">        <span class="keyword">let</span> timer = &#123; <span class="attr">flag</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="comment">// 设置递归函数，模拟定时器执行</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (timer.<span class="property">flag</span>) &#123;</span><br><span class="line">            <span class="title function_">fn</span>();</span><br><span class="line">            <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动定时器</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">        <span class="comment">// 返回控制器</span></span><br><span class="line">        <span class="keyword">return</span> timer;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用setInterval实现setTimeout</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">        <span class="comment">//timer用来接收setInterval返回的编号，用于后面清除setInterval</span></span><br><span class="line">        <span class="comment">//setInterval会一直执行，但是在setInterval里面执行clearInterval()将会被清除</span></span><br><span class="line">        <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//执行传入函数</span></span><br><span class="line">          <span class="title function_">fn</span>();</span><br><span class="line">          <span class="comment">//清除该次setInterval</span></span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        &#125;, timeout);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h1 id="手写-EventBus"><a href="#手写-EventBus" class="headerlink" title="手写-EventBus"></a>手写-EventBus</h1><p>通俗理解：</p>
<blockquote>
<p>小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼 MM 告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。</p>
<p>小明离开之前，把电话号留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记载售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。</p>
</blockquote>
<p>有三个要点：</p>
<ul>
<li><code>发布者</code>：dep 对象</li>
<li><code>缓存列表</code>：dep.subscribers</li>
<li><code>发布消息</code>：dep.notify()</li>
</ul>
<ol>
<li>首先要指定好谁充当发布者（比如售楼处）</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）</li>
</ol>
<p>极简版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SyncHook &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.taps = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //注册监听函数，这里的name其实没啥用</span><br><span class="line">  tap(name, fn) &#123;</span><br><span class="line">    this.taps.push(&#123; name, fn &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //执行函数</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    this.taps.forEach((tap) =&gt; tap.fn(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件通信，一个触发与监听的过程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 存储事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="variable language_">this</span>.<span class="property">events</span> || <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听事件</span></span><br><span class="line">  addListener (type, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emit (type) &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type)</span><br><span class="line">    handle.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>()</span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">emitter.<span class="title function_">addListener</span>(<span class="string">&#x27;ages&#x27;</span>, <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;ages&#x27;</span>, <span class="number">18</span>)  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h1 id="手写-JSON-stringfy-和JSON-parse"><a href="#手写-JSON-stringfy-和JSON-parse" class="headerlink" title="手写-JSON.stringfy()和JSON.parse()"></a>手写-JSON.stringfy()和JSON.parse()</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">if (!window.JSON) &#123;</span><br><span class="line">    window.JSON = &#123;</span><br><span class="line">        parse: function(jsonStr) &#123;</span><br><span class="line">            return eval(&#x27;(&#x27; + jsonStr + &#x27;)&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        stringify: function(jsonObj) &#123;</span><br><span class="line">            var result = &#x27;&#x27;,</span><br><span class="line">                curVal;</span><br><span class="line">            if (jsonObj === null) &#123;</span><br><span class="line">                return String(jsonObj);</span><br><span class="line">            &#125;</span><br><span class="line">            switch (typeof jsonObj) &#123;</span><br><span class="line">                case &#x27;number&#x27;:</span><br><span class="line">                case &#x27;boolean&#x27;:</span><br><span class="line">                    return String(jsonObj);</span><br><span class="line">                case &#x27;string&#x27;:</span><br><span class="line">                    return &#x27;&quot;&#x27; + jsonObj + &#x27;&quot;&#x27;;</span><br><span class="line">                case &#x27;undefined&#x27;:</span><br><span class="line">                case &#x27;function&#x27;:</span><br><span class="line">                    return undefined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (Object.prototype.toString.call(jsonObj)) &#123;</span><br><span class="line">                case &#x27;[object Array]&#x27;:</span><br><span class="line">                    result += &#x27;[&#x27;;</span><br><span class="line">                    for (var i = 0, len = jsonObj.length; i &lt; len; i++) &#123;</span><br><span class="line">                        curVal = JSON.stringify(jsonObj[i]);</span><br><span class="line">                        result += (curVal === undefined ? null : curVal) + &quot;,&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (result !== &#x27;[&#x27;) &#123;</span><br><span class="line">                        result = result.slice(0, -1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += &#x27;]&#x27;;</span><br><span class="line">                    return result;</span><br><span class="line">                case &#x27;[object Date]&#x27;:</span><br><span class="line">                    return &#x27;&quot;&#x27; + (jsonObj.toJSON ? jsonObj.toJSON() : jsonObj.toString()) + &#x27;&quot;&#x27;;</span><br><span class="line">                case &#x27;[object RegExp]&#x27;:</span><br><span class="line">                    return &quot;&#123;&#125;&quot;;</span><br><span class="line">                case &#x27;[object Object]&#x27;:</span><br><span class="line">                    result += &#x27;&#123;&#x27;;</span><br><span class="line">                    for (i in jsonObj) &#123;</span><br><span class="line">                        if (jsonObj.hasOwnProperty(i)) &#123;</span><br><span class="line">                            curVal = JSON.stringify(jsonObj[i]);</span><br><span class="line">                            if (curVal !== undefined) &#123;</span><br><span class="line">                                result += &#x27;&quot;&#x27; + i + &#x27;&quot;:&#x27; + curVal + &#x27;,&#x27;;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (result !== &#x27;&#123;&#x27;) &#123;</span><br><span class="line">                        result = result.slice(0, -1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += &#x27;&#125;&#x27;;</span><br><span class="line">                    return result;</span><br><span class="line"></span><br><span class="line">                case &#x27;[object String]&#x27;:</span><br><span class="line">                    return &#x27;&quot;&#x27; + jsonObj.toString() + &#x27;&quot;&#x27;;</span><br><span class="line">                case &#x27;[object Number]&#x27;:</span><br><span class="line">                case &#x27;[object Boolean]&#x27;:</span><br><span class="line">                    return jsonObj.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写-简单路由"><a href="#手写-简单路由" class="headerlink" title="手写-简单路由"></a>手写-简单路由</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hash路由</span><br><span class="line">class Route&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 路由存储对象</span><br><span class="line">    this.routes = &#123;&#125;</span><br><span class="line">    // 当前hash</span><br><span class="line">    this.currentHash = &#x27;&#x27;</span><br><span class="line">    // 绑定this，避免监听时this指向改变</span><br><span class="line">    this.freshRoute = this.freshRoute.bind(this)</span><br><span class="line">    // 监听</span><br><span class="line">    window.addEventListener(&#x27;load&#x27;, this.freshRoute, false)</span><br><span class="line">    window.addEventListener(&#x27;hashchange&#x27;, this.freshRoute, false)</span><br><span class="line">  &#125;</span><br><span class="line">  // 存储</span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    this.routes[path] = cb || function () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    this.currentHash = location.hash.slice(1) || &#x27;/&#x27;</span><br><span class="line">    this.routes[this.currentHash]()</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写-JS实现图片懒加载"><a href="#手写-JS实现图片懒加载" class="headerlink" title="手写-JS实现图片懒加载"></a>手写-JS实现图片懒加载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let imgs =  document.querySelectorAll(&#x27;img&#x27;)</span><br><span class="line">// 可视区高度</span><br><span class="line">let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight</span><br><span class="line">function lazyLoad () &#123;</span><br><span class="line">  // 滚动卷去的高度</span><br><span class="line">  let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">  for (let i = 0; i &lt; imgs.length; i ++) &#123;</span><br><span class="line">    // 图片在可视区冒出的高度</span><br><span class="line">    let x = clientHeight + scrollTop - imgs[i].offsetTop</span><br><span class="line">    // 图片在可视区内</span><br><span class="line">    if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(&#x27;data&#x27;)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line">// addEventListener(&#x27;scroll&#x27;, lazyLoad) or setInterval(lazyLoad, 1000)</span><br></pre></td></tr></table></figure>

<h1 id="手写-rem实现原理"><a href="#手写-rem实现原理" class="headerlink" title="手写-rem实现原理"></a>手写-rem实现原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 原始配置</span><br><span class="line">function setRem () &#123;</span><br><span class="line">  let doc = document.documentElement</span><br><span class="line">  let width = doc.getBoundingClientRect().width</span><br><span class="line">  let rem = width / 75</span><br><span class="line">  doc.style.fontSize = rem + &#x27;px&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 监听窗口变化</span><br><span class="line">addEventListener(&quot;resize&quot;, setRem)</span><br></pre></td></tr></table></figure>

<h1 id="手写-AJAX"><a href="#手写-AJAX" class="headerlink" title="手写-AJAX"></a>手写-AJAX</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 1. 简单流程</span><br><span class="line">// 实例化</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">// 初始化</span><br><span class="line">xhr.open(method, url, async)</span><br><span class="line">// 发送请求</span><br><span class="line">xhr.send(data)</span><br><span class="line">// 设置状态变化回调处理请求结果</span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">    console.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 基于promise实现 </span><br><span class="line">function ajax (options) &#123;</span><br><span class="line">  // 请求地址</span><br><span class="line">  const url = options.url</span><br><span class="line">  // 请求方法</span><br><span class="line">  const method = options.method.toLocaleLowerCase() || &#x27;get&#x27;</span><br><span class="line">  // 默认为异步true</span><br><span class="line">  const async = options.async</span><br><span class="line">  // 请求参数</span><br><span class="line">  const data = options.data</span><br><span class="line">  // 实例化</span><br><span class="line">  const xhr = new XMLHttpRequest()</span><br><span class="line">  // 请求超时</span><br><span class="line">  if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123;</span><br><span class="line">    xhr.timeout = options.timeout</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回一个Promise实例</span><br><span class="line">  return new Promise ((resolve, reject) =&gt; &#123;</span><br><span class="line">    xhr.ontimeout = () =&gt; reject &amp;&amp; reject(&#x27;请求超时&#x27;)</span><br><span class="line">    // 监听状态变化回调</span><br><span class="line">    xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">      if (xhr.readyState == 4) &#123;</span><br><span class="line">        // 200-300 之间表示请求成功，304资源未变，取缓存</span><br><span class="line">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123;</span><br><span class="line">          resolve &amp;&amp; resolve(xhr.responseText)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject &amp;&amp; reject()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 错误回调</span><br><span class="line">    xhr.onerror = err =&gt; reject &amp;&amp; reject(err)</span><br><span class="line">    let paramArr = []</span><br><span class="line">    let encodeData</span><br><span class="line">    // 处理请求参数</span><br><span class="line">    if (data instanceof Object) &#123;</span><br><span class="line">      for (let key in data) &#123;</span><br><span class="line">        // 参数拼接需要通过 encodeURIComponent 进行编码</span><br><span class="line">        paramArr.push(encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(data[key]))</span><br><span class="line">      &#125;</span><br><span class="line">      encodeData = paramArr.join(&#x27;&amp;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // get请求拼接参数</span><br><span class="line">    if (method === &#x27;get&#x27;) &#123;</span><br><span class="line">      // 检测url中是否已存在 ? 及其位置</span><br><span class="line">      const index = url.indexOf(&#x27;?&#x27;)</span><br><span class="line">      if (index === -1) url += &#x27;?&#x27;</span><br><span class="line">      else if (index !== url.length -1) url += &#x27;&amp;&#x27;</span><br><span class="line">      // 拼接url</span><br><span class="line">      url += encodeData</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化</span><br><span class="line">    xhr.open(method, url, async)</span><br><span class="line">    // 发送请求</span><br><span class="line">    if (method === &#x27;get&#x27;) xhr.send(null)</span><br><span class="line">    else &#123;</span><br><span class="line">      // post 方式需要设置请求头</span><br><span class="line">      xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;)</span><br><span class="line">      xhr.send(encodeData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写-实现拖拽"><a href="#手写-实现拖拽" class="headerlink" title="手写-实现拖拽"></a>手写-实现拖拽</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">  // drag处于绝对定位状态</span><br><span class="line">  let drag = document.getElementById(&#x27;box&#x27;)</span><br><span class="line">  drag.onmousedown = function(e) &#123;</span><br><span class="line">    var e = e || window.event</span><br><span class="line">    // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离</span><br><span class="line">    let diffX = e.clientX - drag.offsetLeft</span><br><span class="line">    let diffY = e.clientY - drag.offsetTop</span><br><span class="line">    drag.onmousemove = function (e) &#123;</span><br><span class="line">      // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离</span><br><span class="line">      let left = e.clientX - diffX</span><br><span class="line">      let top = e.clientY - diffY</span><br><span class="line">      // 避免拖拽出可视区</span><br><span class="line">      if (left &lt; 0) &#123;</span><br><span class="line">        left = 0</span><br><span class="line">      &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123;</span><br><span class="line">        left = window.innerWidth - drag.offsetWidth</span><br><span class="line">      &#125;</span><br><span class="line">      if (top &lt; 0) &#123;</span><br><span class="line">        top = 0</span><br><span class="line">      &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123;</span><br><span class="line">        top = window.innerHeight - drag.offsetHeight</span><br><span class="line">      &#125;</span><br><span class="line">      drag.style.left = left + &#x27;px&#x27;</span><br><span class="line">      drag.style.top = top + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    drag.onmouseup = function (e) &#123;</span><br><span class="line">      this.onmousemove = null</span><br><span class="line">      this.onmouseup = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写-其他"><a href="#手写-其他" class="headerlink" title="手写-其他"></a>手写-其他</h1><h2 id="手写forEach"><a href="#手写forEach" class="headerlink" title="手写forEach"></a>手写forEach</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(!Array.prototype.forEach) &#123;</span><br><span class="line">    Array.prototype.forEach = function(fn, context) &#123;</span><br><span class="line">        var context = arguments[1];</span><br><span class="line">        if(typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">            throw new TypeError(fn + &quot;is not a function&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">            fn.call(context, this[i], i, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="手写map"><a href="#手写map" class="headerlink" title="手写map"></a>手写map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map = function (fn) &#123;</span><br><span class="line">    let arr = []</span><br><span class="line">    for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        arr.push(fn(this[i], i, this))</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce = function (fn, initVal) &#123;</span><br><span class="line">    let res = initVal ? initVal : 0</span><br><span class="line">    for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        res = fn(res, this[i], i, this)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写filter"><a href="#手写filter" class="headerlink" title="手写filter"></a>手写filter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myFilter = function (fn) &#123;</span><br><span class="line">    let arr = []</span><br><span class="line">    for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (fn(this[i], i, this)) &#123;</span><br><span class="line">            arr.push(this[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写push"><a href="#手写push" class="headerlink" title="手写push"></a><strong>手写push</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myPush = function () &#123;</span><br><span class="line">    let args = arguments</span><br><span class="line">    for (let i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        this[this.length] = args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return this.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建函数的几种方式"><a href="#创建函数的几种方式" class="headerlink" title="创建函数的几种方式"></a>创建函数的几种方式</h1><p>说完函数的类型，还需要了解JS中创建函数都有几种创建方法。</p>
<p> <strong>1、声明函数</strong> 最普通最标准的声明函数方法，包括函数名及函数体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>2、创建匿名函数表达式</strong> 创建一个变量，这个变量的内容为一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function ()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意采用这种方法创建的函数为<strong>匿名函数</strong>，即没有函数name</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function ()&#123;&#125;;</span><br><span class="line">getFunctionName(fn1).length;//0</span><br></pre></td></tr></table></figure>

<p> <strong>3、创建具名函数表达式</strong> 创建一个变量，内容为一个带有名称的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function xxcanghai()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：具名函数表达式的函数名只能在创建函数内部使用</p>
</blockquote>
<p>即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用 测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn1=function xxcanghai()&#123;</span><br><span class="line">    console.log(&quot;in:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(&quot;out:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">fn1();</span><br><span class="line">//out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt;</span><br><span class="line">//in:fn1&lt; function &gt;xxcanghai:&lt; function &gt;</span><br></pre></td></tr></table></figure>

<p>可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。</p>
<blockquote>
<p>注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
</blockquote>
<p> <strong>4、Function构造函数</strong> 可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是<strong>匿名函数</strong>。 </p>
<p> <strong>5、自执行函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;alert(1);&#125;)();</span><br><span class="line">(function fn1()&#123;alert(1);&#125;)();</span><br></pre></td></tr></table></figure>

<p>自执行函数属于上述的“函数表达式”，规则相同  </p>
<p><strong>6、其他创建函数的方法</strong> 当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 eval ， setTimeout ， setInterval 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开  </p>
<p><strong>三个fun函数的关系是什么？</strong></p>
<p>说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。 这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 先看第一个fun函数，属于标准具名函数声明，是<strong>新创建</strong>的函数，他的返回值是一个对象字面量表达式，属于一个新的object。 这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个<strong>新创建</strong>匿名函数表达式。</p>
<blockquote>
<p>注意：所有<strong>声明的匿名函数都是一个新函数。</strong></p>
</blockquote>
<p>所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。  </p>
<h1 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h1><p>总原则：顺序执行(如遇异常或throw,则进入catch),最后进入finally，最后再执行return语句(如果有return语句的话)。</p>
<p><strong>catch</strong></p>
<p>一旦出现异常或throw抛出异常，就进入catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    console.log(&#x27;begin throw error&#x27;)</span><br><span class="line">    throw new Error(&#x27;this is a error&#x27;)</span><br><span class="line">    console.log(&#x27;Will it work here ? &#x27;)</span><br><span class="line">&#125; catch(e)&#123;</span><br><span class="line">    console.log(&#x27;e:&#x27;,e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印结果</span><br><span class="line">begin throw error</span><br><span class="line">e: this is a error</span><br></pre></td></tr></table></figure>

<p><strong>finally</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          console.log(1);</span><br><span class="line">          throw new Error(&quot;throw&quot;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          console.log(e.message);</span><br><span class="line">          return &quot;from_catch&quot;;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          console.log(2);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(test());</span><br><span class="line">      /*打印</span><br><span class="line">        1</span><br><span class="line">        throw</span><br><span class="line">        2</span><br><span class="line">        from_catch</span><br><span class="line">      */</span><br></pre></td></tr></table></figure>

<h1 id="九种跨域方式原理"><a href="#九种跨域方式原理" class="headerlink" title="九种跨域方式原理"></a>九种跨域方式原理</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></p>
<h1 id="JS-识别不同浏览器信息"><a href="#JS-识别不同浏览器信息" class="headerlink" title="JS 识别不同浏览器信息"></a><strong>JS 识别不同浏览器信息</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function myBrowser() &#123;</span><br><span class="line">  var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串  </span><br><span class="line">  var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1;</span><br><span class="line">  if (isOpera) &#123;</span><br><span class="line">    return &quot;Opera&quot;</span><br><span class="line">  &#125;; //判断是否Opera浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Firefox&quot;;</span><br><span class="line">  &#125;  //判断是否Firefox浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Chrome&quot;;</span><br><span class="line">  &#125;   //判断是否Google浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) &#123;</span><br><span class="line">    return &quot;Safari&quot;;</span><br><span class="line">  &#125; //判断是否Safari浏览器  </span><br><span class="line">  if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) &#123;</span><br><span class="line">    return &quot;IE&quot;;</span><br><span class="line">  &#125;; //判断是否IE浏览器  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>概述</strong></p>
<ul>
<li>函数式编程：一个函数的返回值，仅仅依赖于参数的值，而不会因为其他外部的状态而不同。</li>
<li>命令式编程：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。</li>
<li>声明式编程：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 函数式</span><br><span class="line">function test(a) &#123;</span><br><span class="line">  return a + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//命令式</span><br><span class="line">var CEOs = [];</span><br><span class="line">for(var i = 0; i &lt; companies.length; i++)&#123;</span><br><span class="line">    CEOs.push(companies[i].CEO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明式</span><br><span class="line">var CEOs = companies.map(c =&gt; c.CEO);</span><br></pre></td></tr></table></figure>

<p>函数式编程有两个基本特点：</p>
<ul>
<li>通过函数来对数据进行转换</li>
<li>通过串联多个函数来求结果</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>无状态(引用透明)</li>
<li>数据不可变(没有副作用)</li>
<li>纯函数</li>
<li>惰性执行</li>
</ul>
<p>1.无状态(引用透明)</p>
<blockquote>
<p>主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</p>
</blockquote>
<p>2.数据不可变(没有副作用)</p>
<blockquote>
<p>它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</p>
</blockquote>
<p>3.纯函数</p>
<p>具有2个特点</p>
<ul>
<li>无状态： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。</li>
<li>数据不可变： 不修改全局变量，不修改入参。</li>
</ul>
<p>4.惰性执行</p>
<p>所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 <code>convertName</code> 产生实际的结果。</p>
<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><p><strong>一、函数的声明与执行</strong></p>
<p>函数申明方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明函数fun0</span><br><span class="line">function fun0()&#123;</span><br><span class="line">    console.log(&quot;fun0&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行函数fun0</span><br><span class="line">fun0(); // fun0</span><br></pre></td></tr></table></figure>

<p>变量赋值方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明函数fun1 - 变量方式</span><br><span class="line">var fun1 = function()&#123;</span><br><span class="line">    console.log(&quot;fun1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行函数fun1</span><br><span class="line">fun1(); // fun1</span><br></pre></td></tr></table></figure>

<p><strong>二、 函数的一点猜想</strong></p>
<p>既然函数名加上括号<code>fun1()</code>就是执行函数。 <strong>思考：</strong>直接取赋值符号右侧的内容直接加个括号，是否也能执行？ 试验如下，直接加上小括弧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>以上会报错 line1：<code>Uncaught SyntaxError: Unexpected token (</code>。 <strong>分析：</strong> <code>function</code> 是声明函数关键字，若非变量赋值方式声明函数，默认其后面需要跟上函数名的。</p>
<p>加上函数名看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun2&quot;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>以上会报错 line3：<code>Uncaught SyntaxError: Unexpected token )</code>。 <strong>分析：</strong> 声明函数的结构花括弧后面不能有其他符号（比如此处的小括弧）。</p>
<p>不死心的再胡乱试一下，给它加个实参（表达式）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>不会报错，但不会输出结果<code>fun3</code>。 <strong>分析：</strong> 以上代码相当于在声明函数后，又声明了一个毫无关系的表达式。相当于如下代码形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若此处执行fun3函数，可以输出结果</span></span><br><span class="line"><span class="title function_">fun3</span>(); <span class="comment">//&quot;fun3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>三、自执行函数表达式</strong></p>
<p><strong>1. 正儿八经的自执行函数</strong></p>
<p>想要解决上面问题，可以采用小括弧将要执行的代码包含住（方式一），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">fun4</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun4&quot;</span>);</span><br><span class="line">    &#125;()); <span class="comment">// &quot;fun4&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>因为在JavaScript语言中，<code>()</code>里面不能包含语句（只能是表达式），所以解析器在解析到<code>function</code>关键字的时候，会把它们当作function表达式，而不是正常的函数声明。 </p>
<p>除了上面直接整个包含住，也可以只包含住函数体（方式二），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">fun5</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun5&quot;</span>);</span><br><span class="line">    &#125;)();<span class="comment">// &quot;fun4&quot;</span></span><br></pre></td></tr></table></figure>

<p>写法上建议采用方式一（这是参考文的建议。但实际上，我个人觉得方式二比较常见）。</p>
<p><strong>2. “歪瓜裂枣”的自执行函数</strong></p>
<p>除了上面<code>()</code>小括弧可以把<code>function</code>关键字作为函数声明的含义转换成函数表达式外，JavaScript的<code>&amp;&amp;</code> 与操作、<code>||</code>或操作、<code>,</code>逗号等操作符也有这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="literal">true</span> &amp;&amp; <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;true &amp;&amp;&quot;</span>) &#125; (); <span class="comment">// &quot;true &amp;&amp;&quot;</span></span><br><span class="line">    <span class="literal">false</span> || <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;true ||&quot;</span>) &#125; (); <span class="comment">// &quot;true ||&quot;</span></span><br><span class="line">    <span class="number">0</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0,&quot;</span>) &#125; (); <span class="comment">// &quot;0,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处要注意： &amp;&amp;, || 的短路效应。即： false &amp;&amp; (表达式1)  是不会触发表达式1；</span></span><br><span class="line"><span class="comment">// 同理，true || (表达式2) 不会触发表达式2</span></span><br></pre></td></tr></table></figure>

<p>如果不在意返回值，也不在意代码的可读性，我们甚至还可以使用一元操作符（<code>!</code> <code>~</code> <code>-</code> <code>+</code> ），函数同样也会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!&quot;</span>); &#125; (); <span class="comment">//&quot;!&quot;</span></span><br><span class="line">~<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;~&quot;</span>); &#125; (); <span class="comment">//&quot;~&quot;</span></span><br><span class="line">-<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-&quot;</span>); &#125; (); <span class="comment">//&quot;-&quot;</span></span><br><span class="line">+<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;+&quot;</span>); &#125; (); <span class="comment">//&quot;+&quot;</span></span><br></pre></td></tr></table></figure>

<p>甚至还可以使用<code>new</code>关键字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：采用new方式，可以不要再解释花括弧 `&#125;` 后面加小括弧 `()` </span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new&quot;</span>); &#125; <span class="comment">//&quot;new&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要传递参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">function</span> (<span class="params">a</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a); &#125; (<span class="string">&quot;newwwwwwww&quot;</span>); <span class="comment">//&quot;newwwwwwww&quot;</span></span><br></pre></td></tr></table></figure>

<p>嗯，最好玩的是赋值符号<code>=</code>同样也有此效用（例子中的<code>i</code>变量方式）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处 要注意区分 i 和 j 不同之处。前者是函数自执行后返回值给 i ；后者是声明一个函数，函数名为 j 。</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125; (); <span class="comment">// &quot;output i:&quot;</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output j:&quot;</span>); <span class="keyword">return</span> <span class="number">99</span>;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ƒ () &#123; console.log(&quot;output j:&quot;); return 99;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面提及到，要注意区分 <code>var i</code>和 <code>var j</code> 不同之处（前者是函数自执行后返回值给<code>i</code> ；后者是声明一个函数，函数名为<code>j</code>）。如果是看代码，我们需要查看代码结尾是否有没有<code>()</code>才能区分。一般为了方便开发人员阅读，我们会采用下面这种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> i2 = (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i2:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125; ()); <span class="comment">// &quot;output i2:&quot;</span></span><br><span class="line">    <span class="keyword">var</span> i3 = (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i3:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125;) (); <span class="comment">// &quot;output i3:&quot;</span></span><br><span class="line"><span class="comment">// 以上两种都可以，但依旧建议采用第一种 i2 的方式。（个人依旧喜欢第二种i3方式）</span></span><br></pre></td></tr></table></figure>

<p><strong>四、自执行函数的应用</strong></p>
<p><strong>1. for循环 + setTimeout 例子</strong></p>
<p>因为是全局变量，所以输出都是同一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for( var i=0;i&lt;3;i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ,300);</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果 3,3,3</span><br></pre></td></tr></table></figure>

<p>那怎么样才能输出<code>1,2,3</code>呢？ 看看下面的方式（写法一）：把<code>setTimeout</code>代码包含在匿名自执行函数里面，就可以实现“锁住”索引<code>i</code>，正常输出索引值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">lockedIndex</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(lockedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：尽管循环执行结束，<code>i</code>值已经变成了3。但因遇到了自执行函数，当时的<code>i</code>值已经被 <code>lockedIndex</code>锁住了。也可以理解为 自执行函数属于for循环一部分，每次遍历<code>i</code>，自执行函数也会立即执行。所以尽管有延时器，但依旧会保留住立即执行时的<code>i</code>值。 <em>上面的分析有点模糊和牵强，也可以从</em> *<strong>闭包*</strong> <em>角度出发分析的。</em></p>
<p>除了上面的写法，也可以直接在 <code>setTimeout</code> 第一个参数做自执行（写法二），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">lockedInIndex</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(lockedInIndex);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. lockedInIndex变量，也可以换成i，因为和外面的i不在一个作用域</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自执行函数不带入参数 </span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3,3,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)()</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自执行函数只有实参没有写形参</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3,3,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 自执行函数只有形参没有写实参，这种情况不行。因为会导致输出 undefined。</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// undefined,undefined,undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// undefined,undefined,undefined</span></span><br><span class="line">    &#125;)()</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a><strong>尾调用</strong></h2><p><strong>PS:ES6尾调用优化只能在严格模式下使用，详见<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化 阮一峰</a></strong></p>
<p><strong>定义：</strong>某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;//尾调用</span><br><span class="line">// 情况一 非尾调用</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line">// 情况二 非尾调用</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line">//尾调用不一定出现在函数尾部，只要是最后一步操作即可。</span><br><span class="line">    function f(x) &#123;</span><br><span class="line">  if (x &gt; 0) &#123;</span><br><span class="line">    return m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  return n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1)尾调用优化（Tail call optimization）</p>
<p>如图所示，函数调用会在内存形成<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">调用栈（call stack）</a>，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>
<p><strong>优点：</strong>减小调用栈，节省内存使用。</p>
<p><img src="/img/image-20220114072242443.png" alt="image-20220114072242443"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  let m = 1;</span><br><span class="line">  let n = 2;</span><br><span class="line">  return g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line">// 等同于</span><br><span class="line">function f() &#123;</span><br><span class="line">  return g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure>

<p>(2)尾递归</p>
<p><strong>定义：</strong>尾调用自身。<br> “尾调用优化”对递归操作意义重大。ES6中第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归（在严格模式下），就不会发生栈溢出，相对节省内存</p>
<h2 id="尾递归-tail-recursion"><a href="#尾递归-tail-recursion" class="headerlink" title="尾递归(tail recursion)"></a>尾递归(tail recursion)</h2><p><strong>非尾递归</strong></p>
<p>因为最后一个操作并不是调用自己, 而是 乘法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fact(n)&#123;</span><br><span class="line">    if(n==0)return 1;</span><br><span class="line">    return n*fact(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾递归</strong></p>
<p>当然是最后一个操作一定是调用自己.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fact(n, acc)&#123;</span><br><span class="line">    if(n==0)return acc;</span><br><span class="line">    return fact(n-1, acc*n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个地方值得注意</p>
<ul>
<li>看到 <code>acc</code> 了没有, 这就是典型的尾递归最常见的东西, 用来累计每次递归运算结果</li>
<li>fact函数的最后一个操作是fact本身</li>
</ul>
<p>由于tail recur非常容易改写成循环, 编译器容易对其进行优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fact(n)&#123;</span><br><span class="line">    var acc=1,i=n</span><br><span class="line">    while(i!=0)&#123;</span><br><span class="line">        acc=acc*i;</span><br><span class="line">        i-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有觉得尾递归和循环非常像, 唯一的区别是</p>
<ul>
<li>尾递归用参数重新绑定递减的n</li>
<li>尾递归用参数重新绑定叠加值acc</li>
<li>循环直接改变变量i来进行递减</li>
<li>循环叠加变量acc</li>
</ul>
<h2 id="柯里化-实现add-1-2-3-6"><a href="#柯里化-实现add-1-2-3-6" class="headerlink" title="柯里化-实现add(1)(2)(3)=6"></a>柯里化-实现add(1)(2)(3)=6</h2><p><strong>定义</strong></p>
<p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行 add 函数，一次传入两个参数即可</span><br><span class="line">add(1, 2) // 3</span><br><span class="line"></span><br><span class="line">// 假设有一个 curry 函数可以做到柯里化</span><br><span class="line">var addCurry = curry(add);</span><br><span class="line">addCurry(1)(2) // 3</span><br></pre></td></tr></table></figure>

<p><strong>柯里化写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">高颜值写法：</span><br><span class="line">const curry = fn =&gt;</span><br><span class="line">    judge = (...args) =&gt;</span><br><span class="line">        args.length === fn.length</span><br><span class="line">            ? fn(...args)</span><br><span class="line">            : (arg) =&gt; judge(...args, arg)</span><br><span class="line">高颜值的等效写法：</span><br><span class="line">const curry = (fn) =&gt;</span><br><span class="line">  (judge = (...args) =&gt;</span><br><span class="line">    args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));</span><br><span class="line">            </span><br><span class="line">简单写法：</span><br><span class="line">const curry = (fn, ...args) =&gt; </span><br><span class="line">            args.length &lt; fn.length </span><br><span class="line">            // 参数长度不足时,重新柯里化函数,等待接受新参数</span><br><span class="line">            ? (...arguments) =&gt; curry(fn, ...args, ...arguments)</span><br><span class="line">            // 函数长度满足时,执行函数</span><br><span class="line">             : fn(...args);</span><br></pre></td></tr></table></figure>

<p>currying 函数详解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, length</span>) &#123;</span><br><span class="line">  length = length || fn.<span class="property">length</span>;  <span class="comment">// 注释 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;   <span class="comment">// 注释 2</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="property">length</span> &gt;= length <span class="comment">// 注释 3</span></span><br><span class="line">     ? fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)   <span class="comment">// 注释 4</span></span><br><span class="line">      : <span class="title function_">currying</span>(fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>, ...args), length - args.<span class="property">length</span>) <span class="comment">// 注释 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">currying</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度</li>
<li>注释 2：currying 包裹之后返回一个新函数，接收参数为 <code>...args</code></li>
<li>注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度</li>
<li>注释 4：满足要求，执行 fn 函数，传入新函数的参数</li>
<li>注释 5：不满足要求，递归 currying 函数，新的 fn 为 <code>bind</code> 返回的新函数（<code>bind</code> 绑定了 <code>...args</code> 参数，未执行），新的 length 为 fn 剩余参数的长度</li>
</ul>
<p><strong>柯里化应用场景</strong></p>
<blockquote>
<ul>
<li>参数复用，如var curriedAdd = curry(add, 5)</li>
<li>延迟执行，sum(1)(2)(3)，传入参数个数没有满足原函数入参个数，都不会立即返回结果。</li>
<li>函数式编程中，作为compose, functor, monad 等实现的基础</li>
</ul>
</blockquote>
<p><strong>注意事项</strong></p>
<p>使用柯里化函数，离不开闭包， arguments， 递归。</p>
<blockquote>
<p>闭包，函数中的变量都保存在内存中，内存消耗大，有可能导致内存泄漏。<br>递归，效率非常差，<br>arguments, 变量存取慢，访问性很差,</p>
</blockquote>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/42">JavaScript专题之函数柯里化</a></p>
<h1 id="devDependencies-和-dependencies-的区别"><a href="#devDependencies-和-dependencies-的区别" class="headerlink" title="devDependencies 和 dependencies 的区别"></a>devDependencies 和 dependencies 的区别</h1><p><code>devDependencies</code> 和 <code>dependencies</code>的区别核心体现在 <strong>npm包</strong> 中。</p>
<p>只要开发的项目是<strong>发npm包</strong>提供给外部、其他业务项目使用的，需要非常注意依赖的安装地方，因为搞不好很容易在业务使用中会出现bug。dependencies的依赖包会被打入到npm包中，慎用。</p>
<p>而如果只是自己项目用，<strong>不需要发npm包</strong>的话，把依赖安装到 <code>devDependencies</code> 或者 <code>dependencies</code> 中，实质上是没有任何区别的。</p>
<h1 id="args剩余参数与arguments函数形参类数组"><a href="#args剩余参数与arguments函数形参类数组" class="headerlink" title="args剩余参数与arguments函数形参类数组"></a>args剩余参数与arguments函数形参类数组</h1><p><strong>args</strong></p>
<p>定义：只包含那些没有对应形参的实参。将所有后面剩余的是实参个数包裹成一个数组。</p>
<ul>
<li>展开运算符</li>
<li>用于解构赋值</li>
<li>类数组对象变成数组</li>
</ul>
<blockquote>
<p><strong>var</strong> arr1=[‘a’,’b’,’c’]; <strong>var</strong> arr2=[‘d’,’e’];arr1.<strong>push</strong>(…arr2)</p>
<p><strong>let</strong> b=[…new Set([1,2])]</p>
</blockquote>
<p><strong>arguments对象</strong></p>
<p>1.定义：包含了传给函数的所有实参。在函数代码中，使用特殊对象 <code>arguments</code>，开发者无需明确指出参数名，就能访问它们。它是一个类数组，不是数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>) <span class="comment">// Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ] </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">length</span>) <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">length</span>) <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">其中<span class="variable language_">arguments</span> 代表的是函数实参的个数</span><br><span class="line">其中fn.<span class="property">length</span> 代表函数形参的个数</span><br><span class="line">其中<span class="variable language_">arguments</span>.<span class="property">callee</span> 指向函数本身</span><br></pre></td></tr></table></figure>

<p>2.提取参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>警告：</strong> 对参数使用 slice 会阻止某些 JavaScript 引擎中的优化 (比如 V8 - <a target="_blank" rel="noopener" href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments">更多信息</a>)。如果你关心性能，尝试通过遍历 arguments 对象来构造一个新的数组。另一种方法是使用被忽视的<code>Array</code>构造函数作为一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.一般模式和严格模式下arguments</p>
<ul>
<li>一般模式：如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的</li>
<li>严格模式：arguments和参数是双向绑定的</li>
</ul>
<p>(1)一般模式</p>
<p>直接上代码，先来看调用时缺省参数的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a1(x) &#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a1(); // 2 undefined</span><br><span class="line"></span><br><span class="line">function a2(x) &#123;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a2(); // undefined 2</span><br></pre></td></tr></table></figure>

<p>再来看调用时传入参数的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a3(x) &#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a3(1); // 2 2</span><br><span class="line"></span><br><span class="line">function a4(x) &#123;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a4(1); // 2 2</span><br></pre></td></tr></table></figure>

<p>可以看到如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的。</p>
<p>(2)严格模式</p>
<p>再来看看严格模式，直接上代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function b1(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b1(); // 2 undefined</span><br><span class="line"></span><br><span class="line">function b2(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b2(); // undefined 2</span><br><span class="line"></span><br><span class="line">function b3(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b3(1); // 2 1</span><br><span class="line"></span><br><span class="line">function b4(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b4(1); // 1 2</span><br></pre></td></tr></table></figure>

<p>在严格模式下，无论参数是否缺省，arguments和参数都是隔离开的。</p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="字符串自动补全padStart-和padEnd"><a href="#字符串自动补全padStart-和padEnd" class="headerlink" title="字符串自动补全padStart()和padEnd()"></a>字符串自动补全padStart()和padEnd()</h2><p><code>padStart</code>可以在字符串的前面进行字符补全.padEnd是在字符串后面补全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let month  = 8;</span><br><span class="line">month.padStart(2, 0);// 08</span><br></pre></td></tr></table></figure>

<p>可以省掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (month &lt; 10) &#123;</span><br><span class="line">    month = &#x27;0&#x27; + month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机生成10以下正数"><a href="#随机生成10以下正数" class="headerlink" title="随机生成10以下正数"></a>随机生成10以下正数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random()*10)</span><br></pre></td></tr></table></figure>

<h2 id="数组的交集，差集，并集，补集"><a href="#数组的交集，差集，并集，补集" class="headerlink" title="数组的交集，差集，并集，补集"></a>数组的交集，差集，并集，补集</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> b.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">var</span> d = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> b.<span class="title function_">indexOf</span>(v) == -<span class="number">1</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//补集</span></span><br><span class="line"><span class="keyword">var</span> e = a.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(b.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>) &#125;)</span><br><span class="line">        .<span class="title function_">concat</span>(b.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(a.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>)&#125;))</span><br><span class="line"> </span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">var</span> f = a.<span class="title function_">concat</span>(b.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v</span>)&#123; <span class="keyword">return</span> !(a.<span class="title function_">indexOf</span>(v) &gt; -<span class="number">1</span>)&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数组a：&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数组b：&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的交集：&quot;</span>, c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的差集：&quot;</span>, d);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的补集：&quot;</span>, e);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a与b的并集：&quot;</span>, f);</span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const uniqueArr = (arr) =&gt; [...new Set(arr)];</span><br></pre></td></tr></table></figure>

<h2 id="从url获取参数"><a href="#从url获取参数" class="headerlink" title="从url获取参数"></a>从url获取参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const getParameters = () =&gt; &#123;</span><br><span class="line">  const url = window.location.href;</span><br><span class="line">  return JSON.parse(`&#123;&quot;$&#123;decodeURI(url.split(&#x27;?&#x27;)[1]).replace(/&quot;/g, &#x27;\\&quot;&#x27;).replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;).replace(/=/g, &#x27;&quot;:&quot;&#x27;)&#125;&quot;&#125;`);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="检查对象是否为空"><a href="#检查对象是否为空" class="headerlink" title="检查对象是否为空"></a>检查对象是否为空</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const isEmpty = obj =&gt; Reflect.ownKeys(obj).length === 0 &amp;&amp; obj.constructor === Object;</span><br></pre></td></tr></table></figure>

<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="生成随机十六进制颜色"><a href="#生成随机十六进制颜色" class="headerlink" title="生成随机十六进制颜色"></a>生成随机十六进制颜色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const randomHexColor = () =&gt; `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;)&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="检查设备类型"><a href="#检查设备类型" class="headerlink" title="检查设备类型"></a>检查设备类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const judgeDeviceType =</span><br><span class="line">      () =&gt; /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? &#x27;Mobile&#x27; : &#x27;PC&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="文字复制到剪贴板"><a href="#文字复制到剪贴板" class="headerlink" title="文字复制到剪贴板"></a>文字复制到剪贴板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const copyText = async (text) =&gt; await navigator.clipboard.writeText(text)</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://fuyunjinglong.github.io/2099/05/29/B_JS_0%E5%9F%BA%E7%A1%80/" title="0基础_JS" target="_blank" rel="external">https://fuyunjinglong.github.io/2099/05/29/B_JS_0基础/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://fuyunjinglong.github.io/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://fuyunjinglong.github.io/" target="_blank"><span class="text-dark">Elven</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2099/06/26/C_CSS_0%E5%9F%BA%E7%A1%80/" title="CSS_0基础"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2099/03/01/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/" title="0基础_框架"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fuyunjinglong" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://fuyunjinglong.github.io/" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>