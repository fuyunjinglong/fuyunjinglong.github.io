<!DOCTYPE html>
<html lang=cn>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Hexo</title>
  <meta name="description" content="JS闭包闭包是什么？首先要理解全局变量和局部变量，函数内部可以读取全局变量，但函数外部无法读取函数内部局部变量。 闭包就是能够读取其他函数内部变量的函数。确定吗？ 1234567891011121314151617function funOne()&amp;#123;    &#x2F;&#x2F; 外部函数    var num &#x3D; 0;      &#x2F;&#x2F; 局部变量    function funTwo()&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://anandasuper.top/2022/12/11/%E6%A8%A1%E6%9D%BF2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JS闭包闭包是什么？首先要理解全局变量和局部变量，函数内部可以读取全局变量，但函数外部无法读取函数内部局部变量。 闭包就是能够读取其他函数内部变量的函数。确定吗？ 1234567891011121314151617function funOne()&amp;#123;    &#x2F;&#x2F; 外部函数    var num &#x3D; 0;      &#x2F;&#x2F; 局部变量    function funTwo()&amp;#123;">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-11T04:20:22.712Z">
<meta property="article:modified_time" content="2023-01-30T14:50:18.674Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://anandasuper.top/2022/12/11/%E6%A8%A1%E6%9D%BF2/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">昵称</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/G-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">G_性能优化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">前端高频面试题</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/" class="title">插件</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-11T23:33:16.000Z" itemprop="datePublished">2023-01-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/12/11/%E6%A8%A1%E6%9D%BF2/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-11T04:20:22.712Z" itemprop="datePublished">2022-12-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" class="title">E_左神</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-12T23:33:16.000Z" itemprop="datePublished">2022-11-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/10/22/Test/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-22T08:05:41.618Z" itemprop="datePublished">2022-10-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/12/Z_%E4%B9%A6%E5%8D%95/" class="title">书单</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-12T00:33:16.000Z" itemprop="datePublished">2022-09-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-模板2" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/12/11/%E6%A8%A1%E6%9D%BF2/" class="article-date">
	  <time datetime="2022-12-11T04:20:22.712Z" itemprop="datePublished">2022-12-11</time>
	</a>
</span>
        
        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/12/11/%E6%A8%A1%E6%9D%BF2/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h1><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>首先要理解全局变量和局部变量，函数内部可以读取全局变量，但函数外部无法读取函数内部局部变量。</p>
<p>闭包就是能够读取其他函数内部变量的函数。确定吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funOne</span>(<span class="params"></span>)&#123;    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">funTwo</span>(<span class="params"></span>)&#123;   <span class="comment">// 内部函数</span></span><br><span class="line">        num++; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);           </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="title function_">funTwo</span>();</span><br><span class="line">&#125;</span><br><span class="line">执行<span class="title function_">funOne</span>();<span class="comment">//不是闭包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funOne</span>(<span class="params"></span>)&#123;    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">    num++; </span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="title function_">funOne</span>();</span><br><span class="line">执行fun;<span class="comment">//不是闭包</span></span><br></pre></td></tr></table></figure>

<p>真正的闭包：闭包是将函数内部和函数外部连接的桥梁。</p>
<p>本质：funOne()的执行结果赋给了全局变量fun,导致的结果是funTwo和num始终在内存中没有回收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funOne</span>(<span class="params"></span>)&#123;    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">funTwo</span>(<span class="params"></span>)&#123;   <span class="comment">// 内部函数</span></span><br><span class="line">        num++; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印：&#x27;</span>+num);           </span><br><span class="line">        <span class="keyword">return</span> num;<span class="comment">//对于闭包来说，可有可无</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funTwo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// funOne()的执行结果是闭包</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="title function_">funOne</span>();</span><br><span class="line"><span class="title function_">fun</span>()</span><br><span class="line"></span><br><span class="line">简化写法：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funOne</span>(<span class="params"></span>)&#123;    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;   <span class="comment">// 内部函数</span></span><br><span class="line">        num++; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印：&#x27;</span>+num);           </span><br><span class="line">        <span class="keyword">return</span> num;<span class="comment">//对于闭包来说，可有可无</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="title function_">funOne</span>();</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure>

<p><strong>闭包拥有自己独立的作用域</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="title function_">funOne</span>();</span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="title function_">funOne</span>();</span><br><span class="line"><span class="title function_">fun</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fun</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fun</span>() <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">fun2</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fun2</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么需要闭包"><a href="#为什么需要闭包" class="headerlink" title="为什么需要闭包"></a>为什么需要闭包</h2><p>局部变量无法共享和长久保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久保存变量，又不会造成全局污染，所有有了闭包。</p>
<h2 id="利用闭包封装原生XMLHttpRequest请求"><a href="#利用闭包封装原生XMLHttpRequest请求" class="headerlink" title="利用闭包封装原生XMLHttpRequest请求"></a>利用闭包封装原生XMLHttpRequest请求</h2><p>原始代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendData</span>(<span class="params">mobile, password</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> xmlHttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">      xmlHttp.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;//localhost:3333/form&#x27;</span>);</span><br><span class="line">      xmlHttp.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">      xmlHttp.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; mobile, password &#125;));</span><br><span class="line">      xmlHttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlHttp.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xmlHttp.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="title function_">alert</span>(xmlHttp.<span class="property">responseText</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>闭包封装改造</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">http</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 对sendData简单封装</span></span><br><span class="line">      <span class="keyword">const</span> xmlHttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 返回对象是方便后续扩展</span></span><br><span class="line">        <span class="attr">request</span>: <span class="function">(<span class="params">method, url, data, success, error</span>) =&gt;</span> &#123;</span><br><span class="line">          xmlHttp.<span class="title function_">open</span>(method, url);</span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">            xmlHttp.<span class="title function_">send</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xmlHttp.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">            xmlHttp.<span class="title function_">send</span>(data);</span><br><span class="line">          &#125;</span><br><span class="line">          xmlHttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xmlHttp.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xmlHttp.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">              <span class="comment">// 成功的回调函数</span></span><br><span class="line">              <span class="title function_">success</span>(xmlHttp.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 失败的回调函数</span></span><br><span class="line">              <span class="title function_">error</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">调用</span><br><span class="line"><span class="keyword">const</span> http_ = http;</span><br><span class="line"><span class="keyword">const</span> method = <span class="string">&#x27;post&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;//localhost:3333/form&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">mobile</span>: <span class="number">1</span>, <span class="attr">password</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">success</span> = res =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">error</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line">http_.<span class="title function_">request</span>(method, url, data, success, error);</span><br></pre></td></tr></table></figure>

<p>再看个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = ( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">    <span class="comment">// “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">get_secret</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 通过定义的接口来访问 secret</span></span><br><span class="line">            <span class="keyword">return</span> secret;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">new_secret</span>: <span class="keyword">function</span> (<span class="params"> new_secret </span>) &#123;</span><br><span class="line">            <span class="comment">// 通过定义的接口来修改 secret</span></span><br><span class="line">            secret = new_secret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; () );</span><br><span class="line"></span><br><span class="line">foo.<span class="property">get_secret</span> (); <span class="comment">// 得到 &#x27;secret&#x27;</span></span><br><span class="line">foo.<span class="property">secret</span>; <span class="comment">// Type error，访问不能</span></span><br><span class="line">foo.<span class="property">new_secret</span> (<span class="string">&#x27;a new secret&#x27;</span>); <span class="comment">// 通过函数接口，我们访问并修改了 secret 变量</span></span><br><span class="line">foo.<span class="property">get_secret</span> (); <span class="comment">// 得到 &#x27;a new secret&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="Github仓库整理"><a href="#Github仓库整理" class="headerlink" title="Github仓库整理"></a>Github仓库整理</h1><p>1、software-template</p>
<p>整理为前后台代码仓，代码仓software-template，分支vue2-web,vue3-web,springboot-server</p>
<p>2.tem-xxx</p>
<p>3.fuyunjinglong.github.io</p>
<p>vuepress的一级目录，hexo子目录，vitePress子目录</p>
<h1 id="划词翻译服务"><a href="#划词翻译服务" class="headerlink" title="划词翻译服务"></a>划词翻译服务</h1><p>百度</p>
<p>20221020001403389密GZ5jMi1SC9Tek7bMA4md</p>
<p>彩云</p>
<p>lax3hdplm6mnvnxkw17w</p>
<p>阿里</p>
<p>LTAI5tMHUUxWUcHvwTcWXFXE密L8GJS9zpIkLKY4FyoubjoOra5kL0l5</p>
<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="一、v-model原理"><a href="#一、v-model原理" class="headerlink" title="一、v-model原理"></a><strong>一、v-model原理</strong></h3><p>v-model的原理就是: v-bind 和 v-on的语法糖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-bind=&quot;age&quot; v-on:input=&quot;age = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="二、Vue2中双向绑定实现"><a href="#二、Vue2中双向绑定实现" class="headerlink" title="二、Vue2中双向绑定实现"></a><strong>二、Vue2中双向绑定实现</strong></h3><p><strong>1.v-bind</strong></p>
<p>通过自定义事件触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;Son :ageValue=&quot;age&quot; @changeInput=&quot;changeInput&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    ageValue: &#123;</span><br><span class="line">      typeof: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sonAge: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeInput() &#123;</span><br><span class="line">      this.$emit(&#x27;changeInput&#x27;, this.sonAge)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  /*</span><br><span class="line">   为什么要监听:</span><br><span class="line">   因为父组件传递过来属性, 可能有默认值,</span><br><span class="line">   子组件的input需要根据默认值回显,或者别的地方需要</span><br><span class="line">  */</span><br><span class="line">  watch: &#123;</span><br><span class="line">    ageValue: &#123;</span><br><span class="line">      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数</span><br><span class="line">      handler(val) &#123;</span><br><span class="line">        this.sonAge = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2.sync修饰符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;Son :ageValue.sync=&quot;age&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    ageValue: &#123;</span><br><span class="line">      typeof: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sonAge: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeInput() &#123;</span><br><span class="line">      // this.$emit(&#x27;changeInput&#x27;, this.sonAge)</span><br><span class="line">      // 这样父组件内的值也同时被更改,省略了监听事件这一步</span><br><span class="line">      this.$emit(&#x27;update:ageValue&#x27;, this.sonAge)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    ageValue: &#123;</span><br><span class="line">      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数</span><br><span class="line">      handler(val) &#123;</span><br><span class="line">        this.sonAge = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3.v-model</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;Son v-model=&quot;age&quot; /&gt;</span><br><span class="line">&lt;!-- &lt;Son :age=&quot;age&quot; @change=&quot;age = $event&quot;&gt;&lt;/Son&gt;--&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;sonAge&quot; @input=&quot;changeInput&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      typeof: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sonAge: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 超级牛</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;value&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeInput() &#123;</span><br><span class="line">      this.$emit(&#x27;change&#x27;, this.sonAge)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      immediate: true, // 立即执行 :当刷新页面时会立即执行一次handler函数</span><br><span class="line">      handler(val) &#123;</span><br><span class="line">        this.sonAge = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三、Vue3中双向绑定实现"><a href="#三、Vue3中双向绑定实现" class="headerlink" title="三、Vue3中双向绑定实现"></a><strong>三、Vue3中双向绑定实现</strong></h3><p><strong>1.自定义事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;Son v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot;</span><br><span class="line">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &#x27;vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: [&#x27;modelValue&#x27;],</span><br><span class="line">  emits: [&#x27;update:modelValue&#x27;],</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2.v-model结合computed计算属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;!-- 两个方法等价 --&gt;</span><br><span class="line">&lt;!-- &lt;Son :modelValue=&quot;message&quot; @update:modelValue=&quot;message = $event&quot; /&gt; --&gt;</span><br><span class="line">&lt;Son v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 两个方法等价 --&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;newValue&quot; @input=&quot;newValue = $event.target.value&quot; /&gt; --&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;newValue&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, computed &#125; from &#x27;vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: [&#x27;modelValue&#x27;],</span><br><span class="line">  emits: [&#x27;update:modelValue&#x27;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const newValue = computed(&#123;</span><br><span class="line">      // 子组件v-model绑定 计算属性, 一旦发生变化, 就会给父组件传递值</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: (nv) =&gt; &#123;</span><br><span class="line">        emit(&#x27;update:modelValue&#x27;, nv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3.v-model结合watch</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;proxy&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, watch &#125; from &quot;vue&quot;;</span><br><span class="line">const emit = defineEmits();</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  modelValue: String,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const proxy = ref(props.modelValue);</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; proxy.value,</span><br><span class="line">  (v) =&gt; emit(&quot;update:modelValue&quot;,v)</span><br><span class="line">);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4.Hooks封装</strong></p>
<p>提取公用逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;proxy&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, watch, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useVmodel &#125; <span class="keyword">from</span> <span class="string">&quot;./hooks/useVmodel1&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">modelValue</span>: <span class="title class_">String</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> proxy = <span class="title function_">useVmodel</span>(props, emit);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useVmodel1.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useVmodel</span>(<span class="params">props, emit</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="title function_">ref</span>(props.<span class="property">modelValue</span>);</span><br><span class="line">  <span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> proxy.<span class="property">value</span>,</span><br><span class="line">    <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="title function_">emit</span>(<span class="string">&quot;update:modelValue&quot;</span>, v)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.v-model多个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// father.vue</span><br><span class="line">&lt;Son v-model=&quot;message&quot; v-model:title=&quot;title&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 两个方法等价 --&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;newValue&quot; @input=&quot;newValue = $event.target.value&quot; /&gt; --&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;newValue&quot; /&gt;</span><br><span class="line">    -</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;newTitle&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, computed &#125; from &#x27;vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // v-model默认的名字</span><br><span class="line">    modelValue: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;,</span><br><span class="line">    title: &#123;</span><br><span class="line">      //这里可以直接使用 v-model:title ,:号后面的名字</span><br><span class="line">      type: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  emits: [&#x27;update:modelValue&#x27;, &#x27;update:title&#x27;],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const newValue = computed(&#123;</span><br><span class="line">      get: () =&gt; props.modelValue,</span><br><span class="line">      set: (nv) =&gt; &#123;</span><br><span class="line">        console.log(nv)</span><br><span class="line">        emit(&#x27;update:modelValue&#x27;, nv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const newTitle = computed(&#123;</span><br><span class="line">      get: () =&gt; props.title,</span><br><span class="line">      set: (nv) =&gt; &#123;</span><br><span class="line">        emit(&#x27;update:title&#x27;, nv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      newValue,</span><br><span class="line">      newTitle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="四、vue2-对比-vue3的-v-model区别"><a href="#四、vue2-对比-vue3的-v-model区别" class="headerlink" title="四、vue2 对比 vue3的 v-model区别"></a>四、vue2 对比 vue3的 v-model区别</h3><p><strong>Vue2</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;<span class="title class_">ChildComponent</span> v-model = <span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span>  @<span class="attr">change</span>=<span class="string">&quot;title = $event&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;title&#x27;</span>, <span class="comment">// v-model绑定的属性名称</span></span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span> <span class="comment">// v-model绑定的事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">String</span>, <span class="comment">// value跟v-model无关</span></span><br><span class="line">    <span class="attr">title</span>: &#123; <span class="comment">// title是跟v-model绑定的属性</span></span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;Default title&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 这里的 change, 对应 event</span></span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vue3</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;!-- 两个方法等价 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">:modelValue</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;message = $event&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">modelValue</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, &#123; emit &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title function_">computed</span>(&#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> props.<span class="property">modelValue</span>,</span><br><span class="line">      <span class="attr">set</span>: <span class="function">(<span class="params">nv</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(nv)</span><br><span class="line">        <span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, nv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>Vue2:</p>
<ol>
<li>v-model: 会把 <code>value</code> 用作 prop 且把 <code>input</code> 用作 event;</li>
<li>可以通过 <code>.sync</code>修饰符 指定传递名字</li>
<li>支持model: 可以指定v-model的 value属性名 和 event事件名字</li>
</ol>
<p>Vue3:</p>
<ol>
<li>v-model: 不在绑定 value 而是 <code>modelValue</code>, 接受方法也不再是 input 而是 <code>update:modelValue</code></li>
<li>组件支持多个 v-model, 并且可以指定名字 v-model:名字</li>
</ol>
<ul>
<li>修改默认 prop 名和事件名</li>
<li>废除 model 选项和 .sync 修饰符</li>
<li>使用多个 v-model</li>
<li>自定义 v-model 修饰符</li>
</ul>
<h2 id="watch、watchEffect区别"><a href="#watch、watchEffect区别" class="headerlink" title="watch、watchEffect区别"></a>watch、watchEffect区别</h2><ul>
<li>1、watch是惰性执行，也就是只有监听的值发生变化的时候才会执行，但是watchEffect不同，每次代码加载watchEffect都会执行（忽略watch第三个参数的配置，如果修改配置项也可以实现立即执行）</li>
<li>2、watch需要传递监听的对象，watchEffect不需要</li>
<li>3、watch只能监听响应式数据：ref定义的属性和reactive定义的对象，如果直接监听reactive定义对象中的属性是不允许的，除非使用函数转换一下</li>
<li>4、watchEffect如果监听reactive定义的对象是不起作用的，只能监听对象中的属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> countObj = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 惰性，首次加载不执行</span></span><br><span class="line">  <span class="title function_">watch</span>(count, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(newVal, oldVal)&#125; )</span><br><span class="line">  <span class="comment">// watch 不能直接监听reactive里面的属性，只能监听ref、reactiveObject， function， array, 如果想监听reactive的某个属性，那么需要转换成函数</span></span><br><span class="line">  <span class="title function_">watch</span>(<span class="function">() =&gt;</span> countObj.<span class="property">count</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal, newVal)&#125;, &#123;&#125;)</span><br><span class="line">  watch (countObj, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal, oldVal)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听多个值，前面是监听数据的数组，后面的参数是两个数组，前面数组是变化后监听对象值的数组，后面是变化前监听对象值的数组</span></span><br><span class="line">  watch ([countObj, count], <span class="function">(<span class="params">[oneNewName, twoNewName], [oneOldName, twoOldName]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(oneNewName, oneOldName, twoNewName, twoOldName)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// watchEffect，和watch不一样，1、会立即执行，只要定义了就会执行。2、他只能监听某个值，监听对象不管用。3、不需要传递参数，会自动管制代码中的变量。4、没法获取newVal和oldVal</span></span><br><span class="line">  <span class="keyword">const</span> watchEf = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(countObj.<span class="property">count</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>watchEffect副作用函数</strong></p>
<p>定义：watchEffect的第三个参数是用于注册副作用清理的回调函数，该回调函数会在副作用函数下一次重新执行前调用，多用于取消重复请求、防抖、事件注册销毁等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消重复请求</span></span><br><span class="line"><span class="title function_">watch</span>(source, <span class="keyword">async</span> (old, <span class="keyword">new</span>, <span class="title class_">OnCleanup</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 是否过期是标志</span></span><br><span class="line">  <span class="keyword">let</span> expired = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 注册过期回调</span></span><br><span class="line">  <span class="title class_">OnCleanup</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    expired = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"> <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line"> <span class="comment">// 如果未过期，那么可以取res为finalData</span></span><br><span class="line"> <span class="keyword">if</span> (!expired) &#123;</span><br><span class="line">   finalData = res</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="title function_">ref</span>(<span class="number">13</span>)</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 异步请求</span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">performAsyncOperation</span>(id.<span class="property">value</span>)</span><br><span class="line">  <span class="comment">// 如果id频繁改变，会触发失效函数，取消之前的接口请求</span></span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// id has changed or watcher is stopped.</span></span><br><span class="line">    <span class="comment">// invalidate previously pending async operation</span></span><br><span class="line">    token.<span class="title function_">cancel</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom的事件监听和取消监听</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick, <span class="literal">false</span>)</span><br><span class="line">    <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<p>Vue2————–vue3<br>beforeCreate  -&gt; setup() // 开始创建组件之前，在<code>beforeCreate</code>和<code>created</code>之前执行。创建的是<code>data</code>和<code>method</code><br>created       -&gt; setup()<br>beforeMount   -&gt; onBeforeMount // 组件挂载到节点上之前执行<br>mounted       -&gt; onMounted // 组件挂载完成后执行<br>beforeUpdate  -&gt; onBeforeUpdate //  组件更新之前执行<br>updated       -&gt; onUpdated // 组件更新完成之后执行<br>beforeDestroy -&gt; onBeforeUnmount // 组件卸载之前执行<br>destroyed     -&gt; onUnmounted // 组件卸载完成后执行<br>activated     -&gt; onActivated // 被包含在<code>&lt;keep-alive&gt;</code>中的组件，会多出两个生命周期钩子函数。被激活时执行。<br>deactivated   -&gt; onDeactivated // 比如从 A 组件，切换到 B 组件，A 组件消失时执行<br>errorCaptured -&gt; onErrorCaptured // 当捕获一个来自子孙组件的异常时激活钩子函数</p>
</blockquote>
<p><strong>新增 onRenderTracked()和 onRenderTriggered()</strong></p>
<p>onRenderTracked()</p>
<blockquote>
<p>直译过来就是<code>状态跟踪</code>，它会跟踪页面上所有响应式变量和方法的状态。只要页面有<code>update</code>的情况，他就会跟踪，然后生成一个<code>event</code>对象。</p>
</blockquote>
<p>onRenderTriggered()</p>
<blockquote>
<p>直译过来是<code>状态触发</code>，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。 与<code>watch</code>相似。</p>
<p>event 对象属性的详细介绍：</p>
<ul>
<li>key 那边变量发生了变化</li>
<li>newValue 更新后变量的值</li>
<li>oldValue 更新前变量的值</li>
<li>target 目前页面中的响应变量和函数</li>
</ul>
</blockquote>
<h2 id="setup语法糖就是香"><a href="#setup语法糖就是香" class="headerlink" title="setup语法糖就是香"></a>setup语法糖就是香</h2><ul>
<li>组件自动注册</li>
<li>组件核心 API</li>
<li>属性和方法直接使用</li>
</ul>
<p><strong>组件自动注册</strong></p>
<p>它会自动以文件名为主，也就是不用再写<code>name</code>属性了</p>
<p><strong>组件核心 API</strong></p>
<p>1.使用 props</p>
<p>通过<code>defineProps</code>指定当前 props 类型，获得上下文的props对象。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; defineProps &#125; from &#x27;vue&#x27;</span><br><span class="line">  const props = defineProps(&#123;</span><br><span class="line">    title: String,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2.使用 emits</p>
<p>使用<code>defineEmit</code>定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; defineEmits &#125; from &#x27;vue&#x27;</span><br><span class="line">  const emit = defineEmits([&#x27;change&#x27;, &#x27;delete&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>3.获取 slots 和 attrs</p>
<p>可以通过<code>useContext</code>从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了<code>useAttrs</code>和<code>useSlots</code>。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 旧</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; useContext &#125; from &#x27;vue&#x27;</span><br><span class="line">  const &#123; slots, attrs &#125; = useContext()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 新</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; useAttrs, useSlots &#125; from &#x27;vue&#x27;</span><br><span class="line">  const attrs = useAttrs()</span><br><span class="line">  const slots = useSlots()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>4.defineExpose API</p>
<p>传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 <code>template</code>模板，谁都不能访问内部的数据和方法。</p>
<p>如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"> import &#123; defineExpose &#125; from &#x27;vue&#x27;</span><br><span class="line"> const a = 1</span><br><span class="line"> const b = 2</span><br><span class="line"> defineExpose(&#123;</span><br><span class="line">     a</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>属性和方法直接使用</strong></p>
<p>定义的属性和方法无需返回，可以直接使用</p>
<h2 id="Vue3标准模板"><a href="#Vue3标准模板" class="headerlink" title="Vue3标准模板"></a>Vue3标准模板</h2><p><strong>模板工具：</strong></p>
<ul>
<li><p><code>编程语言</code>：<strong>TypeScript 4.x 、JavaScript</strong></p>
</li>
<li><p><code>前端框架</code>：<strong>Vue 3.x</strong></p>
</li>
<li><p><code>构建工具</code>：<strong>Vite 2.x</strong></p>
</li>
<li><p><code>UI 框架</code>：<strong>Element Plus</strong></p>
</li>
<li><p><code>图标工具</code>：<strong>icones</strong></p>
</li>
<li><p><code>CSS预编译</code>：<strong>Sass</strong></p>
</li>
<li><p><code>CSS框架</code>：<strong>Windi CSS</strong></p>
</li>
<li><p><code>HTTP工具</code>：<strong>Axios</strong></p>
</li>
<li><p><code>路由管理</code>：<strong>Vue Router 4.x</strong></p>
</li>
<li><p><code>状态管理</code>：<strong>Pinia</strong></p>
</li>
<li><p><code>代码规范</code>：<strong>EditorConifg、Prettier、ESLint、Airbnb JavaScript Style Guide</strong></p>
</li>
<li><p><code>提交规范</code>：<strong>husky、Commitlint 、lint-staged</strong></p>
</li>
<li><p><code>实现自动按需加载</code>（**<code>墙裂推荐</code><strong>）：</strong>unplugin-auto-import、unplugin-vue-components、unplugin-icons**</p>
</li>
<li><p><code>实现 SVG图标 的组件化</code>：<strong>vite-svg-loader</strong></p>
</li>
<li><p><code>让各种 API 支持响应式</code>：<strong>VueUse</strong></p>
</li>
<li><p><code>让加载页面时有所反馈</code>：<strong>NProgress</strong></p>
</li>
<li><p><code>支持 markdown</code>：<strong>vite-plugin-md</strong></p>
</li>
<li><p>vetur -&gt; volar:对于 vue3 的支持，<code>vetur</code> 很明显的不如 <code>volar</code>，这边建议小伙伴们禁用vuetur而使用volor</p>
</li>
</ul>
<p><strong>模板代码目录结构：</strong></p>
<ul>
<li><code>.husky</code>：用来放husky 钩子的配置文件夹</li>
<li><code>.vscode</code>：用来放项目中的 vscode 配置</li>
<li><code>presets</code>：用来放 vite 插件的 plugin 配置</li>
<li><code>public</code>：用来放一些诸如 页头icon 之类的公共文件，会被打包到dist根目录下</li>
<li><code>src</code>：用来放项目代码文件</li>
<li><code>api</code>：用来放http的一些接口配置</li>
<li><code>assets</code>：用来放一些 CSS 之类的静态资源</li>
<li><code>components</code>：用来放 Vue 组件</li>
<li><code>layout</code>：用来放项目的布局</li>
<li><code>router</code>：用来放项目的路由配置</li>
<li><code>store</code>：用来放状态管理Pinia的配置</li>
<li><code>utils</code>：用来放项目中的工具方法类</li>
<li><code>views</code>：用来放项目的.vue视图</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h1><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的<strong>所有执行上下文</strong>。</p>
<p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文<strong>栈</strong>（Execution context stack，ECS）来<strong>管理</strong>执行上下文。</p>
<p>当 JavaScript 初始化的时候会向执行上下文栈压入一个<strong>全局</strong>执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。</p>
<p><strong>一、执行上下文</strong></p>
<p>执行上下文总共有三种类型</p>
<ul>
<li><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 window 对象，<code>this</code> 指向这个全局对象。</li>
<li><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</li>
<li><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li>
</ul>
<p><strong>二、执行上下文的创建</strong></p>
<p>分为2个阶段：</p>
<ul>
<li>创建阶段</li>
<li>执行阶段</li>
</ul>
<p><strong>1.创建阶段</strong></p>
<p>分为3部分：</p>
<ul>
<li>1、确定 <strong>this</strong> 的值，也被称为 <strong>This Binding</strong>。</li>
<li>2、<strong>LexicalEnvironment（词法环境）</strong> 组件被创建。</li>
<li>3、<strong>VariableEnvironment（变量环境）</strong> 组件被创建。</li>
</ul>
<p><strong>(1)This Binding</strong></p>
<ul>
<li><strong>全局</strong>执行上下文中，<code>this</code> 的值指向全局对象，在浏览器中<code>this</code> 的值指向 <code>window</code>对象，而在<code>nodejs</code>中指向这个文件的<code>module</code>对象。</li>
<li><strong>函数</strong>执行上下文中，<code>this</code> 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、<code>new</code>绑定、箭头函数，具体内容会在【this全面解析】部分详解。</li>
</ul>
<p><strong>(2)词法环境</strong></p>
<p>分为2部分：</p>
<ul>
<li><strong>环境记录</strong>：存储变量和函数声明的实际位置</li>
<li><strong>对外部环境的引用</strong>：可以访问其外部词法环境</li>
</ul>
<p>词法环境有两种<strong>类型</strong></p>
<ul>
<li>1、<strong>全局环境</strong>：是一个没有外部环境的词法环境，其外部环境引用为 <strong>null</strong>。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</li>
<li>2、<strong>函数环境</strong>：用户在函数中定义的变量被存储在<strong>环境记录</strong>中，包含了<code>arguments</code> 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li>
</ul>
<p><strong>(3)变量环境</strong></p>
<p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>
<p>在 ES6 中，<strong>词法</strong> 环境和 <strong>变量</strong> 环境的区别在于前者用于存储<strong>函数声明和变量（ <code>let</code> 和 <code>const</code> ）</strong>绑定，而后者仅用于存储<strong>变量（ <code>var</code> ）</strong>绑定。</p>
<p><strong>2.执行阶段</strong></p>
<p>完成对所有变量的分配，执行代码，函数出栈</p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bdfd3e151882516c6432c32">理解 Javascript 执行上下文和执行栈</a></p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>例子一：<strong>变量提升</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo;  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// foo1，foo赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo2，foo重新赋值</span></span><br></pre></td></tr></table></figure>

<p>例子二：<strong>函数提升</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();  <span class="comment">// foo2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// foo2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure>

<p>例子三：声明优先级，<strong>函数 &gt; 变量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();  <span class="comment">// foo2</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// foo1，foo重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo1</span></span><br></pre></td></tr></table></figure>

<p>上面三个例子中，第一个例子是变量提升，第二个例子是函数提升，第三个例子是函数声明优先级高于变量声明。</p>
<p>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>();</span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()();</span><br></pre></td></tr></table></figure>

<p>答案是 执行上下文栈的变化不一样。</p>
<p>第一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;checkscope&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;f&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>

<p>第二段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;checkscope&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;f&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>

<p><strong>讨论题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;n: 1&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">a.x = a = &#123;n: 2&#125;;</span><br><span class="line"></span><br><span class="line">a.x  // --&gt; undefined</span><br><span class="line">b.x  // --&gt; &#123;n: 2&#125;</span><br></pre></td></tr></table></figure>

<p>答案已经写上面了，这道题的关键在于</p>
<ul>
<li>1、优先级。<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>&#123;n: 1&#125;</code>就会变成<code>&#123;n: 1, x: undefined&#125;</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li>
<li>2、赋值操作是<code>从右到左</code>，所以先执行<code>a = &#123;n: 2&#125;</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，<strong>需要注意</strong>的是这时候<code>a.x</code>是第一步中的<code>&#123;n: 1, x: undefined&#125;</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = &#123;n: 2&#125;</code></li>
</ul>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></p>
<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>JS内存空间分为<strong>栈(stack)<strong>、</strong>堆(heap)<strong>、</strong>池(一般也会归类为栈中)<strong>。 其中</strong>栈</strong>存放基本变量，<strong>堆</strong>存放应用对象(引用地址存放在栈，真实变量在堆)，<strong>池</strong>存放常量，所以也叫常量池。</p>
<p><strong>几个问题</strong></p>
<p>问题1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 这时a的值是多少？</span></span><br></pre></td></tr></table></figure>

<p>问题2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;前端开发&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;进阶&#x27;</span>;</span><br><span class="line"><span class="comment">// 这时a.name的值是多少</span></span><br></pre></td></tr></table></figure>

<p>问题3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;前端开发&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 这时b的值是多少</span></span><br></pre></td></tr></table></figure>

<p>现在来解答一下，三个问题的答案分别是<code>20</code>、<code>‘进阶’</code>、<code>&#123; name: &#39;前端开发&#39; &#125;</code></p>
<ul>
<li>对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。</li>
<li>对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改<code>b.name</code>的值后，相应的<code>a.name</code>也就发生了改变。</li>
<li>对于问题3，首先要说明的是<code>null</code>是基本类型，<code>a = null</code>之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。</li>
</ul>
<p><strong>JS的内存生命周期</strong></p>
<ul>
<li>1、分配你所需要的内存</li>
<li>2、使用分配到的内存（读、写）</li>
<li>3、不需要时将其释放、归还</li>
</ul>
<h1 id="从内存来看-null-和-undefined-本质的区别是什么？"><a href="#从内存来看-null-和-undefined-本质的区别是什么？" class="headerlink" title="从内存来看 null 和 undefined 本质的区别是什么？"></a><strong>从内存来看 null 和 undefined 本质的区别是什么？</strong></h1><p><strong>解答</strong>：</p>
<p>给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。</p>
<p>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>定义</strong></p>
<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>
<p>关键在于2点：</p>
<ul>
<li>是函数</li>
<li>能够访问函数作用域外的变量</li>
</ul>
<p><strong>三个特性</strong></p>
<ul>
<li>闭包可以访问当前函数以外的变量</li>
<li>即使外部函数已经返回，闭包仍能访问外部函数定义的变量</li>
<li>闭包可以更新外部变量的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 闭包可以访问当前函数以外的变量</span><br><span class="line">function getOuter()&#123;</span><br><span class="line">  var date = &#x27;815&#x27;;</span><br><span class="line">  function getDate(str)&#123;</span><br><span class="line">    console.log(str + date);  //访问外部的date</span><br><span class="line">  &#125;</span><br><span class="line">  return getDate(&#x27;今天是：&#x27;); //&quot;今天是：815&quot;</span><br><span class="line">&#125;</span><br><span class="line">getOuter();</span><br><span class="line">// 即使外部函数已经返回，闭包仍能访问外部函数定义的变量</span><br><span class="line">function getOuter()&#123;</span><br><span class="line">  var date = &#x27;815&#x27;;</span><br><span class="line">  function getDate(str)&#123;</span><br><span class="line">    console.log(str + date);  //访问外部的date</span><br><span class="line">  &#125;</span><br><span class="line">  return getDate;     //外部函数返回</span><br><span class="line">&#125;</span><br><span class="line">var today = getOuter();</span><br><span class="line">today(&#x27;今天是：&#x27;);   //&quot;今天是：815&quot;</span><br><span class="line">today(&#x27;明天不是：&#x27;);   //&quot;明天不是：815&quot;</span><br><span class="line">// 闭包可以更新外部变量的值</span><br><span class="line">function updateCount()&#123;</span><br><span class="line">  var count = 0;</span><br><span class="line">  function getCount(val)&#123;</span><br><span class="line">    count = val;</span><br><span class="line">    console.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  return getCount;     //外部函数返回</span><br><span class="line">&#125;</span><br><span class="line">var count = updateCount();</span><br><span class="line">count(815); //815</span><br><span class="line">count(816); //816</span><br></pre></td></tr></table></figure>

<p><strong>一个简单例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = checkscope(); // foo指向函数f</span><br><span class="line">foo();     // 调用函数f()</span><br></pre></td></tr></table></figure>

<p>简要的执行过程如下：</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文<strong>压入执行上下文栈</strong></li>
<li>全局执行<strong>上下文初始化</strong></li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行<strong>上下文初始化</strong>，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ol>
<p>那么<strong>问题</strong>来了， 函数f 执行的时候，checkscope 函数上下文已经被销毁了，那函数f是如何获取到scope变量的呢？</p>
<blockquote>
<p>函数f 执行上下文维护了一个作用域链，会指向指向<code>checkscope</code>作用域。</p>
<p>所以指向关系是当前作用域 –&gt; <code>checkscope</code>作用域–&gt; 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的<strong>关键</strong>。</p>
</blockquote>
<p><strong>一个闭包题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure>

<p>如果知道闭包的，答案就很明显了，都是3</p>
<p>如果要依次输出索引值，解决：改成闭包，方法就是<code>data[i]</code>返回一个函数，并访问变量<code>i</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = (function (i) &#123;</span><br><span class="line">      return function()&#123;</span><br><span class="line">          console.log(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0](); // 0</span><br><span class="line">data[1](); // 1</span><br><span class="line">data[2](); // 2</span><br></pre></td></tr></table></figure>

<p>循环结束后的全局执行上下文没有变化。</p>
<p>执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：因为闭包执行上下文中贮存了变量<code>i</code>，所以根据作用域链会在<code>globalContext.VO</code>中查找到变量<code>i</code>,并输出0。</p>
<p><strong>一、作用域</strong></p>
<p><strong>1.变量提升</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope=<span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scopeTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    <span class="keyword">var</span> scope=<span class="string">&quot;local&quot;</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">scopeTest</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的代码输出是<code>undefined</code>，这是因为局部变量<code>scope</code>变量提升了，等效于下面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope=<span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scopeTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    scope=<span class="string">&quot;local&quot;</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">scopeTest</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，如果在局部作用域中忘记var，那么变量就被声明为全局变量。</p>
<p><strong>2.没有块级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><strong>闭包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createClosure()&#123;</span><br><span class="line">    var name = &quot;jack&quot;;</span><br><span class="line">    return &#123;</span><br><span class="line">        setStr:function()&#123;</span><br><span class="line">            name = &quot;rose&quot;;</span><br><span class="line">        &#125;,</span><br><span class="line">        getStr:function()&#123;</span><br><span class="line">            return name + &quot;:hello&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var builder = new createClosure();</span><br><span class="line">builder.setStr();</span><br><span class="line">console.log(builder.getStr()); //rose:hello</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<p>由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。</p>
<p>如果想以下代码按照预期输出索引值，怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0](); // 3</span><br><span class="line">data[1](); // 3</span><br><span class="line">data[2](); // 3</span><br></pre></td></tr></table></figure>

<p><strong>方法1：立即执行函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>方法2：返回一个匿名函数赋值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>无论是<strong>立即执行函数</strong>还是<strong>返回一个匿名函数赋值</strong>，原理上都是因为变量的按值传递，所以会将变量<code>i</code>的值复制给实参<code>num</code>，在匿名函数的内部又创建了一个用于访问<code>num</code>的匿名函数，这样每个函数都有了一个<code>num</code>的副本，互不影响了。</p>
<p><strong>方法3：使用ES6中的let</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure>

<p>解释下<strong>原理</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];<span class="comment">// 创建一个数组data;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入第一次循环</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 注意：因为使用let使得for循环为块级作用域</span></span><br><span class="line">            <span class="comment">// 此次 let i = 0 在这个块级作用域中，而不是在全局环境中</span></span><br><span class="line">    data[<span class="number">0</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="New一个对象发生了什么"><a href="#New一个对象发生了什么" class="headerlink" title="New一个对象发生了什么"></a>New一个对象发生了什么</h1><p><strong>模拟实现</strong></p>
<p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</p>
<ol>
<li>一个继承自 <code>Foo.prototype</code> 的新对象被创建。</li>
<li>使用指定的参数调用构造函数 <code>Foo</code> ，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()</code>，也就是没有指定参数列表，<code>Foo</code> 不带任何参数调用的情况。</li>
<li>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。</li>
</ol>
<p><strong>模拟实现第一步</strong></p>
<p><code>new</code> 是关键词，不可以直接覆盖。这里使用 <code>create</code> 来模拟实现 <code>new</code> 的效果。</p>
<p><code>new</code> 返回一个新对象，通过 <code>obj.__proto__ = Con.prototype</code> 继承构造函数的原型，同时通过 <code>Con.apply(obj, arguments)</code>调用父构造函数实现继承，获取构造函数上的属性（【进阶3-3期】）。</p>
<p>实现代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(),</span><br><span class="line"> <span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"> <span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"> <span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line"> <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">start</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&quot; car start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="title function_">create</span>(<span class="title class_">Car</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line">car.<span class="property">color</span>;</span><br><span class="line"><span class="comment">// black</span></span><br><span class="line"></span><br><span class="line">car.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">// black car start</span></span><br></pre></td></tr></table></figure>

<p>完美！</p>
<p><strong>模拟实现第二步</strong></p>
<p>上面的代码已经实现了 80%，现在继续优化。</p>
<p>构造函数返回值有如下三种情况：</p>
<ul>
<li>1、返回一个对象</li>
<li>2、没有 <code>return</code>，即返回 <code>undefined</code></li>
<li>3、返回<code>undefined</code> 以外的基本类型</li>
</ul>
<p><strong>情况1</strong>：返回一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">color, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;black&quot;</span>, <span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">car.<span class="property">color</span>;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">car.<span class="property">name</span>;</span><br><span class="line"><span class="comment">// &quot;BMW&quot;</span></span><br></pre></td></tr></table></figure>

<p>实例 <code>car</code> 中只能访问到<strong>返回对象中的属性</strong>。</p>
<p><strong>情况2</strong>：没有 <code>return</code>，即返回 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">color, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;black&quot;</span>, <span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">car.<span class="property">color</span>;</span><br><span class="line"><span class="comment">// black</span></span><br><span class="line"></span><br><span class="line">car.<span class="property">name</span>;</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>实例 <code>car</code> 中只能访问到<strong>构造函数中的属性</strong>，和情况1完全相反。</p>
<p><strong>情况3</strong>：返回<code>undefined</code> 以外的基本类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">color, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;new car&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;black&quot;</span>, <span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">car.<span class="property">color</span>;</span><br><span class="line"><span class="comment">// black</span></span><br><span class="line"></span><br><span class="line">car.<span class="property">name</span>;</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>实例 <code>car</code> 中只能访问到<strong>构造函数中的属性</strong>，和情况1完全相反，结果相当于没有返回值。</p>
<p><strong>所以</strong>需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 <code>obj</code>对象。</p>
<p>所以实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 1、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class="line">    <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"> <span class="comment">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line"> <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line"> <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数-柯里化"><a href="#高阶函数-柯里化" class="headerlink" title="高阶函数-柯里化"></a>高阶函数-柯里化</h1><p><strong>一、定义</strong></p>
<p>函数柯里化又叫部分求值，维基百科中对柯里化 (Currying) 的定义为：</p>
<blockquote>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<p>用大白话来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。使用一个简单的例子来介绍下，最常用的就是 add 函数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...args</span>) =&gt; args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入多个参数，执行 add 函数</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们实现了一个 currying 函数，支持一次传入一个参数</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="title function_">currying</span>(add);</span><br><span class="line"><span class="comment">// 封装第一个参数，方便重用</span></span><br><span class="line"><span class="keyword">let</span> addCurryOne = <span class="title function_">sum</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">addCurryOne</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">addCurryOne</span>(<span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>二、实际应用</strong></p>
<ul>
<li>1.延迟计算：部分求和，bind函数</li>
<li>2.动态创建函数：添加监听addEvent、惰性函数</li>
<li>3.参数复用：</li>
</ul>
<p><strong>1.延迟计算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b);</span><br><span class="line"></span><br><span class="line">// 简化写法</span><br><span class="line">function currying(func) &#123;</span><br><span class="line">    const args = [];</span><br><span class="line">    return function result(...rest) &#123;</span><br><span class="line">        if (rest.length === 0) &#123;</span><br><span class="line">          return func(...args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          args.push(...rest);</span><br><span class="line">         return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sum = currying(add);</span><br><span class="line">sum(1,2)(3); // 未真正求值</span><br><span class="line">sum(4);    // 未真正求值</span><br><span class="line">sum();     // 输出 10</span><br></pre></td></tr></table></figure>

<p><strong>bind函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;muyiy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const fun = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line"></span><br><span class="line">fun(); // muyiy</span><br><span class="line"></span><br><span class="line">// bind底层原因也是柯里化的实现</span><br><span class="line">Function.prototype.bind = function (context) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    // 第 1 个参数是指定的 this，截取保存第 1 个之后的参数</span><br><span class="line">  // arr.slice(begin); 即 [begin, end]</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1); </span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        // 此时的 arguments 是指 bind 返回的函数调用时接收的参数</span><br><span class="line">        // 即 return function 的参数，和上面那个不同</span><br><span class="line">       // 类数组转成数组</span><br><span class="line">        var bindArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">       // 执行函数</span><br><span class="line">        return self.apply( context, args.concat(bindArgs) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.动态创建函数</strong></p>
<p>每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断。这种情况下就非常适合使用柯里化方案来处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEvent</span> (type, el, fn, capture = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(type, fn, capture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">attachEvent</span>)&#123;</span><br><span class="line">        el.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addEvent = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">type, el, fn, capture</span>) &#123;</span><br><span class="line">            el.<span class="title function_">addEventListener</span>(type, fn, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">attachEvent</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">type, el, fn</span>) &#123;</span><br><span class="line">            el.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面这种实现方案就是一种典型的柯里化应用，在第一次的 <code>if...else if...</code> 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。</p>
<p><strong>当然可以使用惰性函数来实现</strong>这一功能，原理很简单，就是重写函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEvent</span> (type, el, fn, capture = <span class="literal">false</span>) &#123;</span><br><span class="line">   <span class="comment">// 重写函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        addEvent = <span class="keyword">function</span> (<span class="params">type, el, fn, capture</span>) &#123;</span><br><span class="line">            el.<span class="title function_">addEventListener</span>(type, fn, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">attachEvent</span>)&#123;</span><br><span class="line">        addEvent = <span class="keyword">function</span> (<span class="params">type, el, fn</span>) &#123;</span><br><span class="line">            el.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 执行函数，有循环爆栈风险</span></span><br><span class="line">   <span class="title function_">addEvent</span>(type, el, fn, capture); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用 <code>addEvent</code> 函数后，会进行一次环境判断，在这之后 <code>addEvent</code> 函数被重写，所以下次调用时就不会再次判断环境，可以说很完美了。</p>
<p><strong>3.参数复用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 改造前</span><br><span class="line">function isArray(obj) &#123; </span><br><span class="line">    return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function isNumber(obj) &#123;</span><br><span class="line">    return Object.prototype.toString.call(obj) === &#x27;[object Number]&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">[1, 2, 3].toString(); // &quot;1,2,3&quot;</span><br><span class="line">&#x27;123&#x27;.toString(); // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">// 改造后</span><br><span class="line">const toStr = Function.prototype.call.bind(Object.prototype.toString);</span><br><span class="line">toStr([1, 2, 3]);  // &quot;[object Array]&quot;</span><br><span class="line">toStr(&#x27;123&#x27;);   // &quot;[object String]&quot;</span><br></pre></td></tr></table></figure>

<p><strong>三、实现 currying 函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, length</span>) &#123;</span><br><span class="line">  length = length || fn.<span class="property">length</span>;  <span class="comment">// 注释 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;   <span class="comment">// 注释 2</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="property">length</span> &gt;= length <span class="comment">// 注释 3</span></span><br><span class="line">     ? fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)   <span class="comment">// 注释 4</span></span><br><span class="line">      : <span class="title function_">currying</span>(fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>, ...args), length - args.<span class="property">length</span>) <span class="comment">// 注释 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">currying</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度</li>
<li>注释 2：currying 包裹之后返回一个新函数，接收参数为 <code>...args</code></li>
<li>注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度</li>
<li>注释 4：满足要求，执行 fn 函数，传入新函数的参数</li>
<li>注释 5：不满足要求，递归 currying 函数，新的 fn 为 <code>bind</code> 返回的新函数（<code>bind</code> 绑定了 <code>...args</code> 参数，未执行），新的 length 为 fn 剩余参数的长度</li>
</ul>
<h1 id="Vue3-0入门-3"><a href="#Vue3-0入门-3" class="headerlink" title="Vue3.0入门_3"></a>Vue3.0入门_3</h1><h2 id="生命周期的变化"><a href="#生命周期的变化" class="headerlink" title="生命周期的变化"></a>生命周期的变化</h2><p>整体来看，变化不大，只是名字大部分需要 + <code>on</code>，功能上类似。使用上 Vue3 组合式 API 需要先引入；Vue2 选项 API 则可直接调用，如下所示。</p>
<table>
<thead>
<tr>
<th align="left">Vue2.x</th>
<th align="left">Vue3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">Not needed*</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">Not needed*</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">onBeforeMount</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">onMounted</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">onBeforeUpdate</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">onUpdated</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">onBeforeUnmount</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">onUnmounted</td>
</tr>
</tbody></table>
<p><strong>Tips：</strong> <code>setup</code>是围绕<code>beforeCreate</code>和<code>created</code>生命周期钩子运行的，所以不需要显式地去定义。</p>
<h2 id="多根节点"><a href="#多根节点" class="headerlink" title="多根节点"></a>多根节点</h2><p>Vue3 支持了多根节点组件，也就是<code>fragment</code>。</p>
<p>Vue2中，编写页面的时候，我们需要去将组件包裹在<code>&lt;div&gt;</code>中，否则报错警告</p>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>Vue3 提供 <code>Suspense</code>组件，允许程序在等待异步组件时渲染兜底的内容，如 loading ，使用户体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：<code>default</code>和<code>fallback</code>。<code>Suspense</code>确保加载完异步内容时显示默认插槽，并将<code>fallback</code>插槽用作加载状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tempalte&gt;</span><br><span class="line">   &lt;suspense&gt;</span><br><span class="line">     &lt;template #default&gt;</span><br><span class="line">       &lt;todo-list /&gt;</span><br><span class="line">     &lt;/template&gt;</span><br><span class="line">     &lt;template #fallback&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">         Loading...</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">     &lt;/template&gt;</span><br><span class="line">   &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>Vue3 提供<code>Teleport</code>组件可将部分DOM移动到 Vue app之外的位置。比如项目中常见的<code>Dialog</code>组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=dialogVisible = true&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;teleport to=body&gt;</span><br><span class="line">   &lt;div class=dialog v-if=dialogVisible&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

<h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><p>Vue2 是 <code>选项式API（Option API）</code>，一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期函数等），导致代码的可读性变差，需要上下来回跳转文件位置。Vue3 <code>组合式API（Composition API）</code>则很好地解决了这个问题，可将同一逻辑的内容写到一起。解决了 Vue2 <code>Mixin</code>的存在的命名冲突和数据来源不清，不同组件间配置化使用不够灵活。</p>
<p>除了增强了代码的可读性、内聚性，组合式API 还提供了较为完美的逻辑复用性方案，举个🌰，如下所示公用鼠标坐标案例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>mouse position &#123;&#123;x&#125;&#125; &#123;&#123;y&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span>  vue </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span>  ./useMousePosition </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> &#123;x, y&#125; = <span class="title function_">useMousePosition</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useMousePosition.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span>  vue </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    x.<span class="property">value</span> = e.<span class="property">pageX</span></span><br><span class="line">    y.<span class="property">value</span> = e.<span class="property">pageY</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>( mousemove , update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>( mousemove , update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>Vue2 响应式原理基础是<code>Object.defineProperty</code>；Vue3 响应式原理基础是<code>Proxy</code>。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。<br><strong>Tips：</strong> <code>writable</code> 和 <code>value</code> 与 <code>getter</code> 和 <code>setter</code> 不共存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> name =  瑾行 </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,  name , &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举（是否可通过for...in 或 Object.keys()进行访问）</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可配置（是否可使用delete删除，是否可再次设置属性）</span></span><br><span class="line">  <span class="comment">// value:   , // 任意类型的值，默认undefined</span></span><br><span class="line">  <span class="comment">// writable: true, // 可重写</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    name = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue2核心源码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="comment">// 一 key 一个 dep</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 key 的属性描述符，发现它是不可配置对象的话直接 return</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 getter 和 setter，并获取 val 值</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span>((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123; val = obj[key] &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归处理，保证对象中所有 key 被观察</span></span><br><span class="line">  <span class="keyword">let</span> childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 劫持 obj[key] 的 进行依赖收集</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span>(childOb) &#123;</span><br><span class="line">          <span class="comment">// 针对嵌套对象，依赖收集</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">// 触发数组响应式</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// set 派发更新 obj[key]</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(setter) &#123;</span><br><span class="line">      setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新值设置响应式</span></span><br><span class="line">    childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="comment">// 依赖通知更新</span></span><br><span class="line">    dep.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue2响应式缺陷：无法监听对象或数组新增、删除的元素。<br>Vue2 方案：针对常用数组原型方法<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>进行了hack处理；提供<code>Vue.set</code>监听对象/数组新增属性。对象的新增/删除响应，还可以<code>new</code>个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Proxy</code>是ES6新特性，通过第2个参数<code>handler</code>拦截目标对象的行为。相较于<code>Object.defineProperty</code>提供语言全范围的响应能力，消除了局限性。</p>
<p>基本用法：创建对象的代理，从而实现基本操作的拦截和自定义操作。</p>
<p> Vue3 的源码 reactive.ts </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadOnly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// collectionHandlers: 处理Map、Set、WeakMap、WeakSet</span></span><br><span class="line">  <span class="comment">// baseHandlers: 处理数组、对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如baseHandlers.ts 为例，使用Reflect.get而不是<code>target[key]</code>的原因是receiver参数可以把this指向getter调用时，而非Proxy构造时的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖收集</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: string | symbol, receiver: object</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 数组类型</span></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非数组类型</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象递归调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派发更新</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target: Target, key: string | symbol, value: unknown, receiver: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">    oldValue = target[key]</span><br><span class="line">    <span class="comment">// 因 ref 数据在 set value 时就已 trigger 依赖了，所以直接赋值 return 即可</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">      oldValue.<span class="property">value</span> = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象是否有 key 有 key set，无 key add</span></span><br><span class="line">    <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>Vue3 相比于 Vue2 虚拟DOM 上增加<code>patchFlag</code>字段。我们借助<code>Vue3 Template Explorer</code>来看。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>技术摸鱼<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气真不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染函数如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createElementVNode <span class="keyword">as</span> _createElementVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock, pushScopeId <span class="keyword">as</span> _pushScopeId, popScopeId <span class="keyword">as</span> _popScopeId &#125; <span class="keyword">from</span> vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_withScopeId</span> = n =&gt; (<span class="title function_">_pushScopeId</span>(scope-id),n=<span class="title function_">n</span>(),<span class="title function_">_popScopeId</span>(),n)</span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = &#123; <span class="attr">id</span>: app &#125;</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(h1, <span class="literal">null</span>, 技术摸鱼, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(p, <span class="literal">null</span>, 今天天气真不错, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(div, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(div, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意第 3 个<code>_createElementVNode</code>的第 4 个参数即<code>patchFlag</code>字段类型，字段类型情况如下所示。1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style等。除此之外，发现所有的静态节点，都保存为一个变量进行<code>静态提升</code>，可在重新渲染时直接引用，无需重新创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123; </span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>, <span class="comment">// 动态文本内容</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 动态类名</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 动态样式</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 动态属性，不包含类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">// 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">// 带有监听事件的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">// 不会改变子节点顺序的 fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 带有 key 属性的 fragment 或部分子节点</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,  <span class="comment">// 子节点没有 key 的fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">// 只会进行非 props 的比较</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">// 动态的插槽</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 静态节点，diff阶段忽略其子节点</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 代表 diff 应该结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件缓存"><a href="#事件缓存" class="headerlink" title="事件缓存"></a>事件缓存</h2><p>Vue3 的 <code>cacheHandler</code>可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。加一个<code>click</code>事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>技术摸鱼<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气真不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">onCLick</span>=<span class="string">()</span> =&gt;</span> &#123;&#125;&gt;<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染函数如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createElementVNode <span class="keyword">as</span> _createElementVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock, pushScopeId <span class="keyword">as</span> _pushScopeId, popScopeId <span class="keyword">as</span> _popScopeId &#125; <span class="keyword">from</span> vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_withScopeId</span> = n =&gt; (<span class="title function_">_pushScopeId</span>(scope-id),n=<span class="title function_">n</span>(),<span class="title function_">_popScopeId</span>(),n)</span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = &#123; <span class="attr">id</span>: app &#125;</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(h1, <span class="literal">null</span>, 技术摸鱼, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(p, <span class="literal">null</span>, 今天天气真不错, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_4 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(span, &#123; <span class="attr">onCLick</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;, [</span><br><span class="line">  <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(span)</span><br><span class="line">], -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(div, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(div, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    _hoisted_4</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Diff-优化"><a href="#Diff-优化" class="headerlink" title="Diff 优化"></a>Diff 优化</h2><p>结合上文与源码，patchFlag帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。Vue3 patchChildren 源码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchChildren</span>(<span class="params">n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取新老孩子节点</span></span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> c2 = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.<span class="property">shapeFlag</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理 patchFlag 大于 0 </span></span><br><span class="line">  <span class="keyword">if</span>(patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(patchFlag &amp;&amp; <span class="title class_">PatchFlags</span>.<span class="property">KEYED_FRAGMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 存在 key</span></span><br><span class="line">      <span class="title function_">patchKeyedChildren</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; els <span class="keyword">if</span>(patchFlag &amp;&amp; <span class="title class_">PatchFlags</span>.<span class="property">UNKEYED_FRAGMENT</span>) &#123;</span><br><span class="line">      <span class="comment">// 不存在 key</span></span><br><span class="line">      <span class="title function_">patchUnkeyedChildren</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 匹配是文本节点（静态）：移除老节点，设置文本节点</span></span><br><span class="line">  <span class="keyword">if</span>(shapeFlag &amp;&amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">      <span class="title function_">hostSetElementText</span>(container, c2 <span class="keyword">as</span> string)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点</span></span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="title function_">patchKeyedChildren</span>(c1, c2, container, anchor, parentComponent, parentSuspense,...)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">unmountChildren</span>(c1 <span class="keyword">as</span> <span class="title class_">VNode</span>[], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(prevShapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, )</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span>) &#123;</span><br><span class="line">        <span class="title function_">mountChildren</span>(c2 <span class="keyword">as</span> <span class="title class_">VNodeArrayChildren</span>, container,anchor,parentComponent,...)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>patchUnkeyedChildren 源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchUnkeyedChildren</span>(<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) &#123;</span><br><span class="line">  c1 = c1 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  c2 = c2 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> newLength = c2.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldLength, newLength)</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点</span></span><br><span class="line">    <span class="keyword">const</span> nextChild = (c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">Vnode</span>)) : <span class="title function_">normalizeVnode</span>(c2[i])</span><br><span class="line">    <span class="title function_">patch</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(oldLength &gt; newLength) &#123;</span><br><span class="line">    <span class="comment">// 移除多余的节点</span></span><br><span class="line">    <span class="title function_">unmountedChildren</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新的节点</span></span><br><span class="line">    <span class="title function_">mountChildren</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>patchKeyedChildren源码如下，有运用最长递增序列的算法思想:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> e2 = c2.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从头开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 </span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isSameVnodeType) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从尾开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 </span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[e2]</span><br><span class="line">    <span class="keyword">if</span>(isSameVnodeType) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    e1--</span><br><span class="line">    e2--</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 仅存在需要新增的节点</span></span><br><span class="line">  <span class="keyword">if</span>(i &gt; e1) &#123;    </span><br><span class="line">    <span class="keyword">if</span>(i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos] : parentAnchor</span><br><span class="line">      <span class="keyword">while</span>(i &lt;= e2) &#123;</span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i], container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 仅存在需要删除的节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= e1) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 新旧节点均未遍历完</span></span><br><span class="line">  <span class="comment">// [i ... e1 + 1]: a b [c d e] f g</span></span><br><span class="line">  <span class="comment">// [i ... e2 + 1]: a b [e d c h] f g</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s1 = i</span><br><span class="line">    <span class="keyword">const</span> s2 = i</span><br><span class="line">    <span class="comment">// 缓存新 Vnode 剩余节点 上例即&#123;e: 2, d: 3, c: 4, h: 5&#125;</span></span><br><span class="line">    <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">          ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">          : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; keyToNewIndexMap.<span class="title function_">has</span>(nextChild.<span class="property">key</span>)) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Duplicate keys found during update:`</span>,</span><br><span class="line">             <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(nextChild.<span class="property">key</span>),</span><br><span class="line">            <span class="string">`Make sure keys are unique.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 记录即将 patch 的 新 Vnode 数量</span></span><br><span class="line">  <span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 新 Vnode 剩余节点长度</span></span><br><span class="line">  <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 是否移动标识</span></span><br><span class="line">  <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> maxNewindexSoFar = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化 新老节点的对应关系（用于后续最大递增序列算法）</span></span><br><span class="line">  <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历老 Vnode 剩余节点</span></span><br><span class="line">  <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表当前新 Vnode 都已patch，剩余旧 Vnode 移除即可</span></span><br><span class="line">    <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> newIndex</span><br><span class="line">    <span class="comment">// 旧 Vnode 存在 key，则从 keyToNewIndexMap 获取</span></span><br><span class="line">    <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">      newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line">    <span class="comment">// 旧 Vnode 不存在 key，则遍历新 Vnode 获取</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp; <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>))&#123;</span><br><span class="line">           newIndex = j</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;           </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除、更新节点</span></span><br><span class="line">   <span class="comment">// 新 Vnode 没有 当前节点，移除</span></span><br><span class="line">   <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">     <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 旧 Vnode 的下标位置 + 1，存储到对应 新 Vnode 的 Map 中</span></span><br><span class="line">     <span class="comment">// + 1 处理是为了防止数组首位下标是 0 的情况，因为这里的 0 代表需创建新节点</span></span><br><span class="line">     newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 若不是连续递增，则代表需要移动</span></span><br><span class="line">     <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">       maxNewIndexSoFar = newIndex</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       moved = <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="title function_">patch</span>(prevChild,c2[newIndex],...)</span><br><span class="line">     patched++</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历结束，newIndexToOldIndexMap = &#123;0:5, 1:4, 2:3, 3:0&#125;</span></span><br><span class="line">  <span class="comment">// 新建、移动节点</span></span><br><span class="line">  <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">  <span class="comment">// 获取最长递增序列</span></span><br><span class="line">  ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">  : <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  </span><br><span class="line">  j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line">    <span class="keyword">const</span> anchor = extIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="comment">// 0 新建 Vnode</span></span><br><span class="line">    <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>,nextChild,...)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="comment">// 移动节点</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">        <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h2><blockquote>
<p>tree-shaking：模块打包<code>webpack</code>、<code>rollup</code>等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于<code>import</code>和<code>export</code>语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。</p>
</blockquote>
<p>以<code>nextTick</code>为例子，在 Vue2 中，全局 API 暴露在 Vue 实例上，即使未使用，也无法通过<code>tree-shaking</code>进行消除。</p>
<p>Vue3 中针对全局 和内部的API进行了重构，并考虑到<code>tree-shaking</code>的支持。因此，全局 API 现在只能作为ES模块构建的命名导出进行访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from  vue </span><br><span class="line">nextTick(() =&gt; &#123;</span><br><span class="line">  // 一些和DOM有关的东西</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过这一更改，只要模块绑定器支持<code>tree-shaking</code>，则 Vue 应用程序中未使用的api将从最终的捆绑包中消除，获得最佳文件大小。受此更改影响的全局API有如下。</p>
<ul>
<li>Vue.nextTick</li>
<li>Vue.observable （用 Vue.reactive 替换）</li>
<li>Vue.version</li>
<li>Vue.compile （仅全构建）</li>
<li>Vue.set （仅兼容构建）</li>
<li>Vue.delete （仅兼容构建）</li>
</ul>
<p>内部 API 也有诸如 transition、v-model等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。</p>
<p>根据 尤大 直播可以知道如今 Vue3 将所有运行功能打包也只有<code>22.5kb</code>，比 Vue2 轻量很多。</p>
<h2 id="自定义渲染API"><a href="#自定义渲染API" class="headerlink" title="自定义渲染API"></a>自定义渲染API</h2><p>Vue3 提供的<code>createApp</code>默认是将 template 映射成 html。但若想生成<code>canvas</code>时，就需要使用<code>custom renderer api</code>自定义render生成函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义runtime-render函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span>  ./runtime-render </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span>  ./src/<span class="title class_">App</span> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>( #app )</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-支持"><a href="#TypeScript-支持" class="headerlink" title="TypeScript 支持"></a>TypeScript 支持</h2><p>Vue3 由TS重写，相对于 Vue2 有更好地<code>TypeScript</code>支持。</p>
<ul>
<li>Vue2 <code>Option API</code>中 option 是个简单对象，而TS是一种类型系统，面向对象的语法，不是特别匹配。</li>
<li>Vue2 需要<code>vue-class-component</code>强化vue原生组件，也需要<code>vue-property-decorator</code>增加更多结合Vue特性的装饰器，写法比较繁琐。</li>
</ul>
<h1 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h1><p><strong>一、函数的声明与执行</strong></p>
<p>函数申明方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明函数fun0</span><br><span class="line">function fun0()&#123;</span><br><span class="line">    console.log(&quot;fun0&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行函数fun0</span><br><span class="line">fun0(); // fun0</span><br></pre></td></tr></table></figure>

<p>变量赋值方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明函数fun1 - 变量方式</span><br><span class="line">var fun1 = function()&#123;</span><br><span class="line">    console.log(&quot;fun1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行函数fun1</span><br><span class="line">fun1(); // fun1</span><br></pre></td></tr></table></figure>

<p><strong>二、 函数的一点猜想</strong></p>
<p>既然函数名加上括号<code>fun1()</code>就是执行函数。 <strong>思考：</strong>直接取赋值符号右侧的内容直接加个括号，是否也能执行？ 试验如下，直接加上小括弧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>以上会报错 line1：<code>Uncaught SyntaxError: Unexpected token (</code>。 <strong>分析：</strong> <code>function</code> 是声明函数关键字，若非变量赋值方式声明函数，默认其后面需要跟上函数名的。</p>
<p>加上函数名看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun2&quot;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>以上会报错 line3：<code>Uncaught SyntaxError: Unexpected token )</code>。 <strong>分析：</strong> 声明函数的结构花括弧后面不能有其他符号（比如此处的小括弧）。</p>
<p>不死心的再胡乱试一下，给它加个实参（表达式）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>不会报错，但不会输出结果<code>fun3</code>。 <strong>分析：</strong> 以上代码相当于在声明函数后，又声明了一个毫无关系的表达式。相当于如下代码形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若此处执行fun3函数，可以输出结果</span></span><br><span class="line"><span class="title function_">fun3</span>(); <span class="comment">//&quot;fun3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>三、自执行函数表达式</strong></p>
<p><strong>1. 正儿八经的自执行函数</strong></p>
<p>想要解决上面问题，可以采用小括弧将要执行的代码包含住（方式一），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">fun4</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun4&quot;</span>);</span><br><span class="line">    &#125;()); <span class="comment">// &quot;fun4&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>因为在JavaScript语言中，<code>()</code>里面不能包含语句（只能是表达式），所以解析器在解析到<code>function</code>关键字的时候，会把它们当作function表达式，而不是正常的函数声明。 </p>
<p>除了上面直接整个包含住，也可以只包含住函数体（方式二），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">fun5</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun5&quot;</span>);</span><br><span class="line">    &#125;)();<span class="comment">// &quot;fun4&quot;</span></span><br></pre></td></tr></table></figure>

<p>写法上建议采用方式一（这是参考文的建议。但实际上，我个人觉得方式二比较常见）。</p>
<p><strong>2. “歪瓜裂枣”的自执行函数</strong></p>
<p>除了上面<code>()</code>小括弧可以把<code>function</code>关键字作为函数声明的含义转换成函数表达式外，JavaScript的<code>&amp;&amp;</code> 与操作、<code>||</code>或操作、<code>,</code>逗号等操作符也有这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="literal">true</span> &amp;&amp; <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;true &amp;&amp;&quot;</span>) &#125; (); <span class="comment">// &quot;true &amp;&amp;&quot;</span></span><br><span class="line">    <span class="literal">false</span> || <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;true ||&quot;</span>) &#125; (); <span class="comment">// &quot;true ||&quot;</span></span><br><span class="line">    <span class="number">0</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;0,&quot;</span>) &#125; (); <span class="comment">// &quot;0,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处要注意： &amp;&amp;, || 的短路效应。即： false &amp;&amp; (表达式1)  是不会触发表达式1；</span></span><br><span class="line"><span class="comment">// 同理，true || (表达式2) 不会触发表达式2</span></span><br></pre></td></tr></table></figure>

<p>如果不在意返回值，也不在意代码的可读性，我们甚至还可以使用一元操作符（<code>!</code> <code>~</code> <code>-</code> <code>+</code> ），函数同样也会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!&quot;</span>); &#125; (); <span class="comment">//&quot;!&quot;</span></span><br><span class="line">~<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;~&quot;</span>); &#125; (); <span class="comment">//&quot;~&quot;</span></span><br><span class="line">-<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-&quot;</span>); &#125; (); <span class="comment">//&quot;-&quot;</span></span><br><span class="line">+<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;+&quot;</span>); &#125; (); <span class="comment">//&quot;+&quot;</span></span><br></pre></td></tr></table></figure>

<p>甚至还可以使用<code>new</code>关键字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：采用new方式，可以不要再解释花括弧 `&#125;` 后面加小括弧 `()` </span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new&quot;</span>); &#125; <span class="comment">//&quot;new&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要传递参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">function</span> (<span class="params">a</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(a); &#125; (<span class="string">&quot;newwwwwwww&quot;</span>); <span class="comment">//&quot;newwwwwwww&quot;</span></span><br></pre></td></tr></table></figure>

<p>嗯，最好玩的是赋值符号<code>=</code>同样也有此效用（例子中的<code>i</code>变量方式）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处 要注意区分 i 和 j 不同之处。前者是函数自执行后返回值给 i ；后者是声明一个函数，函数名为 j 。</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125; (); <span class="comment">// &quot;output i:&quot;</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output j:&quot;</span>); <span class="keyword">return</span> <span class="number">99</span>;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ƒ () &#123; console.log(&quot;output j:&quot;); return 99;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面提及到，要注意区分 <code>var i</code>和 <code>var j</code> 不同之处（前者是函数自执行后返回值给<code>i</code> ；后者是声明一个函数，函数名为<code>j</code>）。如果是看代码，我们需要查看代码结尾是否有没有<code>()</code>才能区分。一般为了方便开发人员阅读，我们会采用下面这种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> i2 = (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i2:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125; ()); <span class="comment">// &quot;output i2:&quot;</span></span><br><span class="line">    <span class="keyword">var</span> i3 = (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output i3:&quot;</span>); <span class="keyword">return</span> <span class="number">10</span>; &#125;) (); <span class="comment">// &quot;output i3:&quot;</span></span><br><span class="line"><span class="comment">// 以上两种都可以，但依旧建议采用第一种 i2 的方式。（个人依旧喜欢第二种i3方式）</span></span><br></pre></td></tr></table></figure>

<p><strong>四、自执行函数的应用</strong></p>
<p><strong>1. for循环 + setTimeout 例子</strong></p>
<p>因为是全局变量，所以输出都是同一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for( var i=0;i&lt;3;i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ,300);</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果 3,3,3</span><br></pre></td></tr></table></figure>

<p>那怎么样才能输出<code>1,2,3</code>呢？ 看看下面的方式（写法一）：把<code>setTimeout</code>代码包含在匿名自执行函数里面，就可以实现“锁住”索引<code>i</code>，正常输出索引值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">lockedIndex</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(lockedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：尽管循环执行结束，<code>i</code>值已经变成了3。但因遇到了自执行函数，当时的<code>i</code>值已经被 <code>lockedIndex</code>锁住了。也可以理解为 自执行函数属于for循环一部分，每次遍历<code>i</code>，自执行函数也会立即执行。所以尽管有延时器，但依旧会保留住立即执行时的<code>i</code>值。 <em>上面的分析有点模糊和牵强，也可以从</em> *<strong>闭包*</strong> <em>角度出发分析的。</em></p>
<p>除了上面的写法，也可以直接在 <code>setTimeout</code> 第一个参数做自执行（写法二），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">lockedInIndex</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(lockedInIndex);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. lockedInIndex变量，也可以换成i，因为和外面的i不在一个作用域</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自执行函数不带入参数 </span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3,3,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)()</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自执行函数只有实参没有写形参</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3,3,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1,2,3</span></span><br><span class="line">    &#125;)(i)</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 自执行函数只有形参没有写实参，这种情况不行。因为会导致输出 undefined。</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// undefined,undefined,undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="number">300</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// undefined,undefined,undefined</span></span><br><span class="line">    &#125;)()</span><br><span class="line">    ,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="任职资格"><a href="#任职资格" class="headerlink" title="任职资格"></a>任职资格</h1><p><strong>字节跳动</strong></p>
<p>1、本科及以上学历，扎实的计算机基础和前端基础；<br>2、熟练掌握React/Vue等大型前端框架，理解底层原理，能够灵活运用；<br>3、了解跨客户端/全栈 其中的一种技术体系，理解相关底层原理；<br>4、熟悉前端工程化相关及原理，具备良好的架构设计和工程设计能力；<br>5、有全栈实践，熟悉 Node/Python/Go 加分；<br>6、有跨端开发经验（React Native/Weex/Flutter）加分；<br>7、有Web游戏开发或引擎开发，音视频相关实践经验加分。</p>
<h1 id="Z-Typora常用用法"><a href="#Z-Typora常用用法" class="headerlink" title="Z_Typora常用用法"></a>Z_Typora常用用法</h1><h2 id="低层级目录"><a href="#低层级目录" class="headerlink" title="低层级目录"></a>低层级目录</h2><p>一、</p>
<p>1.</p>
<p>(1.)</p>
<p>a.</p>
<h1 id="一行代码让网站变成灰色"><a href="#一行代码让网站变成灰色" class="headerlink" title="一行代码让网站变成灰色"></a>一行代码让网站变成灰色</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将图像转换为灰度图像。值定义转换的比例。percent 值为 100% 则完全转为灰度图像，值为 0% 图像无变化。</span><br><span class="line">filter: grayscale(100%)</span><br></pre></td></tr></table></figure>

<h1 id="华为术语"><a href="#华为术语" class="headerlink" title="华为术语"></a>华为术语</h1><p>版本生命周期策略GA到EOS,一般GA-&gt;EOM-&gt;EOP-&gt;EOFS-&gt;EOS过程。</p>
<p>1，GA：发布，通用可获得性；</p>
<p>2，EOM：停止销售即停止接单，End of Marketing；</p>
<p>单板/部件EOM：停止接受单板、部件订单（包括新建订单、扩容和备件订单）；<br>产品EOM：停止接受该产品的订单（包括新建订单和扩容订单）；<br>版本EOM：停止接受该软件版本的订单（包括新建订单和扩容订单）；</p>
<p>3，EOP：停止生产，End of Production；</p>
<p>4，EOFS：停止全面支持，End of Full Support,对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复。</p>
<p>单板/部件EOFS: 该点之后对客户提供单板/部件服务标准降低，在EOFS日之后，备件维修服务不为客户提供修复保证，只解决Critical 和 Major 级别的问题；<br>版本EOFS：对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复；</p>
<p>5，EOS：停止服务和支持，End of Service and Support，不再提供针对该软件版本的服务支持，只能通过升级新版本来解决问题。</p>
<p>单板/部件EOS：指从该日起可不再提供该单板/部件任何服务；<br>产品EOS：从该日起不再提供该产品任何服务，包括电话支持；<br>版本EOS：不再提供任何技术服务支持，包含新问题的定位和缺陷修复；</p>
<p>在EOFS、EOS阶段出补丁需要通过例外备案、审批。</p>
<h1 id="如何成为一个优秀的人"><a href="#如何成为一个优秀的人" class="headerlink" title="如何成为一个优秀的人"></a>如何成为一个优秀的人</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.要顾全的大局</span><br><span class="line">  不要为了自己的一点私心去做事，大家嘴上不说但都看的到。多了大局去考虑，领导就喜欢这样的人，也愿意提拔爱顾大局的人。</span><br><span class="line"></span><br><span class="line">2.做事不古板</span><br><span class="line">  在团队里随时都能发生应急事件，遵守规则制度是应该的。但不可事事太古板，要懂得随机应变，有了处理好应急事件的能力。</span><br><span class="line"></span><br><span class="line">3.不逃避责任</span><br><span class="line">  在发生事故的时候，不要逃避责任，更不要给自己找垫背的。优秀的人才都是能够承担责任的，事故不可能总有，也不可能总没有，如果次次都选择逃避，还怎么做优秀</span><br><span class="line">  人物。</span><br><span class="line"></span><br><span class="line">4.愿意帮助每个队员</span><br><span class="line">  收拢人心很要，你能力再强，别人又为什么要选你呢，那是因为你身上有闪光点。而对队员来说，你对大家给予的真诚帮助，就能帮你赢得一大片人心。</span><br><span class="line"></span><br><span class="line">5.取长补短</span><br><span class="line">  这也是最重要的一条，你拥有了别人不会的技术，又是团队必须具备的技术。你就成了技术骨干了，多去学习别的长处，将自身的短处补齐。</span><br></pre></td></tr></table></figure>

<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="思想先行"><a href="#思想先行" class="headerlink" title="思想先行"></a>思想先行</h2><p><strong>TDD：Test-Driven Development（测试驱动开发）</strong></p>
<blockquote>
<p>TDD 则要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行</p>
</blockquote>
<p><strong>BDD：Behavior-Driven Development（行为驱动开发）</strong></p>
<blockquote>
<p>BDD 可以让项目成员（甚至是不懂编程的）使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试</p>
</blockquote>
<h2 id="为什么要测试？"><a href="#为什么要测试？" class="headerlink" title="为什么要测试？"></a>为什么要测试？</h2><ul>
<li>提高代码质量</li>
<li>准确定位问题</li>
<li>方便迭代/重构</li>
<li>最大程度保证产品符合预期</li>
<li>减少回归流程</li>
<li>提升开发者信心和安全感</li>
</ul>
<h2 id="测试类型有哪些？"><a href="#测试类型有哪些？" class="headerlink" title="测试类型有哪些？"></a>测试类型有哪些？</h2><ul>
<li><strong>单元测试（Unit Test）</strong></li>
<li><strong>集成测试（Integration Test）</strong></li>
<li><strong>UI 测试（UI Test）</strong></li>
</ul>
<p><strong>单元测试（Unit Test）</strong></p>
<blockquote>
<p>单元测试是最容易实现的：代码中多个组件共用的工具类库、多个组件共用的子组件等。</p>
<p><strong>通常情况下，在公共函数/组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。</strong></p>
<p>能进行单元测试的函数/组件，一定是低耦合的，这也从一定程度上保证了我们的代码质量。</p>
</blockquote>
<p><strong>集成测试（Integration Test）</strong></p>
<blockquote>
<p>集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。</p>
<p>集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。</p>
</blockquote>
<p><strong>UI 测试（UI Test）</strong></p>
<blockquote>
<p>UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。</p>
<p>UI 测试（UI Test）更贴近于我们的开发流程。在前后端分离的开发模式中，前端开发通常会使用到 Mock 的服务器和数据。因而我们需要在开发基本完成后进行相应的 UI 测试（UI Test）。</p>
<p>UI 测试的自动化程度还不高，大多数还依赖于手工测试。</p>
<p>在一些自动化测试工具中有创建快照的功能，也能帮助我们在一定程度上实现 UI 测试（UI Test）的自动化。</p>
</blockquote>
<h2 id="哪些项目适合自动化测试？"><a href="#哪些项目适合自动化测试？" class="headerlink" title="哪些项目适合自动化测试？"></a>哪些项目适合自动化测试？</h2><p>大部分的开发都会觉得：需求这么多，这么紧急，保证完成需求都已经非常困难了，已经没精力再编写测试代码了。</p>
<p>现实中，我们经常会针对一些活动开发一些一次性的代码模块，这样的代码模块功能简单，且后续继续迭代的可能性低，这种代码就完全没有必要引入自动化测试工具。</p>
<p><strong>适合引入自动化测试的场景：</strong></p>
<ol>
<li>公共库类的开发维护</li>
<li>中长期项目的迭代/重构</li>
<li>引用了不可控的第三方依赖</li>
</ol>
<p>这些场景是需要引入自动化测试来对现有代码进行约束的。<strong>尤其是中长期项目，迭代/重构时人力回归困难，自动化测试就显得尤为重要！</strong></p>
<h2 id="测试工具有哪些？"><a href="#测试工具有哪些？" class="headerlink" title="测试工具有哪些？"></a>测试工具有哪些？</h2><ul>
<li>单元测试（Unit Test）有 Mocha, Ava, Karma, Jest, Jasmine 等。</li>
<li>集成测试（Integration Test）和 UI 测试（UI Test）有 ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils 等。</li>
</ul>
<p><strong>Mocha</strong></p>
<blockquote>
<p>Mocha 是生态最好，使用最广泛的单测框架，但是他需要较多的配置来实现它的高扩展性。</p>
</blockquote>
<p><strong>Ava</strong></p>
<blockquote>
<p>Ava 是更轻量高效简单的单测框架，但是自身不够稳定，并发运行文件多的时候会撑爆 CPU。</p>
</blockquote>
<p><strong>Jasmine</strong></p>
<blockquote>
<p>Jasmine 是单测框架的“元老”，开箱即用，但是异步测试支持较弱。</p>
</blockquote>
<p><strong>Jest</strong></p>
<blockquote>
<p>Jest 基于 Jasmine, 做了大量修改并添加了很多特性，同样开箱即用，但异步测试支持良好。</p>
</blockquote>
<p><strong>Karma</strong></p>
<blockquote>
<p>Karma 能在真实的浏览器中测试，强大适配器，可配置其他单测框架，一般会配合 Mocha 或 Jasmine 等一起使用。</p>
</blockquote>
<p>每个框架都有自己的优缺点，没有最好的框架，只有最适合的框架。</p>
<p>Vue和React 的默认测试框架是 Jest，Augular 的默认测试框架就是 Karma + Jasmine</p>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><p>javascript dom编程艺术</p>
<p>javascript高级程序设计（红宝书） 和javascript权威指南（犀牛书）</p>
<p>Vuejs设计与实现</p>
<p>javascript忍者秘籍</p>
<p>javascript设计模式与开发实践</p>
<p>学习javascript数据结构和算法</p>
<p>前端开发核心知识进阶</p>
<p>javascript迷你正则书</p>
<p>你不知道的javascript （小黄书）</p>
<p>Javascript20周年（历史书）</p>
<p>javascript语言精粹与编程实践</p>
<p>啊哈算法，小灰说算法</p>
<h1 id="掘金夜谈-第一期尤雨溪对话Vue"><a href="#掘金夜谈-第一期尤雨溪对话Vue" class="headerlink" title="掘金夜谈-第一期尤雨溪对话Vue"></a>掘金夜谈-第一期尤雨溪对话Vue</h1><p>视频地址：<a target="_blank" rel="noopener" href="https://live.juejin.cn/4354/vue3">尤大对话</a></p>
<p><strong>尤对吐槽</strong></p>
<p>尤对吐槽 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020">React</a> hooks 的缺点：心智负担，闭包陷阱，useEffect 的依赖项等等.</p>
<p>其实不然。</p>
<blockquote>
<p>首先闭包陷阱的由来在于大家对于闭包的理解不够深刻，因此在使用部分 hooks 的时候，对于某些闭包的产生无法感知到。实际上闭包陷阱的逻辑如果成立的话，并不仅仅存在于 React hooks 中，而是存在于 JavaScript 的所有可能出现的场景。特别是匿名函数这种弱感知的场景。</p>
<p>useEffect 的依赖问题其实在我看来不仅不是 hooks 的缺点，反而是 hooks 的优点。useEffect 的依赖项能够帮助我们监听单一数据以驱动多个数据，于是我们就可以借助这个特性完成单数据驱动多数据，再由多数据驱动 UI 的开关思维。能够极大的简化我们的开发，提升开发效率。</p>
</blockquote>
<p><strong>Vue3尖锐问题</strong></p>
<p>1.vue3 与 ts 的结合</p>
<p> vue3 与 ts 的结合不够完善的事情。主要是 props 的定义方式与泛型组件的问题。</p>
<blockquote>
<p>尤大解释：Props 值定义确实是一个兼容性导致的包袱。但是在 <script setup> 下已经支持直接用 defineProps<{...}> 类型声明 props 了（自动编译为对应的值声明）。</p>
</blockquote>
<p>2.Vue3不支持跨端</p>
<p> Vue 团队没有精力去做这些事情，只有公司级别的体量才有能力去做，因为跨端的支持确实很复杂。</p>
<p><strong>Vue4新变化</strong></p>
<p>vue 会借鉴 solid 的编译模式。solid 是一个摈弃了虚拟 DOM，走编译型路线的框架，别的不说，他的性能是能吊打目前的 Vue 与 React。</p>
<p><strong>郭辉：低代码，无代码</strong></p>
<p>财务公司(金蝶)在低代码做得非常成熟，但是呢，大多数团队都做得不是很好。主要的原因在于许多场景业务逻辑比较复杂，不通用，无法抽象。也就导致了低代码的实现成为了一种愿景。</p>
<p>许多团队在攻克组件渲染这一层的东西，但是实际上这些都是比较简单的，不是项目的核心痛点。也就是说，郭老师觉得他们的方向走错了。</p>
<p>低代码仅仅只适合逻辑抽象比较简单，比较通用的场景。例如发票。业务逻辑抽象比较容易。toB 的业务逻辑是无法解决的。</p>
<h1 id="args剩余参数与arguments函数形参类数组"><a href="#args剩余参数与arguments函数形参类数组" class="headerlink" title="args剩余参数与arguments函数形参类数组"></a>args剩余参数与arguments函数形参类数组</h1><p><strong>args</strong></p>
<p>定义：只包含那些没有对应形参的实参。将所有后面剩余的是实参个数包裹成一个数组。</p>
<ul>
<li>展开运算符</li>
<li>用于解构赋值</li>
<li>类数组对象变成数组</li>
</ul>
<blockquote>
<p><strong>var</strong> arr1=[‘a’,’b’,’c’]; <strong>var</strong> arr2=[‘d’,’e’];arr1.<strong>push</strong>(…arr2)</p>
<p><strong>let</strong> b=[…new Set([1,2])]</p>
</blockquote>
<p><strong>arguments对象</strong></p>
<p>1.定义：包含了传给函数的所有实参。在函数代码中，使用特殊对象 <code>arguments</code>，开发者无需明确指出参数名，就能访问它们。它是一个类数组，不是数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>) <span class="comment">// Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ] </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">length</span>) <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">length</span>) <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">其中<span class="variable language_">arguments</span> 代表的是函数实参的个数</span><br><span class="line">其中fn.<span class="property">length</span> 代表函数形参的个数</span><br><span class="line">其中<span class="variable language_">arguments</span>.<span class="property">callee</span> 指向函数本身</span><br></pre></td></tr></table></figure>

<p>2.提取参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>警告：</strong> 对参数使用 slice 会阻止某些 JavaScript 引擎中的优化 (比如 V8 - <a target="_blank" rel="noopener" href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments">更多信息</a>)。如果你关心性能，尝试通过遍历 arguments 对象来构造一个新的数组。另一种方法是使用被忽视的<code>Array</code>构造函数作为一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.一般模式和严格模式下arguments</p>
<ul>
<li>一般模式：如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的</li>
<li>严格模式：arguments和参数是双向绑定的</li>
</ul>
<p>(1)一般模式</p>
<p>直接上代码，先来看调用时缺省参数的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a1(x) &#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a1(); // 2 undefined</span><br><span class="line"></span><br><span class="line">function a2(x) &#123;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a2(); // undefined 2</span><br></pre></td></tr></table></figure>

<p>再来看调用时传入参数的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a3(x) &#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a3(1); // 2 2</span><br><span class="line"></span><br><span class="line">function a4(x) &#123;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">a4(1); // 2 2</span><br></pre></td></tr></table></figure>

<p>可以看到如果缺省参数，arguments和参数是隔离开的；如果传入参数，arguments和参数是双向绑定的。</p>
<p>(2)严格模式</p>
<p>再来看看严格模式，直接上代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function b1(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b1(); // 2 undefined</span><br><span class="line"></span><br><span class="line">function b2(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b2(); // undefined 2</span><br><span class="line"></span><br><span class="line">function b3(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b3(1); // 2 1</span><br><span class="line"></span><br><span class="line">function b4(x) &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    arguments[0] = 2;</span><br><span class="line">    console.log(x, arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">b4(1); // 1 2</span><br></pre></td></tr></table></figure>

<p>在严格模式下，无论参数是否缺省，arguments和参数都是隔离开的。</p>
<h1 id="CJS-AMD-UMD-和-ESM是什么"><a href="#CJS-AMD-UMD-和-ESM是什么" class="headerlink" title="CJS, AMD, UMD 和 ESM是什么"></a>CJS, AMD, UMD 和 ESM是什么</h1><ul>
<li>由于 <code>ESM</code> 具有简单的语法，异步特性和可摇树性，因此它是最好的模块化方案</li>
<li><code>UMD</code> 随处可见，通常在 <code>ESM</code> 不起作用的情况下用作备用</li>
<li><code>CJS</code> 是同步的，适合后端</li>
<li><code>AMD</code> 是异步的，适合前端</li>
</ul>
<p><strong>1.CJS</strong></p>
<p><code>CJS</code> 是 <code>CommonJS</code> 的缩写。经常我们这么使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// importing </span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="built_in">require</span>(<span class="string">&#x27;./doSomething.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// exporting</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>很多人可以从 <code>Node</code> 中立刻认出 <code>CJS</code> 的语法。这是因为 <code>Node</code> 就是使用 <a href="https://link.juejin.cn/?target=https://blog.risingstack.com/node-js-at-scale-module-system-commonjs-require/"><code>CJS</code> 模块</a>的</li>
<li><code>CJS</code> 是同步导入模块</li>
<li>你可以从 <code>node_modules</code> 中引入一个库或者从本地目录引入一个文件 。如 <code>const myLocalModule = require(&#39;./some/local/file.js&#39;)</code> 或者 <code>var React = require(&#39;react&#39;);</code> ，都可以起作用</li>
<li>当 <code>CJS</code> 导入时，它会给你一个导入对象的副本</li>
<li><code>CJS</code> 不能在浏览器中工作。它必须经过转换和打包</li>
</ul>
<p><strong>2.AMD</strong></p>
<p><code>AMD</code> 代表异步模块定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;dep1&#x27;</span>, <span class="string">&#x27;dep2&#x27;</span>], <span class="keyword">function</span> (<span class="params">dep1, dep2</span>) &#123;</span><br><span class="line">    <span class="comment">//Define the module value by returning a value.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">或者</span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">&#x27;dep1&#x27;</span>),</span><br><span class="line">        dep2 = <span class="built_in">require</span>(<span class="string">&#x27;dep2&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AMD</code> 是异步(<code>asynchronously</code>)导入模块的(因此得名)</li>
<li>一开始被提议的时候，<code>AMD</code> 是为前端而做的(而 <code>CJS</code> 是后端)</li>
<li><code>AMD</code> 的语法不如 <code>CJS</code> 直观。我认为 <code>AMD</code> 和 <code>CJS</code> 完全相反</li>
</ul>
<p><strong>3.UMD</strong></p>
<p><code>UMD</code> 代表通用模块定义（<code>Universal Module Definition</code>）</p>
<ul>
<li>在前端和后端都适用（“通用”因此得名）</li>
<li>兼容 CommonJS 和 AMD 规范</li>
<li>当使用 <code>Rollup/Webpack</code> 之类的打包器时，<code>UMD</code> 通常用作备用模块</li>
</ul>
<p><strong>4.ESM</strong></p>
<p><code>ESM</code> 代表 <code>ES</code> 模块。这是 <code>Javascript</code> 提出的实现一个标准模块系统的方案.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./myLib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// your Function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">function1</span>() &#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">function2</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在很多<a href="https://link.juejin.cn/?target=https://caniuse.com/es6-module">现代浏览器</a>可以使用</li>
<li>它兼具两方面的优点：具有 <code>CJS</code> 的简单语法和 <code>AMD</code> 的异步</li>
<li>得益于 <code>ES6</code> 的<a href="https://link.juejin.cn/?target=https://exploringjs.com/es6/ch_modules.html%23sec_design-goals-es6-modules">静态模块结构</a>，可以进行 <a href="https://link.juejin.cn/?target=https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/"> Tree Shaking</a></li>
<li><code>ESM</code> 允许像 <code>Rollup</code> 这样的打包器，<a href="https://link.juejin.cn/?target=https://dev.to/bennypowers/you-should-be-using-esm-kn3">删除不必要的代码</a>，减少代码包可以获得更快的加载</li>
<li>可以在 <code>HTML</code> 中调用，只要如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;func1&#125; <span class="keyword">from</span> <span class="string">&#x27;my-lib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">func1</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p>初始化项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://anandasuper.top/2022/12/11/%E6%A8%A1%E6%9D%BF2/" title="" target="_blank" rel="external">http://anandasuper.top/2022/12/11/模板2/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">昵称</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/" title="插件"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" title="E_左神"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>