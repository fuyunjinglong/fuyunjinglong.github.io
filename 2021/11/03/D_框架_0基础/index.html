<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>0基础 | Hexo</title>
  <meta name="description" content="canvas和svg技术 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。 从渲染模式上来说，Canvas属于 即时模式，而SVG则是 保留模式 ,这两种模式的区别可以参见 cshao 的博文： http:&#x2F;&#x2F;www.lifelaf.com&#x2F;blog&#x2F;?p&#x3D;354。 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。">
<meta property="og:type" content="article">
<meta property="og:title" content="0基础">
<meta property="og:url" content="http://anandasuper.top/2021/11/03/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="canvas和svg技术 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。 从渲染模式上来说，Canvas属于 即时模式，而SVG则是 保留模式 ,这两种模式的区别可以参见 cshao 的博文： http:&#x2F;&#x2F;www.lifelaf.com&#x2F;blog&#x2F;?p&#x3D;354。 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://anandasuper.top/img/image-20220124072950469.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211012230610276.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20220113072406138.png">
<meta property="og:image" content="http://anandasuper.top/img/image-20211212174443165.png">
<meta property="article:published_time" content="2021-11-02T22:33:16.000Z">
<meta property="article:modified_time" content="2023-02-19T09:34:49.175Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://anandasuper.top/img/image-20220124072950469.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://anandasuper.top/2021/11/03/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">昵称</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AA-%E9%9D%A2%E8%AF%95/">AA_面试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/A-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">A_编码规范</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/B-JS/">B_JS</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-H5%E5%92%8CCSS/">C_H5和CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">F_计算机网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/G-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">G_性能优化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/I-%E7%A7%BB%E5%8A%A8%E7%AB%AF/">I_移动端</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/J-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">J_设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>


    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/H-%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9/">H_工程和热点</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/12/H_%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%83%AD%E7%82%B9_%E6%8F%92%E4%BB%B6/" class="title">插件</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-11T23:33:16.000Z" itemprop="datePublished">2023-01-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/12/11/%E6%A8%A1%E6%9D%BF2/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-11T04:20:22.712Z" itemprop="datePublished">2022-12-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">E_数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/13/E_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B7%A6%E7%A5%9E/" class="title">E_左神</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-12T23:33:16.000Z" itemprop="datePublished">2022-11-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/10/22/Test/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-22T08:05:41.618Z" itemprop="datePublished">2022-10-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Z-%E4%B8%9A%E5%8A%A1%E5%92%8C%E9%9D%A2%E7%BB%8F/">Z_业务和面经</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/12/Z_%E4%B9%A6%E5%8D%95/" class="title">书单</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-12T00:33:16.000Z" itemprop="datePublished">2022-09-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#canvas%E5%92%8Csvg%E6%8A%80%E6%9C%AF"><span class="toc-text">canvas和svg技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VUE"><span class="toc-text">VUE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-text">数据响应式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95"><span class="toc-text">Vue虚拟dom和diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%BC%A0%E5%80%BC"><span class="toc-text">组件通信传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90-%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90-%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90-%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90"><span class="toc-text">接口权限-路由权限-菜单权限-按钮权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">vue源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#methods%E5%92%8Cwatch%E3%80%81computed"><span class="toc-text">methods和watch、computed**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive%E5%8E%9F%E7%90%86"><span class="toc-text">keep-alive原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E4%BA%A7%E7%94%9F%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">v-if产生的内存泄漏问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">父组件监听子组件的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nexttick%E5%8E%9F%E7%90%86"><span class="toc-text">$nexttick原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90"><span class="toc-text">web三大框架解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%902"><span class="toc-text">web三大框架解析2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E8%AF%A6%E8%A7%A3"><span class="toc-text">React详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%AF%A6%E8%A7%A3"><span class="toc-text">Vue详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91"><span class="toc-text">模板编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-text">插件原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E5%BB%BA%E8%AE%AE"><span class="toc-text">技术选型建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue2-0%E4%B8%8Evue3-0%E5%B7%AE%E5%88%AB"><span class="toc-text">vue2.0与vue3.0差别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B9%B6npm%E5%8F%91%E5%B8%83"><span class="toc-text">vue封装自己的组件库并npm发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NodeJS"><span class="toc-text">NodeJS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DevOps"><span class="toc-text">DevOps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B6%E7%BA%A7%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-text">顶级开发工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Echart"><span class="toc-text">Echart</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#clear%E5%92%8Cdispose"><span class="toc-text">clear和dispose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Echart%E6%B8%B2%E6%9F%93%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE"><span class="toc-text">Echart渲染百万数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E6%B8%B2%E6%9F%93%E6%94%B9%E5%A2%9E%E9%87%8F"><span class="toc-text">全量渲染改增量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sampling%E9%99%8D%E9%87%87%E6%A0%B7"><span class="toc-text">sampling降采样</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-D_框架_0基础" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      0基础
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/11/03/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/" class="article-date">
	  <time datetime="2021-11-02T22:33:16.000Z" itemprop="datePublished">2021-11-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/D-%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/">D_框架和类库</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/11/03/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="canvas和svg技术"><a href="#canvas和svg技术" class="headerlink" title="canvas和svg技术"></a>canvas和svg技术</h1><ol>
<li>从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。</li>
<li>从渲染模式上来说，Canvas属于 <strong>即时模式</strong>，而SVG则是 <strong>保留模式</strong> ,这两种模式的区别可以参见 cshao 的博文： <a target="_blank" rel="noopener" href="http://www.lifelaf.com/blog/?p=354%E3%80%82">http://www.lifelaf.com/blog/?p=354。</a></li>
<li>从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。</li>
<li>从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的<strong>Javascript</strong> API对整个画布进行操作的，而SVG则是基于<strong>XML</strong>元素的。</li>
<li>从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。</li>
<li>关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。关于SVG和Canvas的运行场景可参考MSCN关于 **<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/zh-cn/ie/hh377884">如何为您的网站在Canvas和SVG之间做出选择</a>**：</li>
<li>从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索</li>
</ol>
<p><img src="/img/image-20220124072950469.png" alt="image-20220124072950469"></p>
<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="数据响应式"><a href="#数据响应式" class="headerlink" title="数据响应式"></a>数据响应式</h2><p><strong>数据响应式</strong></p>
<p>首先要了解vue的初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化生命周期*/</span></span><br><span class="line"><span class="title function_">initLifecycle</span>(vm)</span><br><span class="line"><span class="comment">/*初始化事件*/</span></span><br><span class="line"><span class="title function_">initEvents</span>(vm)<span class="title class_">Object</span>.<span class="property">defineProperty</span> </span><br><span class="line"><span class="comment">/*初始化render*/</span></span><br><span class="line"><span class="title function_">initRender</span>(vm)</span><br><span class="line"><span class="comment">/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line"><span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line"><span class="comment">/*初始化props、methods、data、computed与watch*/</span></span><br><span class="line"><span class="title function_">initState</span>(vm)</span><br><span class="line"><span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line"><span class="comment">/*调用created钩子函数并且触发created钩子事件*/</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>initState(vm)</strong> 是用来初始化props,methods,data,computed和watch;<strong>initState</strong>中的<strong>initData</strong>为关键一步。</p>
<p><strong>initData</strong>做了两件事：1将_data上面的数据代理到vm；2执行observe()，将所有data变成可观察的。</p>
<p>关键3步：</p>
<p>1）Observer.defineProperty劫持data中的每一个属性添加<code>getter</code>和<code>setter</code>即数据劫持</p>
<p>2）创建<code>dep</code>和<code>watcher</code>进行<code>依赖收集</code>和<code>派发更新</code>，即订阅发布</p>
<p>3）通过<code>diff</code>算法对比新旧vnode差异，通过<code>patch</code>即时更新DOM</p>
<p>简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。Observer与Dep是1对1，Dep和Watcher是多对多。</p>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h2><ul>
<li>Vue是单向数据流，不是双向绑定</li>
<li>Vue的双向绑定不过是语法糖，v-bind数据绑定 与 v-on处理函数绑定</li>
<li>Object.definePropert是用来做响应式更新的</li>
</ul>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;AnalysisSub v-model=&quot;phoneInfo&quot; :zip-code.sync=&quot;zipCode&quot; /&gt;</span><br><span class="line">或 &lt;AnalysisSub :phone-info=&quot;phoneInfo&quot; @change=&quot;val =&gt; (phoneInfo = val)&quot;</span><br><span class="line">    :zip-code=&quot;zipCode&quot;  @update:zipCode=&quot;val =&gt; (zipCode = val)&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      :value=&quot;phoneInfo.phone&quot;</span><br><span class="line">      type=&quot;number&quot;</span><br><span class="line">      placeholder=&quot;手机号&quot;</span><br><span class="line">      @input=&quot;handlePhoneChange&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      :value=&quot;zipCode&quot;</span><br><span class="line">      type=&quot;number&quot;</span><br><span class="line">      placeholder=&quot;邮编&quot;</span><br><span class="line">      @input=&quot;handleZipCodeChange&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;PersonalInfo&quot;,</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &quot;phoneInfo&quot;, // 默认 value</span><br><span class="line">    event: &quot;change&quot; // 默认 input</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    phoneInfo: Object,</span><br><span class="line">    zipCode: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handlePhoneChange(e) &#123;</span><br><span class="line">      this.$emit(&quot;change&quot;, &#123;</span><br><span class="line">        ...this.phoneInfo,</span><br><span class="line">        phone: e.target.value</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleZipCodeChange(e) &#123;</span><br><span class="line">      this.$emit(&quot;update:zipCode&quot;, e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</span><br><span class="line">在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</span><br><span class="line">v-model和.sync修饰符分别在组件单个属性、多个属性需要双向绑定下使用，这是二者使用的场景。引入sync标记。这种双向的改变可以灵活控制，但是会带来维护上的复杂性</span><br></pre></td></tr></table></figure>

<p><strong>Object.defineProperty 与 Proxy</strong></p>
<p>1.Object.defineProperty：<br>只能对属性进行劫持，需要递归遍历对象的每个属性，执行Object.defineProperty把每一层对象数据都变成响应式的（如果定义的响应式数据过于复杂，会有很大的性能负担）<br>不能检测对象属性的添加和删除（需要重新遍历）<br>2.Proxy<br>在getter中去递归响应式，真正访问到的内部对象才会变成响应式，而不是无脑递归，提升了性能<br>劫持的是整个对象，能检测到对象属性的添加和删除</p>
<h2 id="Vue虚拟dom和diff算法"><a href="#Vue虚拟dom和diff算法" class="headerlink" title="Vue虚拟dom和diff算法"></a>Vue虚拟dom和diff算法</h2><p>原理：虚拟dom和diff算法</p>
<p><strong>虚拟DOM</strong></p>
<p>好处：</p>
<ol>
<li>减少直接操作DOM。框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom，同时也使得数据驱动视图</li>
<li>为函数式UI编程提供可能（React核心思想）</li>
<li>可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex</li>
</ol>
<p>虚拟DOM就是一个普通的JavaScript对象，包含了<code>tag</code>、<code>props</code>、<code>children</code>三个属性。</p>
<p>真实dom非常复杂，包括各种属性和事件方法等。</p>
<p>简单场景下真实dom效率高，复杂场景下，操作虚拟dom效率高。</p>
<p><strong>diff算法</strong></p>
<p>虚拟DOM + Diff算法才是vue提高性能的关键，<strong>Diff算法是一种对比算法</strong>，<strong>执行差异化补丁更新</strong>。对比两者是<code>旧虚拟DOM和新虚拟DO</code>。</p>
<p>Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code>。</p>
<p>直到oldNodeStart&gt;=oldNodeEnd&amp;&amp;newNodeStart&gt;=newNodeEnd不符合条件，diff算法才最终结束。</p>
<p>vue的diff算法参考了<code>snabbdom</code>(<a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom)%E6%98%AF%E8%91%97%E5%90%8D%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%BA%93%EF%BC%8Cdiff%E7%AE%97%E6%B3%95%E7%9A%84%E9%BC%BB%E7%A5%96%E3%80%82">https://github.com/snabbdom/snabbdom)是著名的虚拟DOM库，diff算法的鼻祖。</a></p>
<p><img src="/img/image-20211012230610276.png" alt="image-20211012230610276"></p>
<p>1.patch中的sameVnode方法：判断是否为相同节点：依据key和tag标签名</p>
<ul>
<li>是：继续执行<code>patchVnode方法</code>进行深层比对</li>
<li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li>
</ul>
<p><em>key值是否一样</em>；<em>标签名是否一样</em>；<em>否都为注释节点</em>；<em>是否都定义了data</em></p>
<p>2.patchVnode：更新节点</p>
<ul>
<li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li>
<li>如果他们都是文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li>
<li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li>
</ul>
<p>3.<code>updateChildren</code>：首尾指针法</p>
<blockquote>
<p><strong>「双端比较的算法」</strong>过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较.</p>
</blockquote>
<p>oldNode头尾指针标记，newNode头尾指针标记。</p>
<p>oldNode与newNode指针逐个比较，如果判定相同节点，则执行patchVnode更新节点。</p>
<p>否则以newNode的key去oldNode中寻找等key值，如果找到key相等的，再比较sameVnode，如果相同，则patchVnode更新节点，否则插入节点。如果没有找到key相等的，则插入节点。</p>
<p>如果结束后，oldNodeStart&gt;=oldNodeEnd，那么就需要删除旧节点中部分节点。newNodeStart&gt;=newNodeEnd，那么需要新增新节点中的部分节点。</p>
<h2 id="组件通信传值"><a href="#组件通信传值" class="headerlink" title="组件通信传值"></a>组件通信传值</h2><p>1.slot插槽传值</p>
<p>2.privide和inject</p>
<p>provide 和 inject 绑定并不是可响应的。简单类型不可响应。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p>
<p>父组件：</p>
<p>provide(){<br>  return{<br>    test:this.activeData<br>  }<br>},<br>data() {<br>  return {<br>    activeData:{name:’halo’},<br>  }<br>}<br>mounted(){<br>  setTimeout(()=&gt;{<br>    this.activeData.name = ‘world’;<br>  },3000)<br>}</p>
<p>子孙任意组件：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject:[<span class="string">&#x27;test&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口权限-路由权限-菜单权限-按钮权限"><a href="#接口权限-路由权限-菜单权限-按钮权限" class="headerlink" title="接口权限-路由权限-菜单权限-按钮权限"></a>接口权限-路由权限-菜单权限-按钮权限</h2><p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/29">控制到按钮级别怎么做？</a></p>
<p><strong>接口权限</strong></p>
<p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>，跳转到登录页面重新进行登录</p>
<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>
<p><strong>路由权限</strong></p>
<blockquote>
<p><strong>方案一</strong></p>
</blockquote>
<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p>
<p>缺点：加载所有的路由，菜单信息写死在前端，不易维护，菜单跟路由耦合</p>
<blockquote>
<p><strong>方案二</strong></p>
</blockquote>
<p>初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制</p>
<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由</p>
<p>缺点：全局路由守卫里，每次路由跳转都要做判断；菜单跟路由耦合</p>
<p><strong>菜单权限</strong></p>
<p>菜单权限可以理解成将页面与理由进行解耦</p>
<blockquote>
<p><strong>方案一</strong></p>
</blockquote>
<p>菜单与路由分离，菜单由后端返回.</p>
<p>缺点:菜单需要与路由做一一对应，前端添加了新功能</p>
<blockquote>
<p>方案二</p>
</blockquote>
<p>菜单和路由都由后端返回.</p>
<p>缺点：全局路由守卫里，每次路由跳转都要做判断。前后端的配合要求高</p>
<p><strong>按钮权限</strong></p>
<blockquote>
<p><strong>方案一</strong></p>
</blockquote>
<p>按钮权限也可以用<code>v-if</code>判断</p>
<p>但是如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断</p>
<p>这种方式就不展开举例了</p>
<blockquote>
<p><strong>方案二</strong></p>
</blockquote>
<p>通过自定义指令进行按钮权限的判断</p>
<p><strong>参考文献</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw">https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020887109">https://segmentfault.com/a/1190000020887109</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903648057622536#heading-6">https://juejin.cn/post/6844903648057622536#heading-6</a></li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>表单修饰符：lazy；trim；number</p>
<p>事件修饰符</p>
<ul>
<li>.stop：阻止事件冒泡</li>
<li>.native：绑定原生事件，使触发组件和触发标签一样</li>
<li>.once：事件只执行一次</li>
<li>.self ：将事件绑定在自身身上，相当于阻止事件冒泡</li>
<li>.prevent：阻止默认事件</li>
<li>.caption：用于事件捕获</li>
<li>.once：只触发一次</li>
<li>.keyCode：监听特定键盘按下</li>
<li>.right：右键</li>
</ul>
<h2 id="vue源码分析"><a href="#vue源码分析" class="headerlink" title="vue源码分析"></a>vue源码分析</h2><p><strong>1.Vue的编译渲染过程</strong></p>
<p>template =&gt; ast =&gt; render函数 =&gt; VDOM =&gt; 真实DOM</p>
<ul>
<li>先将template解析成抽象语法树（ast）</li>
<li>将ast编译成（complier）成render函数</li>
<li>将render函数渲染（render）成虚拟DOM</li>
<li>最后将虚拟DOM渲染成真实DOM</li>
</ul>
<p><strong>runtime-with-compiler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el:&#x27;#app&#x27;,</span><br><span class="line">  components:&#123;APP&#125;,</span><br><span class="line">  template:&#x27;&lt;APP/&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>渲染过程：template ==&gt; ast ==&gt; render ==&gt; vdom ==&gt; UI</p>
<p><strong>runtime-only</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el:&#x27;#app&#x27;,</span><br><span class="line"></span><br><span class="line">  render: h=&gt;h(APP)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>渲染过程：render ==&gt; vdom ==&gt; UI</p>
<table>
<thead>
<tr>
<th align="left">runtime-compiler</th>
<th align="left">runtime-only</th>
</tr>
</thead>
<tbody><tr>
<td align="left">体积更大（有compiler代码）</td>
<td align="left">体积更小</td>
</tr>
<tr>
<td align="left">有Vue.compilerAPI</td>
<td align="left">无Vue.compilerAPI</td>
</tr>
<tr>
<td align="left">可以使用template模板、render函数渲染</td>
<td align="left">只能使用render函数渲染</td>
</tr>
</tbody></table>
<ul>
<li>若只使用指令、数据绑定等，此时写template比写render函数更容易理解并方便，则需使用Runtime + Compiler构建的Vue库</li>
<li>挂载DOM元素的HTML被提取出来作为模板，则需使用Runtime + Compiler构建的Vue库</li>
</ul>
<p><strong>本质</strong></p>
<p>runtime-with-compiler的打包入口文件是src/platforms/web/entry-runtime-with-compiler.js</p>
<p>runtime-only的打包入口文件是src/platforms/web/entry-runtime.js</p>
<p>runtime-with-compiler调用了runtime-only的$mount,并原形重写其方法。</p>
<p><strong>打包流程</strong></p>
<p><img src="/img/image-20220113072406138.png" alt="image-20220113072406138"></p>
<h2 id="methods和watch、computed"><a href="#methods和watch、computed" class="headerlink" title="methods和watch、computed**"></a>methods和watch、computed**</h2><p>watch和computed都是对数据的监听只有数据发生变化时才会触发。</p>
<p><em><strong>watch更擅长一对多</strong></em>：就是主要监听一个可以影响多个数据的数据，watch比computed更强大。因为它能处理异步。<br><strong>computed擅长多对一</strong>：主要监听多个数据影响一个数据的数据，一定要return</p>
<p><strong>methods</strong>是通过事件驱动来执行函数的是被动的，watch、computed是当监听的数据发生变化时主动执行这个函数。</p>
<p>methods的运算是没有缓存的，computed运算是有缓存的。</p>
<h2 id="keep-alive原理"><a href="#keep-alive原理" class="headerlink" title="keep-alive原理"></a>keep-alive原理</h2><p><strong>1.定义</strong></p>
<p>keep-alive是一个抽象组件：它是一个vNode虚拟节点，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>
<p>keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p>
<p><strong>2.功能</strong></p>
<p><code>include</code>定义缓存白名单，keep-alive会缓存命中的组件；<code>exclude</code>定义缓存黑名单，被命中的组件将不会被缓存；<code>max</code>定义缓存组件上限，超出上限使用<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/LRU">LRU的策略</a>置换缓存数据。<code>include</code>优先级比<code>exclude</code>更高。</p>
<p><strong>3.源码分析</strong></p>
<p><strong>(1.1)初始化过程：</strong></p>
<ol>
<li>获取keep-alive包裹的组件及组件名。</li>
<li>根据设置的黑白名单，判断缓存是否命中，命中则使用缓存，否则直接创建或销毁组件。核心函数pruneCacheEntry</li>
<li>根据组件ID和tag生成缓存Key，value为componentInstance组件实例的键值对。</li>
<li>键值对超过max长度，使用LRU最近最少使用策略删除。</li>
<li>设置keepAlive为true即标记为激活状态,patch期间渲染组件，mounted等生命周期过滤</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// src/core/components/keep-alive.js</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;keep-alive&#x27;,</span><br><span class="line">  abstract: true, // 判断当前组件虚拟dom是否渲染成真实dom的关键</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes, // 缓存白名单</span><br><span class="line">    exclude: patternTypes, // 缓存黑名单</span><br><span class="line">    max: [String, Number] // 缓存的组件实例数量上限，使用LRU最近最少使用的组件删除</span><br><span class="line">  &#125;,</span><br><span class="line">//核心是cache和keys，keys里默认值是tagname。</span><br><span class="line">//这两个属性没有声明到可视化的data中,静态属性声明可以减少数据监听的开销</span><br><span class="line">  created () &#123;</span><br><span class="line">    this.cache = Object.create(null) // 缓存虚拟dom的key和实例的映射</span><br><span class="line">    this.keys = [] // 缓存的虚拟dom的key键集合</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">  //销毁时，更新cache</span><br><span class="line">    for (const key in this.cache) &#123; // 删除所有的缓存</span><br><span class="line">      pruneCacheEntry(this.cache, key, this.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    // 实时监听黑白名单的变动</span><br><span class="line">    this.$watch(&#x27;include&#x27;, val =&gt; &#123;</span><br><span class="line">      pruneCache(this, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$watch(&#x27;exclude&#x27;, val =&gt; &#123;</span><br><span class="line">      pruneCache(this, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    // 先省略...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>核心render函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// src/core/components/keep-alive.js</span><br><span class="line">render () &#123;</span><br><span class="line">  const slot = this.$slots.default</span><br><span class="line">  const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象</span><br><span class="line">  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">  if (componentOptions) &#123; // 存在组件参数</span><br><span class="line">    // check pattern</span><br><span class="line">    const name: ?string = getComponentName(componentOptions) // 组件名,name:&#x27;VBase&#x27;</span><br><span class="line">    const &#123; include, exclude &#125; = this</span><br><span class="line">    if ( // 条件匹配</span><br><span class="line">      // not included</span><br><span class="line">      (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">      // excluded</span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">    //没有匹配到，则直接返回节点</span><br><span class="line">      return vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; cache, keys &#125; = this</span><br><span class="line">    const key: ?string = vnode.key == null // 定义组件的缓存key</span><br><span class="line">      // same constructor may get registered as different local components</span><br><span class="line">      // so cid alone is not enough (#3269)</span><br><span class="line">      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)</span><br><span class="line">      : vnode.key</span><br><span class="line">    if (cache[key]) &#123; // 已经缓存过该组件</span><br><span class="line">    //将缓存的组件，赋值给你要渲染的新的组件</span><br><span class="line">      vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">      // make current key freshest</span><br><span class="line">      //删除并添加key</span><br><span class="line">      remove(keys, key)</span><br><span class="line">      keys.push(key) // 调整key排序</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cache[key] = vnode // 缓存组件对象</span><br><span class="line">      keys.push(key)</span><br><span class="line">      // prune oldest entry</span><br><span class="line">      //如果超过max最大缓存组件的长度，使用LRU策略，删除第一个</span><br><span class="line">      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; // 超过缓存数限制，将第一个删除</span><br><span class="line">        pruneCacheEntry(cache, keys[0], keys, this._vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到</span><br><span class="line">  &#125;</span><br><span class="line">  return vnode || (slot &amp;&amp; slot[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(1.2)actived生命周期流程：</strong></p>
<p>patch阶段调用invokeInsertHook，执行activateChildComponent递归调用自组建的active生命周期。所以先执行子组件的active，然后是父组件的active.</p>
<p>deactivated也是类似。标记为失活状态。</p>
<p>4.使用场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态判断 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;includedComponents&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>首页是A页面</li>
<li>B页面跳转到A，A页面需要缓存</li>
<li>C页面跳转到A，A页面不需要被缓存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    component: A,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        keepAlive: true // 需要被缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">         // 设置下一个路由的 meta</span><br><span class="line">        to.meta.keepAlive = true;  // B 跳转到 A 时，让 A 缓存，即不刷新</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">        // 设置下一个路由的 meta</span><br><span class="line">        to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4.vue的渲染过程</strong></p>
<p><img src="/img/image-20211212174443165.png" alt="image-20211212174443165"></p>
<ul>
<li>Vue在渲染的时候先调用原型上的<code>_render</code>函数将组件对象转化为一个<strong>VNode实例</strong>；而<code>_render</code>是通过调用<code>createElement</code>和<code>createEmptyVNode</code>两个函数进行转化。</li>
<li>完成VNode实例化后，Vue调用原型上的<code>_update</code>函数把VNode渲染为真实DOM，这个过程又是通过调用<code>__patch__</code>函数完成的。</li>
</ul>
<p>keep-alive刚好就发生在patch期间。abstract: true也导致了vue渲染时，不会生成真正的实例。</p>
<h2 id="v-if产生的内存泄漏问题"><a href="#v-if产生的内存泄漏问题" class="headerlink" title="v-if产生的内存泄漏问题"></a>v-if产生的内存泄漏问题</h2><p>v-if 绑定到 false 的值，但是实际上 dom 元素在隐藏的时候没有被真实的释放掉。</p>
<p>比如下面的示例中，我们加载了一个带有非常多选项的选择框，然后我们用到了一个显示/隐藏按钮，通过一个 v-if 指令从虚拟 DOM 中添加或移除它。这个示例的问题在于这个 v-if 指令会从 DOM 中移除父级元素，但是我们并没有清除由 js文件中新添加的 DOM 片段，从而导致了内存泄漏。</p>
<h2 id="父组件监听子组件的生命周期"><a href="#父组件监听子组件的生命周期" class="headerlink" title="父组件监听子组件的生命周期"></a>父组件监听子组件的生命周期</h2><p><strong>1.使用on和on和emit</strong></p>
<p>自定义事件方式</p>
<p><strong>2.callhook钩子函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&#x27;父组件监听到 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">//  Child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#x27;子组件触发 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line">// 以上输出顺序为：</span><br><span class="line">// 子组件触发 mounted 钩子函数 ...</span><br><span class="line">// 父组件监听到 mounted 钩子函数 ...</span><br><span class="line"></span><br><span class="line">相关源码</span><br><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm) // 初始化生命周期</span><br><span class="line">initEvents(vm) // 初始化事件</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, &#x27;beforeCreate&#x27;)</span><br><span class="line">initInjections(vm) // resolve injections before data/props</span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) // resolve provide after data/props</span><br><span class="line">callHook(vm, &#x27;created&#x27;)</span><br><span class="line">//callHook具体实现，就是自定义事件</span><br><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  // #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget()</span><br><span class="line">  const handlers = vm.$options[hook] // 选项当中的生命周期函数</span><br><span class="line">  const info = `$&#123;hook&#125; hook`</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, null, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&#x27;hook:&#x27; + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nexttick原理"><a href="#nexttick原理" class="headerlink" title="$nexttick原理"></a>$nexttick原理</h2><p><strong>1.概述</strong></p>
<p>在下次 <code>DOM</code> 更新循环结束之后执行延迟回调。<code>nextTick</code>主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>setImmediate</li>
<li>如果以上都不行则采用setTimeout</li>
</ul>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<p><strong>2.源码分析</strong></p>
<p>nextTick源码主要分为两块：</p>
<ul>
<li>1.能力检测</li>
<li>2.根据能力检测以不同方式执行回调队列</li>
</ul>
<p><strong>(2.1)能力检测</strong></p>
<p>Event Loop分为宏任务（macro task）以及微任务（ micro task），不管执行宏任务还是微任务，完成后都会进入下一个tick，并在两个tick之间执行UI渲染。</p>
<p>宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务。</p>
<p>nextTick在能力检测这一块，就是遵循的这种思想。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//首先，检测浏览器是否支持setImmediate，不支持就使用MessageChannel，再不支持只能使用效率最差但是兼容性最好的setTimeout了。</span><br><span class="line">//之后，检测浏览器是否支持Promise，如果支持，则使用Promise来执行回调函数队列，毕竟微任务速度大于宏任务。如果不支持的话，就只能使用宏任务来执行回调函数队列。</span><br><span class="line">if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  // 如果支持，宏任务（ macro task）使用setImmediate</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">  // 同上</span><br><span class="line">&#125; else if (typeof MessageChannel !== &#x27;undefined&#x27; &amp;&amp; (</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  // PhantomJS</span><br><span class="line">  MessageChannel.toString() === &#x27;[object MessageChannelConstructor]&#x27;</span><br><span class="line">)) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* istanbul ignore next */</span><br><span class="line">  // 都不支持的情况下，使用setTimeout</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2.2)执行回调函数队列</strong></p>
<p>总体流程是:接收回调函数，将回调函数推入回调函数队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数队列</span><br><span class="line">const callbacks = []</span><br><span class="line">// 异步锁</span><br><span class="line">let pending = false</span><br><span class="line"></span><br><span class="line">// 执行回调函数</span><br><span class="line">function flushCallbacks () &#123;</span><br><span class="line">  // 重置异步锁</span><br><span class="line">  pending = false</span><br><span class="line">  // 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份，清空回调函数队列</span><br><span class="line">  const copies = callbacks.slice(0)</span><br><span class="line">  callbacks.length = 0</span><br><span class="line">  // 执行回调函数队列</span><br><span class="line">  for (let i = 0; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 我们调用的nextTick函数</span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  // 将回调函数推入回调队列</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &#x27;nextTick&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  // 2.1.0新增，如果没有提供回调，并且支持Promise，返回一个Promise</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有2个关键点：</p>
<p><em>如何保证只在接收第一个回调函数时执行异步方法？</em></p>
<p>nextTick源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。</p>
<p>当然执行flushCallbacks函数时有个难以理解的点，即：<em>为什么需要备份回调函数队列？执行的也是备份的回调函数队列</em>？</p>
<p>因为，会出现这么一种情况：nextTick套用nextTick。如果flushCallbacks不做特殊处理，直接循环执行回调函数，会导致里面nextTick中的回调函数会进入回调队列。这就相当于，下一个班车的旅客上了上一个班车。</p>
<p><strong>3.自己实现简易的nextTick</strong></p>
<p>在简易版的nextTick中，通过nextTick接收回调函数，通过setTimeout来异步执行回调函数。通过这种方式，可以实现在下一个tick中执行回调函数，即在UI重新渲染后执行回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let callbacks = []</span><br><span class="line">let pending = false</span><br><span class="line"></span><br><span class="line">function nextTick (cb) &#123;</span><br><span class="line">    callbacks.push(cb)</span><br><span class="line"></span><br><span class="line">    if (!pending) &#123;</span><br><span class="line">        pending = true</span><br><span class="line">        setTimeout(flushCallback, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function flushCallback () &#123;</span><br><span class="line">    pending = false</span><br><span class="line">    let copies = callbacks.slice()</span><br><span class="line">    callbacks.length = 0</span><br><span class="line">    copies.forEach(copy =&gt; &#123;</span><br><span class="line">        copy()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="web三大框架解析"><a href="#web三大框架解析" class="headerlink" title="web三大框架解析"></a>web三大框架解析</h1><p><strong>1三大框架介绍</strong><br> <strong>1)angular</strong><br> <strong>历史</strong>:2012开始1.0版本，16年升级2.0版本。新版本支持es6和ts。<br> <strong>基本特点</strong>：<br> 双向绑定；<br> 依赖注入；<br> 基于ts的组件；<br> 良好的应用架构；<br> 工具生态完整，angular-cli用于创建、开发、测试等。有整套的解决方案，适合大型项目。<br> <strong>缺点</strong>：中文文档较少，框架较重，学习成本高。<br> <strong>2)react</strong><br> <strong>历史</strong>：2013年facebook发布版本。2015年版本稳定，同年发布reacr-native。<br> <strong>基本特点</strong>：<br> 虚拟dom，跨浏览器兼容，性能较好；<br> 组件化，代码复用;<br> JSX,js语法的扩展，模板简单、直接、语义化。<br> 单项数据流：数据流清晰，组件状态更可控。<br> <strong>缺点</strong>：<br> 本身只是view，大型项目需要加上React Router和Redux。<br> <strong>3)VUE</strong><br> <strong>历史</strong>：<br> 2015年1.0版本发布，同年vue-router、vuex、vue-cli出现，标志从一个视图层发展成一个渐进式框架。<br> 2016年vue2.0发布，引入虚拟dom，性能大幅提升。<br> 2019年vue2.0公布源码。<br> <strong>基本特点</strong>：<br> 渐进式、轻量级框架;<br> 简单易用;<br> 双向数据绑定;<br> 组件化;<br> 轻量高效(使用虚拟dom，压缩后只有20kb)<br> <strong>缺点</strong>：<br> vue不支持IE8，生态比较差(语法提示不友好，插件数量比较少)</p>
<p><strong>2.vue和react比较</strong></p>
<p>工程实践上，由于耦合性、代码组织灵活性、平滑升级、测试、重构让我们最终放弃了 Vue。在 Vue 中你操作的是定义好的对象，React 中你操作的是一个函数。所谓前端开发，本质就是在编写下面几个函数。显然，React 对此的抽象更为彻底。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S = async(A1)</span><br><span class="line">S = sync(A2)</span><br><span class="line">UI = f(S)</span><br></pre></td></tr></table></figure>

<p><strong>相同点：</strong></p>
<p>(1)都使用Virtural DOM</p>
<p>(2)都使用组件化思想，流程基本一致</p>
<p>(3)都是响应式，推崇单向数据流</p>
<p>(4)都有成熟的社区，都支持服务端渲染</p>
<p>Vue和React实现原理和流程基本一致，都是使用Virtual DOM + Diff算法.不管是Vue的template模板 + options api写法，还是React的Class或者Function（js 的class写法也是function函数的一种）写法，底层最终都是为了生成render函数,</p>
<p>Vue和React通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode diff -&gt; diff算法对比，并真正去更新真实DOM。</p>
<p><strong>差异点：</strong></p>
<p><strong>(1)核心思想不同</strong></p>
<p>Vue早期定位是尽可能的降低前端开发的门槛，Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集和派发更新）。</p>
<p>React早期口号是Rethinking Best Practices。想要做的是用更好的方式去颠覆前端开发方式，推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其稳定性（无副作用即对主函数（调用者）没有附加影响）和可测试性（输入相同，输出一定相同）。</p>
<p>(1.1)核心思想不同导致写法差异</p>
<p>Vue推崇template。React推崇JSX、HOC、all in js</p>
<p>(1.2)api差异</p>
<p>Vue定位简单易上手，基于template模板 + options API。比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api。</p>
<p><code>React本质上核心只有一个Virtual DOM + Diff算法</code>，所以API非常少，知道setState就可以开发。</p>
<p>(1.3)社区差异</p>
<p><code>由于Vue定义简单易上手，能快速解决问题，所以很多常见的解决方案，是Vue官方主导开发和维护</code>。比如状态管理库Vuex、路由库Vue-Router、脚手架Vue-CLI、Vutur工具等。属于那种大包大揽，遇到某类通用问题，只需要使用官方给出的解决方案即可。</p>
<p>React只关注底层，上层应用解决方案基本不插手。连最基础的状态管理早期也只是给出flow单向数据流思想，大部分都丢给社区去解决。比如状态管理库方面，有redux、mobx、redux-sage、dva等一大堆（选择困难症犯了），所以这也造就了React社区非常繁荣。</p>
<p>(1.4)未来升级方向不同</p>
<p>Vue依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。Vue3核心更新内容可以看到：template语法基本不变、options api只增加了setup选项（composition api）、基于依赖收集（Proxy）的数据可变。</p>
<p><code>React的函数式编程这个基本盘不会变</code>。React核心思想，是把UI作为Basic Type，比如String、Array类型，然后经过render处理，转换为另外一个value（纯函数）。从React Hooks可以看出，React团队致力于组件函数式编程，（纯组件，无class组件），尽量减少副作用（减少this，this会引起副作用）。</p>
<p><strong>(2)组件实现不同</strong></p>
<p><code>Vue源码实现是把options挂载到Vue核心类上，然后再new Vue(&#123;options&#125;)拿到实例</code>（vue组件的script导出的是一个挂满options的纯对象而已）。所以options api中的this指向内部Vue实例，对用户是不透明的，所以需要文档去说明this.$slot、this.$xxx这些api。</p>
<p>React内部实现比较简单，直接定义render函数以生成VNode，而<code>React内部使用了四大组件类包装VNode</code>，不同类型的VNode使用相应的组件类处理，职责划分清晰明了,用户透明。</p>
<p><strong>(3)响应式原理不同</strong></p>
<p>Vue2和Vue3响应式原理基本一致，都是基于依赖收集，不同的是Vue3使用Proxy.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue依赖收集，自动优化，数据可变。</span><br><span class="line">Vue递归监听data的所有属性,直接修改。</span><br><span class="line">当数据改变时，自动找到引用组件重新渲染。</span><br><span class="line"></span><br><span class="line">React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。</span><br><span class="line">当数据改变时，以组件为根目录，默认全部重新渲染</span><br></pre></td></tr></table></figure>

<p><strong>(4)diff算法不同</strong></p>
<p>Vue基于snabbdom库，它有较好的速度以及模块机制。<code>Vue Diff使用双向链表，边对比，边更新DOM。</code></p>
<p><code>React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM</code>。</p>
<p><strong>(5)事件机制不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue原生事件使用标准Web事件</span><br><span class="line">Vue组件自定义事件机制，是父子组件通信基础</span><br><span class="line">Vue合理利用了snabbdom库的模块插件</span><br><span class="line"></span><br><span class="line">React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。</span><br><span class="line">React组件上无事件，父子组件通信使用props</span><br></pre></td></tr></table></figure>

<p><strong>Vue与React的区别小结</strong></p>
<ul>
<li>vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；</li>
<li><code>props</code>是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；</li>
<li>子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；</li>
<li>每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；</li>
<li>vue使用<code>插槽</code>分发内容，使得可以混合父组件的内容与子组件自己的模板；</li>
<li>vue多了<code>指令系统</code>，让模版可以实现更丰富的功能，而React只能使用JSX语法；</li>
<li>Vue增加的语法糖<code>computed</code>和<code>watch</code>，而在React中需要自己写一套逻辑来实现；</li>
<li>react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li>
<li>react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些，比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li>
<li>react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin</li>
</ul>
<h1 id="web三大框架解析2"><a href="#web三大框架解析2" class="headerlink" title="web三大框架解析2"></a>web三大框架解析2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>angular</strong></p>
<p>诞生于2009年的Angular可以算得上Web前端三大主流框架中最完整的框架，它包含模板、数据双向绑定、路由、模块化、服务、过滤器、依赖注入等所有功能。虽然出现较早，但是因为其强大的功能，至今使用热度不减。对于刚开始前端初学者来讲，AngularJS完全基于HTML和JavaScript，因此无需学习其他语法或语言。使用TypeScript能够提高代码可维护性，有利于后期重构。<br>当然，Angular框架也不是完全没有缺点的。虽然双向数据流很方便，但是等业务复杂之后，你可能就搞不清楚数据流了。还有令人不开心的脏值检查，以及directive的封装并没有解决视图与数据关系完全分离的问题，有时候还要用$digist强制触发检测，当然，因为其由Google主导，小伙伴们还是不要选择了，毕竟Angular能搞定的，Vue也是完全能够胜任的。</p>
<p><strong>React</strong></p>
<p>React是一个开源的JavaScript库，由Facebook和一个大型开发者社区共同维护。广泛用于开发web应用程序的用户界面。React框架的主要功能是对DOM操作，声明式设计，更快的开发出Web应用系统。使用React框架，可以非常轻松地创建用户交互界面，为应用的每一个状态设计简洁的视图。甚至在数据改变时，React也可以高效地更新渲染界面。<br>虽然React框架本身比较容易理解，结构很清晰，就是由十几个API组成，然后异步渲染。但是很多人反映上手还是有一定的的难度的。React是单向数据流，代码写起来会较双向数据流的多一些，但是同样的排查问题时思路清晰很多。</p>
<p><strong>Vue</strong></p>
<p>Vue框架的最大优势就是简单易上手，同时它也是目前Web前端开发的最常使用的主流框架。Vue.js是用于构建交互式的Web 界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。从技术上讲， Vue.js集中在MVVM模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的DOM操作和输出格式被抽象出来成指令和过滤器。所以相比其它的MVVM框架，Vue.js更容易上手。<br>而且它能够开发单页面应用程序，还可以用作Web应用程序框架。Vue框架最大的优势就是能够在没有任何动作的情况下重新渲染，而且允许我们在需要时随时添加组件。</p>
<h2 id="React详解"><a href="#React详解" class="headerlink" title="React详解"></a>React详解</h2><p><strong>概述</strong></p>
<p>React（有时叫React.js或ReactJS），是一个为数据提供渲染为HTML视图的开源JavaScript 库。React视图通常采用包含以自定义HTML标记规定的其他组件的组件渲染。React为程序员提供了一种子组件不能直接影响外层组件（”data flows down”）的模型，数据改变时对HTML文档的有效更新，和现代单页应用中组件之间干净的分离。<br>它由Facebook、Instagram和一个由个人开发者和企业组成的社群维护。</p>
<p><strong>Fiber架构</strong></p>
<p>Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。<br>从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。<br>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的”虚拟 DOM”。<br>一个 fiber 就是一个 JavaScript 对象，Fiber 的数据结构如下：</p>
<p><strong>Fiber 如何解决问题的</strong></p>
<p>Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个”执行单元”，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。</p>
<p><strong>Fiber 实现原理</strong></p>
<p>实现的方式是requestIdleCallback这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。<br>window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。<br>requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。<br>即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。<br>简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。<br>React 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。<br>作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。<br>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。<br>每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性</p>
<p><strong>Fiber 架构核心</strong></p>
<p>Fiber 架构可以分为三层：</p>
<ul>
<li>Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler 协调器 —— 负责找出变化的组件</li>
<li>Renderer 渲染器 —— 负责将变化的组件渲染到页面上<br>在新的架构模式下，工作流如下：</li>
<li>每个更新任务都会被赋予一个优先级。</li>
<li>当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；</li>
<li>此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。</li>
<li>当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。<br>Fiber 架构的核心即是”可中断”、”可恢复”、”优先级”。</li>
</ul>
<p><em>Scheduler 调度器</em><br>这个需要上面提到的requestIdleCallback，React 团队实现了功能更完备的 requestIdleCallback polyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p>
<p><em>Reconciler 协调器</em><br>在 React 15 中是递归处理虚拟 DOM 的，React 16 则是变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间</p>
<p><em>React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</em><br>在 React 16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上的标记。</p>
<p>整个Scheduler与Reconciler的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。</p>
<h2 id="Vue详解"><a href="#Vue详解" class="headerlink" title="Vue详解"></a>Vue详解</h2><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>Vue 主要实现了以下几个阶段：</p>
<ol>
<li><p>组件初始化，包括事件初始化、数据初始化、依赖注入初始化等；</p>
</li>
<li><p>模板编译，即把 HTML 模板转化为可以被 Vue 利用的渲染函数，其中包括了虚拟 DOM 的概念；</p>
</li>
<li><p>DOM 挂载与更新，即把渲染函数的返回值映射为真实的 DOM ，复用或创建新的 DOM 节点；</p>
</li>
<li><p>组件销毁，包括为了实现响应式而挂载的监听器、事件监听器等。</p>
</li>
</ol>
<h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><p>为了实现无侵入的响应式数据，Vue 使用了设计模式中的代理模式，在 2.x 系列借助 ES 5 对象方法 Object.defineProperty 对原始数据进行代理，在 3.x 系列中则使用 ES 6 Proxy 对象进行代理。ES 5 对象方法要求 ES 5 支持，因此 Vue 2.x 不支持 IE 8 以下的版本。ES 6 Proxy 要求 ES 6 支持，因此 Vue 3.x 无法支持 IE 11 。下文我们以目前广泛使用的 Vue 2.x 版本为例讲解数据响应式原理。<br>其中 Object.defineProperty 只能代理属性的 set/get 方法，而 ES 6 Proxy 可以代理 defineProperty/deleteProperty 等方法，能够更全面地代理数据的增删改查，规避了原来使用 Object.defineProperty 无法捕捉的情况。这也是为什么 Vue 3 使用 ES 6 Proxy 的原因。</p>
<p><strong>对象</strong></p>
<p>Vue无法检测对象属性的添加或移除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, &#x27;b&#x27;, 2)</span><br></pre></td></tr></table></figure>

<p>这行语句的原理是虽然修改的是 b 属性的值，但是触发 someObject 的更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>数组</strong></p>
<p>在 JS 中，数组可以看作是一类特殊的对象，因此，对于数组而言 Vue 2.x不能检测以下数组的变动：<br>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue；<br>当你修改数组的长度时，例如：vm.items.length = newLength；</p>
<p>但是数组新增元素的情况要比对象新增属性常用得多，因此有必要解决数组无法响应新增属性的问题。为此，Vue 把数组的方法都代理了，调用数组方法相当于 *Vue.set(…)*。因此，用数组的方法也可以使数组保持响应的。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<p><strong>依赖收集</strong></p>
<p>依赖收集主要依赖两个数据结构实现，分别是 <code>Dep</code> 和 <code>Watcher</code> ，<code>Watcher</code> 封装观察者的信息，而 <code>Dep</code> 封装了依赖队列。每个响应式属性都有一个 <code>Dep</code> 维护其 <code>Watcher</code> 队列，当数据变化时逐个调用 <code>Dep</code> 队列中封装的 <code>Watcher</code> 实现视图更新。<br>其过程大致是渲染函数初始化 <code>Watcher</code> ，把重新渲染作为 <code>Watcher</code> 的回调，触发具体渲染，如果获取了响应式数据，则在 getter 里把 <code>Watcher</code> 收集到对应的 <code>Dep</code> 中。当事件触发了响应式数据更新，则在其 setter 里通知 <code>Dep</code> 中的 <code>Watcher</code> 触发视图更新。<br>读者在此处可能会对如何收集 <code>Watcher</code> 有疑问，毕竟 <code>Watcher</code> 和 getter 分别在两个过程中定义的，两者如何关联起来？答案是用了全局变量 <code>Dep.target</code> 在模块内形成了一个闭包。因此，如果页面上引用了两个 Vue （最常见的情况是创建库的时候把 Vue 打包进去了），响应式属性是无法在两个 Vue 中共享的，可能会造成难以定位的问题。</p>
<p><strong>响应时机</strong></p>
<p>由于 JS 是一个单线程的执行环境，也就是说每次只能执行一件事，意味着执行 JS 和更新 DOM 只能选一样执行。每次响应式属性变更时，如果都直接触发界面更新，那么在一个函数里对响应式数据进行大量更新时，就会出现“DOM 更新 - JS 执行 - DOM 更新…”的循环，如果 JS 执行较慢，就会出现卡顿，这显然不是我们想要的。因此，Vue 在更新 DOM 时是<strong>异步</strong>执行的。<br>只要侦听到数据变化，Vue  将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher  被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM  操作是非常重要的，在下一章虚拟 DOM 的时候会详细讲述。然后，在下一个的事件循环（在 JS 的术语里称为“tick”）中，Vue 刷新队列并执行实际（已去重的）工作。<br>值得注意的是，Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替，本质上是希望利用事件队列中的微任务在逻辑后进行视图更新。</p>
<h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p><strong>渲染函数</strong></p>
<p>一般在使用 Vue 的时候都会使用 Vue 单文件组件里的 HTML 模板或者直接使用挂载元素的 HTML 模板，HTML 模板为视图提供了一种比 JS 代码更友好的表达形式。但是 Vue 的模板并不是完全是 HTML ，因为 HTML 本身不支持定义自定义组件，缺少这种扩展的机制，Vue 设计了一个编译器，输入通过类似的 HTML 的语法，输出为一个输出到虚拟 DOM 的函数，这个过程称为渲染，这个函数就是渲染函数。</p>
<p>渲染函数采用了构造器的设计模式，通过传入一个构建 VNode 的构造函数，开发者可以层次化地构建出虚拟 DOM 树。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    render: function (createElement) &#123;</span><br><span class="line">      return createElement(&#x27;div&#x27;, [</span><br><span class="line">        createElement(&#x27;child&#x27;, &#123;</span><br><span class="line">          // 在数据对象中传递 `scopedSlots`</span><br><span class="line">          // 格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span><br><span class="line">          scopedSlots: &#123;</span><br><span class="line">            default: function (props) &#123;</span><br><span class="line">              return createElement(&#x27;span&#x27;, props.text)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数对应为 HTML 模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;child v-slot=&quot;props&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到渲染函数实际上比 HTML 模板复杂而且不直观，但是它是驱动 Vue 模板优化的基本原理。</p>
<p><strong>虚拟DOM</strong></p>
<p>实际上，虚拟 DOM 是 React 社区提出来的一个概念。在 Vue 早期（大约 2.0 以前），Vue 也是没有使用虚拟 DOM 的。使用虚拟 DOM 的原因主要是直接操作 DOM 会带来重大的性能影响。<br>主要体现在两方面：</p>
<ul>
<li>DOM 节点的属性多，空间开销较大，频繁操作必定会带来性能问题：</li>
<li>JS 是单线程语言，每次操作 DOM 都是阻塞操作，将会阻塞 JS 的执行，操作 DOM 的时候无法同时执行 JS ，执行 JS 的时候无法更新 DOM ，频繁地切换将会导致动画不能及时响应。更为重要的是，即使 DOM 没有属性值没有更新，但是设置 DOM 的属性值也将阻塞 JS 的执行。</li>
</ul>
<p><strong>Diff 算法</strong></p>
<p>在介绍 Diff 算法前，需要了解一个关于浏览器渲染的概念：</p>
<ul>
<li><p>回流（reflow）：当 DOM 的布局变化时，例如改变元素大小、位置或者增减元素，浏览器需要清楚当前 DOM 子树并应用重新计算的结果。</p>
</li>
<li><p>重绘（redraw）：当 DOM 的属性修改时，例如改变字体颜色，浏览器并不需要重新计算元素的布局，而只要重新绘制新样式。</p>
<p>很显然回流比重绘更加耗费性能，因此我们在设计 Diff 算法时必须尽可能复用已有元素，避免频繁增减元素造成布局回流。</p>
</li>
</ul>
<p><em>算法实现</em></p>
<p>虚拟 DOM 应用的核心算法就是 Diff 算法，其目标就是找出两个虚拟 DOM 树之间的最小化差异，好确定要更新的元素。Vue 2.x 的虚拟 DOM 实现主要参考 SnabbDOM ，其 Diff 算法主要有两个特点：</p>
<ul>
<li>同级比较：对于给定两棵树，只比较同一级节点，如果节点类型不同则直接抛弃，重新构建。</li>
<li>就近复用：当两个节点类型相同，则复用节点，只修改节点的实例属性。</li>
</ul>
<p>可以看到该算法主要是在实现简单的基础上尽可能复用节点，避免布局回流。</p>
<p>对于子节点集的比较则是希望找到没有同类型的最小集，为此，Diff 算法用了两个优化策略：</p>
<ul>
<li>双指针比较：对列表的两端分别进行寻找，当两端的值不一致后，按新的前后两端和旧的前后两端比较（尽可能复用已知的索引）</li>
<li>按组件 key 寻找：当所有已知索引都无法匹配时，按 key 的散列表寻找，如果还找不到，只能遍历了。<br>在实际应用中，新旧 DOM 树往往是比较接近的，因此双指针比较就可以很快地找出差异，剩下的部分再根据 key 或遍历寻找即可。</li>
</ul>
<h3 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h3><p>Vue提供了几种扩展的方式，即：</p>
<ul>
<li>添加全局方法或者property。如vue-custom-element；</li>
<li>添加全局资源：指令/过滤器/过渡等。如vue-touch；</li>
<li>通过全局混入来添加一些组件选项。如vue-router；</li>
<li>添加Vue实例方法，通过把它们添加到Vue.prototype上实现；</li>
</ul>
<p><strong>开发插件</strong></p>
<p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = function (Vue, options) &#123;</span><br><span class="line">    // 插件逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Vue 使用时，将会被回调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(MyPlugin, options);</span><br></pre></td></tr></table></figure>

<p> 这个策略也可以认为是一种<strong>依赖反转</strong>，也就是被调用方不需要知道调用方以何种方式引入。因为 Vue 出现的年代里，Webpack 方兴未艾，全局变量引入模块的方式还大行其道，而全局变量名往往会因为冲突而改变，因此使用这种依赖注入的方式能够很好地规避此类情况。</p>
<p>但在现今倡导 ES 模块和 tree-shaking 优化的视角下，实际上 Vue 这么设计是不够优雅的，因为插件将会被全局共享，难以去掉不必要的依赖。在 Vue 3.x 对此已经进行了整改。</p>
<h2 id="技术选型建议"><a href="#技术选型建议" class="headerlink" title="技术选型建议"></a>技术选型建议</h2><p><strong>大小</strong><br>开发框架的大小对未来应用的性能至关重要。框架和应用程序必须在应用程序开始正常工作之前加载。<br>在这方面，Angular 最复杂，有143KB。React 次之，有43KB，而 Vue.js只有23KB。除非你的应用特别大，并且包含了大量的组件，否则最好使用更小的结构。</p>
<p><strong>性能</strong><br>在 Web 项目中，性能与 DOM 密切相关：DOM 在浏览器/代码中表示 Web 页面。在发生更新时，你可以通过 DOM 控制 Web页面。<br>Vue、React和Angular的性能会因为任务的不同而有所差异，但在大多数情况下，它们都非常高效和快速。React和Vue都实现了 DOM。得益于其精心设计的结构，Vue提供了出色的性能和内存分配。这就是 React 和 Vue.js 优于Angular的地方：它们利用了虚拟 DOM。</p>
<p><strong>社区</strong><br>React 是世界上最流行的框架，这已不是什么秘密。它越来越受欢迎，因为它提供了真正的 Promise。React 的 Mental Model 看起来很可靠，其组件让创建用户界面变得更容易，API 灵活且富有表现力，整个项目给人的感觉是就应该那样。对 API 库的描述也友好，更容易给人留下良好的印象。<br>从那时起，React 库在基本概念和 API 方面就基本保持不变，但已经形成并发展出了一整套的知识和最佳实践，越来越多的人在使用它。Angular 因其优点而备受赞誉，并拥有大量的社区支持。遗憾的是，尽管 Vue.js 有很多好处，但它并没有像它的竞争对手那样被开发者所接受。<br>下面让我们从流行度和相关性两个方面比较下这三个框架：</p>
<ul>
<li>GitHub：目前，Vue.js 是最流行的框架，尽管它是最年轻的，这意味着越来越多的项目将使用它。</li>
<li>谷歌搜索：在谷歌搜索中，React 查询请求最多，紧随其后的是 Vue.js。目前最不受欢迎的是 Angular.js。Angular.js 的人气在下降，而 Vue.js 的人气却在上升。</li>
</ul>
<p><strong>Vue、React 和 Angular：该选哪个？</strong></p>
<p> 为了选出最合适的库，你应该首先仔细分析这些框架并理解自己的需求。无论是有许多依赖项的现有项目，还是你想使用熟悉的库进行开发的新应用程序，Vue 都不会给你带来任何麻烦。你可以继续使用 Bootstrap 或 Bulma 这样的 CSS 框架，保留为јQuery 或 Backbone 编写的组件，集成你最喜欢的库执行 HTTP 请求，或使用 Promise 对象。</p>
<p> 要开始使用 Vue 进行编程，你所要做的就是将 Vue.js 库连接到 Web 页面。不需要复杂的组装工具！从头到尾开发一个原型只需要 1 到 2 周的时间，这让你能够尽早并经常地收集用户反馈。Vue 2 引入了服务器端渲染（SSR）支持。这让你可以最小化初期的数据加载，并根据需要请求新的视图和资源。与高效的组件缓存相结合，可以进一步减少流量消耗。<br> React 库能够做一些令人惊叹的事情。因为整个用户界面都是用 JavaScript 定义的，所以你可以使用 JavaScript 的丰富功能在模板中执行各种操作。你只会受到 JavaScript 特性的限制，而不会受到模板框架特性的限制。当你想到完全用 JavaScript 定义的视觉效果时，你可能会想到很多引号、转义字符和 createElement 调用。别担心，React 库允许你（选择性地）使用可以与 JavaScript 代码共存的 HTML-like JSX 语法定义可视元素。<br> React 与其他两个框架在以下理念上有所不同：<br> 与其说它是一个框架，不如说它是一个库（最初是为了处理 UI 而创建的），因为它不受框架的限制，所以它的功能更多——更适合专业人士，而不是初学者；在 Angular 中许多可以“开箱即用”的主要特性，在这里必须单独连接（这种方法有优点，也有缺点，对于初学者来说是缺点，因为需要做不必要的动作）；更多地面向 JavaScript 而不是 TypeScript（尽管每个版本对 TS 的支持都在增加）；更便于创建原生 Android 和 iOS 移动应用程序，拥有大量适用于各种场合的第三方库（多于 Angular）。<br> Angular 已经被用在了许多规模最大、最复杂的 Web 应用程序中。</p>
<h1 id="vue2-0与vue3-0差别"><a href="#vue2-0与vue3-0差别" class="headerlink" title="vue2.0与vue3.0差别"></a>vue2.0与vue3.0差别</h1><p>Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 。它为后续做服务端渲染以及跨端框架 Weex 提供了基础。</p>
<p>Vue2.0很多需要解决的痛点,比如源码自身的维护性，数据量大后带来的渲染和更新的性能问题.</p>
<p>Vue3.0从<strong>源码、性能和语法 API</strong> 三个大的方面优化框架，vue3是一个比较好符合开源标准的工程化解决方案。</p>
<p><strong>1.源码优化</strong></p>
<p><strong>(1)代码管理方式</strong></p>
<p>Vue.js 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">源码托管在 src 目录</span><br><span class="line">src</span><br><span class="line">├── compiler        # 编译相关</span><br><span class="line">├── core            # 核心代码</span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></table></figure>

<p>Vue.js 3.0<br>monorepo 把这些模块拆分到不同的目录中，每个模块有各自的API类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@vue</span><br><span class="line">├── compiler-core</span><br><span class="line">│   ├── LICENSE</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── dist</span><br><span class="line">│   │   ├── compiler-core.cjs.js</span><br><span class="line">│   │   ├── compiler-core.cjs.prod.js</span><br><span class="line">│   │   ├── compiler-core.d.ts</span><br><span class="line">│   │   └── compiler-core.esm-bundler.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── package.json</span><br><span class="line">├── compiler-dom</span><br></pre></td></tr></table></figure>

<p>(1)类型检查</p>
<p>Vue.js 2.x<br>使用Flow做类型检查，Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，它可以以非常小的成本对已有的 JavaScript 代码迁入，非常灵活。但是Flow 对于一些复杂场景类型的检查，支持得并不好。</p>
<p>Vue.js 3.0<br>使用 TypeScript 重构了整个项目。TypeScript提供了更好的类型检查，能支持复杂的类型推导。</p>
<p><strong>2.性能优化</strong></p>
<p>(1)源码体积优化</p>
<p>Vue.js 3.0<br>移除一些冷门的 feature(比如 filter、inline-template 等)；<br>引入 tree-shaking 的技术，减少打包体积；</p>
<p>Vue.js 2.x<br>Vue.js 2.x是采用数据劫持结合发布者-订阅者模式的方式来达到数据响应效果的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(data, &#x27;a&#x27;,&#123;  get()&#123;    // track  &#125;,  set()&#123;    // trigger  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue.js 2.x 内部是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter.但这个 API 有一些缺陷:</p>
<ul>
<li>它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法；</li>
<li>对于嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。如果我们定义的响应式数据过于复杂，这就会有相当大的性能损耗；</li>
</ul>
<p>为了解决上述 2 个问题，Vue.js 3.0 使用了 Proxy API 做数据劫持，它的内部是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observed = new Proxy(data, &#123;  get() &#123;    // track  &#125;,  set() &#123;    // trigger  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>使用了 Proxy API 做数据劫持，它劫持的是整个对象，对于对象的属性的增加和删除都能检测到。</p>
<p>Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理 。</p>
<p>(2)编译优化</p>
<p>Vue.js 2.x<br>通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树。这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。</p>
<p>Vue.js 3.0<br>通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关。</p>
<p><strong>3.语法 API 优化</strong> </p>
<p>(1)逻辑组织 优化</p>
<p>Vue.js 2.x<br>在 Vue.js 2.x版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API。Options API 的设计是按照 methods、computed、data、props 这些不同的选项进行分类。和一个逻辑点相关的代码可能写在多个Option里，非常分散，如果需要修改一个逻辑点，就需要在单个文件中不断切换和寻找。</p>
<p>Vue.js 3.0<br>Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p>
<p>(2)逻辑复用优化</p>
<p>Vue.js 2.x<br>我们通常会用 mixins 去复用逻辑。使用单个 mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。<br>每个 mixin 都可以定义自己的props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突；<br>对组件而言，如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰；</p>
<p>Vue.js 3.0<br>使用 hook 函数，整个数据来源清晰了，也不会出现命名冲突的问题。</p>
<p>(3)更好的类型支持</p>
<p>因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了。不像 Options API 所有的东西使用 this。</p>
<p>(4)tree-shaking 友好</p>
<p>tree-shaking有一个两个要求,必须是import导入,必须是单个函数或常量导出</p>
<p>Vue.js 2.x<br>直接导出的是整个vue实例，如果我们只是简单的用某一些功能的话就有点累赘。</p>
<p>Vue.js 3.0<br>用到的函数可以通过import声明，对“按需加载”有更好的支持。</p>
<p>注意<br>Composition API 属于 API 的增强，它并不是 Vue.js 3.0组件开发的范式，如果组件足够简单，可以使用 Options API</p>
<h1 id="vue封装自己的组件库并npm发布"><a href="#vue封装自己的组件库并npm发布" class="headerlink" title="vue封装自己的组件库并npm发布"></a>vue封装自己的组件库并npm发布</h1><h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><p>它是运行在服务端的js代码。它是一个运行环境，没有它npm,webpack等都无法运行。</p>
<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化，它促进开发和运营团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中。</p>
<p>DevOps有助于提高组织提供应用程序和服务的速度。它使组织能够更好地为客户服务，并在市场中更有竞争力。</p>
<p><strong>为什么需要DevOps？</strong></p>
<p>在DevOps之前：</p>
<p>●　开发和运营团队完全孤立。</p>
<p>●　测试和部署是在设计构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。</p>
<p>●　在不使用DevOps的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。</p>
<p>●　手动代码部署会导致生产中出现人为错误</p>
<p>●　开发和运营团队有各自的时间表，不同步导致进一步的延误。</p>
<p>在DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。</p>
<p><strong>DevOps原则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、以客户为中心的行动： DevOps团队必须采取以客户为中心的行动，因为他们应该不断投资于产品和服务。</span><br><span class="line"></span><br><span class="line">2、端到端的责任： DevOps团队需要提供性能支持，直到它们终止为止。这提高了产品的责任水平和质量。</span><br><span class="line"></span><br><span class="line">3、持续改进： DevOps文化专注于持续改进，以尽量减少浪费。它不断加快提供的产品或服务的改进。</span><br><span class="line"></span><br><span class="line">4、自动化一切：自动化是DevOps流程的重要原则。这不仅适用于软件开发，也适用于整个基础架构环境。</span><br><span class="line"></span><br><span class="line">5、作为一个团队工作：在DevOps文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。</span><br><span class="line"></span><br><span class="line">6、监控和测试所有内容： DevOps团队拥有强大的监控和测试程序非常重要。</span><br></pre></td></tr></table></figure>

<h1 id="顶级开发工具"><a href="#顶级开发工具" class="headerlink" title="顶级开发工具"></a>顶级开发工具</h1><ul>
<li><p>CSS代码生成器</p>
</li>
<li><ul>
<li>CSS3 Generator</li>
<li>终极CSS Generator</li>
<li>CSS Grid布局生成器</li>
</ul>
</li>
<li><p>静态站点生成器</p>
</li>
<li><ul>
<li>Next.js</li>
<li>Gatsby</li>
</ul>
</li>
<li><p>SVG 优化器</p>
</li>
<li><ul>
<li>SVGOMG</li>
<li>SVG Optimizers</li>
</ul>
</li>
<li><p>动画库</p>
</li>
<li><ul>
<li>Animate.css</li>
<li>GreenSock (GSAP)</li>
<li>Anime.js</li>
</ul>
</li>
<li><p>跨浏览器测试</p>
</li>
<li><ul>
<li>Caniuse</li>
<li>Am I Responsive?</li>
<li>Responsive Web Design Checker</li>
<li>BrowserStack</li>
</ul>
</li>
<li><p>代码协作和游乐场</p>
</li>
<li><ul>
<li>GitHub</li>
<li>CodePen</li>
<li>JSFiddle</li>
<li>SoloLearn</li>
<li>jsrun.net</li>
</ul>
</li>
</ul>
<h1 id="Echart"><a href="#Echart" class="headerlink" title="Echart"></a>Echart</h1><h2 id="clear和dispose"><a href="#clear和dispose" class="headerlink" title="clear和dispose"></a>clear和dispose</h2><p>clear:清空绘画内容，清空后实例可用,不会删除实例</p>
<p>dispose：释放图表实例，释放后实例不再可用。</p>
<h2 id="Echart渲染百万数据"><a href="#Echart渲染百万数据" class="headerlink" title="Echart渲染百万数据"></a>Echart渲染百万数据</h2><h3 id="全量渲染改增量"><a href="#全量渲染改增量" class="headerlink" title="全量渲染改增量"></a>全量渲染改增量</h3><p>虽然这并不能解决拖动时的卡顿(因为仍旧需要遍历所有点),但能将每秒渲染的全量数据从百万改成几百个的增量数据，至少能给CPU放个假。</p>
<p>官方API提供<a href="https://link.juejin.cn/?target=https://github.com/apache/echarts/issues/7625">appendData</a>方法。</p>
<p>研究了下Echarts的实现，其在填入数据时做了diff，而G每次填入的都是在原有数据基础上新增一秒数据，所以在diff算法的加持下，早就是增量渲染了。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>走投无路之下，便想砍掉几张图表。</p>
<p>G支持的性能数据颇多，同时需要绘制很多张图表。</p>
<p>但实际上电脑屏幕并不足够大，展示给用户的可视范围并不大，我们可以只实时渲染用户所见的部分，其余部分通过监听滚轮，鼠标，键盘的操作，当其可视时，再进行渲染。</p>
<p>可以看到一帧的时间已经达到了100ms+，其中占据较多时间的是Echart.setOption这个函数。实际上，Echarts在渲染单张图表时表现还是不错的，一般能做到20ms内，但因为我们图表共有数十张，10*10=100。改成滚动时加载之后帧渲染便好了极多。</p>
<h3 id="sampling降采样"><a href="#sampling降采样" class="headerlink" title="sampling降采样"></a><code>sampling</code>降采样</h3><p>实际上，我们可以注意到，G上的一个折线图，一般占用的像素宽度大概只有700到1500，就算是百万个点，能展示出来的也不过寥寥，这里便大有文章可做。</p>
<p>ECharts 有 <a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-line.sampling">提供 </a><code>sampling</code><a href="https://link.juejin.cn/?target=https://echarts.apache.org/zh/option.html%23series-line.sampling"> 降采样功能</a> ，其中有max，min，avg以及lttb等。使用G进行性能测试的同学很多时候，都是需要观测离群值的，所以max，min以及avg势必会丢弃很多细节，没法使用。</p>
<p>可以看出，使用了lttb算法之后，细节和趋势都保留的非常好，而且每帧渲染耗时更是从之前的成百上千降至50ms内，相当给力。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://anandasuper.top/2021/11/03/D_%E6%A1%86%E6%9E%B6_0%E5%9F%BA%E7%A1%80/" title="0基础" target="_blank" rel="external">http://anandasuper.top/2021/11/03/D_框架_0基础/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">昵称</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/11/04/F_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0%E5%9F%BA%E7%A1%80/" title="0基础"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/11/01/AA_%E9%9D%A2%E8%AF%95_%E9%9D%A2%E8%AF%95%E9%A2%98-1/" title="面试题-1"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>